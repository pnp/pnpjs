{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PnPjs is a collection of fluent libraries for consuming SharePoint, Graph, and Office 365 REST APIs in a type-safe way. You can use it within SharePoint Framework, Nodejs, or any JavaScript project. This an open source initiative and we encourage contributions and constructive feedback from the community. Animation of the library in use, note intellisense help in building your queries General Guidance \u00b6 These articles provide general guidance for working with the libraries. If you are migrating from v1 please review the transition guide . Getting Started Authentication Get Started Contributing npm scripts Polyfills Packages \u00b6 Patterns and Practices client side libraries (PnPjs) are comprised of the packages listed below. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins Authentication \u00b6 We have a new section dedicated to helping you figure out the best way to handle authentication in your application, check it out! Issues, Questions, Ideas \u00b6 Please log an issue using our template as a guide. This will let us track your request and ensure we respond. We appreciate any constructive feedback, questions, ideas, or bug reports with our thanks for giving back to the project. Changelog \u00b6 Please review the CHANGELOG for release details on all library changes. Code of Conduct \u00b6 This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. \"Sharing is Caring\" \u00b6 Please use http://aka.ms/sppnp for the latest updates around the whole SharePoint Patterns and Practices (PnP) program . Disclaimer \u00b6 THIS CODE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.","title":"Home"},{"location":"#general-guidance","text":"These articles provide general guidance for working with the libraries. If you are migrating from v1 please review the transition guide . Getting Started Authentication Get Started Contributing npm scripts Polyfills","title":"General Guidance"},{"location":"#packages","text":"Patterns and Practices client side libraries (PnPjs) are comprised of the packages listed below. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins","title":"Packages"},{"location":"#authentication","text":"We have a new section dedicated to helping you figure out the best way to handle authentication in your application, check it out!","title":"Authentication"},{"location":"#issues-questions-ideas","text":"Please log an issue using our template as a guide. This will let us track your request and ensure we respond. We appreciate any constructive feedback, questions, ideas, or bug reports with our thanks for giving back to the project.","title":"Issues, Questions, Ideas"},{"location":"#changelog","text":"Please review the CHANGELOG for release details on all library changes.","title":"Changelog"},{"location":"#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Code of Conduct"},{"location":"#sharing-is-caring","text":"Please use http://aka.ms/sppnp for the latest updates around the whole SharePoint Patterns and Practices (PnP) program .","title":"\"Sharing is Caring\""},{"location":"#disclaimer","text":"THIS CODE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.","title":"Disclaimer"},{"location":"SPFx-on-premises/","text":"Workaround for on-premises SPFx TypeScript Version (SharePoint 2016 or 2019) \u00b6 Note this article applies to version 1.4.1 SharePoint Framework projects targeting on-premises only. When using the Yeoman generator to create a SharePoint Framework 1.4.1 project targeting on-premises it installs TypeScript version 2.2.2 (SP2016) or 2.4.2/2.4.1 (SP2019). Unfortunately this library relies on 3.6.4 or later due to extensive use of default values for generic type parameters in the libraries. To work around this limitation you can follow the steps in this article. npm i npm i -g rimraf # used to remove the node_modules folder (much better/faster) Ensure that the @pnp/sp package is already installed npm i @pnp/sp Remove the package-lock.json file & node_modules rimraf node_modules folder and execute npm install Open package-lock.json from the root folder Search for \"typescript\" or similar with version 2.4.1 (SP2019) 2.2.2 (SP2016) Replace \"2.4.1\" or \"2.2.2\" with \"3.6.4\" Search for the next \"typescript\" occurrence and replace the block with: JSON \"typescript\": { \"version\": \"3.6.4\", \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-3.6.4.tgz\", \"integrity\": \"sha512-unoCll1+l+YK4i4F8f22TaNVPRHcD9PA3yCuZ8g5e0qGqlVlJ/8FSateOLLSagn+Yg5+ZwuPkL8LFUc0Jcvksg==\", \"dev\": true } Remove node_modules folder rimraf node_modules Run npm install Alternative using npm-force-resolutions \u00b6 Install resolutions package and TypeScript providing considered version explicitly: bash npm i -D npm-force-resolutions typescript@3.6.4 Add a resolution for TypeScript and preinstall script into package.json to a corresponding code blocks: JSON { \"scripts\": { \"preinstall\": \"npx npm-force-resolutions\" }, \"resolutions\": { \"typescript\": \"3.6.4\" } } Run npm install to trigger preinstall script and bumping TypeScript version into package-lock.json Run npm run build , should produce no errors Installing additional dependencies should be safe then.","title":"SPFx On-Premises"},{"location":"SPFx-on-premises/#workaround-for-on-premises-spfx-typescript-version-sharepoint-2016-or-2019","text":"Note this article applies to version 1.4.1 SharePoint Framework projects targeting on-premises only. When using the Yeoman generator to create a SharePoint Framework 1.4.1 project targeting on-premises it installs TypeScript version 2.2.2 (SP2016) or 2.4.2/2.4.1 (SP2019). Unfortunately this library relies on 3.6.4 or later due to extensive use of default values for generic type parameters in the libraries. To work around this limitation you can follow the steps in this article. npm i npm i -g rimraf # used to remove the node_modules folder (much better/faster) Ensure that the @pnp/sp package is already installed npm i @pnp/sp Remove the package-lock.json file & node_modules rimraf node_modules folder and execute npm install Open package-lock.json from the root folder Search for \"typescript\" or similar with version 2.4.1 (SP2019) 2.2.2 (SP2016) Replace \"2.4.1\" or \"2.2.2\" with \"3.6.4\" Search for the next \"typescript\" occurrence and replace the block with: JSON \"typescript\": { \"version\": \"3.6.4\", \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-3.6.4.tgz\", \"integrity\": \"sha512-unoCll1+l+YK4i4F8f22TaNVPRHcD9PA3yCuZ8g5e0qGqlVlJ/8FSateOLLSagn+Yg5+ZwuPkL8LFUc0Jcvksg==\", \"dev\": true } Remove node_modules folder rimraf node_modules Run npm install","title":"Workaround for on-premises SPFx TypeScript Version (SharePoint 2016 or 2019)"},{"location":"SPFx-on-premises/#alternative-using-npm-force-resolutions","text":"Install resolutions package and TypeScript providing considered version explicitly: bash npm i -D npm-force-resolutions typescript@3.6.4 Add a resolution for TypeScript and preinstall script into package.json to a corresponding code blocks: JSON { \"scripts\": { \"preinstall\": \"npx npm-force-resolutions\" }, \"resolutions\": { \"typescript\": \"3.6.4\" } } Run npm install to trigger preinstall script and bumping TypeScript version into package-lock.json Run npm run build , should produce no errors Installing additional dependencies should be safe then.","title":"Alternative using npm-force-resolutions"},{"location":"getting-started/","text":"Getting Started \u00b6 These libraries are geared towards folks working with TypeScript but will work equally well for JavaScript projects. To get started you need to install the libraries you need via npm. Many of the packages have a peer dependency to other packages with the @pnp namespace meaning you may need to install more than one package. All packages are released together eliminating version confusion - all packages will depend on packages with the same version number. If you need to support older browsers please review the article on polyfills for required functionality. Install \u00b6 First you will need to install those libraries you want to use in your application. Here we will install the most frequently used packages. This step applies to any environment or project. npm install @pnp/sp @pnp/graph --save Next we can import and use the functionality within our application. Below is a very simple example, please see the individual package documentation for more details and examples. import { getRandomString } from \"@pnp/core\"; (function() { // get and log a random string console.log(getRandomString(20)); })() Getting Started with SharePoint Framework \u00b6 The @pnp/sp and @pnp/graph libraries are designed to work seamlessly within SharePoint Framework projects with a small amount of upfront configuration. If you are running in 2016 or 2019 on-premises please read this note on a workaround for the included TypeScript version. If you are targeting SharePoint online you do not need to take any additional steps. Establish Context \u00b6 Because SharePoint Framework provides a local context to each component we need to set that context within the library. This allows us to determine request urls as well as use the SPFx HttpGraphClient within @pnp/graph. There are two ways to provide the SPFx context to the library. Either through the setup method imported from @pnp/core or using the setup method on either the @pnp/sp or @pnp/graph main export. All three are shown below and are equivalent, meaning if you are already importing the sp variable from @pnp/sp or the graph variable from @pnp/graph you should use their setup method to reduce imports. The setup is always done in the onInit method to ensure it runs before your other life-cycle code. You can also set any other settings at this time. Using @pnp/core setup \u00b6 import { setup as pnpSetup } from \"@pnp/core\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present pnpSetup({ spfxContext: this.context }); }); } // ... Using @pnp/sp setup \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... Sp setup also supports passing just the SPFx context object directly as this is the most common case import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ... Using @pnp/graph setup \u00b6 import { graph } from \"@pnp/graph/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ... Establish context within an SPFx service \u00b6 Because you do not have full access to the context object within a service you need to setup things a little differently. If you do not need AAD tokens you can leave that part out and specify just the pageContext. import { ServiceKey, ServiceScope } from \"@microsoft/sp-core-library\"; import { PageContext } from \"@microsoft/sp-page-context\"; import { AadTokenProviderFactory } from \"@microsoft/sp-http\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; export interface ISampleService { getLists(): Promise<any[]>; } export class SampleService { public static readonly serviceKey: ServiceKey<ISampleService> = ServiceKey.create<ISampleService>('SPFx:SampleService', SampleService); constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { const pageContext = serviceScope.consume(PageContext.serviceKey); const tokenProviderFactory = serviceScope.consume(AadTokenProviderFactory.serviceKey); // we need to \"spoof\" the context object with the parts we need for PnPjs sp.setup({ spfxContext: { aadTokenProviderFactory: tokenProviderFactory, pageContext: pageContext, } }); // This approach also works if you do not require AAD tokens // you don't need to do both // sp.setup({ // sp : { // baseUrl : pageContext.web.absoluteUrl // } // }); }); } public getLists(): Promise<any[]> { return sp.web.lists(); } } Connect to SharePoint from Node \u00b6 Please see the main article on how we support node versions that require commonjs modules. npm i @pnp/sp-commonjs @pnp/nodejs-commonjs This will install the logging, common, odata, sp, and nodejs packages. You can read more about what each package does starting on the packages page. Once these are installed you need to import them into your project, to communicate with SharePoint from node we'll need the following imports: import { sp } from \"@pnp/sp-commonjs\"; import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; Once you have imported the necessary resources you can update your code to setup the node fetch client as well as make a call to SharePoint. // configure your node options (only once in your application) sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // make a call to SharePoint and log it in the console sp.web.select(\"Title\", \"Description\")().then(w => { console.log(JSON.stringify(w, null, 4)); }); Connect to Microsoft Graph From Node \u00b6 Similar to the above you can also make calls to the Graph api from node using the libraries. Again we start with installing the required resources. You can see ./debug/launch/graph.ts for a live example. npm i @pnp/graph-commonjs @pnp/nodejs-commonjs Now we need to import what we'll need to call graph import { graph } from \"@pnp/graph-commonjs\"; import { AdalFetchClient } from \"@pnp/nodejs-commonjs\"; Now we can make our graph calls after setting up the Adal client. Note you'll need to setup an AzureAD App registration with the necessary permissions. graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{mytenant}.onmicrosoft.com\", \"{application id}\", \"{application secret}\"); }, }, }); // make a call to Graph and get all the groups graph.groups().then(g => { console.log(JSON.stringify(g, null, 4)); }); Getting Started outside SharePoint Framework \u00b6 In some cases you may be working in a way such that we cannot determine the base url for the web. In this scenario you have two options. Set baseUrl through setup \u00b6 Here we are setting the baseUrl via the sp.setup method. We are also setting the headers to use verbose mode, something you may have to do when working against unpatched versions of SharePoint 2013 as discussed here . This is optional for 2016 or SharePoint Online. The library does not support setting the headers to use nometadata as we rely on the metadata in the response to do some of the more complicated functions. Some of the pure data calls will probably work but it is not a supported configuration. import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { headers: { Accept: \"application/json;odata=verbose\", }, baseUrl: \"{Absolute SharePoint Web URL}\" }, }); const w = await sp.web(); Create Web instances directly \u00b6 Using this method you create the web directly with the url you want to use as the base. import { Web } from \"@pnp/sp/presets/all\"; const web = Web(\"{Absolute SharePoint Web URL}\"); const w = await web(); Next Steps \u00b6 Be sure to review the article describing all of the available settings across the libraries.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"These libraries are geared towards folks working with TypeScript but will work equally well for JavaScript projects. To get started you need to install the libraries you need via npm. Many of the packages have a peer dependency to other packages with the @pnp namespace meaning you may need to install more than one package. All packages are released together eliminating version confusion - all packages will depend on packages with the same version number. If you need to support older browsers please review the article on polyfills for required functionality.","title":"Getting Started"},{"location":"getting-started/#install","text":"First you will need to install those libraries you want to use in your application. Here we will install the most frequently used packages. This step applies to any environment or project. npm install @pnp/sp @pnp/graph --save Next we can import and use the functionality within our application. Below is a very simple example, please see the individual package documentation for more details and examples. import { getRandomString } from \"@pnp/core\"; (function() { // get and log a random string console.log(getRandomString(20)); })()","title":"Install"},{"location":"getting-started/#getting-started-with-sharepoint-framework","text":"The @pnp/sp and @pnp/graph libraries are designed to work seamlessly within SharePoint Framework projects with a small amount of upfront configuration. If you are running in 2016 or 2019 on-premises please read this note on a workaround for the included TypeScript version. If you are targeting SharePoint online you do not need to take any additional steps.","title":"Getting Started with SharePoint Framework"},{"location":"getting-started/#establish-context","text":"Because SharePoint Framework provides a local context to each component we need to set that context within the library. This allows us to determine request urls as well as use the SPFx HttpGraphClient within @pnp/graph. There are two ways to provide the SPFx context to the library. Either through the setup method imported from @pnp/core or using the setup method on either the @pnp/sp or @pnp/graph main export. All three are shown below and are equivalent, meaning if you are already importing the sp variable from @pnp/sp or the graph variable from @pnp/graph you should use their setup method to reduce imports. The setup is always done in the onInit method to ensure it runs before your other life-cycle code. You can also set any other settings at this time.","title":"Establish Context"},{"location":"getting-started/#using-pnpcore-setup","text":"import { setup as pnpSetup } from \"@pnp/core\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present pnpSetup({ spfxContext: this.context }); }); } // ...","title":"Using @pnp/core setup"},{"location":"getting-started/#using-pnpsp-setup","text":"import { sp } from \"@pnp/sp/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... Sp setup also supports passing just the SPFx context object directly as this is the most common case import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ...","title":"Using @pnp/sp setup"},{"location":"getting-started/#using-pnpgraph-setup","text":"import { graph } from \"@pnp/graph/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ...","title":"Using @pnp/graph setup"},{"location":"getting-started/#establish-context-within-an-spfx-service","text":"Because you do not have full access to the context object within a service you need to setup things a little differently. If you do not need AAD tokens you can leave that part out and specify just the pageContext. import { ServiceKey, ServiceScope } from \"@microsoft/sp-core-library\"; import { PageContext } from \"@microsoft/sp-page-context\"; import { AadTokenProviderFactory } from \"@microsoft/sp-http\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; export interface ISampleService { getLists(): Promise<any[]>; } export class SampleService { public static readonly serviceKey: ServiceKey<ISampleService> = ServiceKey.create<ISampleService>('SPFx:SampleService', SampleService); constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { const pageContext = serviceScope.consume(PageContext.serviceKey); const tokenProviderFactory = serviceScope.consume(AadTokenProviderFactory.serviceKey); // we need to \"spoof\" the context object with the parts we need for PnPjs sp.setup({ spfxContext: { aadTokenProviderFactory: tokenProviderFactory, pageContext: pageContext, } }); // This approach also works if you do not require AAD tokens // you don't need to do both // sp.setup({ // sp : { // baseUrl : pageContext.web.absoluteUrl // } // }); }); } public getLists(): Promise<any[]> { return sp.web.lists(); } }","title":"Establish context within an SPFx service"},{"location":"getting-started/#connect-to-sharepoint-from-node","text":"Please see the main article on how we support node versions that require commonjs modules. npm i @pnp/sp-commonjs @pnp/nodejs-commonjs This will install the logging, common, odata, sp, and nodejs packages. You can read more about what each package does starting on the packages page. Once these are installed you need to import them into your project, to communicate with SharePoint from node we'll need the following imports: import { sp } from \"@pnp/sp-commonjs\"; import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; Once you have imported the necessary resources you can update your code to setup the node fetch client as well as make a call to SharePoint. // configure your node options (only once in your application) sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // make a call to SharePoint and log it in the console sp.web.select(\"Title\", \"Description\")().then(w => { console.log(JSON.stringify(w, null, 4)); });","title":"Connect to SharePoint from Node"},{"location":"getting-started/#connect-to-microsoft-graph-from-node","text":"Similar to the above you can also make calls to the Graph api from node using the libraries. Again we start with installing the required resources. You can see ./debug/launch/graph.ts for a live example. npm i @pnp/graph-commonjs @pnp/nodejs-commonjs Now we need to import what we'll need to call graph import { graph } from \"@pnp/graph-commonjs\"; import { AdalFetchClient } from \"@pnp/nodejs-commonjs\"; Now we can make our graph calls after setting up the Adal client. Note you'll need to setup an AzureAD App registration with the necessary permissions. graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{mytenant}.onmicrosoft.com\", \"{application id}\", \"{application secret}\"); }, }, }); // make a call to Graph and get all the groups graph.groups().then(g => { console.log(JSON.stringify(g, null, 4)); });","title":"Connect to Microsoft Graph From Node"},{"location":"getting-started/#getting-started-outside-sharepoint-framework","text":"In some cases you may be working in a way such that we cannot determine the base url for the web. In this scenario you have two options.","title":"Getting Started outside SharePoint Framework"},{"location":"getting-started/#set-baseurl-through-setup","text":"Here we are setting the baseUrl via the sp.setup method. We are also setting the headers to use verbose mode, something you may have to do when working against unpatched versions of SharePoint 2013 as discussed here . This is optional for 2016 or SharePoint Online. The library does not support setting the headers to use nometadata as we rely on the metadata in the response to do some of the more complicated functions. Some of the pure data calls will probably work but it is not a supported configuration. import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { headers: { Accept: \"application/json;odata=verbose\", }, baseUrl: \"{Absolute SharePoint Web URL}\" }, }); const w = await sp.web();","title":"Set baseUrl through setup"},{"location":"getting-started/#create-web-instances-directly","text":"Using this method you create the web directly with the url you want to use as the base. import { Web } from \"@pnp/sp/presets/all\"; const web = Web(\"{Absolute SharePoint Web URL}\"); const w = await web();","title":"Create Web instances directly"},{"location":"getting-started/#next-steps","text":"Be sure to review the article describing all of the available settings across the libraries.","title":"Next Steps"},{"location":"nodejs-support/","text":"Working in Nodejs \u00b6 As outlined on the getting started page you can easily use the library with Nodejs, but there are some key differences you need to consider. But first a little history, you can skip this part if you just want to see how things work but we felt some folks might be interested. To make selective imports work we need to support es module syntax for client-side environments such as SPFx development. All versions of Nodejs that are currently LTS do not support es modules without flags (as of when this was written). We thought we had a scheme to handle this following the available guidance but ultimately it didn't work across all node versions and we unpublished 2.0.1. CommonJS Libraries \u00b6 Because of the difficulties of working with es modules in node we recommend using our mirror packages providing commonjs modules. These can be installed by using the package name and appending -commonjs, such as: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs These packages are built from the same source and released at the same time so all updates are included with each release. The only difference is that for the sp-commonjs and graph-commonjs packages we target the \"all\" preset as the entry point. This makes things a little easier in node where bundle sizes aren't an issue. You can see this in the nodejs-app sample . Here is that sample explained fully: Install Libraries \u00b6 We want to make a simple request to SharePoint so we need to first install the modules we need: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs --save We will also install TypeScript: npm install typescript --save-dev index.ts \u00b6 We will create an index.ts file and add the following code. You will need to update the site url, client id, and client secret to your values. This should be done using a settings file or something like Azure KeyVault for production, but for this example it is good enough. // our imports come from the -commonjs libs import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; // we call setup to use the node client sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{ site url }\", \"{ client id }\", \"{ client secret }\"); }, }, }); async function makeRequest() { // make a request to get the web's details const w = await sp.web(); console.log(JSON.stringify(w, null, 2)); } // get past no await at root of app makeRequest(); Don't forget you will need to register an app to get the client id and secret. Add a tsconfig.json \u00b6 Not strictly necessary but very useful to include a tsconfig.json to control how tsc transpiles your code to JavaScript { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"esnext\", \"moduleResolution\": \"node\", \"declaration\": true, \"outDir\": \"dist\", \"skipLibCheck\": true, \"sourceMap\": true, \"lib\": [ \"dom\", \"esnext\" ] }, \"files\": [ \"./index.ts\" ] } Add an script to package.json \u00b6 We add the \"start\" script to the default package.json { \"name\": \"nodejs-app\", \"version\": \"1.0.0\", \"description\": \"Sample nodejs app using PnPjs\", \"main\": \"index.js\", \"scripts\": { \"start\": \"tsc -p . && node dist/index.js\", \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"MIT\", \"dependencies\": { \"@pnp/nodejs-commonjs\": \"^2.0.2-5\", \"@pnp/sp-commonjs\": \"^2.0.2-5\" }, \"devDependencies\": { \"typescript\": \"^3.7.5\" } } Run It \u00b6 You can now run your program using: npm start","title":"Working in Nodejs"},{"location":"nodejs-support/#working-in-nodejs","text":"As outlined on the getting started page you can easily use the library with Nodejs, but there are some key differences you need to consider. But first a little history, you can skip this part if you just want to see how things work but we felt some folks might be interested. To make selective imports work we need to support es module syntax for client-side environments such as SPFx development. All versions of Nodejs that are currently LTS do not support es modules without flags (as of when this was written). We thought we had a scheme to handle this following the available guidance but ultimately it didn't work across all node versions and we unpublished 2.0.1.","title":"Working in Nodejs"},{"location":"nodejs-support/#commonjs-libraries","text":"Because of the difficulties of working with es modules in node we recommend using our mirror packages providing commonjs modules. These can be installed by using the package name and appending -commonjs, such as: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs These packages are built from the same source and released at the same time so all updates are included with each release. The only difference is that for the sp-commonjs and graph-commonjs packages we target the \"all\" preset as the entry point. This makes things a little easier in node where bundle sizes aren't an issue. You can see this in the nodejs-app sample . Here is that sample explained fully:","title":"CommonJS Libraries"},{"location":"nodejs-support/#install-libraries","text":"We want to make a simple request to SharePoint so we need to first install the modules we need: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs --save We will also install TypeScript: npm install typescript --save-dev","title":"Install Libraries"},{"location":"nodejs-support/#indexts","text":"We will create an index.ts file and add the following code. You will need to update the site url, client id, and client secret to your values. This should be done using a settings file or something like Azure KeyVault for production, but for this example it is good enough. // our imports come from the -commonjs libs import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; // we call setup to use the node client sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{ site url }\", \"{ client id }\", \"{ client secret }\"); }, }, }); async function makeRequest() { // make a request to get the web's details const w = await sp.web(); console.log(JSON.stringify(w, null, 2)); } // get past no await at root of app makeRequest(); Don't forget you will need to register an app to get the client id and secret.","title":"index.ts"},{"location":"nodejs-support/#add-a-tsconfigjson","text":"Not strictly necessary but very useful to include a tsconfig.json to control how tsc transpiles your code to JavaScript { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"esnext\", \"moduleResolution\": \"node\", \"declaration\": true, \"outDir\": \"dist\", \"skipLibCheck\": true, \"sourceMap\": true, \"lib\": [ \"dom\", \"esnext\" ] }, \"files\": [ \"./index.ts\" ] }","title":"Add a tsconfig.json"},{"location":"nodejs-support/#add-an-script-to-packagejson","text":"We add the \"start\" script to the default package.json { \"name\": \"nodejs-app\", \"version\": \"1.0.0\", \"description\": \"Sample nodejs app using PnPjs\", \"main\": \"index.js\", \"scripts\": { \"start\": \"tsc -p . && node dist/index.js\", \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"MIT\", \"dependencies\": { \"@pnp/nodejs-commonjs\": \"^2.0.2-5\", \"@pnp/sp-commonjs\": \"^2.0.2-5\" }, \"devDependencies\": { \"typescript\": \"^3.7.5\" } }","title":"Add an script to package.json"},{"location":"nodejs-support/#run-it","text":"You can now run your program using: npm start","title":"Run It"},{"location":"npm-scripts/","text":"Supported NPM Scripts \u00b6 As you likely are aware you can embed scripts within package.json. Using this capability coupled with the knowledge that pretty much all of the tools we use now support code files (.js/.ts) as configuration we have removed gulp from our tooling and now execute our various actions via scripts. This is not a knock on gulp, it remains a great tool, rather an opportunity for us to remove some dependencies. This article outlines the current scripts we've implemented and how to use them, with available options and examples. Start \u00b6 Executes the serve command npm start Serve \u00b6 Starts a debugging server serving a bundled script with ./debug/serve/main.ts as the entry point. This allows you to run tests and debug code running within the context of a webpage rather than node. npm run serve Test \u00b6 Runs the tests and coverage for the library. Starting with 2.3.0 ONLY MSAL auth is supported for running the tests. More details on setting up MSAL for node. Options \u00b6 There are several options you can provide to the test command. All of these need to be separated using a \"--\" double hyphen so they are passed to the spawned sub-commands. Test a Single Package \u00b6 --package or -p This option will only run the tests associated with the package you specify. The values are the folder names within the ./packages directory. # run only sp tests npm test -- -p sp # run only logging tests npm test -- -package logging Run a Single Test File \u00b6 --single or --s You can also run a specific file with a package. This option must be used with the single package option as you are essentially specifying the folder and file. This option uses either the flags. # run only sp web tests npm test -- -p sp -s web # run only graph groups tests npm test -- -package graph -single groups Specify a Site \u00b6 --site By default every time you run the tests a new sub-site is created below the site specified in your settings file . You can choose to reuse a site for testing, which saves time when re-running a set of tests frequently. Testing content is not deleted after tests, so if you need to inspect the created content from testing you may wish to forgo this option. This option can be used with any or none of the other testing options. # run only sp web tests with a certain site npm test -- -p sp -s web --site https://some.site.com/sites/dev Cleanup \u00b6 --cleanup If you include this flag the testing web will be deleted once tests are complete. Useful for local testing where you do not need to inspect the web once the tests are complete. Works with any of the other options, be careful when specifying a web using --site as it will be deleted. # clean up our testing site npm test -- --cleanup Logging \u00b6 --logging If you include this flag a console logger will be subscribed and the log level will be set to Info. This will provide console output for all the requests being made during testing. This flag is compatible with all other flags - however unless you are trying to debug a specific test this will produce a lot of chatty output. # enable logging during testing npm test -- --logging spVerbose \u00b6 Added in 2.0.13 --spverbose This flag will enable \"verbose\" OData mode for SharePoint tests. This flag is compatible with other flags. npm test -- --spverbose build \u00b6 Invokes the pnpbuild cli to transpile the TypeScript into JavaScript. All behavior is controlled via the tsconfig.json in the root of the project and sub folders as needed. npm run build package \u00b6 Invokes the pnpbuild cli to create the package directories under the dist folder. This will allow you to see exactly what will end up in the npm packages once they are published. npm run package lint \u00b6 Runs the linter. npm run lint clean \u00b6 Removes any generated folders from the working directory. npm run clean","title":"Npm Scripts"},{"location":"npm-scripts/#supported-npm-scripts","text":"As you likely are aware you can embed scripts within package.json. Using this capability coupled with the knowledge that pretty much all of the tools we use now support code files (.js/.ts) as configuration we have removed gulp from our tooling and now execute our various actions via scripts. This is not a knock on gulp, it remains a great tool, rather an opportunity for us to remove some dependencies. This article outlines the current scripts we've implemented and how to use them, with available options and examples.","title":"Supported NPM Scripts"},{"location":"npm-scripts/#start","text":"Executes the serve command npm start","title":"Start"},{"location":"npm-scripts/#serve","text":"Starts a debugging server serving a bundled script with ./debug/serve/main.ts as the entry point. This allows you to run tests and debug code running within the context of a webpage rather than node. npm run serve","title":"Serve"},{"location":"npm-scripts/#test","text":"Runs the tests and coverage for the library. Starting with 2.3.0 ONLY MSAL auth is supported for running the tests. More details on setting up MSAL for node.","title":"Test"},{"location":"npm-scripts/#options","text":"There are several options you can provide to the test command. All of these need to be separated using a \"--\" double hyphen so they are passed to the spawned sub-commands.","title":"Options"},{"location":"npm-scripts/#test-a-single-package","text":"--package or -p This option will only run the tests associated with the package you specify. The values are the folder names within the ./packages directory. # run only sp tests npm test -- -p sp # run only logging tests npm test -- -package logging","title":"Test a Single Package"},{"location":"npm-scripts/#run-a-single-test-file","text":"--single or --s You can also run a specific file with a package. This option must be used with the single package option as you are essentially specifying the folder and file. This option uses either the flags. # run only sp web tests npm test -- -p sp -s web # run only graph groups tests npm test -- -package graph -single groups","title":"Run a Single Test File"},{"location":"npm-scripts/#specify-a-site","text":"--site By default every time you run the tests a new sub-site is created below the site specified in your settings file . You can choose to reuse a site for testing, which saves time when re-running a set of tests frequently. Testing content is not deleted after tests, so if you need to inspect the created content from testing you may wish to forgo this option. This option can be used with any or none of the other testing options. # run only sp web tests with a certain site npm test -- -p sp -s web --site https://some.site.com/sites/dev","title":"Specify a Site"},{"location":"npm-scripts/#cleanup","text":"--cleanup If you include this flag the testing web will be deleted once tests are complete. Useful for local testing where you do not need to inspect the web once the tests are complete. Works with any of the other options, be careful when specifying a web using --site as it will be deleted. # clean up our testing site npm test -- --cleanup","title":"Cleanup"},{"location":"npm-scripts/#logging","text":"--logging If you include this flag a console logger will be subscribed and the log level will be set to Info. This will provide console output for all the requests being made during testing. This flag is compatible with all other flags - however unless you are trying to debug a specific test this will produce a lot of chatty output. # enable logging during testing npm test -- --logging","title":"Logging"},{"location":"npm-scripts/#spverbose","text":"Added in 2.0.13 --spverbose This flag will enable \"verbose\" OData mode for SharePoint tests. This flag is compatible with other flags. npm test -- --spverbose","title":"spVerbose"},{"location":"npm-scripts/#build","text":"Invokes the pnpbuild cli to transpile the TypeScript into JavaScript. All behavior is controlled via the tsconfig.json in the root of the project and sub folders as needed. npm run build","title":"build"},{"location":"npm-scripts/#package","text":"Invokes the pnpbuild cli to create the package directories under the dist folder. This will allow you to see exactly what will end up in the npm packages once they are published. npm run package","title":"package"},{"location":"npm-scripts/#lint","text":"Runs the linter. npm run lint","title":"lint"},{"location":"npm-scripts/#clean","text":"Removes any generated folders from the working directory. npm run clean","title":"clean"},{"location":"packages/","text":"Packages \u00b6 The following packages comprise the Patterns and Practices client side libraries. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins","title":"Packages"},{"location":"packages/#packages","text":"The following packages comprise the Patterns and Practices client side libraries. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins","title":"Packages"},{"location":"transition-guide/","text":"Transition Guide \u00b6 We have worked to make moving from @pnp library 1. to 2. as painless as possible, however there are some changes to how things work. The below guide we have provided an overview of what it takes to transition between the libraries. If we missed something, please let us know in the issues list so we can update the guide. Thanks! Installing @pnp libraries \u00b6 In version 1.* the libraries were setup as peer dependencies of each other requiring you to install each of them separately. We continue to believe this correctly describes the relationship, but recognize that basically nothing in the world accounts for peer dependencies. So we have updated the libraries to be dependencies. This makes it easier to install into your projects as you only need to install a single library: npm i --save @pnp/sp Selective Imports \u00b6 Another big change in v2 is the ability to selectively import the pieces you need from the libraries. This allows you to have smaller bundles and works well with tree-shaking. It does require you to have more import statements, which can potentially be a bit confusing at first. The selective imports apply to the sp and graph libraries. To help explain let's take the example of the Web object. In v1 Web includes a reference to pretty much everything else in the entire sp library. Meaning that if you use web (and you pretty much have to) you hold a ref to all the other pieces (like Fields, Lists, ContentTypes) even if you aren't using them. Because of that tree shaking can't do anything to reduce the bundle size because it \"thinks\" you are using them simply because they have been imported. To solve this in v2 the Web object no longer contains references to anything, it is a bare object with a few methods. If you look at the source you will see that, for example, there is no longer a \"lists\" property. These properties and methods are now added through selectively importing the functionality you need: Selectively Import Web lists functionality \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports the functionality for lists associated only with web import \"@pnp/sp/lists/web\"; const r = await sp.web.lists(); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports all the functionality for lists import \"@pnp/sp/lists\"; const r = await sp.web.lists(); Each of the docs pages shows the selective import paths for each sub-module (lists, items, etc.). Presets \u00b6 In addition to the ability to selectively import functionality you can import presets. This allows you to import an entire set of functionality in a single line. At launch the sp library will support two presets \"all\" and \"core\" with the graph library supporting \"all\". Using the \"all\" preset will match the functionality of v1. This can save you time in transitioning your projects so you can update to selective imports later. For new projects we recommend using the selective imports from day 1. To update your V1 projects to V2 you can replace all instances of \"@pnp/sp\" with \"@pnp/sp/presets/all\" and things should work as before (though some class names or other things may have changed, please review the change log and the rest of this guide). // V1 way of doing things: import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes, } from \"@pnp/sp\"; // V2 way with selective imports import { sp } from \"@pnp/sp\"; import { ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/clientside-pages\"; // V2 way with preset \"all\" import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/presets/all\"; Invokable Objects \u00b6 Another new feature is the addition of invokable objects. Previously where you used \"get()\" to invoke a request you can now leave it off. We have left the .get method in place so everyone's code wasn't broken immediately upon transitioning. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // old way (still works) const r1 = sp.web(); // invokable const r2 = sp.web(); The benefit is that objects can now support default actions that are not \"get\" but might be \"post\". And you save typing a few extra characters. This still work the same as with select or any of the other odata methods: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // invokable const r = sp.web.select(\"Title\", \"Url\")(); Factory Functions & Interfaces \u00b6 Another change in the library is in the structure of exports. We are no longer exporting the objects themselves, rather we are only exposing factory functions and interfaces. This allows us to decouple what developers use from our internal implementation. For folks using the fluent chain starting with sp you shouldn't need to update your code. If you are using any of the v1 classes directly you should just need to remove the \"new\" keyword and update the import path. The factory functions signature matches the constructor signature of the v1 objects. // v1 import { Web } from \"@pnp/sp\"; const web: Web = new Web(\"some absolute url\"); const r1 = web(); // v2 import { Web, IWeb } from \"@pnp/sp/webs\"; const web: IWeb = Web(\"some absolute url\"); const r2 = web(); Extension Methods \u00b6 Another new capability in v2 is the ability to extend objects and factories. This allows you to easily add methods or properties on a per-object basis. Please see the full article on extension methods describing this great new capability. CDN publishing \u00b6 Starting with v2 we will no longer create bundles for each of the packages. Historically these are not commonly used, don't work perfectly for everyone (there are a lot of ways to bundle things), and another piece we need to maintain. Instead we encourage folks to create their own bundles , optimized for their particular scenario. This will result in smaller overall bundle size and allow folks to bundle things to match their scenario. Please review the article on creating your custom bundles to see how to tailor bundles to your needs. The PnPjs bundle will remain, though it is designed only for backwards compatibility and we strongly recommend creating your own bundles, or directly importing the libraries into your projects using selective imports. Drop client-svc and sp-taxonomy libraries \u00b6 These libraries were created to allow folks to access and manage SharePoint taxonomy and manage metadata. Given that there is upcoming support for taxonomy via a supported REST API we will drop these two libraries. If working with taxonomy remains a core requirement of your application and we do not yet have support for the new apis, please remain on v1 for the time being. As of 2.0.6 we support reading the modern taxonomy API. Docs here","title":"Transition Guide"},{"location":"transition-guide/#transition-guide","text":"We have worked to make moving from @pnp library 1. to 2. as painless as possible, however there are some changes to how things work. The below guide we have provided an overview of what it takes to transition between the libraries. If we missed something, please let us know in the issues list so we can update the guide. Thanks!","title":"Transition Guide"},{"location":"transition-guide/#installing-pnp-libraries","text":"In version 1.* the libraries were setup as peer dependencies of each other requiring you to install each of them separately. We continue to believe this correctly describes the relationship, but recognize that basically nothing in the world accounts for peer dependencies. So we have updated the libraries to be dependencies. This makes it easier to install into your projects as you only need to install a single library: npm i --save @pnp/sp","title":"Installing @pnp libraries"},{"location":"transition-guide/#selective-imports","text":"Another big change in v2 is the ability to selectively import the pieces you need from the libraries. This allows you to have smaller bundles and works well with tree-shaking. It does require you to have more import statements, which can potentially be a bit confusing at first. The selective imports apply to the sp and graph libraries. To help explain let's take the example of the Web object. In v1 Web includes a reference to pretty much everything else in the entire sp library. Meaning that if you use web (and you pretty much have to) you hold a ref to all the other pieces (like Fields, Lists, ContentTypes) even if you aren't using them. Because of that tree shaking can't do anything to reduce the bundle size because it \"thinks\" you are using them simply because they have been imported. To solve this in v2 the Web object no longer contains references to anything, it is a bare object with a few methods. If you look at the source you will see that, for example, there is no longer a \"lists\" property. These properties and methods are now added through selectively importing the functionality you need:","title":"Selective Imports"},{"location":"transition-guide/#selectively-import-web-lists-functionality","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports the functionality for lists associated only with web import \"@pnp/sp/lists/web\"; const r = await sp.web.lists(); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports all the functionality for lists import \"@pnp/sp/lists\"; const r = await sp.web.lists(); Each of the docs pages shows the selective import paths for each sub-module (lists, items, etc.).","title":"Selectively Import Web lists functionality"},{"location":"transition-guide/#presets","text":"In addition to the ability to selectively import functionality you can import presets. This allows you to import an entire set of functionality in a single line. At launch the sp library will support two presets \"all\" and \"core\" with the graph library supporting \"all\". Using the \"all\" preset will match the functionality of v1. This can save you time in transitioning your projects so you can update to selective imports later. For new projects we recommend using the selective imports from day 1. To update your V1 projects to V2 you can replace all instances of \"@pnp/sp\" with \"@pnp/sp/presets/all\" and things should work as before (though some class names or other things may have changed, please review the change log and the rest of this guide). // V1 way of doing things: import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes, } from \"@pnp/sp\"; // V2 way with selective imports import { sp } from \"@pnp/sp\"; import { ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/clientside-pages\"; // V2 way with preset \"all\" import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/presets/all\";","title":"Presets"},{"location":"transition-guide/#invokable-objects","text":"Another new feature is the addition of invokable objects. Previously where you used \"get()\" to invoke a request you can now leave it off. We have left the .get method in place so everyone's code wasn't broken immediately upon transitioning. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // old way (still works) const r1 = sp.web(); // invokable const r2 = sp.web(); The benefit is that objects can now support default actions that are not \"get\" but might be \"post\". And you save typing a few extra characters. This still work the same as with select or any of the other odata methods: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // invokable const r = sp.web.select(\"Title\", \"Url\")();","title":"Invokable Objects"},{"location":"transition-guide/#factory-functions-interfaces","text":"Another change in the library is in the structure of exports. We are no longer exporting the objects themselves, rather we are only exposing factory functions and interfaces. This allows us to decouple what developers use from our internal implementation. For folks using the fluent chain starting with sp you shouldn't need to update your code. If you are using any of the v1 classes directly you should just need to remove the \"new\" keyword and update the import path. The factory functions signature matches the constructor signature of the v1 objects. // v1 import { Web } from \"@pnp/sp\"; const web: Web = new Web(\"some absolute url\"); const r1 = web(); // v2 import { Web, IWeb } from \"@pnp/sp/webs\"; const web: IWeb = Web(\"some absolute url\"); const r2 = web();","title":"Factory Functions &amp; Interfaces"},{"location":"transition-guide/#extension-methods","text":"Another new capability in v2 is the ability to extend objects and factories. This allows you to easily add methods or properties on a per-object basis. Please see the full article on extension methods describing this great new capability.","title":"Extension Methods"},{"location":"transition-guide/#cdn-publishing","text":"Starting with v2 we will no longer create bundles for each of the packages. Historically these are not commonly used, don't work perfectly for everyone (there are a lot of ways to bundle things), and another piece we need to maintain. Instead we encourage folks to create their own bundles , optimized for their particular scenario. This will result in smaller overall bundle size and allow folks to bundle things to match their scenario. Please review the article on creating your custom bundles to see how to tailor bundles to your needs. The PnPjs bundle will remain, though it is designed only for backwards compatibility and we strongly recommend creating your own bundles, or directly importing the libraries into your projects using selective imports.","title":"CDN publishing"},{"location":"transition-guide/#drop-client-svc-and-sp-taxonomy-libraries","text":"These libraries were created to allow folks to access and manage SharePoint taxonomy and manage metadata. Given that there is upcoming support for taxonomy via a supported REST API we will drop these two libraries. If working with taxonomy remains a core requirement of your application and we do not yet have support for the new apis, please remain on v1 for the time being. As of 2.0.6 we support reading the modern taxonomy API. Docs here","title":"Drop client-svc and sp-taxonomy libraries"},{"location":"authentication/","text":"Authentication \u00b6 One of the more challenging aspects of web development is ensuring you are properly authenticated to access the resources you need. This section is designed to guide you through connecting to the resources you need using the appropriate methods. There are two places the PnPjs libraries can be used to connect to various services client (browser) or server . Utility Scenarios \u00b6 BearerTokenFetchClient LambdaFetchClient Client Scenarios \u00b6 SharePoint Framework Connect As: Current User User + AAD App via MSAL User + AAD App via ADAL Connect To: SharePoint as: Current User User + AAD App via MSAL Graph as: Current User User + AAD App via MSAL Both as: Current User User + AAD App via MSAL Single Page Application User + AAD App via MSAL Server Scenarios \u00b6 NodeJS SharePoint App Registration (App-Only) ADAL (App-Only) MSAL (App-Only) - coming soon","title":"Getting Started"},{"location":"authentication/#authentication","text":"One of the more challenging aspects of web development is ensuring you are properly authenticated to access the resources you need. This section is designed to guide you through connecting to the resources you need using the appropriate methods. There are two places the PnPjs libraries can be used to connect to various services client (browser) or server .","title":"Authentication"},{"location":"authentication/#utility-scenarios","text":"BearerTokenFetchClient LambdaFetchClient","title":"Utility Scenarios"},{"location":"authentication/#client-scenarios","text":"SharePoint Framework Connect As: Current User User + AAD App via MSAL User + AAD App via ADAL Connect To: SharePoint as: Current User User + AAD App via MSAL Graph as: Current User User + AAD App via MSAL Both as: Current User User + AAD App via MSAL Single Page Application User + AAD App via MSAL","title":"Client Scenarios"},{"location":"authentication/#server-scenarios","text":"NodeJS SharePoint App Registration (App-Only) ADAL (App-Only) MSAL (App-Only) - coming soon","title":"Server Scenarios"},{"location":"authentication/adaljsclient/","text":"@pnp/core/adalclient \u00b6 This module contains the AdalClient class which can be used to authenticate to any AzureAD secured resource. It is designed to work seamlessly with SharePoint Framework's permissions. Where possible it is recommended to use the MSAL client . Getting Started \u00b6 Install the library and required dependencies npm install @pnp/adaljsclient --save Setup and Use inside SharePoint Framework \u00b6 Using the SharePoint Framework is the preferred way to make use of the AdalClient as we can use the AADTokenProvider to efficiently get tokens on your behalf. You can also read more about how this process works and the necessary SPFx configurations in the SharePoint Framework 1.6 release notes . This method will only work for SharePoint Framework >= 1.6. For earlier versions of SharePoint Framework you can still use the AdalClient as outlined below using the constructor to specify the values for an AAD Application you have setup. Calling the graph api \u00b6 By providing the context in the onInit we can create the adal client from known information. import { graph } from \"@pnp/graph\"; import { getRandomString } from \"@pnp/core\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup(this.context); }); } public render(): void { // here we are creating a team with a random name, required Group ReadWrite All permissions const teamName = `ATeam.${getRandomString(4)}`; this.domElement.innerHTML = `Hello, I am creating a team named \"${teamName}\" for you...`; graph.teams.create(teamName, \"This is a description\").then(t => { this.domElement.innerHTML += \"done!\"; }).catch(e => { this.domElement.innerHTML = `Oops, I ran into a problem...${JSON.stringify(e, null, 4)}`; }); } Calling the SharePoint API \u00b6 This example shows how to use the ADALClient with the @pnp/sp library to call an API secured with AAD from within SharePoint Framework. import { SPFxAdalClient } from \"@pnp/core\"; import { sp } from \"@pnp/sp/presets/all\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context, sp: { fetchClientFactory: () => new SPFxAdalClient(this.context), }, }); }); } public render(): void { sp.web().then(t => { this.domElement.innerHTML = JSON.stringify(t); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); } Calling the any API \u00b6 You can also use the AdalClient to execute AAD authenticated requests to any API which is properly configured to accept the incoming tokens. This approach will only work within SharePoint Framework >= 1.6. Here we call the SharePoint REST API without the sp library as an example. import { FetchOptions } from \"@pnp/core\"; import { AdalClient } from \"@pnp/adaljsclient\"; import { ODataDefaultParser } from \"@pnp/queryable\"; // ... public render(): void { // create an ADAL Client const client = AdalClient.fromSPFxContext(this.context); // setup the request options const opts: FetchOptions = { method: \"GET\", headers: { \"Accept\": \"application/json\", }, }; // execute the request client.fetch(\"https://{tenant}.sharepoint.com/_api/web\", opts).then(response => { // create a parser to convert the response into JSON. // You can create your own, at this point you have a fetch Response to work with const parser = new ODataDefaultParser(); parser.parse(response).then(json => { this.domElement.innerHTML = JSON.stringify(json); }); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); } Manually Configure \u00b6 This example shows setting up and using the AdalClient to make queries using information you have setup. You can review this article for more information on setting up and securing any application using AzureAD. Setup and Use with Microsoft Graph \u00b6 This sample uses a custom AzureAd app you have created and granted the appropriate permissions. import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph\"; // configure the graph client // parameters are: // client id - the id of the application you created in azure ad // tenant - can be id or URL (shown) // redirect url - absolute url of a page to which your application and Azure AD app allows replies graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"https://myapp/singlesignon.aspx\"); }, }, }); try { // call the graph API const groups = await graph.groups(); console.log(JSON.stringify(groups, null, 4)); } catch (e) { console.error(e); } Nodejs Applications \u00b6 We have a dedicated node client in @pnp/nodejs.","title":"ADAL Client"},{"location":"authentication/adaljsclient/#pnpcoreadalclient","text":"This module contains the AdalClient class which can be used to authenticate to any AzureAD secured resource. It is designed to work seamlessly with SharePoint Framework's permissions. Where possible it is recommended to use the MSAL client .","title":"@pnp/core/adalclient"},{"location":"authentication/adaljsclient/#getting-started","text":"Install the library and required dependencies npm install @pnp/adaljsclient --save","title":"Getting Started"},{"location":"authentication/adaljsclient/#setup-and-use-inside-sharepoint-framework","text":"Using the SharePoint Framework is the preferred way to make use of the AdalClient as we can use the AADTokenProvider to efficiently get tokens on your behalf. You can also read more about how this process works and the necessary SPFx configurations in the SharePoint Framework 1.6 release notes . This method will only work for SharePoint Framework >= 1.6. For earlier versions of SharePoint Framework you can still use the AdalClient as outlined below using the constructor to specify the values for an AAD Application you have setup.","title":"Setup and Use inside SharePoint Framework"},{"location":"authentication/adaljsclient/#calling-the-graph-api","text":"By providing the context in the onInit we can create the adal client from known information. import { graph } from \"@pnp/graph\"; import { getRandomString } from \"@pnp/core\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup(this.context); }); } public render(): void { // here we are creating a team with a random name, required Group ReadWrite All permissions const teamName = `ATeam.${getRandomString(4)}`; this.domElement.innerHTML = `Hello, I am creating a team named \"${teamName}\" for you...`; graph.teams.create(teamName, \"This is a description\").then(t => { this.domElement.innerHTML += \"done!\"; }).catch(e => { this.domElement.innerHTML = `Oops, I ran into a problem...${JSON.stringify(e, null, 4)}`; }); }","title":"Calling the graph api"},{"location":"authentication/adaljsclient/#calling-the-sharepoint-api","text":"This example shows how to use the ADALClient with the @pnp/sp library to call an API secured with AAD from within SharePoint Framework. import { SPFxAdalClient } from \"@pnp/core\"; import { sp } from \"@pnp/sp/presets/all\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context, sp: { fetchClientFactory: () => new SPFxAdalClient(this.context), }, }); }); } public render(): void { sp.web().then(t => { this.domElement.innerHTML = JSON.stringify(t); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); }","title":"Calling the SharePoint API"},{"location":"authentication/adaljsclient/#calling-the-any-api","text":"You can also use the AdalClient to execute AAD authenticated requests to any API which is properly configured to accept the incoming tokens. This approach will only work within SharePoint Framework >= 1.6. Here we call the SharePoint REST API without the sp library as an example. import { FetchOptions } from \"@pnp/core\"; import { AdalClient } from \"@pnp/adaljsclient\"; import { ODataDefaultParser } from \"@pnp/queryable\"; // ... public render(): void { // create an ADAL Client const client = AdalClient.fromSPFxContext(this.context); // setup the request options const opts: FetchOptions = { method: \"GET\", headers: { \"Accept\": \"application/json\", }, }; // execute the request client.fetch(\"https://{tenant}.sharepoint.com/_api/web\", opts).then(response => { // create a parser to convert the response into JSON. // You can create your own, at this point you have a fetch Response to work with const parser = new ODataDefaultParser(); parser.parse(response).then(json => { this.domElement.innerHTML = JSON.stringify(json); }); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); }","title":"Calling the any API"},{"location":"authentication/adaljsclient/#manually-configure","text":"This example shows setting up and using the AdalClient to make queries using information you have setup. You can review this article for more information on setting up and securing any application using AzureAD.","title":"Manually Configure"},{"location":"authentication/adaljsclient/#setup-and-use-with-microsoft-graph","text":"This sample uses a custom AzureAd app you have created and granted the appropriate permissions. import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph\"; // configure the graph client // parameters are: // client id - the id of the application you created in azure ad // tenant - can be id or URL (shown) // redirect url - absolute url of a page to which your application and Azure AD app allows replies graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"https://myapp/singlesignon.aspx\"); }, }, }); try { // call the graph API const groups = await graph.groups(); console.log(JSON.stringify(groups, null, 4)); } catch (e) { console.error(e); }","title":"Setup and Use with Microsoft Graph"},{"location":"authentication/adaljsclient/#nodejs-applications","text":"We have a dedicated node client in @pnp/nodejs.","title":"Nodejs Applications"},{"location":"authentication/bearertokenclient/","text":"@pnp/core/BearerTokenFetchClient \u00b6 The BearerTokenFetchClient takes a single parameter representing an access token and uses it to make the requests. The disadvantage to this approach is not knowing to where the request will be sent, which in some cases is fine. An alternative is the LambdaFetchClient Static \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { BearerTokenFetchClient } from \"@pnp/core\"; import { myTokenFactory } from \"./my-auth.js\"; graph.setup({ graph: { fetchClientFactory: () => { // note this method is not async, so your logic here cannot await. // Please see the LambdaFetchClient if you have a need for async support. const token = myTokenFactory(); return new BearerTokenFetchClient(token); }, }, });","title":"Bearer Token Client"},{"location":"authentication/bearertokenclient/#pnpcorebearertokenfetchclient","text":"The BearerTokenFetchClient takes a single parameter representing an access token and uses it to make the requests. The disadvantage to this approach is not knowing to where the request will be sent, which in some cases is fine. An alternative is the LambdaFetchClient","title":"@pnp/core/BearerTokenFetchClient"},{"location":"authentication/bearertokenclient/#static","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { BearerTokenFetchClient } from \"@pnp/core\"; import { myTokenFactory } from \"./my-auth.js\"; graph.setup({ graph: { fetchClientFactory: () => { // note this method is not async, so your logic here cannot await. // Please see the LambdaFetchClient if you have a need for async support. const token = myTokenFactory(); return new BearerTokenFetchClient(token); }, }, });","title":"Static"},{"location":"authentication/client-spa/","text":"Authentication in Single Page Application \u00b6 If you are writing a single page application deployed outside SharePoint it is recommended to use the MSAL client. You can find further details on the settings in the MSAL docs . You will need to ensure that you grant the permissions required to the application you are trying to use. import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); const data = await graph.me();","title":"SPA Auth"},{"location":"authentication/client-spa/#authentication-in-single-page-application","text":"If you are writing a single page application deployed outside SharePoint it is recommended to use the MSAL client. You can find further details on the settings in the MSAL docs . You will need to ensure that you grant the permissions required to the application you are trying to use. import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); const data = await graph.me();","title":"Authentication in Single Page Application"},{"location":"authentication/client-spfx/","text":"Authentication in SharePoint Framework \u00b6 Auth as Current User \u00b6 PnPjs is designed to work as easily as possible within the SharePoint Framework so the authentication setup is very simple for the base case. Supply the current SharePoint Framework context to the library. This works for both SharePoint authentication and Graph authentication using the current user. Graph permissions are controlled by the permissions granted to the SharePoint shared application within your tenant. The below example is taken from a SharePoint Framework webpart. Connect to SharePoint as Current User \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ... Connect to Graph as Current User \u00b6 Permissions for this graph connection are controlled by the Shared SharePoint Application. You can target other applications using the MSAL Client . import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present // this will use the ADAL client behind the scenes with no additional configuration work graph.setup(this.context); } // ... MSAL Client \u00b6 You might want/need to use a client configured to use your own AAD application and not the shared SharePoint application. You can do so using the MSAL client . Here we show this using graph, this works the same with any of the setup strategies . Please see the MSAL library docs for more details on what values to supply in the configuration. Note: you must install the @pnp/msaljsclient client package before using it import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); } // ... ADAL Client \u00b6 You can use the ADAL client from within SPFx, though it is recommended to transition to the MSAL client. Note: you must install the @pnp/adaljsclient client package before using it import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"\"); }, }); } // ...","title":"SPFx Auth"},{"location":"authentication/client-spfx/#authentication-in-sharepoint-framework","text":"","title":"Authentication in SharePoint Framework"},{"location":"authentication/client-spfx/#auth-as-current-user","text":"PnPjs is designed to work as easily as possible within the SharePoint Framework so the authentication setup is very simple for the base case. Supply the current SharePoint Framework context to the library. This works for both SharePoint authentication and Graph authentication using the current user. Graph permissions are controlled by the permissions granted to the SharePoint shared application within your tenant. The below example is taken from a SharePoint Framework webpart.","title":"Auth as Current User"},{"location":"authentication/client-spfx/#connect-to-sharepoint-as-current-user","text":"import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ...","title":"Connect to SharePoint as Current User"},{"location":"authentication/client-spfx/#connect-to-graph-as-current-user","text":"Permissions for this graph connection are controlled by the Shared SharePoint Application. You can target other applications using the MSAL Client . import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present // this will use the ADAL client behind the scenes with no additional configuration work graph.setup(this.context); } // ...","title":"Connect to Graph as Current User"},{"location":"authentication/client-spfx/#msal-client","text":"You might want/need to use a client configured to use your own AAD application and not the shared SharePoint application. You can do so using the MSAL client . Here we show this using graph, this works the same with any of the setup strategies . Please see the MSAL library docs for more details on what values to supply in the configuration. Note: you must install the @pnp/msaljsclient client package before using it import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); } // ...","title":"MSAL Client"},{"location":"authentication/client-spfx/#adal-client","text":"You can use the ADAL client from within SPFx, though it is recommended to transition to the MSAL client. Note: you must install the @pnp/adaljsclient client package before using it import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"\"); }, }); } // ...","title":"ADAL Client"},{"location":"authentication/lambdaclient/","text":"@pnp/core/LambdaFetchClient \u00b6 The LambdaFetchClient class allows you to provide an async function that returns an access token using any logic/supporting libraries you need. This provides total freedom to define how you do authentication, so long as it results in a usable Bearer token to call the target resource. The advantage to the LambdaFetchClient is that you get the url for each request, meaning your logic can account for where the request is headed. The token function should be as efficient as possible as it's logic must complete before each request will be sent. Signature \u00b6 The LambdaFetchClient accepts a single argument of type ILambdaTokenFactoryParams. // signature of method, the return string is the access token (parms: ILambdaTokenFactoryParams) => Promise<string> // ILambdaTokenFactoryParams export interface ILambdaTokenFactoryParams { /** * Url to which the request for which we are requesting a token will be sent */ url: string; /** * Any options supplied for the request */ options: IFetchOptions; } @azure/msal-browser example \u00b6 This example shows how to use @azure/msal-browser along with LambdaFetchClient to achieve signin. msal-browser has many possible configurations which are described within their documentation. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { LambdaFetchClient } from \"@pnp/core\"; import { PublicClientApplication, Configuration } from \"@azure/msal-browser\"; const config: Configuration = { auth: { clientId: \"{client id}\", authority: \"https://login.microsoftonline.com/common/\" } } // create a single application, could also create this within the lambda client, but it would create a new applicaiton per request const msal = new PublicClientApplication(config); // create a new instance of the lambda fetch client const client = new LambdaFetchClient(async () => { const request = { scopes: [\"User.Read.All\"], }; const response = await msal.loginPopup(request); // lamba returns the access token return response.accessToken; }); // setup graph with the client graph.setup({ graph: { fetchClientFactory: () => client, }, }); // execute the request to graph which will use the client defined above const result = await graph.users();","title":"Lambda Token Client"},{"location":"authentication/lambdaclient/#pnpcorelambdafetchclient","text":"The LambdaFetchClient class allows you to provide an async function that returns an access token using any logic/supporting libraries you need. This provides total freedom to define how you do authentication, so long as it results in a usable Bearer token to call the target resource. The advantage to the LambdaFetchClient is that you get the url for each request, meaning your logic can account for where the request is headed. The token function should be as efficient as possible as it's logic must complete before each request will be sent.","title":"@pnp/core/LambdaFetchClient"},{"location":"authentication/lambdaclient/#signature","text":"The LambdaFetchClient accepts a single argument of type ILambdaTokenFactoryParams. // signature of method, the return string is the access token (parms: ILambdaTokenFactoryParams) => Promise<string> // ILambdaTokenFactoryParams export interface ILambdaTokenFactoryParams { /** * Url to which the request for which we are requesting a token will be sent */ url: string; /** * Any options supplied for the request */ options: IFetchOptions; }","title":"Signature"},{"location":"authentication/lambdaclient/#azuremsal-browser-example","text":"This example shows how to use @azure/msal-browser along with LambdaFetchClient to achieve signin. msal-browser has many possible configurations which are described within their documentation. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { LambdaFetchClient } from \"@pnp/core\"; import { PublicClientApplication, Configuration } from \"@azure/msal-browser\"; const config: Configuration = { auth: { clientId: \"{client id}\", authority: \"https://login.microsoftonline.com/common/\" } } // create a single application, could also create this within the lambda client, but it would create a new applicaiton per request const msal = new PublicClientApplication(config); // create a new instance of the lambda fetch client const client = new LambdaFetchClient(async () => { const request = { scopes: [\"User.Read.All\"], }; const response = await msal.loginPopup(request); // lamba returns the access token return response.accessToken; }); // setup graph with the client graph.setup({ graph: { fetchClientFactory: () => client, }, }); // execute the request to graph which will use the client defined above const result = await graph.users();","title":"@azure/msal-browser example"},{"location":"authentication/msaljsclient/","text":"msaljsclient - MSAL Client for PnPjs \u00b6 The MSAL client is a thin wrapper around the MSAL library adapting it for use with PnPjs's request pipeline. Install \u00b6 You need to install the MSAL client before using it. This is in addition to installing the other PnPjs libraries you require. npm install @pnp/msaljsclient --save Configure \u00b6 The PnP client is a very thin wrapper around the MSAL library and you can supply any of the arguments supported. These are described in the MSAL docs . The basic configuration values you need (at least from our testing) are client id, authority, and redirectUri. The other options are settable but not required. This article is not intended to be an exhaustive discussion of all the MSAL configuration possibilities, please see the official docs to understand all of the available options. The second parameter when configuring the PnP client is the list of scope you are seeking to use. These must be configured and properly granted within AAD and you can request one or more scopes as needed for the current scenario. Use in SPFx \u00b6 Calling SharePoint via MSAL \u00b6 When calling the SharePoint REST API we must use only a special scope \"https://{tenant}.sharepoint.com/.default\" import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/mytentant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://mytentant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"https://mytentant.sharepoint.com/.default\"]), }, }); const r = await sp.web(); Calling Graph via MSAL \u00b6 When calling the graph API you must specify the scopes you need and ensure they are configured in AAD import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups(); Use in Single Page Applications \u00b6 You can also use the PnPjs MSAL client within your SPA applications. Please review the various settings to ensure you are configuring MSAL as needed for your application import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://myapp.com/login.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups(); Get a Token \u00b6 You can also use the client to get a token if you need a token for use outside the PnPjs libraries import { MsalClient } from \"@pnp/msaljsclient\"; // note we do not provide scopes here as the second parameter. We certainly could and will get a token // based on those scopes by making a call to getToken() without a param. const client = new MsalClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant}.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://{tenant}.sharepoint.com/sites/dev/SitePages/webpacktest.aspx\", }, }); const token = await client.getToken([\"Group.Read.All\"]); const token2 = await client.getToken([\"Files.Read\"]);","title":"MSAL Client"},{"location":"authentication/msaljsclient/#msaljsclient-msal-client-for-pnpjs","text":"The MSAL client is a thin wrapper around the MSAL library adapting it for use with PnPjs's request pipeline.","title":"msaljsclient - MSAL Client for PnPjs"},{"location":"authentication/msaljsclient/#install","text":"You need to install the MSAL client before using it. This is in addition to installing the other PnPjs libraries you require. npm install @pnp/msaljsclient --save","title":"Install"},{"location":"authentication/msaljsclient/#configure","text":"The PnP client is a very thin wrapper around the MSAL library and you can supply any of the arguments supported. These are described in the MSAL docs . The basic configuration values you need (at least from our testing) are client id, authority, and redirectUri. The other options are settable but not required. This article is not intended to be an exhaustive discussion of all the MSAL configuration possibilities, please see the official docs to understand all of the available options. The second parameter when configuring the PnP client is the list of scope you are seeking to use. These must be configured and properly granted within AAD and you can request one or more scopes as needed for the current scenario.","title":"Configure"},{"location":"authentication/msaljsclient/#use-in-spfx","text":"","title":"Use in SPFx"},{"location":"authentication/msaljsclient/#calling-sharepoint-via-msal","text":"When calling the SharePoint REST API we must use only a special scope \"https://{tenant}.sharepoint.com/.default\" import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/mytentant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://mytentant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"https://mytentant.sharepoint.com/.default\"]), }, }); const r = await sp.web();","title":"Calling SharePoint via MSAL"},{"location":"authentication/msaljsclient/#calling-graph-via-msal","text":"When calling the graph API you must specify the scopes you need and ensure they are configured in AAD import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups();","title":"Calling Graph via MSAL"},{"location":"authentication/msaljsclient/#use-in-single-page-applications","text":"You can also use the PnPjs MSAL client within your SPA applications. Please review the various settings to ensure you are configuring MSAL as needed for your application import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://myapp.com/login.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups();","title":"Use in Single Page Applications"},{"location":"authentication/msaljsclient/#get-a-token","text":"You can also use the client to get a token if you need a token for use outside the PnPjs libraries import { MsalClient } from \"@pnp/msaljsclient\"; // note we do not provide scopes here as the second parameter. We certainly could and will get a token // based on those scopes by making a call to getToken() without a param. const client = new MsalClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant}.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://{tenant}.sharepoint.com/sites/dev/SitePages/webpacktest.aspx\", }, }); const token = await client.getToken([\"Group.Read.All\"]); const token2 = await client.getToken([\"Files.Read\"]);","title":"Get a Token"},{"location":"authentication/server-nodejs/","text":"Authentication in Nodejs \u00b6 SharePoint App Registration \u00b6 Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Auth . Within the PnPjs testing framework we make use of SharePoint App Registration. This uses the SPFetchClient client from the nodejs package. This client works based on the legacy SharePoint App Registration model making use of a client and secret granted permissions through AppInv.aspx. This method works and at the time of writing has no published end date. See: details on how to register a legacy SharePoint application . import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web(); MSAL \u00b6 Added in 2.0.11 You can now use the @azure/msal-node client with PnPjs using MsalFetchClient. You must configure an AAD application with the appropriate permissions for your application. At the time this article was written the msal-node package is not yet GA. Call Graph \u00b6 You can call the Microsoft Graph API with a client id and secret or certificate (see SharePoint example for cert auth) import { graph } from \"@pnp/graph/presets/all\"; // configure your node options graph.setup({ graph: { fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientId: \"{guid}\", clientSecret: \"{client secret}\", } }); }, }, }); const userInfo = await graph.users(); Call SharePoint \u00b6 To call the SharePoint APIs via MSAL you are required to use certificate authentication with your application. Fully covering certificates is outside the scope of these docs, but the following commands were used with openssl to create testing certs for the sample code below. mkdir \\temp cd \\temp openssl req -x509 -newkey rsa:2048 -keyout keytmp.pem -out cert.pem -days 365 -passout pass:HereIsMySuperPass -subj '/C=US/ST=Washington/L=Seattle' openssl rsa -in keytmp.pem -out key.pem -passin pass:HereIsMySuperPass Using the above code you end up with three files, \"cert.pem\", \"key.pem\", and \"keytmp.pem\". The \"cert.pem\" file is uploaded to your AAD application registration. The \"key.pem\" is read as the private key for the configuration. You need to set the baseUrl property when using the MsalFetchClient import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const w = await sp.web(); ADAL \u00b6 The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. See: More details on the node client import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"NodeJS Auth"},{"location":"authentication/server-nodejs/#authentication-in-nodejs","text":"","title":"Authentication in Nodejs"},{"location":"authentication/server-nodejs/#sharepoint-app-registration","text":"Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Auth . Within the PnPjs testing framework we make use of SharePoint App Registration. This uses the SPFetchClient client from the nodejs package. This client works based on the legacy SharePoint App Registration model making use of a client and secret granted permissions through AppInv.aspx. This method works and at the time of writing has no published end date. See: details on how to register a legacy SharePoint application . import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web();","title":"SharePoint App Registration"},{"location":"authentication/server-nodejs/#msal","text":"Added in 2.0.11 You can now use the @azure/msal-node client with PnPjs using MsalFetchClient. You must configure an AAD application with the appropriate permissions for your application. At the time this article was written the msal-node package is not yet GA.","title":"MSAL"},{"location":"authentication/server-nodejs/#call-graph","text":"You can call the Microsoft Graph API with a client id and secret or certificate (see SharePoint example for cert auth) import { graph } from \"@pnp/graph/presets/all\"; // configure your node options graph.setup({ graph: { fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientId: \"{guid}\", clientSecret: \"{client secret}\", } }); }, }, }); const userInfo = await graph.users();","title":"Call Graph"},{"location":"authentication/server-nodejs/#call-sharepoint","text":"To call the SharePoint APIs via MSAL you are required to use certificate authentication with your application. Fully covering certificates is outside the scope of these docs, but the following commands were used with openssl to create testing certs for the sample code below. mkdir \\temp cd \\temp openssl req -x509 -newkey rsa:2048 -keyout keytmp.pem -out cert.pem -days 365 -passout pass:HereIsMySuperPass -subj '/C=US/ST=Washington/L=Seattle' openssl rsa -in keytmp.pem -out key.pem -passin pass:HereIsMySuperPass Using the above code you end up with three files, \"cert.pem\", \"key.pem\", and \"keytmp.pem\". The \"cert.pem\" file is uploaded to your AAD application registration. The \"key.pem\" is read as the private key for the configuration. You need to set the baseUrl property when using the MsalFetchClient import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const w = await sp.web();","title":"Call SharePoint"},{"location":"authentication/server-nodejs/#adal","text":"The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. See: More details on the node client import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"ADAL"},{"location":"authentication/sp-app-registration/","text":"Legacy SharePoint App Registration \u00b6 This section outlines how to register for a client id and secret for use in the above code. Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Authentication . Register An Add-In \u00b6 Before you can begin running tests you need to register a low-trust add-in with SharePoint. This is primarily designed for Office 365, but can work on-premises if you configure your farm accordingly . Navigation to {site url}/_layouts/appregnew.aspx Click \"Generate\" for both the Client Id and Secret values Give you add-in a title, this can be anything but will let you locate it in the list of add-in permissions Provide a fake value for app domain and redirect uri Click \"Create\" Copy the returned block of text containing the client id and secret as well as app name for your records and later in this article. Grant Your Add-In Permissions \u00b6 Now that we have created an add-in registration we need to tell SharePoint what permissions it can use. Due to an update in SharePoint Online you now have to register add-ins with certain permissions in the admin site . Navigate to {admin site url}/_layouts/appinv.aspx Paste your client id from the above section into the App Id box and click \"Lookup\" You should see the information populated into the form from the last section, if not ensure you have the correct id value Paste the below XML into the permissions request xml box and hit \"Create\" You should get a confirmation message. <AppPermissionRequests AllowAppOnlyPolicy=\"true\"> <AppPermissionRequest Scope=\"http://sharepoint/content/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/social/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/search\" Right=\"QueryAsUserIgnoreAppPrincipal\" /> </AppPermissionRequests> Note that the above XML will grant full tenant control. This is OK for testing, but you should grant only those permissions necessary for your application in production.","title":"SP App Reg"},{"location":"authentication/sp-app-registration/#legacy-sharepoint-app-registration","text":"This section outlines how to register for a client id and secret for use in the above code. Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Authentication .","title":"Legacy SharePoint App Registration"},{"location":"authentication/sp-app-registration/#register-an-add-in","text":"Before you can begin running tests you need to register a low-trust add-in with SharePoint. This is primarily designed for Office 365, but can work on-premises if you configure your farm accordingly . Navigation to {site url}/_layouts/appregnew.aspx Click \"Generate\" for both the Client Id and Secret values Give you add-in a title, this can be anything but will let you locate it in the list of add-in permissions Provide a fake value for app domain and redirect uri Click \"Create\" Copy the returned block of text containing the client id and secret as well as app name for your records and later in this article.","title":"Register An Add-In"},{"location":"authentication/sp-app-registration/#grant-your-add-in-permissions","text":"Now that we have created an add-in registration we need to tell SharePoint what permissions it can use. Due to an update in SharePoint Online you now have to register add-ins with certain permissions in the admin site . Navigate to {admin site url}/_layouts/appinv.aspx Paste your client id from the above section into the App Id box and click \"Lookup\" You should see the information populated into the form from the last section, if not ensure you have the correct id value Paste the below XML into the permissions request xml box and hit \"Create\" You should get a confirmation message. <AppPermissionRequests AllowAppOnlyPolicy=\"true\"> <AppPermissionRequest Scope=\"http://sharepoint/content/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/social/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/search\" Right=\"QueryAsUserIgnoreAppPrincipal\" /> </AppPermissionRequests> Note that the above XML will grant full tenant control. This is OK for testing, but you should grant only those permissions necessary for your application in production.","title":"Grant Your Add-In Permissions"},{"location":"common/","text":"@pnp/core \u00b6 The common modules provides a set of utilities classes and reusable building blocks used throughout the @pnp modules. They can be used within your applications as well. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/core --save Import and use functionality, see details on modules below. import { getGUID } from \"@pnp/core\"; console.log(getGUID()); Exports \u00b6 collections libconfig netutil storage util Custom HttpClient","title":"common"},{"location":"common/#pnpcore","text":"The common modules provides a set of utilities classes and reusable building blocks used throughout the @pnp modules. They can be used within your applications as well.","title":"@pnp/core"},{"location":"common/#getting-started","text":"Install the library and required dependencies npm install @pnp/core --save Import and use functionality, see details on modules below. import { getGUID } from \"@pnp/core\"; console.log(getGUID());","title":"Getting Started"},{"location":"common/#exports","text":"collections libconfig netutil storage util Custom HttpClient","title":"Exports"},{"location":"common/collections/","text":"@pnp/core/collections \u00b6 The collections module provides typings and classes related to working with dictionaries. TypedHash \u00b6 Interface used to described an object with string keys corresponding to values of type T export interface TypedHash<T> { [key: string]: T; } objectToMap \u00b6 Converts a plain object to a Map instance const map = objectToMap({ a: \"b\", c: \"d\"}); mergeMaps \u00b6 Merges two or more maps, overwriting values with the same key. Last value in wins. const m1 = new Map(); const m2 = new Map(); const m3 = new Map(); const m4 = new Map(); const m = mergeMaps(m1, m2, m3, m4);","title":"collections"},{"location":"common/collections/#pnpcorecollections","text":"The collections module provides typings and classes related to working with dictionaries.","title":"@pnp/core/collections"},{"location":"common/collections/#typedhash","text":"Interface used to described an object with string keys corresponding to values of type T export interface TypedHash<T> { [key: string]: T; }","title":"TypedHash"},{"location":"common/collections/#objecttomap","text":"Converts a plain object to a Map instance const map = objectToMap({ a: \"b\", c: \"d\"});","title":"objectToMap"},{"location":"common/collections/#mergemaps","text":"Merges two or more maps, overwriting values with the same key. Last value in wins. const m1 = new Map(); const m2 = new Map(); const m3 = new Map(); const m4 = new Map(); const m = mergeMaps(m1, m2, m3, m4);","title":"mergeMaps"},{"location":"common/custom-httpclientimpl/","text":"Custom HttpClientImpl \u00b6 This should be considered an advanced topic and creating a custom HttpClientImpl is not something you will likely need to do. Also, we don't offer support beyond this article for writing your own implementation. It is possible you may need complete control over the sending and receiving of requests. Before you get started read and understand the fetch specification as you are essentially writing a custom fetch implementation. The first step (second if you read the fetch spec as mentioned just above) is to understand the interface you need to implement, HttpClientImpl. export interface HttpClientImpl { fetch(url: string, options: FetchOptions): Promise<Response>; } There is a single method \"fetch\" which takes a url string and a set of options. These options can be just about anything but are constrained within the library to the FetchOptions interface. export interface FetchOptions { method?: string; headers?: HeadersInit | { [index: string]: string }; body?: BodyInit; mode?: string | RequestMode; credentials?: string | RequestCredentials; cache?: string | RequestCache; } So you will need to handle any of those options along with the provided url when sending your request. The library will expect your implementation to return a Promise that resolves to a Response defined by the fetch specification - which you've already read \ud83d\udc4d. Using Your Custom HttpClientImpl \u00b6 Once you have written your implementation using it on your requests is done by setting it in the global library configuration: import { setup } from \"@pnp/core\"; import { sp, Web } from \"@pnp/sp\"; import { MyAwesomeClient } from \"./awesomeclient\"; sp.setup({ sp: { fetchClientFactory: () => { return new MyAwesomeClient(); } } }); let w = new Web(\"{site url}\"); // this request will use your client. const result = await w.select(\"Title\")(); console.log(result); Subclassing is Better \u00b6 You can of course inherit from one of the implementations available within the @pnp scope if you just need to say add a header or need to do something to every request sent. Perhaps some advanced logging. This approach will save you from needing to fully write a fetch implementation. A FINAL NOTE \u00b6 Whatever you do, do not write a client that uses a client id and secret and exposes them on the client side. Client Id and Secret should only ever be used on a server, never exposed to clients as anyone with those values has the full permissions granted to that id and secret.","title":"Custom HttpClientImpl"},{"location":"common/custom-httpclientimpl/#custom-httpclientimpl","text":"This should be considered an advanced topic and creating a custom HttpClientImpl is not something you will likely need to do. Also, we don't offer support beyond this article for writing your own implementation. It is possible you may need complete control over the sending and receiving of requests. Before you get started read and understand the fetch specification as you are essentially writing a custom fetch implementation. The first step (second if you read the fetch spec as mentioned just above) is to understand the interface you need to implement, HttpClientImpl. export interface HttpClientImpl { fetch(url: string, options: FetchOptions): Promise<Response>; } There is a single method \"fetch\" which takes a url string and a set of options. These options can be just about anything but are constrained within the library to the FetchOptions interface. export interface FetchOptions { method?: string; headers?: HeadersInit | { [index: string]: string }; body?: BodyInit; mode?: string | RequestMode; credentials?: string | RequestCredentials; cache?: string | RequestCache; } So you will need to handle any of those options along with the provided url when sending your request. The library will expect your implementation to return a Promise that resolves to a Response defined by the fetch specification - which you've already read \ud83d\udc4d.","title":"Custom HttpClientImpl"},{"location":"common/custom-httpclientimpl/#using-your-custom-httpclientimpl","text":"Once you have written your implementation using it on your requests is done by setting it in the global library configuration: import { setup } from \"@pnp/core\"; import { sp, Web } from \"@pnp/sp\"; import { MyAwesomeClient } from \"./awesomeclient\"; sp.setup({ sp: { fetchClientFactory: () => { return new MyAwesomeClient(); } } }); let w = new Web(\"{site url}\"); // this request will use your client. const result = await w.select(\"Title\")(); console.log(result);","title":"Using Your Custom HttpClientImpl"},{"location":"common/custom-httpclientimpl/#subclassing-is-better","text":"You can of course inherit from one of the implementations available within the @pnp scope if you just need to say add a header or need to do something to every request sent. Perhaps some advanced logging. This approach will save you from needing to fully write a fetch implementation.","title":"Subclassing is Better"},{"location":"common/custom-httpclientimpl/#a-final-note","text":"Whatever you do, do not write a client that uses a client id and secret and exposes them on the client side. Client Id and Secret should only ever be used on a server, never exposed to clients as anyone with those values has the full permissions granted to that id and secret.","title":"A FINAL NOTE"},{"location":"common/libconfig/","text":"@pnp/core/libconfig \u00b6 Contains the shared classes and interfaces used to configure the libraries. These bases classes are expanded on in dependent libraries with the core configuration defined here. This module exposes an instance of the RuntimeConfigImpl class: RuntimeConfig. This configuration object can be referenced and contains the global configuration shared across the libraries. You can also extend the configuration for use within your own applications. ILibraryConfiguration Interface \u00b6 Defines the shared configurable values used across the library as shown below. Each of these has a default value as shown below export interface ILibraryConfiguration { /** * Allows caching to be global disabled, default: false */ globalCacheDisable?: boolean; /** * Defines the default store used by the usingCaching method, default: session */ defaultCachingStore?: \"session\" | \"local\"; /** * Defines the default timeout in seconds used by the usingCaching method, default 30 */ defaultCachingTimeoutSeconds?: number; /** * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval */ enableCacheExpiration?: boolean; /** * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) */ cacheExpirationIntervalMilliseconds?: number; /** * Used to supply the current context from an SPFx webpart to the library */ spfxContext?: any; } RuntimeConfigImpl \u00b6 The class which implements the runtime configuration management as well as sets the default values used within the library. At its heart lies a Dictionary used to track the configuration values. The keys will match the values in the interface or plain object passed to the extend method. assign \u00b6 The assign method is used to add configuration to the global configuration instance. You can pass it any plain object with string keys and those values will be added. Any existing values will be overwritten based on the keys. Last value in wins. For a more detailed scenario of using the RuntimeConfig instance in your own application please see the section below \"Using RuntimeConfig within your application\". Note there are no methods to remove/clear the global config as it should be considered fairly static as frequent updates may have unpredictable side effects as it is a global shared object. Generally it should be set at the start of your application. import { RuntimeConfig } from \"@pnp/core\"; // add your custom keys to the global configuration // note you can use object hashes as values RuntimeConfig.assign({ \"myKey1\": \"value 1\", \"myKey2\": { \"subKey\": \"sub value 1\", \"subKey2\": \"sub value 2\", }, }); // read your custom values const v = RuntimeConfig.get(\"myKey1\"); // \"value 1\" Using RuntimeConfig within your Application \u00b6 If you have a set of properties you will access very frequently it may be desirable to implement your own configuration object and expose those values as properties. To do so you will need to create an interface for your configuration (optional) and a wrapper class for RuntimeConfig to expose your properties import { ILibraryConfiguration, RuntimeConfig, ITypedHash } from \"@pnp/core\"; // first we create our own interface by extending LibraryConfiguration. This allows your class to accept all the values with correct type checking. Note, because // TypeScript allows you to extend from multiple interfaces you can build a complex configuration definition from many sub definitions. // create the interface of your properties // by creating this separately you allows others to compose your parts into their own config interface MyConfigurationPart { // you can create a grouped definition and access your settings as an object // keys can be optional or required as defined by your interface my?: { prop1?: string; prop2?: string; } // and/or define multiple top level properties (beware key collision) // it is good practice to use a unique prefix myProp1: string; myProp2: number; } // now create a combined interface interface MyConfiguration extends ILibraryConfiguration, MyConfigurationPart { } // now create a wrapper object and expose your properties class MyRuntimeConfigImpl { // exposing a nested property public get prop1(): ITypedHash<string> { const myPart = RuntimeConfig.get(\"my\"); if (myPart !== null && typeof myPart !== \"undefined\" && typeof myPart.prop1 !== \"undefined\") { return myPart.prop1; } return {}; } // exposing a root level property public get myProp1(): string | null { let myProp1 = RuntimeConfig.get(\"myProp1\"); if (myProp1 === null) { myProp1 = \"some default value\"; } return myProp1; } setup(config: MyConfiguration): void { RuntimeConfig.assign(config); } } // create a single static instance of your impl class export let MyRuntimeConfig = new MyRuntimeConfigImpl(); Now in other files you can use and set your configuration with a typed interface and properties import { MyRuntimeConfig } from \"{location of module}\"; MyRuntimeConfig.setup({ my: { prop1: \"hello\", }, }); const value = MyRuntimeConfig.myProp1; // \"hello\"","title":"libconfig"},{"location":"common/libconfig/#pnpcorelibconfig","text":"Contains the shared classes and interfaces used to configure the libraries. These bases classes are expanded on in dependent libraries with the core configuration defined here. This module exposes an instance of the RuntimeConfigImpl class: RuntimeConfig. This configuration object can be referenced and contains the global configuration shared across the libraries. You can also extend the configuration for use within your own applications.","title":"@pnp/core/libconfig"},{"location":"common/libconfig/#ilibraryconfiguration-interface","text":"Defines the shared configurable values used across the library as shown below. Each of these has a default value as shown below export interface ILibraryConfiguration { /** * Allows caching to be global disabled, default: false */ globalCacheDisable?: boolean; /** * Defines the default store used by the usingCaching method, default: session */ defaultCachingStore?: \"session\" | \"local\"; /** * Defines the default timeout in seconds used by the usingCaching method, default 30 */ defaultCachingTimeoutSeconds?: number; /** * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval */ enableCacheExpiration?: boolean; /** * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) */ cacheExpirationIntervalMilliseconds?: number; /** * Used to supply the current context from an SPFx webpart to the library */ spfxContext?: any; }","title":"ILibraryConfiguration Interface"},{"location":"common/libconfig/#runtimeconfigimpl","text":"The class which implements the runtime configuration management as well as sets the default values used within the library. At its heart lies a Dictionary used to track the configuration values. The keys will match the values in the interface or plain object passed to the extend method.","title":"RuntimeConfigImpl"},{"location":"common/libconfig/#assign","text":"The assign method is used to add configuration to the global configuration instance. You can pass it any plain object with string keys and those values will be added. Any existing values will be overwritten based on the keys. Last value in wins. For a more detailed scenario of using the RuntimeConfig instance in your own application please see the section below \"Using RuntimeConfig within your application\". Note there are no methods to remove/clear the global config as it should be considered fairly static as frequent updates may have unpredictable side effects as it is a global shared object. Generally it should be set at the start of your application. import { RuntimeConfig } from \"@pnp/core\"; // add your custom keys to the global configuration // note you can use object hashes as values RuntimeConfig.assign({ \"myKey1\": \"value 1\", \"myKey2\": { \"subKey\": \"sub value 1\", \"subKey2\": \"sub value 2\", }, }); // read your custom values const v = RuntimeConfig.get(\"myKey1\"); // \"value 1\"","title":"assign"},{"location":"common/libconfig/#using-runtimeconfig-within-your-application","text":"If you have a set of properties you will access very frequently it may be desirable to implement your own configuration object and expose those values as properties. To do so you will need to create an interface for your configuration (optional) and a wrapper class for RuntimeConfig to expose your properties import { ILibraryConfiguration, RuntimeConfig, ITypedHash } from \"@pnp/core\"; // first we create our own interface by extending LibraryConfiguration. This allows your class to accept all the values with correct type checking. Note, because // TypeScript allows you to extend from multiple interfaces you can build a complex configuration definition from many sub definitions. // create the interface of your properties // by creating this separately you allows others to compose your parts into their own config interface MyConfigurationPart { // you can create a grouped definition and access your settings as an object // keys can be optional or required as defined by your interface my?: { prop1?: string; prop2?: string; } // and/or define multiple top level properties (beware key collision) // it is good practice to use a unique prefix myProp1: string; myProp2: number; } // now create a combined interface interface MyConfiguration extends ILibraryConfiguration, MyConfigurationPart { } // now create a wrapper object and expose your properties class MyRuntimeConfigImpl { // exposing a nested property public get prop1(): ITypedHash<string> { const myPart = RuntimeConfig.get(\"my\"); if (myPart !== null && typeof myPart !== \"undefined\" && typeof myPart.prop1 !== \"undefined\") { return myPart.prop1; } return {}; } // exposing a root level property public get myProp1(): string | null { let myProp1 = RuntimeConfig.get(\"myProp1\"); if (myProp1 === null) { myProp1 = \"some default value\"; } return myProp1; } setup(config: MyConfiguration): void { RuntimeConfig.assign(config); } } // create a single static instance of your impl class export let MyRuntimeConfig = new MyRuntimeConfigImpl(); Now in other files you can use and set your configuration with a typed interface and properties import { MyRuntimeConfig } from \"{location of module}\"; MyRuntimeConfig.setup({ my: { prop1: \"hello\", }, }); const value = MyRuntimeConfig.myProp1; // \"hello\"","title":"Using RuntimeConfig within your Application"},{"location":"common/netutil/","text":"@pnp/core/net \u00b6 This module contains a set of classes and interfaces used to characterize shared http interactions and configuration of the libraries. Some of the interfaces are described below (many have no use outside the library) as well as several classes. Interfaces \u00b6 HttpClientImpl \u00b6 Defines an implementation of an Http Client within the context of @pnp. This being a class with a a single method \"fetch\" takes a URL and options. It returns a Promise<Response> . Used primarily with the shared request pipeline to define the client used to make the actual request. You can write your own custom implementation if needed. RequestClient \u00b6 An abstraction that contains specific methods related to each of the primary request methods get, post, patch, delete as well as fetch and fetchRaw. The difference between fetch and fetchRaw is that a client may include additional logic or processing in fetch, where fetchRaw should be a direct call to the underlying HttpClientImpl fetch method. Classes \u00b6 This module export two classes of note, FetchClient and BearerTokenFetchClient. Both implement HttpClientImpl. FetchClient \u00b6 Basic implementation that calls the global (window) fetch method with no additional processing. import { FetchClient } from \"@pnp/core\"; const client = new FetchClient(); client.fetch(\"{url}\", {}); BearerTokenFetchClient \u00b6 A simple implementation that takes a provided authentication token and adds the Authentication Bearer header to the request. No other processing is done and the token is treated as a static string. import { BearerTokenFetchClient } from \"@pnp/core\"; const client = new BearerTokenFetchClient(\"{authentication token}\"); client.fetch(\"{url}\", {});","title":"netutil"},{"location":"common/netutil/#pnpcorenet","text":"This module contains a set of classes and interfaces used to characterize shared http interactions and configuration of the libraries. Some of the interfaces are described below (many have no use outside the library) as well as several classes.","title":"@pnp/core/net"},{"location":"common/netutil/#interfaces","text":"","title":"Interfaces"},{"location":"common/netutil/#httpclientimpl","text":"Defines an implementation of an Http Client within the context of @pnp. This being a class with a a single method \"fetch\" takes a URL and options. It returns a Promise<Response> . Used primarily with the shared request pipeline to define the client used to make the actual request. You can write your own custom implementation if needed.","title":"HttpClientImpl"},{"location":"common/netutil/#requestclient","text":"An abstraction that contains specific methods related to each of the primary request methods get, post, patch, delete as well as fetch and fetchRaw. The difference between fetch and fetchRaw is that a client may include additional logic or processing in fetch, where fetchRaw should be a direct call to the underlying HttpClientImpl fetch method.","title":"RequestClient"},{"location":"common/netutil/#classes","text":"This module export two classes of note, FetchClient and BearerTokenFetchClient. Both implement HttpClientImpl.","title":"Classes"},{"location":"common/netutil/#fetchclient","text":"Basic implementation that calls the global (window) fetch method with no additional processing. import { FetchClient } from \"@pnp/core\"; const client = new FetchClient(); client.fetch(\"{url}\", {});","title":"FetchClient"},{"location":"common/netutil/#bearertokenfetchclient","text":"A simple implementation that takes a provided authentication token and adds the Authentication Bearer header to the request. No other processing is done and the token is treated as a static string. import { BearerTokenFetchClient } from \"@pnp/core\"; const client = new BearerTokenFetchClient(\"{authentication token}\"); client.fetch(\"{url}\", {});","title":"BearerTokenFetchClient"},{"location":"common/storage/","text":"@pnp/core/storage \u00b6 This module provides a thin wrapper over the browser storage options, local and session. If neither option is available it shims storage with a non-persistent in memory polyfill. Optionally through configuration you can activate expiration. Sample usage is shown below. PnPClientStorage \u00b6 The main export of this module, contains properties representing local and session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); const myvalue = storage.local.get(\"mykey\"); PnPClientStorageWrapper \u00b6 Each of the storage locations (session and local) are wrapped with this helper class. You can use it directly, but generally it would be used from an instance of PnPClientStorage as shown below. These examples all use local storage, the operations are identical for session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // get a value from storage const value = storage.local.get(\"mykey\"); // put a value into storage storage.local.put(\"mykey2\", \"my value\"); // put a value into storage with an expiration storage.local.put(\"mykey2\", \"my value\", new Date()); // put a simple object into storage // because JSON.stringify is used to package the object we do NOT do a deep rehydration of stored objects storage.local.put(\"mykey3\", { key: \"value\", key2: \"value2\", }); // remove a value from storage storage.local.delete(\"mykey3\"); // get an item or add it if it does not exist // returns a promise in case you need time to get the value for storage // optionally takes a third parameter specifying the expiration storage.local.getOrPut(\"mykey4\", () => { return Promise.resolve(\"value\"); }); // delete expired items storage.local.deleteExpired(); Cache Expiration \u00b6 The ability remove of expired items based on a configured timeout can help if the cache is filling up. This can be accomplished in two ways. The first is to explicitly call the new deleteExpired method on the cache you wish to clear. A suggested usage is to add this into your page init code as clearing expired items once per page load is likely sufficient. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // session storage storage.session.deleteExpired(); // local storage storage.local.deleteExpired(); // this returns a promise, so you can perform some activity after the expired items are removed: storage.local.deleteExpired().then(_ => { // init my application }); The second method is to enable automated cache expiration through global config. Setting the enableCacheExpiration property to true will enable the timer. Optionally you can set the interval at which the cache is checked via the cacheExpirationIntervalMilliseconds property, by default 750 milliseconds is used. We enforce a minimum of 300 milliseconds as this functionality is enabled via setTimeout and there is little value in having an excessive number of cache checks. This method is more appropriate for a single page application where the page is infrequently reloaded and many cached operations are performed. There is no advantage to enabling cache expiration unless you are experiencing cache storage space pressure in a long running page - and you may see a performance hit due to the use of setTimeout. import { setup } from \"@pnp/core\"; setup({ enableCacheExpiration: true, cacheExpirationIntervalMilliseconds: 1000, // optional });","title":"storage"},{"location":"common/storage/#pnpcorestorage","text":"This module provides a thin wrapper over the browser storage options, local and session. If neither option is available it shims storage with a non-persistent in memory polyfill. Optionally through configuration you can activate expiration. Sample usage is shown below.","title":"@pnp/core/storage"},{"location":"common/storage/#pnpclientstorage","text":"The main export of this module, contains properties representing local and session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); const myvalue = storage.local.get(\"mykey\");","title":"PnPClientStorage"},{"location":"common/storage/#pnpclientstoragewrapper","text":"Each of the storage locations (session and local) are wrapped with this helper class. You can use it directly, but generally it would be used from an instance of PnPClientStorage as shown below. These examples all use local storage, the operations are identical for session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // get a value from storage const value = storage.local.get(\"mykey\"); // put a value into storage storage.local.put(\"mykey2\", \"my value\"); // put a value into storage with an expiration storage.local.put(\"mykey2\", \"my value\", new Date()); // put a simple object into storage // because JSON.stringify is used to package the object we do NOT do a deep rehydration of stored objects storage.local.put(\"mykey3\", { key: \"value\", key2: \"value2\", }); // remove a value from storage storage.local.delete(\"mykey3\"); // get an item or add it if it does not exist // returns a promise in case you need time to get the value for storage // optionally takes a third parameter specifying the expiration storage.local.getOrPut(\"mykey4\", () => { return Promise.resolve(\"value\"); }); // delete expired items storage.local.deleteExpired();","title":"PnPClientStorageWrapper"},{"location":"common/storage/#cache-expiration","text":"The ability remove of expired items based on a configured timeout can help if the cache is filling up. This can be accomplished in two ways. The first is to explicitly call the new deleteExpired method on the cache you wish to clear. A suggested usage is to add this into your page init code as clearing expired items once per page load is likely sufficient. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // session storage storage.session.deleteExpired(); // local storage storage.local.deleteExpired(); // this returns a promise, so you can perform some activity after the expired items are removed: storage.local.deleteExpired().then(_ => { // init my application }); The second method is to enable automated cache expiration through global config. Setting the enableCacheExpiration property to true will enable the timer. Optionally you can set the interval at which the cache is checked via the cacheExpirationIntervalMilliseconds property, by default 750 milliseconds is used. We enforce a minimum of 300 milliseconds as this functionality is enabled via setTimeout and there is little value in having an excessive number of cache checks. This method is more appropriate for a single page application where the page is infrequently reloaded and many cached operations are performed. There is no advantage to enabling cache expiration unless you are experiencing cache storage space pressure in a long running page - and you may see a performance hit due to the use of setTimeout. import { setup } from \"@pnp/core\"; setup({ enableCacheExpiration: true, cacheExpirationIntervalMilliseconds: 1000, // optional });","title":"Cache Expiration"},{"location":"common/util/","text":"@pnp/core/util \u00b6 This module contains utility methods that you can import individually from the common library. import { getRandomString, } from \"@pnp/core\"; // use from individually imported method console.log(getRandomString(10)); assign \u00b6 Merges a source object's own enumerable properties into a single target object. Similar to Object.assign, but allows control of overwriting of existing properties. import { assign } from \"@pnp/core\"; let obj1 = { prop: 1, prop2: 2, }; const obj2 = { prop: 4, prop3: 9, }; const example1 = assign(obj1, obj2); // example1 = { prop: 4, prop2: 2, prop3: 9 } //noOverwrite = true stops overwriting existing properties const example2 = assign(obj1, obj2, true); // example2 = { prop: 1, prop2: 2, prop3: 9 } combine \u00b6 Combines any number of paths, normalizing the slashes as required import { combine } from \"@pnp/core\"; // \"https://microsoft.com/something/more\" const paths = combine(\"https://microsoft.com\", \"something\", \"more\"); // \"also/works/with/relative\" const paths2 = combine(\"/also/\", \"/works\", \"with/\", \"/relative\\\\\"); dateAdd \u00b6 Manipulates a date, please see the Stack Overflow discussion from where this method was taken. import { dateAdd } from \"@pnp/core\"; const testDate = new Date(); dateAdd(testDate,'minute',10); getCtxCallback \u00b6 Gets a callback function which will maintain context across async calls. import { getCtxCallback } from \"@pnp/core\"; const contextThis = { myProp: 6, }; function theFunction() { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp; } const callback = getCtxCallback(contextThis, theFunction); callback(); // returns 6 // You can also supply additional parameters if needed function theFunction2(g: number) { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp + g; } const callback2 = getCtxCallback(contextThis, theFunction2, 4); callback2(); // returns 10 (6 + 4) getGUID \u00b6 Creates a random guid, please see the Stack Overflow discussion from where this method was taken. import { getGUID } from \"@pnp/core\"; const newGUID = getGUID(); getRandomString \u00b6 Gets a random string consisting of the number of characters requested. import { getRandomString } from \"@pnp/core\"; const randomString = getRandomString(10); hOP \u00b6 Shortcut for Object.hasOwnProperty. Determines if an object has a specified property. import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { //Checks to see if the error object has a property called isHttpRequestError. Returns a bool. if (hOP(e, \"isHttpRequestError\")) { // Handle this type or error } else { // not an HttpRequestError so we do something else } } isArray \u00b6 Determines if a supplied variable represents an array. import { isArray } from \"@pnp/core\"; let x:String[] = [1,2,3]]; if (isArray(x)){ console.log(\"I am an array\"); }else{ console.log(\"I am not an array\"); } isFunc \u00b6 Determines if a supplied variable represents a function. import { isFunc } from \"@pnp/core\"; public testFunction() { console.log(\"test function\"); return } if (isFunc(testFunction)){ console.log(\"this is a function\"); testFunction(); } isUrlAbsolute \u00b6 Determines if a supplied url is absolute and returns true; otherwise returns false. import { isUrlAbsolute } from \"@pnp/core\"; const webPath = 'https://{tenant}.sharepoint.com/sites/dev/'; if (isUrlAbsolute(webPath)){ console.log(\"URL is absolute\"); }else{ console.log(\"URL is not absolute\"); } objectDefinedNotNull \u00b6 Determines if an object is defined and not null. import { objectDefinedNotNull } from \"@pnp/core\"; let obj = { prop: 1 }; if (objectDefinedNotNull(obj)){ console.log(\"Not null\"); }else{ console.log(\"Null\"); } stringIsNullOrEmpty \u00b6 Determines if a supplied string is null or empty. import { stringIsNullOrEmpty } from \"@pnp/core\"; let x:String = \"hello\"; if (stringIsNullOrEmpty(x)){ console.log(\"Null or empty\"); }else{ console.log(\"Not null or empty\"); } Removed \u00b6 Some methods that were no longer used internally by the @pnp libraries have been removed. You can find the source for those methods below for use in your projects should you require. /** * Loads a stylesheet into the current page * * @param path The url to the stylesheet * @param avoidCache If true a value will be appended as a query string to avoid browser caching issues */ public static loadStylesheet(path: string, avoidCache: boolean): void { if (avoidCache) { path += \"?\" + encodeURIComponent((new Date()).getTime().toString()); } const head = document.getElementsByTagName(\"head\"); if (head.length > 0) { const e = document.createElement(\"link\"); head[0].appendChild(e); e.setAttribute(\"type\", \"text/css\"); e.setAttribute(\"rel\", \"stylesheet\"); e.setAttribute(\"href\", path); } } /** * Tests if a url param exists * * @param name The name of the url parameter to check */ public static urlParamExists(name: string): boolean { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); return regex.test(location.search); } /** * Gets a url param value by name * * @param name The name of the parameter for which we want the value */ public static getUrlParamByName(name: string): string { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); const results = regex.exec(location.search); return results == null ? \"\" : decodeURIComponent(results[1].replace(/\\+/g, \" \")); } /** * Gets a url param by name and attempts to parse a bool value * * @param name The name of the parameter for which we want the boolean value */ public static getUrlParamBoolByName(name: string): boolean { const p = this.getUrlParamByName(name); const isFalse = (p === \"\" || /false|0/i.test(p)); return !isFalse; } /** * Inserts the string s into the string target as the index specified by index * * @param target The string into which we will insert s * @param index The location in target to insert s (zero based) * @param s The string to insert into target at position index */ public static stringInsert(target: string, index: number, s: string): string { if (index > 0) { return target.substring(0, index) + s + target.substring(index, target.length); } return s + target; }","title":"util"},{"location":"common/util/#pnpcoreutil","text":"This module contains utility methods that you can import individually from the common library. import { getRandomString, } from \"@pnp/core\"; // use from individually imported method console.log(getRandomString(10));","title":"@pnp/core/util"},{"location":"common/util/#assign","text":"Merges a source object's own enumerable properties into a single target object. Similar to Object.assign, but allows control of overwriting of existing properties. import { assign } from \"@pnp/core\"; let obj1 = { prop: 1, prop2: 2, }; const obj2 = { prop: 4, prop3: 9, }; const example1 = assign(obj1, obj2); // example1 = { prop: 4, prop2: 2, prop3: 9 } //noOverwrite = true stops overwriting existing properties const example2 = assign(obj1, obj2, true); // example2 = { prop: 1, prop2: 2, prop3: 9 }","title":"assign"},{"location":"common/util/#combine","text":"Combines any number of paths, normalizing the slashes as required import { combine } from \"@pnp/core\"; // \"https://microsoft.com/something/more\" const paths = combine(\"https://microsoft.com\", \"something\", \"more\"); // \"also/works/with/relative\" const paths2 = combine(\"/also/\", \"/works\", \"with/\", \"/relative\\\\\");","title":"combine"},{"location":"common/util/#dateadd","text":"Manipulates a date, please see the Stack Overflow discussion from where this method was taken. import { dateAdd } from \"@pnp/core\"; const testDate = new Date(); dateAdd(testDate,'minute',10);","title":"dateAdd"},{"location":"common/util/#getctxcallback","text":"Gets a callback function which will maintain context across async calls. import { getCtxCallback } from \"@pnp/core\"; const contextThis = { myProp: 6, }; function theFunction() { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp; } const callback = getCtxCallback(contextThis, theFunction); callback(); // returns 6 // You can also supply additional parameters if needed function theFunction2(g: number) { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp + g; } const callback2 = getCtxCallback(contextThis, theFunction2, 4); callback2(); // returns 10 (6 + 4)","title":"getCtxCallback"},{"location":"common/util/#getguid","text":"Creates a random guid, please see the Stack Overflow discussion from where this method was taken. import { getGUID } from \"@pnp/core\"; const newGUID = getGUID();","title":"getGUID"},{"location":"common/util/#getrandomstring","text":"Gets a random string consisting of the number of characters requested. import { getRandomString } from \"@pnp/core\"; const randomString = getRandomString(10);","title":"getRandomString"},{"location":"common/util/#hop","text":"Shortcut for Object.hasOwnProperty. Determines if an object has a specified property. import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { //Checks to see if the error object has a property called isHttpRequestError. Returns a bool. if (hOP(e, \"isHttpRequestError\")) { // Handle this type or error } else { // not an HttpRequestError so we do something else } }","title":"hOP"},{"location":"common/util/#isarray","text":"Determines if a supplied variable represents an array. import { isArray } from \"@pnp/core\"; let x:String[] = [1,2,3]]; if (isArray(x)){ console.log(\"I am an array\"); }else{ console.log(\"I am not an array\"); }","title":"isArray"},{"location":"common/util/#isfunc","text":"Determines if a supplied variable represents a function. import { isFunc } from \"@pnp/core\"; public testFunction() { console.log(\"test function\"); return } if (isFunc(testFunction)){ console.log(\"this is a function\"); testFunction(); }","title":"isFunc"},{"location":"common/util/#isurlabsolute","text":"Determines if a supplied url is absolute and returns true; otherwise returns false. import { isUrlAbsolute } from \"@pnp/core\"; const webPath = 'https://{tenant}.sharepoint.com/sites/dev/'; if (isUrlAbsolute(webPath)){ console.log(\"URL is absolute\"); }else{ console.log(\"URL is not absolute\"); }","title":"isUrlAbsolute"},{"location":"common/util/#objectdefinednotnull","text":"Determines if an object is defined and not null. import { objectDefinedNotNull } from \"@pnp/core\"; let obj = { prop: 1 }; if (objectDefinedNotNull(obj)){ console.log(\"Not null\"); }else{ console.log(\"Null\"); }","title":"objectDefinedNotNull"},{"location":"common/util/#stringisnullorempty","text":"Determines if a supplied string is null or empty. import { stringIsNullOrEmpty } from \"@pnp/core\"; let x:String = \"hello\"; if (stringIsNullOrEmpty(x)){ console.log(\"Null or empty\"); }else{ console.log(\"Not null or empty\"); }","title":"stringIsNullOrEmpty"},{"location":"common/util/#removed","text":"Some methods that were no longer used internally by the @pnp libraries have been removed. You can find the source for those methods below for use in your projects should you require. /** * Loads a stylesheet into the current page * * @param path The url to the stylesheet * @param avoidCache If true a value will be appended as a query string to avoid browser caching issues */ public static loadStylesheet(path: string, avoidCache: boolean): void { if (avoidCache) { path += \"?\" + encodeURIComponent((new Date()).getTime().toString()); } const head = document.getElementsByTagName(\"head\"); if (head.length > 0) { const e = document.createElement(\"link\"); head[0].appendChild(e); e.setAttribute(\"type\", \"text/css\"); e.setAttribute(\"rel\", \"stylesheet\"); e.setAttribute(\"href\", path); } } /** * Tests if a url param exists * * @param name The name of the url parameter to check */ public static urlParamExists(name: string): boolean { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); return regex.test(location.search); } /** * Gets a url param value by name * * @param name The name of the parameter for which we want the value */ public static getUrlParamByName(name: string): string { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); const results = regex.exec(location.search); return results == null ? \"\" : decodeURIComponent(results[1].replace(/\\+/g, \" \")); } /** * Gets a url param by name and attempts to parse a bool value * * @param name The name of the parameter for which we want the boolean value */ public static getUrlParamBoolByName(name: string): boolean { const p = this.getUrlParamByName(name); const isFalse = (p === \"\" || /false|0/i.test(p)); return !isFalse; } /** * Inserts the string s into the string target as the index specified by index * * @param target The string into which we will insert s * @param index The location in target to insert s (zero based) * @param s The string to insert into target at position index */ public static stringInsert(target: string, index: number, s: string): string { if (index > 0) { return target.substring(0, index) + s + target.substring(index, target.length); } return s + target; }","title":"Removed"},{"location":"concepts/configuration/","text":"PnPjs Configuration \u00b6 This article describes the configuration architecture used by the library as well as the settings available. Starting with version 2.1.0 we updated our configuration design to support the ability to isolate settings to individual objects. The first part of this article discusses the newer design, you can read about the pre v2.1.0 configuration further down. Post v2.1.0 \u00b6 Architecture \u00b6 Starting from v2.1.0 we have modified our configuration design to allow for configuring individual queryable objects. Backward Compatibility \u00b6 If you have no need to use the isolated runtimes introduced in 2.1.0 then you should see no change in library behavior from prior versions. You can continue to refer to the pre v2.1.0 configuration section - and if you see any issues please let us know. All of the available settings as described below remain, unchanged. If you previously used our internal configuration classes directly RuntimeConfigImpl, SPRuntimeConfigImpl, or GraphRuntimeConfigImpl they no longer exist. We do not consider this a breaking change as they were meant to be internal and their direct use was not documented. This includes the concrete default instances RuntimeConfig, SPRuntimeConfig, and GraphRuntimeConfig. Isolated Runtimes \u00b6 You can create an isolated runtime when using either the sp or graph libraries. What this does is create an isolated set of properties and behaviors specific to a given fluent chain. Have a look at this basic example below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuration applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuration applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the web at https://mytenant.sharepoint.com/ const web1 = await sp.web(); // details for the web at https://mytenant.sharepoint.com/sites/dev const web2 = await isolatedSP.web(); This configuration is supplied to all objects down a given fluent chain: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuraiton applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuraiton applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the lists at https://mytenant.sharepoint.com/ const lists1 = await sp.web.lists(); // details for the lists at https://mytenant.sharepoint.com/sites/dev const lists2 = await isolatedSP.web.lists(); createIsolated \u00b6 The createIsolated method is used to establish the isolated runtime for a given instance of either the sp or graph libraries. Once created it is no longer connected to the default instance and if you have common settings that must be updated you would need to update them across each isolated instance, this is by design. Currently sp and graph createIsolated methods accept the same init, but we have broken them out to make thing clear. All properties of the init object are optional. Any properties provided will overwrite those cloned from the default if cloneGlobal is true. If cloneGlobal is false you start with an empty config containing only the core defaults . sp.createIsolated \u00b6 import { sp, ISPConfiguration } from \"@pnp/sp\"; // accept all the defaults, will clone any settings from sp const isolatedSP = await sp.createIsolated(); // - specify all the config options, using the ISPConfiguration interface to type the config // - setting baseUrl in the root is equivelent to setting it with sp: { baseUrl: }, it is provided as a shortcut as this seemed to be a common use case // - if you set them both the baseUrl in the root will be used. // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedSP = await sp.createIsolated<ISPConfiguration>({ baseUrl: \"https://mytenant.sharepoint.com\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, sp: { baseUrl: \"https://mytenant.sharepoint.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, }); Defaults Name Default baseUrl \"\" cloneGlobal true config {} options {} graph.createIsolated \u00b6 import { graph, IGraphConfiguration } from \"@pnp/graph\"; // - specify all the config options, using the IGraphConfiguration interface to type the config // - setting baseUrl in the root is restricted to \"v1.0\" or \"beta\". If you need to specify a different absolute url should use config.graph.baseUrl // - in practice you should use one or the other. You can always swap Graph api version using IGraphQueryable.setEndpoint // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedGraph = await graph.createIsolated<IGraphConfiguration>({ baseUrl: \"v1.0\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, graph: { baseUrl: \"https://graph.microsoft.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, }); Defaults \u00b6 name Default baseUrl \"v1.0\" cloneGlobal true config {} options {} Additional Examples \u00b6 MSAL with Node multiple site requests \u00b6 MSAL Support Added in 2.0.11 In this example you can see how you can setup the MSAL client once and then set a different baseUrl for an isolated instance. More information specific to setting up the MSAL client is available . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev2/\", }, }, }); Node multiple site requests \u00b6 Isolated configuration was most requested for scenarios in node where you need to access information in multiple sites. This example shows setting up the global configuration and then creating an isolated config with only the baseUrl updated. import { SPFetchClient } from \"@pnp/nodejs\"; import { ISPConfigurationPart, sp } from \"@pnp/sp\"; sp.setup({ cacheExpirationIntervalMilliseconds: 1000, defaultCachingStore: \"local\", sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/\", \"id\", \"secret\"); }, headers: { \"X-MyRequiredHeader\": \"SomeValue\", \"X-MyRequiredHeader2\": \"SomeValue\", }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/site/dev\", \"id\", \"secret\"); }, }, }, }); Batching \u00b6 All batching functionality works as expected, but you must take care to only associate requests from the same isolated instance as you create the batch. Mixing requests across isolation boundaries is not supported. This applies to sp and graph batching. sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"url1\", \"id\", \"secret\"); }, }, }); const isolated = await sp.createIsolated<ISPConfiguration>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"url2\", \"id\", \"secret\"); }, }, }, }); const batch1 = sp.createBatch(); sp.web.lists.select(\"Title\").top(3).inBatch(batch1)().then(r => console.log(`here 1: ${JSON.stringify(r, null, 2)}`)); sp.web.select(\"Title\").inBatch(batch1)().then(r => console.log(`here 2: ${JSON.stringify(r, null, 2)}`)); await batch1.execute(); const batch2 = isolated.createBatch(); isolated.web.lists.select(\"Title\").top(3).inBatch(batch2)().then(r => console.log(`here 3: ${JSON.stringify(r, null, 2)}`)); isolated.web.select(\"Title\").inBatch(batch2)().then(r => console.log(`here 4: ${JSON.stringify(r, null, 2)}`)); await batch2.execute(); IE11 Mode \u00b6 The IE11 mode setting is always global. There is no scenario we care to support where once instance needs to run in ie11 mode and another does not. Your code either does or does not run in ie11. Prior to v2.1.0 \u00b6 Architecture \u00b6 PnPjs uses an additive configuration design with multiple libraries sharing a single global configuration instance. If you need non-global configuration please see this section . There are three ways to access the setup functionality - through either the common, sp, or graph library's setup method. While the configuration is global the various methods have different typing on their input parameter. You can review the libconfig article for more details on storing your own configuration. Common Configuration \u00b6 The common libary's setup method takes parameters defined by ILibraryConfiguration . The properties and their defaults are listed below, followed by a code sample. You can call setup multiple times and any new values will be added to the existing configuration or replace the previous value if one existed. All values are optional. Name Description Default defaultCachingStore Where will PnPjs store cached data by default (session or local) session defaultCachingTimeoutSeconds The global default value used for cached data timeouts in seconds 60 globalCacheDisable Provides a way to globally within PnPjs disable all caching false enableCacheExpiration If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval false cacheExpirationIntervalMilliseconds Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) 750 spfxContext When running in SPFx the current context should always be supplied to PnPjs when available null ie11 If true the library downgrades functionality to work in IE11 false For more information on setting up in SPFx please see the authentication section For more details on ie11 mode please see the topic article import { setup } from \"@pnp/core\"; // called before other code setup({ cacheExpirationIntervalMilliseconds: 15000, defaultCachingStore: \"local\", defaultCachingTimeoutSeconds: 600, enableCacheExpiration: true, globalCacheDisable: false, ie11: false, spfxContext: this.context, // if in SPFx, otherwise leave it out }); SP Configuration \u00b6 The sp library's configuration is defined by the ISPConfiguration interface which extends ILibraryConfiguration. All of the sp values are contained in a top level property named \"sp\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { sp } from \"@pnp/sp\"; import { SPFxAdalClient } from \"@pnp/core\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration sp.setup({ ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", fetchClientFactory: () => { return new SPFxAdalClient(this.context); }, headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, }); SharePoint Framework \u00b6 You can optionally supply only the SPFx context to the sp configure method. import { sp } from \"@pnp/sp\"; // in SPFx only sp.setup(this.context); Graph Configuration \u00b6 The graph configuration works exactly the same as the sp configuration but is defined by the IGraphConfiguration interface which extends ILibraryConfiguration. All of the graph values are contained in a top level property named \"graph\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. ( Added in 2.0.8 ) none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { graph } from \"@pnp/graph\"; import { MsalClientSetup } from \"@pnp/msaljsclient\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration graph.setup({ ie11: false, graph: { // we set the GCC url baseUrl: \"https://graph.microsoft.us\", fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, }); SharePoint Framework \u00b6 You can optionally supply only the SPFx context to the graph configure method. We will attempt to set the baseUrl property from the context - but if that is failing in your environment and you need to call a special cloud (i.e. graph.microsoft.us) please set the baseUrl property. import { graph } from \"@pnp/graph\"; // in SPFx only graph.setup(this.context); Configure Everything At Once \u00b6 In some cases you might want to configure everything in one go. Because the configuration is stored in a single location you can use the common library's setup method and adjust the typings to ensure you are using the correct property names while only having to setup things with a single call. In versions before 2.0.8 ISPConfigurationPart, IGraphConfigurationPart, and ILibraryConfiguration incorrectly were missing the \"I\" prefix. That was fixed in 2.0.8 - but note if you are using an older version of the library you'll need to use the old names. Everything else in the below example works as expected. import { ISPConfigurationPart } from \"@pnp/sp\"; import { IGraphConfigurationPart } from \"@pnp/graph\"; import { ILibraryConfiguration, setup } from \"@pnp/core\"; // you could also include your custom configuration parts export interface AllConfig extends ILibraryConfiguration, ISPConfigurationPart, IGraphConfigurationPart { } // create a single big configuration entry const config: AllConfig = { graph: { baseUrl: \"https://graph.microsoft.us\", }, ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", }, }; setup(config);","title":"Configuration"},{"location":"concepts/configuration/#pnpjs-configuration","text":"This article describes the configuration architecture used by the library as well as the settings available. Starting with version 2.1.0 we updated our configuration design to support the ability to isolate settings to individual objects. The first part of this article discusses the newer design, you can read about the pre v2.1.0 configuration further down.","title":"PnPjs Configuration"},{"location":"concepts/configuration/#post-v210","text":"","title":"Post v2.1.0"},{"location":"concepts/configuration/#architecture","text":"Starting from v2.1.0 we have modified our configuration design to allow for configuring individual queryable objects.","title":"Architecture"},{"location":"concepts/configuration/#backward-compatibility","text":"If you have no need to use the isolated runtimes introduced in 2.1.0 then you should see no change in library behavior from prior versions. You can continue to refer to the pre v2.1.0 configuration section - and if you see any issues please let us know. All of the available settings as described below remain, unchanged. If you previously used our internal configuration classes directly RuntimeConfigImpl, SPRuntimeConfigImpl, or GraphRuntimeConfigImpl they no longer exist. We do not consider this a breaking change as they were meant to be internal and their direct use was not documented. This includes the concrete default instances RuntimeConfig, SPRuntimeConfig, and GraphRuntimeConfig.","title":"Backward Compatibility"},{"location":"concepts/configuration/#isolated-runtimes","text":"You can create an isolated runtime when using either the sp or graph libraries. What this does is create an isolated set of properties and behaviors specific to a given fluent chain. Have a look at this basic example below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuration applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuration applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the web at https://mytenant.sharepoint.com/ const web1 = await sp.web(); // details for the web at https://mytenant.sharepoint.com/sites/dev const web2 = await isolatedSP.web(); This configuration is supplied to all objects down a given fluent chain: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuraiton applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuraiton applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the lists at https://mytenant.sharepoint.com/ const lists1 = await sp.web.lists(); // details for the lists at https://mytenant.sharepoint.com/sites/dev const lists2 = await isolatedSP.web.lists();","title":"Isolated Runtimes"},{"location":"concepts/configuration/#createisolated","text":"The createIsolated method is used to establish the isolated runtime for a given instance of either the sp or graph libraries. Once created it is no longer connected to the default instance and if you have common settings that must be updated you would need to update them across each isolated instance, this is by design. Currently sp and graph createIsolated methods accept the same init, but we have broken them out to make thing clear. All properties of the init object are optional. Any properties provided will overwrite those cloned from the default if cloneGlobal is true. If cloneGlobal is false you start with an empty config containing only the core defaults .","title":"createIsolated"},{"location":"concepts/configuration/#spcreateisolated","text":"import { sp, ISPConfiguration } from \"@pnp/sp\"; // accept all the defaults, will clone any settings from sp const isolatedSP = await sp.createIsolated(); // - specify all the config options, using the ISPConfiguration interface to type the config // - setting baseUrl in the root is equivelent to setting it with sp: { baseUrl: }, it is provided as a shortcut as this seemed to be a common use case // - if you set them both the baseUrl in the root will be used. // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedSP = await sp.createIsolated<ISPConfiguration>({ baseUrl: \"https://mytenant.sharepoint.com\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, sp: { baseUrl: \"https://mytenant.sharepoint.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, }); Defaults Name Default baseUrl \"\" cloneGlobal true config {} options {}","title":"sp.createIsolated"},{"location":"concepts/configuration/#graphcreateisolated","text":"import { graph, IGraphConfiguration } from \"@pnp/graph\"; // - specify all the config options, using the IGraphConfiguration interface to type the config // - setting baseUrl in the root is restricted to \"v1.0\" or \"beta\". If you need to specify a different absolute url should use config.graph.baseUrl // - in practice you should use one or the other. You can always swap Graph api version using IGraphQueryable.setEndpoint // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedGraph = await graph.createIsolated<IGraphConfiguration>({ baseUrl: \"v1.0\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, graph: { baseUrl: \"https://graph.microsoft.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, });","title":"graph.createIsolated"},{"location":"concepts/configuration/#defaults","text":"name Default baseUrl \"v1.0\" cloneGlobal true config {} options {}","title":"Defaults"},{"location":"concepts/configuration/#additional-examples","text":"","title":"Additional Examples"},{"location":"concepts/configuration/#msal-with-node-multiple-site-requests","text":"MSAL Support Added in 2.0.11 In this example you can see how you can setup the MSAL client once and then set a different baseUrl for an isolated instance. More information specific to setting up the MSAL client is available . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev2/\", }, }, });","title":"MSAL with Node multiple site requests"},{"location":"concepts/configuration/#node-multiple-site-requests","text":"Isolated configuration was most requested for scenarios in node where you need to access information in multiple sites. This example shows setting up the global configuration and then creating an isolated config with only the baseUrl updated. import { SPFetchClient } from \"@pnp/nodejs\"; import { ISPConfigurationPart, sp } from \"@pnp/sp\"; sp.setup({ cacheExpirationIntervalMilliseconds: 1000, defaultCachingStore: \"local\", sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/\", \"id\", \"secret\"); }, headers: { \"X-MyRequiredHeader\": \"SomeValue\", \"X-MyRequiredHeader2\": \"SomeValue\", }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/site/dev\", \"id\", \"secret\"); }, }, }, });","title":"Node multiple site requests"},{"location":"concepts/configuration/#batching","text":"All batching functionality works as expected, but you must take care to only associate requests from the same isolated instance as you create the batch. Mixing requests across isolation boundaries is not supported. This applies to sp and graph batching. sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"url1\", \"id\", \"secret\"); }, }, }); const isolated = await sp.createIsolated<ISPConfiguration>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"url2\", \"id\", \"secret\"); }, }, }, }); const batch1 = sp.createBatch(); sp.web.lists.select(\"Title\").top(3).inBatch(batch1)().then(r => console.log(`here 1: ${JSON.stringify(r, null, 2)}`)); sp.web.select(\"Title\").inBatch(batch1)().then(r => console.log(`here 2: ${JSON.stringify(r, null, 2)}`)); await batch1.execute(); const batch2 = isolated.createBatch(); isolated.web.lists.select(\"Title\").top(3).inBatch(batch2)().then(r => console.log(`here 3: ${JSON.stringify(r, null, 2)}`)); isolated.web.select(\"Title\").inBatch(batch2)().then(r => console.log(`here 4: ${JSON.stringify(r, null, 2)}`)); await batch2.execute();","title":"Batching"},{"location":"concepts/configuration/#ie11-mode","text":"The IE11 mode setting is always global. There is no scenario we care to support where once instance needs to run in ie11 mode and another does not. Your code either does or does not run in ie11.","title":"IE11 Mode"},{"location":"concepts/configuration/#prior-to-v210","text":"","title":"Prior to v2.1.0"},{"location":"concepts/configuration/#architecture_1","text":"PnPjs uses an additive configuration design with multiple libraries sharing a single global configuration instance. If you need non-global configuration please see this section . There are three ways to access the setup functionality - through either the common, sp, or graph library's setup method. While the configuration is global the various methods have different typing on their input parameter. You can review the libconfig article for more details on storing your own configuration.","title":"Architecture"},{"location":"concepts/configuration/#common-configuration","text":"The common libary's setup method takes parameters defined by ILibraryConfiguration . The properties and their defaults are listed below, followed by a code sample. You can call setup multiple times and any new values will be added to the existing configuration or replace the previous value if one existed. All values are optional. Name Description Default defaultCachingStore Where will PnPjs store cached data by default (session or local) session defaultCachingTimeoutSeconds The global default value used for cached data timeouts in seconds 60 globalCacheDisable Provides a way to globally within PnPjs disable all caching false enableCacheExpiration If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval false cacheExpirationIntervalMilliseconds Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) 750 spfxContext When running in SPFx the current context should always be supplied to PnPjs when available null ie11 If true the library downgrades functionality to work in IE11 false For more information on setting up in SPFx please see the authentication section For more details on ie11 mode please see the topic article import { setup } from \"@pnp/core\"; // called before other code setup({ cacheExpirationIntervalMilliseconds: 15000, defaultCachingStore: \"local\", defaultCachingTimeoutSeconds: 600, enableCacheExpiration: true, globalCacheDisable: false, ie11: false, spfxContext: this.context, // if in SPFx, otherwise leave it out });","title":"Common Configuration"},{"location":"concepts/configuration/#sp-configuration","text":"The sp library's configuration is defined by the ISPConfiguration interface which extends ILibraryConfiguration. All of the sp values are contained in a top level property named \"sp\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { sp } from \"@pnp/sp\"; import { SPFxAdalClient } from \"@pnp/core\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration sp.setup({ ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", fetchClientFactory: () => { return new SPFxAdalClient(this.context); }, headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, });","title":"SP Configuration"},{"location":"concepts/configuration/#sharepoint-framework","text":"You can optionally supply only the SPFx context to the sp configure method. import { sp } from \"@pnp/sp\"; // in SPFx only sp.setup(this.context);","title":"SharePoint Framework"},{"location":"concepts/configuration/#graph-configuration","text":"The graph configuration works exactly the same as the sp configuration but is defined by the IGraphConfiguration interface which extends ILibraryConfiguration. All of the graph values are contained in a top level property named \"graph\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. ( Added in 2.0.8 ) none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { graph } from \"@pnp/graph\"; import { MsalClientSetup } from \"@pnp/msaljsclient\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration graph.setup({ ie11: false, graph: { // we set the GCC url baseUrl: \"https://graph.microsoft.us\", fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, });","title":"Graph Configuration"},{"location":"concepts/configuration/#sharepoint-framework_1","text":"You can optionally supply only the SPFx context to the graph configure method. We will attempt to set the baseUrl property from the context - but if that is failing in your environment and you need to call a special cloud (i.e. graph.microsoft.us) please set the baseUrl property. import { graph } from \"@pnp/graph\"; // in SPFx only graph.setup(this.context);","title":"SharePoint Framework"},{"location":"concepts/configuration/#configure-everything-at-once","text":"In some cases you might want to configure everything in one go. Because the configuration is stored in a single location you can use the common library's setup method and adjust the typings to ensure you are using the correct property names while only having to setup things with a single call. In versions before 2.0.8 ISPConfigurationPart, IGraphConfigurationPart, and ILibraryConfiguration incorrectly were missing the \"I\" prefix. That was fixed in 2.0.8 - but note if you are using an older version of the library you'll need to use the old names. Everything else in the below example works as expected. import { ISPConfigurationPart } from \"@pnp/sp\"; import { IGraphConfigurationPart } from \"@pnp/graph\"; import { ILibraryConfiguration, setup } from \"@pnp/core\"; // you could also include your custom configuration parts export interface AllConfig extends ILibraryConfiguration, ISPConfigurationPart, IGraphConfigurationPart { } // create a single big configuration entry const config: AllConfig = { graph: { baseUrl: \"https://graph.microsoft.us\", }, ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", }, }; setup(config);","title":"Configure Everything At Once"},{"location":"concepts/custom-bundle/","text":"Custom Bundling \u00b6 With the introduction of selective imports it is now possible to create your own bundle to exactly fit your needs. This provides much greater control over how your solutions are deployed and what is included in your bundles. Scenarios could include: Deploying a company-wide PnPjs custom bundle shared by all your components so it only needs to be downloaded once. Creating SPFx libraries either for one project or a single webpart. Create a single library containing the PnPjs code you need bundled along with your custom extensions . Create a custom bundle \u00b6 Webpack \u00b6 You can see/clone a sample project of this example here . Rollup \u00b6 You can see/clone a sample project of this example here .","title":"Custom Bundle"},{"location":"concepts/custom-bundle/#custom-bundling","text":"With the introduction of selective imports it is now possible to create your own bundle to exactly fit your needs. This provides much greater control over how your solutions are deployed and what is included in your bundles. Scenarios could include: Deploying a company-wide PnPjs custom bundle shared by all your components so it only needs to be downloaded once. Creating SPFx libraries either for one project or a single webpart. Create a single library containing the PnPjs code you need bundled along with your custom extensions .","title":"Custom Bundling"},{"location":"concepts/custom-bundle/#create-a-custom-bundle","text":"","title":"Create a custom bundle"},{"location":"concepts/custom-bundle/#webpack","text":"You can see/clone a sample project of this example here .","title":"Webpack"},{"location":"concepts/custom-bundle/#rollup","text":"You can see/clone a sample project of this example here .","title":"Rollup"},{"location":"concepts/error-handling/","text":"Error Handling \u00b6 This article describes the most common types of errors generated by the library. It provides context on the error object, and ways to handle the errors. As always you should tailor your error handling to what your application needs. These are ideas that can be applied to many different patterns. For 429, 503, and 504 errors we include retry logic within the library The HttpRequestError \u00b6 All errors resulting from executed web requests will be returned as an HttpRequestError object which extends the base Error . In addition to the standard Error properties it has some other properties to help you figure out what went wrong. We used a custom error to attempt to normalize what can be a wide assortment of http related errors, while also seeking to provide as much information to library consumers as possible. Property Name Description name Standard Error.name property. Always 'Error' message Normalized string containing the status, status text, and the full response text stack The callstack producing the error isHttpRequestError Always true, allows you to reliably determine if you have an HttpRequestError instance response Unread copy of the Response object resulting in the thrown error status The Response.status value (such as 404) statusText The Response.statusText value (such as 'Not Found') Basic Handling \u00b6 For all operations involving a web request you should account for the possibility they might fail. That failure might be transient or permanent - you won't know until they happen \ud83d\ude09. The most basic type of error handling involves a simple try-catch. import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { console.error(e); } This will produce output like: Error making HttpClient request in queryable [404] Not Found ::> {\"odata.error\":{\"code\":\"-1, System.ArgumentException\",\"message\":{\"lang\":\"en-US\",\"value\":\"List 'no' does not exist at site with URL 'https://tenant.sharepoint.com/sites/dev'.\"}}} Data: {\"response\":{\"size\":0,\"timeout\":0},\"status\":404,\"statusText\":\"Not Found\",\"isHttpRequestError\":true} This is very descriptive and provides full details as to what happened, but you might want to handle things a little more cleanly. Reading the Response \u00b6 In some cases the response body will have additional details such as a localized error messages which can be nicer to display rather than our normalized string. You can read the response directly and process it however you desire: import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { // are we dealing with an HttpRequestError? if (e?.isHttpRequestError) { // we can read the json from the response const json = await (<HttpRequestError>e).response.json(); // if we have a value property we can show it console.log(typeof json[\"odata.error\"] === \"object\" ? json[\"odata.error\"].message.value : e.message); // add of course you have access to the other properties and can make choices on how to act if ((<HttpRequestError>e).status === 404) { console.error((<HttpRequestError>e).statusText); // maybe create the resource, or redirect, or fallback to a secondary data source // just ideas, handle any of the status codes uniquely as needed } } else { // not an HttpRequestError so we just log message console.log(e.message); } } Logging errors \u00b6 Using the PnPjs Logging Framework you can directly pass the error object and the normalized message will be logged. These techniques can be applied to any logging framework. import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { Logger.error(e); } You may want to read the response and customize the message as described above: import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { if (e?.isHttpRequestError) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } } Putting it All Together \u00b6 After reviewing the above section you might have thought it seems like a lot of work to include all that logic for every error. One approach is to establish a single function you use application wide to process errors. This allows all the error handling logic to be easily updated and consistent across the application. errorhandler.ts \u00b6 import { Logger } from \"@pnp/logging\"; import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { if (hOP(e, \"isHttpRequestError\")) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } } web-request.ts \u00b6 import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { await handleError(e); } web-request2.ts \u00b6 import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists(); } catch (e) { await handleError(e); }","title":"Error Handling"},{"location":"concepts/error-handling/#error-handling","text":"This article describes the most common types of errors generated by the library. It provides context on the error object, and ways to handle the errors. As always you should tailor your error handling to what your application needs. These are ideas that can be applied to many different patterns. For 429, 503, and 504 errors we include retry logic within the library","title":"Error Handling"},{"location":"concepts/error-handling/#the-httprequesterror","text":"All errors resulting from executed web requests will be returned as an HttpRequestError object which extends the base Error . In addition to the standard Error properties it has some other properties to help you figure out what went wrong. We used a custom error to attempt to normalize what can be a wide assortment of http related errors, while also seeking to provide as much information to library consumers as possible. Property Name Description name Standard Error.name property. Always 'Error' message Normalized string containing the status, status text, and the full response text stack The callstack producing the error isHttpRequestError Always true, allows you to reliably determine if you have an HttpRequestError instance response Unread copy of the Response object resulting in the thrown error status The Response.status value (such as 404) statusText The Response.statusText value (such as 'Not Found')","title":"The HttpRequestError"},{"location":"concepts/error-handling/#basic-handling","text":"For all operations involving a web request you should account for the possibility they might fail. That failure might be transient or permanent - you won't know until they happen \ud83d\ude09. The most basic type of error handling involves a simple try-catch. import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { console.error(e); } This will produce output like: Error making HttpClient request in queryable [404] Not Found ::> {\"odata.error\":{\"code\":\"-1, System.ArgumentException\",\"message\":{\"lang\":\"en-US\",\"value\":\"List 'no' does not exist at site with URL 'https://tenant.sharepoint.com/sites/dev'.\"}}} Data: {\"response\":{\"size\":0,\"timeout\":0},\"status\":404,\"statusText\":\"Not Found\",\"isHttpRequestError\":true} This is very descriptive and provides full details as to what happened, but you might want to handle things a little more cleanly.","title":"Basic Handling"},{"location":"concepts/error-handling/#reading-the-response","text":"In some cases the response body will have additional details such as a localized error messages which can be nicer to display rather than our normalized string. You can read the response directly and process it however you desire: import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { // are we dealing with an HttpRequestError? if (e?.isHttpRequestError) { // we can read the json from the response const json = await (<HttpRequestError>e).response.json(); // if we have a value property we can show it console.log(typeof json[\"odata.error\"] === \"object\" ? json[\"odata.error\"].message.value : e.message); // add of course you have access to the other properties and can make choices on how to act if ((<HttpRequestError>e).status === 404) { console.error((<HttpRequestError>e).statusText); // maybe create the resource, or redirect, or fallback to a secondary data source // just ideas, handle any of the status codes uniquely as needed } } else { // not an HttpRequestError so we just log message console.log(e.message); } }","title":"Reading the Response"},{"location":"concepts/error-handling/#logging-errors","text":"Using the PnPjs Logging Framework you can directly pass the error object and the normalized message will be logged. These techniques can be applied to any logging framework. import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { Logger.error(e); } You may want to read the response and customize the message as described above: import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { if (e?.isHttpRequestError) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } }","title":"Logging errors"},{"location":"concepts/error-handling/#putting-it-all-together","text":"After reviewing the above section you might have thought it seems like a lot of work to include all that logic for every error. One approach is to establish a single function you use application wide to process errors. This allows all the error handling logic to be easily updated and consistent across the application.","title":"Putting it All Together"},{"location":"concepts/error-handling/#errorhandlerts","text":"import { Logger } from \"@pnp/logging\"; import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { if (hOP(e, \"isHttpRequestError\")) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } }","title":"errorhandler.ts"},{"location":"concepts/error-handling/#web-requestts","text":"import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { await handleError(e); }","title":"web-request.ts"},{"location":"concepts/error-handling/#web-request2ts","text":"import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists(); } catch (e) { await handleError(e); }","title":"web-request2.ts"},{"location":"concepts/ie11-mode/","text":"IE11 Mode \u00b6 Starting with v2 we have made the decision to no longer support IE11. Because we know this affects folks we have introduced IE11 compatibility mode. Configuring the library will allow it to work within IE11, however at a possibly reduced level of functionality depending on your use case. Please see the list below of known limitations. Limitations \u00b6 When required to use IE11 mode there is certain functionality which may not work correctly or at all. Unavailable: Extension Methods Unavailable: OData Debugging Configure IE11 Mode \u00b6 To enable IE11 Mode set the ie11 flag to true in the setup object. Optionally, supply the context object when working in SharePoint Framework . import { sp } from \"@pnp/sp\"; sp.setup({ // set ie 11 mode ie11: true, // only needed when working within SharePoint Framework spfxContext: this.context }); If you are supporting IE 11, please see the article on required polyfills . A note on ie11 mode and support \u00b6 Because IE11 is no longer a primary supported browser our policy moving forward will be doing our best not to break anything in ie11 mode, but not all features will work and new features may never come to ie11 mode. Also, if you find an ie11 bug we expect you to work with us on helping to fix it. If you aren't willing to invest some time to support an old browser it seems we shouldn't either.","title":"IE11 Mode"},{"location":"concepts/ie11-mode/#ie11-mode","text":"Starting with v2 we have made the decision to no longer support IE11. Because we know this affects folks we have introduced IE11 compatibility mode. Configuring the library will allow it to work within IE11, however at a possibly reduced level of functionality depending on your use case. Please see the list below of known limitations.","title":"IE11 Mode"},{"location":"concepts/ie11-mode/#limitations","text":"When required to use IE11 mode there is certain functionality which may not work correctly or at all. Unavailable: Extension Methods Unavailable: OData Debugging","title":"Limitations"},{"location":"concepts/ie11-mode/#configure-ie11-mode","text":"To enable IE11 Mode set the ie11 flag to true in the setup object. Optionally, supply the context object when working in SharePoint Framework . import { sp } from \"@pnp/sp\"; sp.setup({ // set ie 11 mode ie11: true, // only needed when working within SharePoint Framework spfxContext: this.context }); If you are supporting IE 11, please see the article on required polyfills .","title":"Configure IE11 Mode"},{"location":"concepts/ie11-mode/#a-note-on-ie11-mode-and-support","text":"Because IE11 is no longer a primary supported browser our policy moving forward will be doing our best not to break anything in ie11 mode, but not all features will work and new features may never come to ie11 mode. Also, if you find an ie11 bug we expect you to work with us on helping to fix it. If you aren't willing to invest some time to support an old browser it seems we shouldn't either.","title":"A note on ie11 mode and support"},{"location":"concepts/invokable/","text":"Invokables \u00b6 For people who have been using the library since the early days you are familiar with the need to use the () method to invoke a method chain: // an example of get const lists = await sp.web.lists(); Starting with v2 this is no longer required, you can invoke the object directly to execute the default action for that class - typically a get. const lists = await sp.web.lists(); This has two main benefits for people using the library: you can write less code, and we now have a way to model default actions for objects that might do something other than a get. The way we designed the library prior to v2 hid the post, put, delete operations as protected methods attached to the Queryable classes. Without diving into why we did this, having a rethink seemed appropriate for v2. Based on that, the entire queryable chain is now invokable as well for any of the operations. Other Operations (post, put, delete) \u00b6 import { sp, spPost } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // do a post to a web - just an example doesn't do anything fancy spPost(sp.web); Things get a little more interesting in that you can now do posts (or any of the operations) to any of the urls defined by a fluent chain. Meaning you can easily implement methods that are not yet part of the library. For this example I have made up a method called \"MagicFieldCreationMethod\" that doesn't exist. Imagine it was just added to the SharePoint API and we do not yet have support for it. You can now write code like so: import { sp, spPost, SharePointQueryable } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields/web\"; // call our made up example method spPost(SharePointQueryable(sp.web.fields, \"MagicFieldCreationMethod\"), { body: JSON.stringify({ // ... this would be the post body }), });","title":"Invokables"},{"location":"concepts/invokable/#invokables","text":"For people who have been using the library since the early days you are familiar with the need to use the () method to invoke a method chain: // an example of get const lists = await sp.web.lists(); Starting with v2 this is no longer required, you can invoke the object directly to execute the default action for that class - typically a get. const lists = await sp.web.lists(); This has two main benefits for people using the library: you can write less code, and we now have a way to model default actions for objects that might do something other than a get. The way we designed the library prior to v2 hid the post, put, delete operations as protected methods attached to the Queryable classes. Without diving into why we did this, having a rethink seemed appropriate for v2. Based on that, the entire queryable chain is now invokable as well for any of the operations.","title":"Invokables"},{"location":"concepts/invokable/#other-operations-post-put-delete","text":"import { sp, spPost } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // do a post to a web - just an example doesn't do anything fancy spPost(sp.web); Things get a little more interesting in that you can now do posts (or any of the operations) to any of the urls defined by a fluent chain. Meaning you can easily implement methods that are not yet part of the library. For this example I have made up a method called \"MagicFieldCreationMethod\" that doesn't exist. Imagine it was just added to the SharePoint API and we do not yet have support for it. You can now write code like so: import { sp, spPost, SharePointQueryable } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields/web\"; // call our made up example method spPost(SharePointQueryable(sp.web.fields, \"MagicFieldCreationMethod\"), { body: JSON.stringify({ // ... this would be the post body }), });","title":"Other Operations (post, put, delete)"},{"location":"concepts/polyfill/","text":"Polyfills \u00b6 These libraries may make use of some features not found in older browsers. This primarily affects Internet Explorer 11, which requires that we provide this missing functionality. If you are supporting IE11 enable IE11 mode . IE 11 Polyfill package \u00b6 We created a package you try and help provide this missing functionality. This package is independent of the other @pnp/* packages and does not need to be updated monthly unless we introduce additional polyfills and publish a new version. This package is only needed if you are required to support IE 11. Install \u00b6 npm install @pnp/polyfill-ie11 --save Use \u00b6 import \"@pnp/polyfill-ie11\"; import { sp } from \"@pnp/sp/presets/all\"; sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); }); Selective Use \u00b6 Starting with version 2.0.2 you can selectively include the polyfills from the package. Depending on your needs it may make sense in your application to use the underlying libraries directly. We have added an expanded statement on our polyfills . // individually include polyfills as needed to match your requirements import \"@pnp/polyfill-ie11/dist/fetch\"; import \"@pnp/polyfill-ie11/dist/fill\"; import \"@pnp/polyfill-ie11/dist/from\"; import \"@pnp/polyfill-ie11/dist/iterator\"; import \"@pnp/polyfill-ie11/dist/map\"; import \"@pnp/polyfill-ie11/dist/promise\"; import \"@pnp/polyfill-ie11/dist/reflect\"; import \"@pnp/polyfill-ie11/dist/symbol\"; // works in IE11 and other browsers sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); }); SearchQueryBuilder \u00b6 Because the latest version of SearchQueryBuilder uses Proxy internally you can fall back on the older version as shown below. import \"@pnp/polyfill-ie11\"; import { SearchQueryBuilder } from \"@pnp/polyfill-ie11/dist/searchquerybuilder\"; import { sp, ISearchQueryBuilder } from \"@pnp/sp/presets/all\"; // works in IE11 and other browsers const builder: ISearchQueryBuilder = SearchQueryBuilder().text(\"test\"); sp.search(builder).then(r => { this.domElement.innerHTML = JSON.stringify(r); }); General Statement on Polyfills \u00b6 Internet Explorer 11 (IE11) has been an enterprise standard browser for many years. Given the complexity in changing technical platforms in many organizations, it is no surprise standardization on this out-of-date browser continues. Unfortunately, for those organizations, the Internet has moved on and many - if not all - SaaS platforms are embracing modern standards and no longer supporting the legacy IE11 browser. Even Microsoft states in their official documentation that Microsoft 365 is best experienced with a modern browser. They have even gone so far to build the latest version of Microsoft Edge based on Chromium (Edge Chromium), with an \"Internet Explorer mode\" allowing organizations to load legacy sites which require IE automatically. PnPjs is now \"modern\" as well, and by that we mean we have moved to using capabilities of current browsers and JavaScript which are not present in IE11. We understand as a developer your ability to require an organization to switch browsers is unrealistic. We want to do everything we can to support you, but it is up to you to ensure your application is properly supported in IE11. There are many polyfills available, depending on the platform you're running on, the frameworks you are using, and the libraries you consume. Although the majority of PnPjs users build for SharePoint Online, a significant number build for earlier versions of the platform as well as for their own node-based solutions or websites. Unfortunately, there is no way our polyfill library can support all these scenarios. What we intended with the @pnp/polyfill-ie11 package was to provide a comprehensive group of all the polyfills that would be needed based on the complete PnPjs library. We are finding when we aggregate our polyfills with the polyfills provided in the SharePoint page and from other sources, things don't always work well. We cannot solve this for your specific situations except by providing you transparency into the polyfills which we know are necessary for our packages. You may need to adjust what polyfills your application uses based on the other libraries you are using. To that end, we want to provide the list of polyfills we recommend here - along with the associated packages \u2013 with the goal of helping you to work out what combination of polyfills might work with your code. Also, if you haven't reviewed it yet, please check out the information on IE11 Mode for how to configure IE11 mode in the sp.setup as well as what limitations doing so will have on your usage of PnPjs. imports import \"core-js/stable/array/from\"; import \"core-js/stable/array/fill\"; import \"core-js/stable/array/iterator\"; import \"core-js/stable/promise\"; import \"core-js/stable/reflect\"; import \"es6-map/implement\"; import \"core-js/stable/symbol\"; import \"whatwg-fetch\"; The following NPM packages are what we use to do the above indicated imports |package| |---| | core-js | | es6-map | | whatwg-fetch |","title":"Polyfills"},{"location":"concepts/polyfill/#polyfills","text":"These libraries may make use of some features not found in older browsers. This primarily affects Internet Explorer 11, which requires that we provide this missing functionality. If you are supporting IE11 enable IE11 mode .","title":"Polyfills"},{"location":"concepts/polyfill/#ie-11-polyfill-package","text":"We created a package you try and help provide this missing functionality. This package is independent of the other @pnp/* packages and does not need to be updated monthly unless we introduce additional polyfills and publish a new version. This package is only needed if you are required to support IE 11.","title":"IE 11 Polyfill package"},{"location":"concepts/polyfill/#install","text":"npm install @pnp/polyfill-ie11 --save","title":"Install"},{"location":"concepts/polyfill/#use","text":"import \"@pnp/polyfill-ie11\"; import { sp } from \"@pnp/sp/presets/all\"; sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); });","title":"Use"},{"location":"concepts/polyfill/#selective-use","text":"Starting with version 2.0.2 you can selectively include the polyfills from the package. Depending on your needs it may make sense in your application to use the underlying libraries directly. We have added an expanded statement on our polyfills . // individually include polyfills as needed to match your requirements import \"@pnp/polyfill-ie11/dist/fetch\"; import \"@pnp/polyfill-ie11/dist/fill\"; import \"@pnp/polyfill-ie11/dist/from\"; import \"@pnp/polyfill-ie11/dist/iterator\"; import \"@pnp/polyfill-ie11/dist/map\"; import \"@pnp/polyfill-ie11/dist/promise\"; import \"@pnp/polyfill-ie11/dist/reflect\"; import \"@pnp/polyfill-ie11/dist/symbol\"; // works in IE11 and other browsers sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); });","title":"Selective Use"},{"location":"concepts/polyfill/#searchquerybuilder","text":"Because the latest version of SearchQueryBuilder uses Proxy internally you can fall back on the older version as shown below. import \"@pnp/polyfill-ie11\"; import { SearchQueryBuilder } from \"@pnp/polyfill-ie11/dist/searchquerybuilder\"; import { sp, ISearchQueryBuilder } from \"@pnp/sp/presets/all\"; // works in IE11 and other browsers const builder: ISearchQueryBuilder = SearchQueryBuilder().text(\"test\"); sp.search(builder).then(r => { this.domElement.innerHTML = JSON.stringify(r); });","title":"SearchQueryBuilder"},{"location":"concepts/polyfill/#general-statement-on-polyfills","text":"Internet Explorer 11 (IE11) has been an enterprise standard browser for many years. Given the complexity in changing technical platforms in many organizations, it is no surprise standardization on this out-of-date browser continues. Unfortunately, for those organizations, the Internet has moved on and many - if not all - SaaS platforms are embracing modern standards and no longer supporting the legacy IE11 browser. Even Microsoft states in their official documentation that Microsoft 365 is best experienced with a modern browser. They have even gone so far to build the latest version of Microsoft Edge based on Chromium (Edge Chromium), with an \"Internet Explorer mode\" allowing organizations to load legacy sites which require IE automatically. PnPjs is now \"modern\" as well, and by that we mean we have moved to using capabilities of current browsers and JavaScript which are not present in IE11. We understand as a developer your ability to require an organization to switch browsers is unrealistic. We want to do everything we can to support you, but it is up to you to ensure your application is properly supported in IE11. There are many polyfills available, depending on the platform you're running on, the frameworks you are using, and the libraries you consume. Although the majority of PnPjs users build for SharePoint Online, a significant number build for earlier versions of the platform as well as for their own node-based solutions or websites. Unfortunately, there is no way our polyfill library can support all these scenarios. What we intended with the @pnp/polyfill-ie11 package was to provide a comprehensive group of all the polyfills that would be needed based on the complete PnPjs library. We are finding when we aggregate our polyfills with the polyfills provided in the SharePoint page and from other sources, things don't always work well. We cannot solve this for your specific situations except by providing you transparency into the polyfills which we know are necessary for our packages. You may need to adjust what polyfills your application uses based on the other libraries you are using. To that end, we want to provide the list of polyfills we recommend here - along with the associated packages \u2013 with the goal of helping you to work out what combination of polyfills might work with your code. Also, if you haven't reviewed it yet, please check out the information on IE11 Mode for how to configure IE11 mode in the sp.setup as well as what limitations doing so will have on your usage of PnPjs. imports import \"core-js/stable/array/from\"; import \"core-js/stable/array/fill\"; import \"core-js/stable/array/iterator\"; import \"core-js/stable/promise\"; import \"core-js/stable/reflect\"; import \"es6-map/implement\"; import \"core-js/stable/symbol\"; import \"whatwg-fetch\"; The following NPM packages are what we use to do the above indicated imports |package| |---| | core-js | | es6-map | | whatwg-fetch |","title":"General Statement on Polyfills"},{"location":"concepts/selective-imports/","text":"Selective Imports \u00b6 As the libraries have grown to support more of the SharePoint and Graph API they have also grown in size. On one hand this is good as more functionality becomes available but you had to include lots of code you didn't use if you were only doing simple operations. To solve this we introduced selective imports in v2. This allows you to only import the parts of the sp or graph library you need, allowing you to greatly reduce your overall solution bundle size - and enables treeshaking . This concept works well with custom bundling to create a shared package tailored exactly to your needs. If you would prefer to not worry about selective imports please see the section on presets . Old way \u00b6 // the sp var came with all library functionality already attached // meaning treeshaking couldn't reduce the size import { sp } from \"@pnp/sp\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); New Way \u00b6 // the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); Above we are being very specific in what we are importing, but you can also import entire sub-modules and be slightly less specific // the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); The above two examples both work just fine but you may end up with slightly smaller bundle sizes using the first. Consider this example: // this import statement will attach content-type functionality to list, web, and item import \"@pnp/sp/content-types\"; // this import statement will only attach content-type functionality to web import \"@pnp/sp/content-types/web\"; If you only need to access content types on the web object you can reduce size by only importing that piece. // this will fail import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IList } from \"@pnp/sp/lists\"; // do this instead import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { IList } from \"@pnp/sp/lists\"; const lists = await sp.web.lists(); Presets \u00b6 Sometimes you don't care as much about bundle size - testing or node development for example. In these cases we have provided what we are calling presets to allow you to skip importing each module individually. SP \u00b6 For the sp library there are two presets \"all\" and \"core\". The all preset mimics the behavior in v1 and includes everything in the library already attached to the sp var. import { sp } from \"@pnp/sp/presets/all\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists(); The \"core\" preset includes sites, webs, lists, and items. import { sp } from \"@pnp/sp/presets/core\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists(); Graph \u00b6 The graph library contains a single preset, \"all\" mimicking the v1 structure. import { graph } from \"@pnp/graph/presets/all\"; // graph.* exists as it did in v1, tree shaking will not work While we may look to add additional presets in the future you are encouraged to look at making your own custom bundles as a preferred solution.","title":"Selective Imports"},{"location":"concepts/selective-imports/#selective-imports","text":"As the libraries have grown to support more of the SharePoint and Graph API they have also grown in size. On one hand this is good as more functionality becomes available but you had to include lots of code you didn't use if you were only doing simple operations. To solve this we introduced selective imports in v2. This allows you to only import the parts of the sp or graph library you need, allowing you to greatly reduce your overall solution bundle size - and enables treeshaking . This concept works well with custom bundling to create a shared package tailored exactly to your needs. If you would prefer to not worry about selective imports please see the section on presets .","title":"Selective Imports"},{"location":"concepts/selective-imports/#old-way","text":"// the sp var came with all library functionality already attached // meaning treeshaking couldn't reduce the size import { sp } from \"@pnp/sp\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)();","title":"Old way"},{"location":"concepts/selective-imports/#new-way","text":"// the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); Above we are being very specific in what we are importing, but you can also import entire sub-modules and be slightly less specific // the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); The above two examples both work just fine but you may end up with slightly smaller bundle sizes using the first. Consider this example: // this import statement will attach content-type functionality to list, web, and item import \"@pnp/sp/content-types\"; // this import statement will only attach content-type functionality to web import \"@pnp/sp/content-types/web\"; If you only need to access content types on the web object you can reduce size by only importing that piece. // this will fail import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IList } from \"@pnp/sp/lists\"; // do this instead import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { IList } from \"@pnp/sp/lists\"; const lists = await sp.web.lists();","title":"New Way"},{"location":"concepts/selective-imports/#presets","text":"Sometimes you don't care as much about bundle size - testing or node development for example. In these cases we have provided what we are calling presets to allow you to skip importing each module individually.","title":"Presets"},{"location":"concepts/selective-imports/#sp","text":"For the sp library there are two presets \"all\" and \"core\". The all preset mimics the behavior in v1 and includes everything in the library already attached to the sp var. import { sp } from \"@pnp/sp/presets/all\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists(); The \"core\" preset includes sites, webs, lists, and items. import { sp } from \"@pnp/sp/presets/core\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists();","title":"SP"},{"location":"concepts/selective-imports/#graph","text":"The graph library contains a single preset, \"all\" mimicking the v1 structure. import { graph } from \"@pnp/graph/presets/all\"; // graph.* exists as it did in v1, tree shaking will not work While we may look to add additional presets in the future you are encouraged to look at making your own custom bundles as a preferred solution.","title":"Graph"},{"location":"concepts/settings/","text":"Project Settings \u00b6 This article discusses creating a project settings file for use in local development and debugging of the libraries. The settings file contains authentication and other settings to enable you to run and debug the project locally. The settings file is a JavaScript file that exports a single object representing the settings of your project. You can view the example settings file in the project root . Settings File Format (>= 2.0.13) \u00b6 Starting with version 2.0.13 we have added support within the settings file for MSAL authentication for both SharePoint and Graph. You are NOT required to update your existing settings file unless you want to use MSAL authentication with a Graph application. The existing id/secret settings continue to work however we recommend updating when you have an opportunity. For more information coinfiguring MSAL please review the section in the authentication section for node . MSAL configuration has two parts, these are the initialization which is passed directly to the MsalFetchClient (and on to the underlying msal-node instance) and the scopes. The scopes are always \"https://{tenant}.sharepoint.com/.default\" or \"https://graph.microsoft.com/.default\" depending on what you are calling. If you are calling Microsoft Graph sovereign or gov clouds the scope may need to be updated. const privateKey = `-----BEGIN RSA PRIVATE KEY----- your private key, read from a file or included here -----END RSA PRIVATE KEY----- `; var msalInit = { auth: { authority: \"https://login.microsoftonline.com/{tenant id}\", clientCertificate: { thumbprint: \"{certificate thumbnail}\", privateKey: privateKey, }, clientId: \"{AAD App registration id}\", } } var settings = { testing: { enableWebTests: true, testUser: \"i:0#.f|membership|user@consto.com\", sp: { url: \"{required for MSAL - absolute url of test site}\", notificationUrl: \"{ optional: notification url }\", msal: { init: msalInit, scopes: [\"https://{tenant}.sharepoint.com/.default\"] }, }, graph: { msal: { init: msalInit, scopes: [\"https://graph.microsoft.com/.default\"] }, }, }, } module.exports = settings; The settings object has a single sub-object testing which contains the configuration used for debugging and testing PnPjs. The parts of this object are described in detail below. enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. testUser AAD login account to be used when running tests. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests SP values \u00b6 name description url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions msal Information about MSAL authentication setup Graph value \u00b6 The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description msal Information about MSAL authentication setup Settings File Format (<= 2.0.12) \u00b6 var settings = { testing: { enableWebTests: true, sp: { id: \"{ client id }\", secret: \"{ client secret }\", url: \"{ site collection url }\", notificationUrl: \"{ optional: notification url }\", }, graph: { tenant: \"{tenant.onmicrosoft.com}\", id: \"{your app id}\", secret: \"{your secret}\" }, } } module.exports = settings; enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests SP values \u00b6 The sp values are described in the table below and come from registering a legacy SharePoint add-in . name description id The client id of the registered application secret The client secret of the registered application url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions Graph values \u00b6 The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description tenant Tenant to target for authentication and data (ex: contoso.onmicrosoft.com) id The application id secret The application secret Create Settings.js file \u00b6 Copy the example file and rename it settings.js. Place the file in the root of your project. Update the settings as needed for your environment. If you are only doing SharePoint testing you can leave the graph section off and vice-versa. Also, if you are not testing anything with hooks you can leave off the notificationUrl.","title":"Settings"},{"location":"concepts/settings/#project-settings","text":"This article discusses creating a project settings file for use in local development and debugging of the libraries. The settings file contains authentication and other settings to enable you to run and debug the project locally. The settings file is a JavaScript file that exports a single object representing the settings of your project. You can view the example settings file in the project root .","title":"Project Settings"},{"location":"concepts/settings/#settings-file-format-2013","text":"Starting with version 2.0.13 we have added support within the settings file for MSAL authentication for both SharePoint and Graph. You are NOT required to update your existing settings file unless you want to use MSAL authentication with a Graph application. The existing id/secret settings continue to work however we recommend updating when you have an opportunity. For more information coinfiguring MSAL please review the section in the authentication section for node . MSAL configuration has two parts, these are the initialization which is passed directly to the MsalFetchClient (and on to the underlying msal-node instance) and the scopes. The scopes are always \"https://{tenant}.sharepoint.com/.default\" or \"https://graph.microsoft.com/.default\" depending on what you are calling. If you are calling Microsoft Graph sovereign or gov clouds the scope may need to be updated. const privateKey = `-----BEGIN RSA PRIVATE KEY----- your private key, read from a file or included here -----END RSA PRIVATE KEY----- `; var msalInit = { auth: { authority: \"https://login.microsoftonline.com/{tenant id}\", clientCertificate: { thumbprint: \"{certificate thumbnail}\", privateKey: privateKey, }, clientId: \"{AAD App registration id}\", } } var settings = { testing: { enableWebTests: true, testUser: \"i:0#.f|membership|user@consto.com\", sp: { url: \"{required for MSAL - absolute url of test site}\", notificationUrl: \"{ optional: notification url }\", msal: { init: msalInit, scopes: [\"https://{tenant}.sharepoint.com/.default\"] }, }, graph: { msal: { init: msalInit, scopes: [\"https://graph.microsoft.com/.default\"] }, }, }, } module.exports = settings; The settings object has a single sub-object testing which contains the configuration used for debugging and testing PnPjs. The parts of this object are described in detail below. enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. testUser AAD login account to be used when running tests. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests","title":"Settings File Format (&gt;= 2.0.13)"},{"location":"concepts/settings/#sp-values","text":"name description url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions msal Information about MSAL authentication setup","title":"SP values"},{"location":"concepts/settings/#graph-value","text":"The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description msal Information about MSAL authentication setup","title":"Graph value"},{"location":"concepts/settings/#settings-file-format-2012","text":"var settings = { testing: { enableWebTests: true, sp: { id: \"{ client id }\", secret: \"{ client secret }\", url: \"{ site collection url }\", notificationUrl: \"{ optional: notification url }\", }, graph: { tenant: \"{tenant.onmicrosoft.com}\", id: \"{your app id}\", secret: \"{your secret}\" }, } } module.exports = settings; enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests","title":"Settings File Format (&lt;= 2.0.12)"},{"location":"concepts/settings/#sp-values_1","text":"The sp values are described in the table below and come from registering a legacy SharePoint add-in . name description id The client id of the registered application secret The client secret of the registered application url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions","title":"SP values"},{"location":"concepts/settings/#graph-values","text":"The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description tenant Tenant to target for authentication and data (ex: contoso.onmicrosoft.com) id The application id secret The application secret","title":"Graph values"},{"location":"concepts/settings/#create-settingsjs-file","text":"Copy the example file and rename it settings.js. Place the file in the root of your project. Update the settings as needed for your environment. If you are only doing SharePoint testing you can leave the graph section off and vice-versa. Also, if you are not testing anything with hooks you can leave off the notificationUrl.","title":"Create Settings.js file"},{"location":"config-store/","text":"@pnp/config-store \u00b6 This module provides a way to load application configuration from one or more providers and share it across an application in a consistent way. A provider can be anything - but we have included one to load information from a SharePoint list. This library is most helpful for larger applications where a formal configuration model is needed. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/sp @pnp/config-store --save See the topics below for usage: configuration providers","title":"config-store"},{"location":"config-store/#pnpconfig-store","text":"This module provides a way to load application configuration from one or more providers and share it across an application in a consistent way. A provider can be anything - but we have included one to load information from a SharePoint list. This library is most helpful for larger applications where a formal configuration model is needed.","title":"@pnp/config-store"},{"location":"config-store/#getting-started","text":"Install the library and required dependencies npm install @pnp/sp @pnp/config-store --save See the topics below for usage: configuration providers","title":"Getting Started"},{"location":"config-store/configuration/","text":"@pnp/config-store/configuration \u00b6 The main class exported from the config-store package is Settings. This is the class through which you will load and access your settings via providers . import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create an instance of the settings class, could be static and shared across your application // or built as needed. const settings = new Settings(); // you can add/update a single value using add settings.add(\"mykey\", \"myvalue\"); // you can also add/update a JSON value which will be stringified for you as a shorthand settings.addJSON(\"mykey2\", { field: 1, field2: 2, field3: 3, }); // and you can apply a plain object of keys/values that will be written as single values // this results in each enumerable property of the supplied object being added to the settings collection settings.apply({ field: 1, field2: 2, field3: 3, }); // and finally you can load values from a configuration provider const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // this will load values from the supplied list // by default the key will be from the Title field and the value from a column named Value await settings.load(provider); // once we have loaded values we can then read them const value = settings.get(\"mykey\"); // or read JSON that will be parsed for you from the store const value2 = settings.getJSON(\"mykey2\");","title":"configuration"},{"location":"config-store/configuration/#pnpconfig-storeconfiguration","text":"The main class exported from the config-store package is Settings. This is the class through which you will load and access your settings via providers . import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create an instance of the settings class, could be static and shared across your application // or built as needed. const settings = new Settings(); // you can add/update a single value using add settings.add(\"mykey\", \"myvalue\"); // you can also add/update a JSON value which will be stringified for you as a shorthand settings.addJSON(\"mykey2\", { field: 1, field2: 2, field3: 3, }); // and you can apply a plain object of keys/values that will be written as single values // this results in each enumerable property of the supplied object being added to the settings collection settings.apply({ field: 1, field2: 2, field3: 3, }); // and finally you can load values from a configuration provider const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // this will load values from the supplied list // by default the key will be from the Title field and the value from a column named Value await settings.load(provider); // once we have loaded values we can then read them const value = settings.get(\"mykey\"); // or read JSON that will be parsed for you from the store const value2 = settings.getJSON(\"mykey2\");","title":"@pnp/config-store/configuration"},{"location":"config-store/providers/","text":"@pnp/config-store/providers \u00b6 Currently there is a single provider included in the library, but contributions of additional providers are welcome. SPListConfigurationProvider \u00b6 This provider is based on a SharePoint list it reads all of the rows and makes them available as a TypedHash<string> . By default the column names used are Title for key and \"Value\" for value, but you can update these as needed. Additionally, the settings class supports the idea of last value in wins - so you can easily load multiple configurations. This helps to support a common scenario in the enterprise where you might have one main list for global configuration but some settings can be set at the web level. In this case you would first load the global, then the local settings and any local values will take precedence. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); const settings = new Settings(); // load our values from the list await settings.load(provider); CachingConfigurationProvider \u00b6 Because making requests on each page load is very inefficient you can optionally use the caching configuration provider, which wraps a provider and caches the configuration in local or session storage. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // get an instance of the provider wrapped // you can optionally provide a key that will be used in the cache to the asCaching method const wrappedProvider = provider.asCaching(); // use that wrapped provider to populate the settings await settings.load(wrappedProvider);","title":"providers"},{"location":"config-store/providers/#pnpconfig-storeproviders","text":"Currently there is a single provider included in the library, but contributions of additional providers are welcome.","title":"@pnp/config-store/providers"},{"location":"config-store/providers/#splistconfigurationprovider","text":"This provider is based on a SharePoint list it reads all of the rows and makes them available as a TypedHash<string> . By default the column names used are Title for key and \"Value\" for value, but you can update these as needed. Additionally, the settings class supports the idea of last value in wins - so you can easily load multiple configurations. This helps to support a common scenario in the enterprise where you might have one main list for global configuration but some settings can be set at the web level. In this case you would first load the global, then the local settings and any local values will take precedence. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); const settings = new Settings(); // load our values from the list await settings.load(provider);","title":"SPListConfigurationProvider"},{"location":"config-store/providers/#cachingconfigurationprovider","text":"Because making requests on each page load is very inefficient you can optionally use the caching configuration provider, which wraps a provider and caches the configuration in local or session storage. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // get an instance of the provider wrapped // you can optionally provide a key that will be used in the cache to the asCaching method const wrappedProvider = provider.asCaching(); // use that wrapped provider to populate the settings await settings.load(wrappedProvider);","title":"CachingConfigurationProvider"},{"location":"contributing/","text":"Contributing to PnPjs \u00b6 Thank you for your interest in contributing to PnPjs. We have updated our contribution section to make things easier to get started, debug the library locally, and learn how to extend the functionality. Section Description Setup Dev Machine Covers setting up your machine to ensure you are ready to debug the solution Local Debug Configuration Discusses the steps required to establish local configuration used for debugging and running tests Debugging Describes how to debug PnPjs locally Extending the library Basic examples on how to extend the library such as adding a method or property Writing Tests How to write and debug tests Update Documentation Describes the steps required to edit and locally view the documentation Submit a Pull Request Outlines guidance for submitting a pull request Need Help? \u00b6 The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website.","title":"Contributing"},{"location":"contributing/#contributing-to-pnpjs","text":"Thank you for your interest in contributing to PnPjs. We have updated our contribution section to make things easier to get started, debug the library locally, and learn how to extend the functionality. Section Description Setup Dev Machine Covers setting up your machine to ensure you are ready to debug the solution Local Debug Configuration Discusses the steps required to establish local configuration used for debugging and running tests Debugging Describes how to debug PnPjs locally Extending the library Basic examples on how to extend the library such as adding a method or property Writing Tests How to write and debug tests Update Documentation Describes the steps required to edit and locally view the documentation Submit a Pull Request Outlines guidance for submitting a pull request","title":"Contributing to PnPjs"},{"location":"contributing/#need-help","text":"The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website.","title":"Need Help?"},{"location":"contributing/debug-tests/","text":"Writing Tests \u00b6 With version 2 we have made a significant effort to improve out test coverage. To keep that up, all changes submitted will require one or more tests be included. For new functionality at least a basic test that the method executes is required. For bug fixes please include a test that would have caught the bug (i.e. fail before your fix) and passes with your fix in place. How to write Tests \u00b6 We use Mocha and Chai for our testing framework. You can see many examples of writing tests within the ./test folder. Here is a sample with extra comments to help explain what's happening, taken from ./test/sp/items.ts : import { getRandomString } from \"@pnp/core\"; import { testSettings } from \"../main\"; import { expect } from \"chai\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import { IList } from \"@pnp/sp/lists\"; describe(\"Items\", () => { // any tests that make a web request should be withing a block checking if web tests are enabled if (testSettings.enableWebTests) { // a block scoped var we will use across our tests let list: IList = null; // we use the before block to setup // executed before all the tests in this block, see the mocha docs for more details // mocha prefers using function vs arrow functions and this is recommended before(async function () { // execute a request to ensure we have a list const ler = await sp.web.lists.ensure(\"ItemTestList\", \"Used to test item operations\"); list = ler.list; // in this case we want to have some items in the list for testing so we add those // only if the list was just created if (ler.created) { // add a few items to get started const batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); await batch.execute(); } }); // this test has a label \"get items\" and is run via an async function it(\"get items\", async function () { // make a request for the list's items const items = await list.items(); // report that we expect that result to be an array with more than 0 items expect(items.length).to.be.gt(0); }); // ... remainder of code removed } } General Guidelines for Writing Tests \u00b6 Tests should operate within the site defined in testSettings Tests should be able to run multiple times on the same site, but do not need to cleanup after themselves Each test should be self contained and not depend on other tests, they can depend on work done in before or beforeAll When writing tests you can use \"only\" and \"skip\" from mochajs to focus on only the tests you are writing Be sure to review the various options when running your tests If you are writing a test and the endpoint doesn't support app only permissions, you can skip writing a test - but please note that in the PR description Next Steps \u00b6 Now that you've written tests to cover your changes you'll need to update the docs .","title":"Writing Tests"},{"location":"contributing/debug-tests/#writing-tests","text":"With version 2 we have made a significant effort to improve out test coverage. To keep that up, all changes submitted will require one or more tests be included. For new functionality at least a basic test that the method executes is required. For bug fixes please include a test that would have caught the bug (i.e. fail before your fix) and passes with your fix in place.","title":"Writing Tests"},{"location":"contributing/debug-tests/#how-to-write-tests","text":"We use Mocha and Chai for our testing framework. You can see many examples of writing tests within the ./test folder. Here is a sample with extra comments to help explain what's happening, taken from ./test/sp/items.ts : import { getRandomString } from \"@pnp/core\"; import { testSettings } from \"../main\"; import { expect } from \"chai\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import { IList } from \"@pnp/sp/lists\"; describe(\"Items\", () => { // any tests that make a web request should be withing a block checking if web tests are enabled if (testSettings.enableWebTests) { // a block scoped var we will use across our tests let list: IList = null; // we use the before block to setup // executed before all the tests in this block, see the mocha docs for more details // mocha prefers using function vs arrow functions and this is recommended before(async function () { // execute a request to ensure we have a list const ler = await sp.web.lists.ensure(\"ItemTestList\", \"Used to test item operations\"); list = ler.list; // in this case we want to have some items in the list for testing so we add those // only if the list was just created if (ler.created) { // add a few items to get started const batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); await batch.execute(); } }); // this test has a label \"get items\" and is run via an async function it(\"get items\", async function () { // make a request for the list's items const items = await list.items(); // report that we expect that result to be an array with more than 0 items expect(items.length).to.be.gt(0); }); // ... remainder of code removed } }","title":"How to write Tests"},{"location":"contributing/debug-tests/#general-guidelines-for-writing-tests","text":"Tests should operate within the site defined in testSettings Tests should be able to run multiple times on the same site, but do not need to cleanup after themselves Each test should be self contained and not depend on other tests, they can depend on work done in before or beforeAll When writing tests you can use \"only\" and \"skip\" from mochajs to focus on only the tests you are writing Be sure to review the various options when running your tests If you are writing a test and the endpoint doesn't support app only permissions, you can skip writing a test - but please note that in the PR description","title":"General Guidelines for Writing Tests"},{"location":"contributing/debug-tests/#next-steps","text":"Now that you've written tests to cover your changes you'll need to update the docs .","title":"Next Steps"},{"location":"contributing/debugging/","text":"Debugging \u00b6 Using the steps in this article you will be able to locally debug the library internals as well as new features you are working on. Before proceeding be sure you have reviewed how to setup for local configuration and debugging. Debugging Library Features \u00b6 The easiest way to debug the library when working on new features is using F5 in Visual Studio Code. This uses launch.json to build and run the library using ./debug/launch/main.ts as the entry point. Basic SharePoint Testing \u00b6 You can start the base debugging case by hitting F5. Before you do place a break point in ./debug/launch/sp.ts. You can also place a break point within any of the libraries or modules. Feel free to edit the sp.ts file to try things out, debug suspected issues, or test new features, etc - but please don't commit any changes as this is a shared file. See the section on creating your own debug modules . All of the setup for the node client is handled within sp.ts using the settings from the local configuration . Basic Graph Testing \u00b6 Testing and debugging Graph calls follows the same process as outlined for SharePoint, however you need to update main.ts to import graph instead of sp. You can place break points anywhere within the library code and they should be hit. All of the setup for the node client is handled within graph.ts using the settings from the local configuration . How to: Create a Debug Module \u00b6 If you are working on multiple features or want to save sample code for various tasks you can create your own debugging modules and leave them in the debug/launch folder locally. The gitignore file is setup to ignore any files that aren't already in git. Using ./debug/launch/sp.ts as a reference create a file in the debug/launch folder, let's call it mydebug.ts and add this content: // note we can use the actual package names for our imports (ex: @pnp/logging) import { Logger, LogLevel, ConsoleListener } from \"@pnp/logging\"; // using the all preset for simplicity in the example, selective imports work as expected import { sp, ListEnsureResult } from \"@pnp/sp/presets/all\"; declare var process: { exit(code?: number): void }; export async function MyDebug() { // configure your options // you can have different configs in different modules as needed for your testing/dev work sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret); }, }, }); // run some debugging const list = await sp.web.lists.ensure(\"MyFirstList\"); Logger.log({ data: list.created, level: LogLevel.Info, message: \"Was list created?\", }); if (list.created) { Logger.log({ data: list.data, level: LogLevel.Info, message: \"Raw data from list creation.\", }); } else { Logger.log({ data: null, level: LogLevel.Info, message: \"List already existed!\", }); } process.exit(0); } Update main.ts to launch your module \u00b6 First comment out the import for the default example and then add the import and function call for yours, the updated launch/main.ts should look like this: // ... // comment out the example // import { Example } from \"./example\"; // Example(); import { MyDebug } from \"./mydebug\" MyDebug(); // ... Remember, please don't commit any changes to the shared files within the debug folder. (Unless you've found a bug that needs fixing in the original file) Debug \u00b6 Place a break point within the mydebug.ts file and hit F5. Your module should run and your break point hit. You can then examine the contents of the objects and see the run time state. Remember, you can also set breakpoints within the package src folders to see exactly how things are working during your debugging scenarios. Debug Module Next Steps \u00b6 Using this pattern you can create and preserve multiple debugging scenarios in separate modules locally - they won't be added to git. You just have to update main.ts to point to the one you want to run. In Browser Debugging \u00b6 You can also serve files locally to debug as a user in the browser by serving code using ./debug/serve/main.ts as the entry. The file is served as https://localhost:8080/assets/pnp.js , allowing you to create a single page in your tenant for in browser testing. The remainder of this section describes the process to setup a SharePoint page to debug in this manner. Start the local serve \u00b6 This will serve a package with ./debug/serve/main.ts as the entry. gulp serve Add reference to library \u00b6 Within a SharePoint page add a script editor web part and then paste in the following code. The div is to give you a place to target with visual updates should you desire. <script src=\"https://localhost:8080/assets/pnp.js\"></script> <div id=\"pnp-test\"></div> You should see an alert with the current web's title using the default main.ts. Feel free to update main.ts to do whatever you would like, but remember not to commit changes to the shared files. Debug \u00b6 Refresh the page and open the developer tools in your browser of choice. If the pnp.js file is blocked due to security restrictions you will need to allow it. Next Steps \u00b6 You can make changes to the library and immediately see them reflected in the browser. All files are watched so changes will be available as soon as webpack reloads the package. This allows you to rapidly test the library in the browser. Now you can learn about extending the library .","title":"Debugging"},{"location":"contributing/debugging/#debugging","text":"Using the steps in this article you will be able to locally debug the library internals as well as new features you are working on. Before proceeding be sure you have reviewed how to setup for local configuration and debugging.","title":"Debugging"},{"location":"contributing/debugging/#debugging-library-features","text":"The easiest way to debug the library when working on new features is using F5 in Visual Studio Code. This uses launch.json to build and run the library using ./debug/launch/main.ts as the entry point.","title":"Debugging Library Features"},{"location":"contributing/debugging/#basic-sharepoint-testing","text":"You can start the base debugging case by hitting F5. Before you do place a break point in ./debug/launch/sp.ts. You can also place a break point within any of the libraries or modules. Feel free to edit the sp.ts file to try things out, debug suspected issues, or test new features, etc - but please don't commit any changes as this is a shared file. See the section on creating your own debug modules . All of the setup for the node client is handled within sp.ts using the settings from the local configuration .","title":"Basic SharePoint Testing"},{"location":"contributing/debugging/#basic-graph-testing","text":"Testing and debugging Graph calls follows the same process as outlined for SharePoint, however you need to update main.ts to import graph instead of sp. You can place break points anywhere within the library code and they should be hit. All of the setup for the node client is handled within graph.ts using the settings from the local configuration .","title":"Basic Graph Testing"},{"location":"contributing/debugging/#how-to-create-a-debug-module","text":"If you are working on multiple features or want to save sample code for various tasks you can create your own debugging modules and leave them in the debug/launch folder locally. The gitignore file is setup to ignore any files that aren't already in git. Using ./debug/launch/sp.ts as a reference create a file in the debug/launch folder, let's call it mydebug.ts and add this content: // note we can use the actual package names for our imports (ex: @pnp/logging) import { Logger, LogLevel, ConsoleListener } from \"@pnp/logging\"; // using the all preset for simplicity in the example, selective imports work as expected import { sp, ListEnsureResult } from \"@pnp/sp/presets/all\"; declare var process: { exit(code?: number): void }; export async function MyDebug() { // configure your options // you can have different configs in different modules as needed for your testing/dev work sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret); }, }, }); // run some debugging const list = await sp.web.lists.ensure(\"MyFirstList\"); Logger.log({ data: list.created, level: LogLevel.Info, message: \"Was list created?\", }); if (list.created) { Logger.log({ data: list.data, level: LogLevel.Info, message: \"Raw data from list creation.\", }); } else { Logger.log({ data: null, level: LogLevel.Info, message: \"List already existed!\", }); } process.exit(0); }","title":"How to: Create a Debug Module"},{"location":"contributing/debugging/#update-maints-to-launch-your-module","text":"First comment out the import for the default example and then add the import and function call for yours, the updated launch/main.ts should look like this: // ... // comment out the example // import { Example } from \"./example\"; // Example(); import { MyDebug } from \"./mydebug\" MyDebug(); // ... Remember, please don't commit any changes to the shared files within the debug folder. (Unless you've found a bug that needs fixing in the original file)","title":"Update main.ts to launch your module"},{"location":"contributing/debugging/#debug","text":"Place a break point within the mydebug.ts file and hit F5. Your module should run and your break point hit. You can then examine the contents of the objects and see the run time state. Remember, you can also set breakpoints within the package src folders to see exactly how things are working during your debugging scenarios.","title":"Debug"},{"location":"contributing/debugging/#debug-module-next-steps","text":"Using this pattern you can create and preserve multiple debugging scenarios in separate modules locally - they won't be added to git. You just have to update main.ts to point to the one you want to run.","title":"Debug Module Next Steps"},{"location":"contributing/debugging/#in-browser-debugging","text":"You can also serve files locally to debug as a user in the browser by serving code using ./debug/serve/main.ts as the entry. The file is served as https://localhost:8080/assets/pnp.js , allowing you to create a single page in your tenant for in browser testing. The remainder of this section describes the process to setup a SharePoint page to debug in this manner.","title":"In Browser Debugging"},{"location":"contributing/debugging/#start-the-local-serve","text":"This will serve a package with ./debug/serve/main.ts as the entry. gulp serve","title":"Start the local serve"},{"location":"contributing/debugging/#add-reference-to-library","text":"Within a SharePoint page add a script editor web part and then paste in the following code. The div is to give you a place to target with visual updates should you desire. <script src=\"https://localhost:8080/assets/pnp.js\"></script> <div id=\"pnp-test\"></div> You should see an alert with the current web's title using the default main.ts. Feel free to update main.ts to do whatever you would like, but remember not to commit changes to the shared files.","title":"Add reference to library"},{"location":"contributing/debugging/#debug_1","text":"Refresh the page and open the developer tools in your browser of choice. If the pnp.js file is blocked due to security restrictions you will need to allow it.","title":"Debug"},{"location":"contributing/debugging/#next-steps","text":"You can make changes to the library and immediately see them reflected in the browser. All files are watched so changes will be available as soon as webpack reloads the package. This allows you to rapidly test the library in the browser. Now you can learn about extending the library .","title":"Next Steps"},{"location":"contributing/documentation/","text":"Documentation \u00b6 Just like with tests we have invested much time in updating the documentation and when you make a change to the library you should update the associated documentation as part of the pull request. Writing Docs \u00b6 Our docs are all written in markdown and processed using MkDocs. You can use code blocks, tables, and other markdown formatting. You can review the other articles for examples on writing docs. Generally articles should focus on how to use the library and where appropriate link to official outside documents as needed. Official documentation could be Microsoft, other library project docs such as MkDocs, or other sources. Building Docs Locally \u00b6 Building the documentation locally can help you visualize change you are making to the docs. What you see locally will be what you see online. Documentation is built using MkDocs. You will need to latest version of Python (tested on version 3.7.1) and pip. If you're on the Windows operating system, make sure you have added Python to your Path environment variable . When executing the pip module on Windows you can prefix it with python -m . For example: python -m pip install mkdocs-material Install MkDocs pip install mkdocs Install the Material theme pip install mkdocs-material install the mkdocs-markdownextradata-plugin - this is used for the version variable pip install mkdocs-markdownextradata-plugin (doesn't work on Python v2.7) install redirect plugin - used to redirect from moved pages pip install mkdocs-redirects Serve it up mkdocs serve Open a browser to http://127.0.0.1:8000/ Please see the official mkdocs site for more details on working with mkdocs Next Steps \u00b6 After your changes are made, you've added/updated tests, and updated the docs you're ready to submit a pull request !","title":"Update Documentation"},{"location":"contributing/documentation/#documentation","text":"Just like with tests we have invested much time in updating the documentation and when you make a change to the library you should update the associated documentation as part of the pull request.","title":"Documentation"},{"location":"contributing/documentation/#writing-docs","text":"Our docs are all written in markdown and processed using MkDocs. You can use code blocks, tables, and other markdown formatting. You can review the other articles for examples on writing docs. Generally articles should focus on how to use the library and where appropriate link to official outside documents as needed. Official documentation could be Microsoft, other library project docs such as MkDocs, or other sources.","title":"Writing Docs"},{"location":"contributing/documentation/#building-docs-locally","text":"Building the documentation locally can help you visualize change you are making to the docs. What you see locally will be what you see online. Documentation is built using MkDocs. You will need to latest version of Python (tested on version 3.7.1) and pip. If you're on the Windows operating system, make sure you have added Python to your Path environment variable . When executing the pip module on Windows you can prefix it with python -m . For example: python -m pip install mkdocs-material Install MkDocs pip install mkdocs Install the Material theme pip install mkdocs-material install the mkdocs-markdownextradata-plugin - this is used for the version variable pip install mkdocs-markdownextradata-plugin (doesn't work on Python v2.7) install redirect plugin - used to redirect from moved pages pip install mkdocs-redirects Serve it up mkdocs serve Open a browser to http://127.0.0.1:8000/ Please see the official mkdocs site for more details on working with mkdocs","title":"Building Docs Locally"},{"location":"contributing/documentation/#next-steps","text":"After your changes are made, you've added/updated tests, and updated the docs you're ready to submit a pull request !","title":"Next Steps"},{"location":"contributing/extending-the-library/","text":"Extending PnPjs \u00b6 This article is targeted at people wishing to extend PnPjs itself, usually by adding a method or property. At the most basic level PnPjs is a set of libraries used to build and execute a web request and handle the response from that request. Conceptually each object in the fluent chain serves as input when creating the next object in the chain. This is how configuration, url, query, and other values are passed along. To get a sense for what this looks like see the code below. This is taken from inside the webs submodule and shows how the \"webs\" property is added to the web class. // TypeScript property, returning an interface public get webs(): IWebs { // using the Webs factory function and providing \"this\" as the first parameter return Webs(this); } Understanding Factory Functions \u00b6 PnPjs v2 is designed to only expose interfaces and factory functions. Let's look at the Webs factory function, used above as an example. All factory functions in sp and graph have a similar form. // create a constant which is a function of type ISPInvokableFactory having the name Webs // this is bound by the generic type param to return an IWebs instance // and it will use the _Webs concrete class to form the internal type of the invocable export const Webs = spInvokableFactory<IWebs>(_Webs); The ISPInvokableFactory type looks like: export type ISPInvokableFactory<R = any> = (baseUrl: string | ISharePointQueryable, path?: string) => R; And the matching graph type: <R>(f: any): (baseUrl: string | IGraphQueryable, path?: string) => R The general idea of a factory function is that it takes two parameters. The first is either a string or Queryable derivative which forms base for the new object. The second is the next part of the url. In some cases (like the webs property example above) you will note there is no second parameter. Some classes are decorated with defaultPath, which automatically fills the second param. Don't worry too much right now about the deep internals of the library, let's instead focus on some concrete examples. import { Web } from \"@pnp/sp/webs\"; // create a web from an absolute url const web = Web(\"https://tenant.sharepoint.com\"); // as an example, create a new web using the first as a base // targets: https://tenant.sharepoint.com/sites/dev const web2 = Web(web, \"sites/dev\"); // or you can add any path components you want, here as an example we access the current user property const cu = Web(web, \"currentuser\"); const currentUserInfo = cu(); Now hey you might say - you can't create a request to current user using the Web factory. Well you can, since everything is just based on urls under the covers the actual factory names don't mean anything other than they have the appropriate properties and method hung off them. This is brought up as you will see in many cases objects being used to create queries within methods and properties that don't match their \"type\". It is an important concept when working with the library to always remember we are just building strings. Class structure \u00b6 Internally to the library we have a bit of complexity to make the whole invocable proxy architecture work and provide the typings folks expect. Here is an example implementation with extra comments explaining what is happening. You don't need to understand the entire stack to add a property or method /* The concrete class implementation. This is never exported or shown directly to consumers of the library. It is wrapped by the Proxy we do expose. It extends the _SharePointQueryableInstance class for which there is a matching _SharePointQueryableCollection. The generic parameter defines the return type of a get operation and the invoked result. Classes can have methods and properties as normal. This one has a single property as a simple example */ export class _HubSite extends _SharePointQueryableInstance<IHubSiteInfo> { /** * Gets the ISite instance associated with this hub site */ // the tag decorator is used to provide some additional telemetry on what methods are // being called. @tag(\"hs.getSite\") public async getSite(): Promise<ISite> { // we execute a request using this instance, selecting the SiteUrl property, and invoking it immediately and awaiting the result const d = await this.select(\"SiteUrl\")(); // we then return a new ISite instance created from the Site factory using the returned SiteUrl property as the baseUrl return Site(d.SiteUrl); } } /* This defines the interface we export and expose to consumers. In most cases this extends the concrete object but may add or remove some methods/properties in special cases */ export interface IHubSite extends _HubSite { } /* This defines the HubSite factory function as discussed above binding the spInvokableFactory to a generic param of IHubSite and a param of _HubSite. This is understood to mean that HubSite is a factory function that returns a types of IHubSite which the spInvokableFactory will create using _HubSite as the concrete underlying type. */ export const HubSite = spInvokableFactory<IHubSite>(_HubSite); Add a Property \u00b6 In most cases you won't need to create the class, interface, or factory - you just want to add a property or method. An example of this is sp.web.lists. web is a property of sp and lists is a property of web. You can have a look at those classes as examples. Let's have a look at the fields on the _View class. export class _View extends _SharePointQueryableInstance<IViewInfo> { // ... other code removed // add the property, and provide a return type // return types should be interfaces public get fields(): IViewFields { // we use the ViewFields factory function supplying \"this\" as the first parameter // this will create a url like \".../fields/viewfields\" due to the defaultPath decorator // on the _ViewFields class. This is equivalent to: ViewFields(this, \"viewfields\") return ViewFields(this); } // ... other code removed } There are many examples throughout the library that follow this pattern. Add a Method \u00b6 Adding a method is just like adding a property with the key difference that a method usually does something like make a web request or act like a property but take parameters. Let's look at the _Items getById method: @defaultPath(\"items\") export class _Items extends _SharePointQueryableCollection { /** * Gets an Item by id * * @param id The integer id of the item to retrieve */ // we declare a method and set the return type to an interface public getById(id: number): IItem { // here we use the tag helper to add some telemetry to our request // we create a new IItem using the factory and appending the id value to the end // this gives us a valid url path to a single item .../items/getById(2) // we can then use the returned IItem to extend our chain or execute a request return tag.configure(Item(this).concat(`(${id})`), \"is.getById\"); } // ... other code removed } Web Request Method \u00b6 A second example is a method that performs a request. Here we use the _Item recycle method as an example: /** * Moves the list item to the Recycle Bin and returns the identifier of the new Recycle Bin item. */ // we use the tag decorator to add telemetry @tag(\"i.recycle\") // we return a promise public recycle(): Promise<string> { // we use the spPost method to post the request created by cloning our current instance IItem using // the Item factory and adding the path \"recycle\" to the end. Url will look like .../items/getById(2)/recycle return spPost<string>(this.clone(Item, \"recycle\")); } Augment Using Selective Imports \u00b6 To understand is how to extend functionality within the selective imports structures look at list.ts file in the items submodule. Here you can see the code below, with extra comments to explain what is happening. Again, you will see this pattern repeated throughout the library so there are many examples available. // import the addProp helper import { addProp } from \"@pnp/queryable\"; // import the _List concrete class from the types module (not the index!) import { _List } from \"../lists/types\"; // import the interface and factory we are going to add to the List import { Items, IItems } from \"./types\"; // This module declaration fixes up the types, allowing .items to appear in intellisense // when you import \"@pnp/sp/items/list\"; declare module \"../lists/types\" { // we need to extend the concrete type interface _List { readonly items: IItems; } // we need to extend the interface // this may not be strictly necessary as the IList interface extends _List so it // should pick up the same additions, but we have seen in some cases this does seem // to be required. So we include it for safety as it will all be removed during // transpilation we don't need to care about the extra code interface IList { readonly items: IItems; } } // finally we add the property to the _List class // this method call says add a property to _List named \"items\" and that property returns a result using the Items factory // The factory will be called with \"this\" when the property is accessed. If needed there is a fourth parameter to append additional path // information to the property url addProp(_List, \"items\", Items); General Rules for Extending PnPjs \u00b6 Only expose interfaces to consumers Use the factory functions except in very special cases Look for other properties and methods as examples Simple is always preferable, but not always possible - use your best judgement If you find yourself writing a ton of code to solve a problem you think should be easy, ask If you find yourself deep within the core classes or odata library trying to make a change, ask - changes to the core classes are rarely needed Next Steps \u00b6 Now that you have extended the library you need to write a test to cover it!","title":"Extending the library"},{"location":"contributing/extending-the-library/#extending-pnpjs","text":"This article is targeted at people wishing to extend PnPjs itself, usually by adding a method or property. At the most basic level PnPjs is a set of libraries used to build and execute a web request and handle the response from that request. Conceptually each object in the fluent chain serves as input when creating the next object in the chain. This is how configuration, url, query, and other values are passed along. To get a sense for what this looks like see the code below. This is taken from inside the webs submodule and shows how the \"webs\" property is added to the web class. // TypeScript property, returning an interface public get webs(): IWebs { // using the Webs factory function and providing \"this\" as the first parameter return Webs(this); }","title":"Extending PnPjs"},{"location":"contributing/extending-the-library/#understanding-factory-functions","text":"PnPjs v2 is designed to only expose interfaces and factory functions. Let's look at the Webs factory function, used above as an example. All factory functions in sp and graph have a similar form. // create a constant which is a function of type ISPInvokableFactory having the name Webs // this is bound by the generic type param to return an IWebs instance // and it will use the _Webs concrete class to form the internal type of the invocable export const Webs = spInvokableFactory<IWebs>(_Webs); The ISPInvokableFactory type looks like: export type ISPInvokableFactory<R = any> = (baseUrl: string | ISharePointQueryable, path?: string) => R; And the matching graph type: <R>(f: any): (baseUrl: string | IGraphQueryable, path?: string) => R The general idea of a factory function is that it takes two parameters. The first is either a string or Queryable derivative which forms base for the new object. The second is the next part of the url. In some cases (like the webs property example above) you will note there is no second parameter. Some classes are decorated with defaultPath, which automatically fills the second param. Don't worry too much right now about the deep internals of the library, let's instead focus on some concrete examples. import { Web } from \"@pnp/sp/webs\"; // create a web from an absolute url const web = Web(\"https://tenant.sharepoint.com\"); // as an example, create a new web using the first as a base // targets: https://tenant.sharepoint.com/sites/dev const web2 = Web(web, \"sites/dev\"); // or you can add any path components you want, here as an example we access the current user property const cu = Web(web, \"currentuser\"); const currentUserInfo = cu(); Now hey you might say - you can't create a request to current user using the Web factory. Well you can, since everything is just based on urls under the covers the actual factory names don't mean anything other than they have the appropriate properties and method hung off them. This is brought up as you will see in many cases objects being used to create queries within methods and properties that don't match their \"type\". It is an important concept when working with the library to always remember we are just building strings.","title":"Understanding Factory Functions"},{"location":"contributing/extending-the-library/#class-structure","text":"Internally to the library we have a bit of complexity to make the whole invocable proxy architecture work and provide the typings folks expect. Here is an example implementation with extra comments explaining what is happening. You don't need to understand the entire stack to add a property or method /* The concrete class implementation. This is never exported or shown directly to consumers of the library. It is wrapped by the Proxy we do expose. It extends the _SharePointQueryableInstance class for which there is a matching _SharePointQueryableCollection. The generic parameter defines the return type of a get operation and the invoked result. Classes can have methods and properties as normal. This one has a single property as a simple example */ export class _HubSite extends _SharePointQueryableInstance<IHubSiteInfo> { /** * Gets the ISite instance associated with this hub site */ // the tag decorator is used to provide some additional telemetry on what methods are // being called. @tag(\"hs.getSite\") public async getSite(): Promise<ISite> { // we execute a request using this instance, selecting the SiteUrl property, and invoking it immediately and awaiting the result const d = await this.select(\"SiteUrl\")(); // we then return a new ISite instance created from the Site factory using the returned SiteUrl property as the baseUrl return Site(d.SiteUrl); } } /* This defines the interface we export and expose to consumers. In most cases this extends the concrete object but may add or remove some methods/properties in special cases */ export interface IHubSite extends _HubSite { } /* This defines the HubSite factory function as discussed above binding the spInvokableFactory to a generic param of IHubSite and a param of _HubSite. This is understood to mean that HubSite is a factory function that returns a types of IHubSite which the spInvokableFactory will create using _HubSite as the concrete underlying type. */ export const HubSite = spInvokableFactory<IHubSite>(_HubSite);","title":"Class structure"},{"location":"contributing/extending-the-library/#add-a-property","text":"In most cases you won't need to create the class, interface, or factory - you just want to add a property or method. An example of this is sp.web.lists. web is a property of sp and lists is a property of web. You can have a look at those classes as examples. Let's have a look at the fields on the _View class. export class _View extends _SharePointQueryableInstance<IViewInfo> { // ... other code removed // add the property, and provide a return type // return types should be interfaces public get fields(): IViewFields { // we use the ViewFields factory function supplying \"this\" as the first parameter // this will create a url like \".../fields/viewfields\" due to the defaultPath decorator // on the _ViewFields class. This is equivalent to: ViewFields(this, \"viewfields\") return ViewFields(this); } // ... other code removed } There are many examples throughout the library that follow this pattern.","title":"Add a Property"},{"location":"contributing/extending-the-library/#add-a-method","text":"Adding a method is just like adding a property with the key difference that a method usually does something like make a web request or act like a property but take parameters. Let's look at the _Items getById method: @defaultPath(\"items\") export class _Items extends _SharePointQueryableCollection { /** * Gets an Item by id * * @param id The integer id of the item to retrieve */ // we declare a method and set the return type to an interface public getById(id: number): IItem { // here we use the tag helper to add some telemetry to our request // we create a new IItem using the factory and appending the id value to the end // this gives us a valid url path to a single item .../items/getById(2) // we can then use the returned IItem to extend our chain or execute a request return tag.configure(Item(this).concat(`(${id})`), \"is.getById\"); } // ... other code removed }","title":"Add a Method"},{"location":"contributing/extending-the-library/#web-request-method","text":"A second example is a method that performs a request. Here we use the _Item recycle method as an example: /** * Moves the list item to the Recycle Bin and returns the identifier of the new Recycle Bin item. */ // we use the tag decorator to add telemetry @tag(\"i.recycle\") // we return a promise public recycle(): Promise<string> { // we use the spPost method to post the request created by cloning our current instance IItem using // the Item factory and adding the path \"recycle\" to the end. Url will look like .../items/getById(2)/recycle return spPost<string>(this.clone(Item, \"recycle\")); }","title":"Web Request Method"},{"location":"contributing/extending-the-library/#augment-using-selective-imports","text":"To understand is how to extend functionality within the selective imports structures look at list.ts file in the items submodule. Here you can see the code below, with extra comments to explain what is happening. Again, you will see this pattern repeated throughout the library so there are many examples available. // import the addProp helper import { addProp } from \"@pnp/queryable\"; // import the _List concrete class from the types module (not the index!) import { _List } from \"../lists/types\"; // import the interface and factory we are going to add to the List import { Items, IItems } from \"./types\"; // This module declaration fixes up the types, allowing .items to appear in intellisense // when you import \"@pnp/sp/items/list\"; declare module \"../lists/types\" { // we need to extend the concrete type interface _List { readonly items: IItems; } // we need to extend the interface // this may not be strictly necessary as the IList interface extends _List so it // should pick up the same additions, but we have seen in some cases this does seem // to be required. So we include it for safety as it will all be removed during // transpilation we don't need to care about the extra code interface IList { readonly items: IItems; } } // finally we add the property to the _List class // this method call says add a property to _List named \"items\" and that property returns a result using the Items factory // The factory will be called with \"this\" when the property is accessed. If needed there is a fourth parameter to append additional path // information to the property url addProp(_List, \"items\", Items);","title":"Augment Using Selective Imports"},{"location":"contributing/extending-the-library/#general-rules-for-extending-pnpjs","text":"Only expose interfaces to consumers Use the factory functions except in very special cases Look for other properties and methods as examples Simple is always preferable, but not always possible - use your best judgement If you find yourself writing a ton of code to solve a problem you think should be easy, ask If you find yourself deep within the core classes or odata library trying to make a change, ask - changes to the core classes are rarely needed","title":"General Rules for Extending PnPjs"},{"location":"contributing/extending-the-library/#next-steps","text":"Now that you have extended the library you need to write a test to cover it!","title":"Next Steps"},{"location":"contributing/local-debug-configuration/","text":"Local Debugging Configuration \u00b6 This article covers the local setup required to debug the library and run tests. This only needs to be done once (unless you update the app registrations, then you just need to update the settings.js file accordingly). Create settings.js \u00b6 Both local debugging and tests make use of a settings.js file located in the root of the project. Ensure you create a settings.js files by copying settings.example.js and renaming it to settings.js. For more information the settings file please see Settings Minimal Configuration \u00b6 You can control which tests are run by including or omitting sp and graph sections. If sp is present and graph is not, only sp tests are run. Include both and all tests are run, respecting the enableWebTests flag. The following configuration file allows you to run all the tests that do not contact services. var sets = { testing: { enableWebTests: false, } } module.exports = sets; Test your setup \u00b6 If you hit F5 in VSCode now you should be able to see the full response from getting the web's title in the internal console window. If not, ensure that you have properly updated the settings file and registered the add-in perms correctly.","title":"Local Debug Configuration"},{"location":"contributing/local-debug-configuration/#local-debugging-configuration","text":"This article covers the local setup required to debug the library and run tests. This only needs to be done once (unless you update the app registrations, then you just need to update the settings.js file accordingly).","title":"Local Debugging Configuration"},{"location":"contributing/local-debug-configuration/#create-settingsjs","text":"Both local debugging and tests make use of a settings.js file located in the root of the project. Ensure you create a settings.js files by copying settings.example.js and renaming it to settings.js. For more information the settings file please see Settings","title":"Create settings.js"},{"location":"contributing/local-debug-configuration/#minimal-configuration","text":"You can control which tests are run by including or omitting sp and graph sections. If sp is present and graph is not, only sp tests are run. Include both and all tests are run, respecting the enableWebTests flag. The following configuration file allows you to run all the tests that do not contact services. var sets = { testing: { enableWebTests: false, } } module.exports = sets;","title":"Minimal Configuration"},{"location":"contributing/local-debug-configuration/#test-your-setup","text":"If you hit F5 in VSCode now you should be able to see the full response from getting the web's title in the internal console window. If not, ensure that you have properly updated the settings file and registered the add-in perms correctly.","title":"Test your setup"},{"location":"contributing/pull-requests/","text":"Submitting Pull Requests \u00b6 Pull requests may be large or small - adding whole new features or fixing some misspellings. Regardless, they are all appreciated and help improve the library for everyone! By following the below guidelines we'll have an easier time merging your work and getting it into the next release. Target your pull requests to the version-2 branch Add/Update any relevant docs articles in the relevant package's docs folder related to your changes Include a test for any new functionality and ensure all existing tests are passing by running npm test Ensure linting checks pass by typing npm run lint Ensure everything works for a build by running npm run package Keep your PRs as simple as possible and describe the changes to help the reviewer understand your work If you have an idea for a larger change to the library please open an issue and let's discuss before you invest many hours - these are very welcome but want to ensure it is something we can merge before you spend the time :) If you need to target a PR for version 1, please target the \"version-1\" branch Sharing is Caring - Pull Request Guidance \u00b6 The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website. Next Steps \u00b6 Now that you've submitted your PR please keep an eye on it as we might have questions. Once an initial review is complete we'll tag it with the expected version number for which it is targeted. Thank you for helping PnPjs grow and improve!!","title":"Submit a Pull Request"},{"location":"contributing/pull-requests/#submitting-pull-requests","text":"Pull requests may be large or small - adding whole new features or fixing some misspellings. Regardless, they are all appreciated and help improve the library for everyone! By following the below guidelines we'll have an easier time merging your work and getting it into the next release. Target your pull requests to the version-2 branch Add/Update any relevant docs articles in the relevant package's docs folder related to your changes Include a test for any new functionality and ensure all existing tests are passing by running npm test Ensure linting checks pass by typing npm run lint Ensure everything works for a build by running npm run package Keep your PRs as simple as possible and describe the changes to help the reviewer understand your work If you have an idea for a larger change to the library please open an issue and let's discuss before you invest many hours - these are very welcome but want to ensure it is something we can merge before you spend the time :) If you need to target a PR for version 1, please target the \"version-1\" branch","title":"Submitting Pull Requests"},{"location":"contributing/pull-requests/#sharing-is-caring-pull-request-guidance","text":"The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website.","title":"Sharing is Caring - Pull Request Guidance"},{"location":"contributing/pull-requests/#next-steps","text":"Now that you've submitted your PR please keep an eye on it as we might have questions. Once an initial review is complete we'll tag it with the expected version number for which it is targeted. Thank you for helping PnPjs grow and improve!!","title":"Next Steps"},{"location":"contributing/setup-dev-machine/","text":"Setting up your Developer Machine \u00b6 If you are a longtime client side developer you likely have your machine already configured and can skip to forking the repo and debugging . Setup your development environment \u00b6 These steps will help you get your environment setup for contributing to the core library. Install Visual Studio Code - this is the development environment we use so the contribution sections expect you are as well. If you prefer you can use Visual Studio or any editor you like. Install Node JS - this provides two key capabilities; the first is the nodejs server which will act as our development server (think iisexpress), the second is npm a package manager (think nuget). This library requires node >= 10.18.0 On Windows: Install Python [Optional] Install the tslint extension in VS Code: Press Shift + Ctrl + \"p\" to open the command panel Begin typing \"install extension\" and select the command when it appears in view Begin typing \"tslint\" and select the package when it appears in view Restart Code after installation Fork The Repo \u00b6 All of our contributions come via pull requests and you'll need to fork the repository Now we need to fork and clone the git repository. This can be done using your console or using your preferred Git GUI tool. Once you have the code locally, navigate to the root of the project in your console. Type the following command: npm install Follow the guidance to complete the one-time local configuration required to debug and run tests. Then you can follow the guidance in the debugging article.","title":"Setup Dev Machine"},{"location":"contributing/setup-dev-machine/#setting-up-your-developer-machine","text":"If you are a longtime client side developer you likely have your machine already configured and can skip to forking the repo and debugging .","title":"Setting up your Developer Machine"},{"location":"contributing/setup-dev-machine/#setup-your-development-environment","text":"These steps will help you get your environment setup for contributing to the core library. Install Visual Studio Code - this is the development environment we use so the contribution sections expect you are as well. If you prefer you can use Visual Studio or any editor you like. Install Node JS - this provides two key capabilities; the first is the nodejs server which will act as our development server (think iisexpress), the second is npm a package manager (think nuget). This library requires node >= 10.18.0 On Windows: Install Python [Optional] Install the tslint extension in VS Code: Press Shift + Ctrl + \"p\" to open the command panel Begin typing \"install extension\" and select the command when it appears in view Begin typing \"tslint\" and select the package when it appears in view Restart Code after installation","title":"Setup your development environment"},{"location":"contributing/setup-dev-machine/#fork-the-repo","text":"All of our contributions come via pull requests and you'll need to fork the repository Now we need to fork and clone the git repository. This can be done using your console or using your preferred Git GUI tool. Once you have the code locally, navigate to the root of the project in your console. Type the following command: npm install Follow the guidance to complete the one-time local configuration required to debug and run tests. Then you can follow the guidance in the debugging article.","title":"Fork The Repo"},{"location":"graph/","text":"@pnp/graph \u00b6 This package contains the fluent api used to call the graph rest services. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application and access the root sp object import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; (function main() { // here we will load the current web's properties graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); }); })() Getting Started with SharePoint Framework \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application, update OnInit, and access the root sp object in render import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; // here we will load the current web's properties graph.groups().then(groups => { this.domElement.innerHTML = `Groups: <ul>${groups.map(g => `<li>${g.displayName}</li>`).join(\"\")}</ul>`; }); } Getting Started on Nodejs \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { graph } from \"@pnp/graph\"; import { AdalFetchClient } from \"@pnp/nodejs\"; import \"@pnp/graph/groups\"; // do this once per page load graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}.onmicrosoft.com\", \"AAD Application Id\", \"AAD Application Secret\"); }, }, }); // here we will load the groups information graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); });","title":"graph"},{"location":"graph/#pnpgraph","text":"This package contains the fluent api used to call the graph rest services.","title":"@pnp/graph"},{"location":"graph/#getting-started","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application and access the root sp object import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; (function main() { // here we will load the current web's properties graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); }); })()","title":"Getting Started"},{"location":"graph/#getting-started-with-sharepoint-framework","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application, update OnInit, and access the root sp object in render import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; // here we will load the current web's properties graph.groups().then(groups => { this.domElement.innerHTML = `Groups: <ul>${groups.map(g => `<li>${g.displayName}</li>`).join(\"\")}</ul>`; }); }","title":"Getting Started with SharePoint Framework"},{"location":"graph/#getting-started-on-nodejs","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { graph } from \"@pnp/graph\"; import { AdalFetchClient } from \"@pnp/nodejs\"; import \"@pnp/graph/groups\"; // do this once per page load graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}.onmicrosoft.com\", \"AAD Application Id\", \"AAD Application Secret\"); }, }, }); // here we will load the groups information graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); });","title":"Getting Started on Nodejs"},{"location":"graph/calendars/","text":"@pnp/graph/calendars \u00b6 Calendars exist in Outlook and can belong to either a user or group. With @pnp/graph@<=2.0.6 , only events for a user and group's default calendar could be fetched/created/updated. In versions 2.0.7 and up, all calendars and their events can be fetched. More information can be found in the official Graph documentation: Calendar Resource Type Event Resource Type ICalendar, ICalendars \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/calendars\"; Preset: All import { graph } from \"@pnp/graph/presets/all\"; Get All Calendars For a User \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendars = await graph.users.getById('user@tenant.onmicrosoft.com').calendars(); const myCalendars = await graph.me.calendars(); Get a Specific Calendar For a User \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CALENDAR_ID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getById(CALENDAR_ID)(); const myCalendar = await graph.me.calendars.getById(CALENDAR_ID)(); Get a User's Default Calendar \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendar(); const myCalendar = await graph.me.calendar(); Get Events For a User's Default Calendar \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // You can get the default calendar events const events = await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events(); // or get all events for the user const events = await graph.users.getById('user@tenant.onmicrosoft.com').events(); // You can get my default calendar events const events = await graph.me.calendar.events(); // or get all events for me const events = await graph.me.events(); Get Events By ID \u00b6 You can use .events.getByID to search through all the events in all calendars or narrow the request to a specific calendar. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CalendarID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA=='; const EventID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; // Get events by ID const event = await graph.users.getById('user@tenant.onmicrosoft.com').events.getByID(EventID); const events = await graph.me.events.getByID(EventID); // Get an event by ID from a specific calendar const event = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getByID(CalendarID).events.getByID(EventID); const events = await graph.me.calendars.getByID(CalendarID).events.getByID(EventID); Create Events \u00b6 This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.add( { \"subject\": \"Let's go for lunch\", \"body\": { \"contentType\": \"HTML\", \"content\": \"Does late morning work for you?\" }, \"start\": { \"dateTime\": \"2017-04-15T12:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"end\": { \"dateTime\": \"2017-04-15T14:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"location\":{ \"displayName\":\"Harry's Bar\" }, \"attendees\": [ { \"emailAddress\": { \"address\":\"samanthab@contoso.onmicrosoft.com\", \"name\": \"Samantha Booth\" }, \"type\": \"required\" } ] }); Update Events \u00b6 This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.getById(EVENT_ID).update({ reminderMinutesBeforeStart: 99, }); Delete Event \u00b6 This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').events.getById(EVENT_ID).delete(); await graph.me.events.getById(EVENT_ID).delete(); Get Calendar for a Group \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; const calendar = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar(); Get Events for a Group \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; // You can do one of const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar.events(); // or const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').events(); Get Calendar View \u00b6 Added in 2.0.7 Gets the events in a calendar during a specified date range. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // basic request, note need to invoke the returned queryable const view = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\")(); // you can use select, top, etc to filter your returned results const view2 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\").select(\"subject\").top(3)(); // you can specify times along with the dates const view3 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01T19:00:00-08:00\", \"2020-03-01T19:00:00-08:00\")(); const view4 = await graph.me.calendarView(\"2020-01-01\", \"2020-03-01\")();","title":"calendars"},{"location":"graph/calendars/#pnpgraphcalendars","text":"Calendars exist in Outlook and can belong to either a user or group. With @pnp/graph@<=2.0.6 , only events for a user and group's default calendar could be fetched/created/updated. In versions 2.0.7 and up, all calendars and their events can be fetched. More information can be found in the official Graph documentation: Calendar Resource Type Event Resource Type","title":"@pnp/graph/calendars"},{"location":"graph/calendars/#icalendar-icalendars","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/calendars\"; Preset: All import { graph } from \"@pnp/graph/presets/all\";","title":"ICalendar, ICalendars"},{"location":"graph/calendars/#get-all-calendars-for-a-user","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendars = await graph.users.getById('user@tenant.onmicrosoft.com').calendars(); const myCalendars = await graph.me.calendars();","title":"Get All Calendars For a User"},{"location":"graph/calendars/#get-a-specific-calendar-for-a-user","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CALENDAR_ID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getById(CALENDAR_ID)(); const myCalendar = await graph.me.calendars.getById(CALENDAR_ID)();","title":"Get a Specific Calendar For a User"},{"location":"graph/calendars/#get-a-users-default-calendar","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendar(); const myCalendar = await graph.me.calendar();","title":"Get a User's Default Calendar"},{"location":"graph/calendars/#get-events-for-a-users-default-calendar","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // You can get the default calendar events const events = await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events(); // or get all events for the user const events = await graph.users.getById('user@tenant.onmicrosoft.com').events(); // You can get my default calendar events const events = await graph.me.calendar.events(); // or get all events for me const events = await graph.me.events();","title":"Get Events For a User's Default Calendar"},{"location":"graph/calendars/#get-events-by-id","text":"You can use .events.getByID to search through all the events in all calendars or narrow the request to a specific calendar. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CalendarID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA=='; const EventID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; // Get events by ID const event = await graph.users.getById('user@tenant.onmicrosoft.com').events.getByID(EventID); const events = await graph.me.events.getByID(EventID); // Get an event by ID from a specific calendar const event = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getByID(CalendarID).events.getByID(EventID); const events = await graph.me.calendars.getByID(CalendarID).events.getByID(EventID);","title":"Get Events By ID"},{"location":"graph/calendars/#create-events","text":"This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.add( { \"subject\": \"Let's go for lunch\", \"body\": { \"contentType\": \"HTML\", \"content\": \"Does late morning work for you?\" }, \"start\": { \"dateTime\": \"2017-04-15T12:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"end\": { \"dateTime\": \"2017-04-15T14:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"location\":{ \"displayName\":\"Harry's Bar\" }, \"attendees\": [ { \"emailAddress\": { \"address\":\"samanthab@contoso.onmicrosoft.com\", \"name\": \"Samantha Booth\" }, \"type\": \"required\" } ] });","title":"Create Events"},{"location":"graph/calendars/#update-events","text":"This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.getById(EVENT_ID).update({ reminderMinutesBeforeStart: 99, });","title":"Update Events"},{"location":"graph/calendars/#delete-event","text":"This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').events.getById(EVENT_ID).delete(); await graph.me.events.getById(EVENT_ID).delete();","title":"Delete Event"},{"location":"graph/calendars/#get-calendar-for-a-group","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; const calendar = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar();","title":"Get Calendar for a Group"},{"location":"graph/calendars/#get-events-for-a-group","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; // You can do one of const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar.events(); // or const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').events();","title":"Get Events for a Group"},{"location":"graph/calendars/#get-calendar-view","text":"Added in 2.0.7 Gets the events in a calendar during a specified date range. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // basic request, note need to invoke the returned queryable const view = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\")(); // you can use select, top, etc to filter your returned results const view2 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\").select(\"subject\").top(3)(); // you can specify times along with the dates const view3 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01T19:00:00-08:00\", \"2020-03-01T19:00:00-08:00\")(); const view4 = await graph.me.calendarView(\"2020-01-01\", \"2020-03-01\")();","title":"Get Calendar View"},{"location":"graph/contacts/","text":"@pnp/graph/contacts \u00b6 The ability to manage contacts and folders in Outlook is a capability introduced in version 1.2.2 of @pnp/graph. Through the methods described you can add and edit both contacts and folders in a users Outlook. More information can be found in the official Graph documentation: Contact Resource Type IContact, IContacts, IContactFolder, IContactFolders \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/contacts\"; Preset: All import { graph } from \"@pnp/graph/presets/all\"; Set up notes \u00b6 To make user calls you can use getById where the id is the users email address. Contact ID, Folder ID, and Parent Folder ID use the following format \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\" Get all of the Contacts \u00b6 Gets a list of all the contacts for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contacts = await graph.users.getById('user@tenant.onmicrosoft.com').contacts(); const contacts2 = await graph.me.contacts(); Get Contact by Id \u00b6 Gets a specific contact by ID for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const contact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID)(); const contact2 = await graph.me.contacts.getById(contactID)(); Add a new Contact \u00b6 Adds a new contact for the user. import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); Update a Contact \u00b6 Updates a specific contact by ID for teh designated user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const updContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).update({birthday: \"1986-05-30\" }); const updContact2 = await graph.me.contacts.getById(contactID).update({birthday: \"1986-05-30\" }); Delete a Contact \u00b6 Delete a contact from the list of contacts for a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const delContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).delete(); const delContact2 = await graph.me.contacts.getById(contactID).delete(); Get all of the Contact Folders \u00b6 Get all the folders for the designated user's contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders(); const contactFolders2 = await graph.me.contactFolders(); Get Contact Folder by Id \u00b6 Get a contact folder by ID for the specified user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID)(); const contactFolder2 = await graph.me.contactFolders.getById(folderID)(); Add a new Contact Folder \u00b6 Add a new folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const parentFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAAAAAEOAAA=\"; const addedContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.add(\"New Folder\", parentFolderID); const addedContactFolder2 = await graph.me.contactFolders.add(\"New Folder\", parentFolderID); Update a Contact Folder \u00b6 Update an existing folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const updContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).update({displayName: \"Updated Folder\" }); const updContactFolder2 = await graph.me.contactFolders.getById(folderID).update({displayName: \"Updated Folder\" }); Delete a Contact Folder \u00b6 Delete a folder from the users contacts list. Deleting a folder deletes the contacts in that folder. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const delContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).delete(); const delContactFolder2 = await graph.me.contactFolders.getById(folderID).delete(); Get all of the Contacts from the Contact Folder \u00b6 Get all the contacts in a folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactsInContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).contacts(); const contactsInContactFolder2 = await graph.me.contactFolders.getById(folderID).contacts(); Get Child Folders of the Contact Folder \u00b6 Get child folders from contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const childFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders(); const childFolders2 = await graph.me.contactFolders.getById(folderID).childFolders(); Add a new Child Folder \u00b6 Add a new child folder to a contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const addedChildFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID); const addedChildFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID); Get Child Folder by Id \u00b6 Get child folder by ID from user contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const childFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID)(); const childFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID)(); Add Contact in Child Folder of Contact Folder \u00b6 Add a new contact to a child folder import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"./@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']);","title":"contacts"},{"location":"graph/contacts/#pnpgraphcontacts","text":"The ability to manage contacts and folders in Outlook is a capability introduced in version 1.2.2 of @pnp/graph. Through the methods described you can add and edit both contacts and folders in a users Outlook. More information can be found in the official Graph documentation: Contact Resource Type","title":"@pnp/graph/contacts"},{"location":"graph/contacts/#icontact-icontacts-icontactfolder-icontactfolders","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/contacts\"; Preset: All import { graph } from \"@pnp/graph/presets/all\";","title":"IContact, IContacts, IContactFolder, IContactFolders"},{"location":"graph/contacts/#set-up-notes","text":"To make user calls you can use getById where the id is the users email address. Contact ID, Folder ID, and Parent Folder ID use the following format \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"","title":"Set up notes"},{"location":"graph/contacts/#get-all-of-the-contacts","text":"Gets a list of all the contacts for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contacts = await graph.users.getById('user@tenant.onmicrosoft.com').contacts(); const contacts2 = await graph.me.contacts();","title":"Get all of the Contacts"},{"location":"graph/contacts/#get-contact-by-id","text":"Gets a specific contact by ID for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const contact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID)(); const contact2 = await graph.me.contacts.getById(contactID)();","title":"Get Contact by Id"},{"location":"graph/contacts/#add-a-new-contact","text":"Adds a new contact for the user. import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']);","title":"Add a new Contact"},{"location":"graph/contacts/#update-a-contact","text":"Updates a specific contact by ID for teh designated user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const updContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).update({birthday: \"1986-05-30\" }); const updContact2 = await graph.me.contacts.getById(contactID).update({birthday: \"1986-05-30\" });","title":"Update a Contact"},{"location":"graph/contacts/#delete-a-contact","text":"Delete a contact from the list of contacts for a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const delContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).delete(); const delContact2 = await graph.me.contacts.getById(contactID).delete();","title":"Delete a Contact"},{"location":"graph/contacts/#get-all-of-the-contact-folders","text":"Get all the folders for the designated user's contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders(); const contactFolders2 = await graph.me.contactFolders();","title":"Get all of the Contact Folders"},{"location":"graph/contacts/#get-contact-folder-by-id","text":"Get a contact folder by ID for the specified user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID)(); const contactFolder2 = await graph.me.contactFolders.getById(folderID)();","title":"Get Contact Folder by Id"},{"location":"graph/contacts/#add-a-new-contact-folder","text":"Add a new folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const parentFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAAAAAEOAAA=\"; const addedContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.add(\"New Folder\", parentFolderID); const addedContactFolder2 = await graph.me.contactFolders.add(\"New Folder\", parentFolderID);","title":"Add a new Contact Folder"},{"location":"graph/contacts/#update-a-contact-folder","text":"Update an existing folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const updContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).update({displayName: \"Updated Folder\" }); const updContactFolder2 = await graph.me.contactFolders.getById(folderID).update({displayName: \"Updated Folder\" });","title":"Update a Contact Folder"},{"location":"graph/contacts/#delete-a-contact-folder","text":"Delete a folder from the users contacts list. Deleting a folder deletes the contacts in that folder. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const delContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).delete(); const delContactFolder2 = await graph.me.contactFolders.getById(folderID).delete();","title":"Delete a Contact Folder"},{"location":"graph/contacts/#get-all-of-the-contacts-from-the-contact-folder","text":"Get all the contacts in a folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactsInContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).contacts(); const contactsInContactFolder2 = await graph.me.contactFolders.getById(folderID).contacts();","title":"Get all of the Contacts from the Contact Folder"},{"location":"graph/contacts/#get-child-folders-of-the-contact-folder","text":"Get child folders from contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const childFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders(); const childFolders2 = await graph.me.contactFolders.getById(folderID).childFolders();","title":"Get Child Folders of the Contact Folder"},{"location":"graph/contacts/#add-a-new-child-folder","text":"Add a new child folder to a contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const addedChildFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID); const addedChildFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID);","title":"Add a new Child Folder"},{"location":"graph/contacts/#get-child-folder-by-id","text":"Get child folder by ID from user contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const childFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID)(); const childFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID)();","title":"Get Child Folder by Id"},{"location":"graph/contacts/#add-contact-in-child-folder-of-contact-folder","text":"Add a new contact to a child folder import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"./@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']);","title":"Add Contact in Child Folder of Contact Folder"},{"location":"graph/directoryobjects/","text":"@pnp/graph/directoryObjects \u00b6 Represents an Azure Active Directory object. The directoryObject type is the base type for many other directory entity types. More information can be found in the official Graph documentation: DirectoryObject Resource Type IDirectoryObject, IDirectoryObjects \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; Preset: All import { graph } from \"@pnp/sp/presets/all\"; The groups and directory roles for the user \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" const memberOf = await graph.users.getById('user@tenant.onmicrosoft.com').memberOf(); const memberOf2 = await graph.me.memberOf(); Return all the groups the user, group or directoryObject is a member of. Add true parameter to return only security enabled groups \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/groups\" const memberGroups = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberGroups(); const memberGroups2 = await graph.me.getMemberGroups(); // Returns only security enabled groups const memberGroups3 = await graph.me.getMemberGroups(true); const memberGroups4 = await graph.groups.getById('user@tenant.onmicrosoft.com').getMemberGroups(); Returns all the groups, administrative units and directory roles that a user, group, or directory object is a member of. Add true parameter to return only security enabled groups \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const memberObjects = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberObjects(); const memberObjects2 = await graph.me.getMemberObjects(); // Returns only security enabled groups const memberObjects3 = await graph.me.getMemberObjects(true); const memberObjects4 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').getMemberObjects(); Check for membership in a specified list of groups \u00b6 And returns from that list those groups of which the specified user, group, or directory object is a member import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const checkedMembers = await graph.users.getById('user@tenant.onmicrosoft.com').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers2 = await graph.me.checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers3 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); Get directoryObject by Id \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const dirObject = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26'); Delete directoryObject \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const deleted = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').delete()","title":"directory objects"},{"location":"graph/directoryobjects/#pnpgraphdirectoryobjects","text":"Represents an Azure Active Directory object. The directoryObject type is the base type for many other directory entity types. More information can be found in the official Graph documentation: DirectoryObject Resource Type","title":"@pnp/graph/directoryObjects"},{"location":"graph/directoryobjects/#idirectoryobject-idirectoryobjects","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; Preset: All import { graph } from \"@pnp/sp/presets/all\";","title":"IDirectoryObject, IDirectoryObjects"},{"location":"graph/directoryobjects/#the-groups-and-directory-roles-for-the-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" const memberOf = await graph.users.getById('user@tenant.onmicrosoft.com').memberOf(); const memberOf2 = await graph.me.memberOf();","title":"The groups and directory roles for the user"},{"location":"graph/directoryobjects/#return-all-the-groups-the-user-group-or-directoryobject-is-a-member-of-add-true-parameter-to-return-only-security-enabled-groups","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/groups\" const memberGroups = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberGroups(); const memberGroups2 = await graph.me.getMemberGroups(); // Returns only security enabled groups const memberGroups3 = await graph.me.getMemberGroups(true); const memberGroups4 = await graph.groups.getById('user@tenant.onmicrosoft.com').getMemberGroups();","title":"Return all the groups the user, group or directoryObject is a member of. Add true parameter to return only security enabled groups"},{"location":"graph/directoryobjects/#returns-all-the-groups-administrative-units-and-directory-roles-that-a-user-group-or-directory-object-is-a-member-of-add-true-parameter-to-return-only-security-enabled-groups","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const memberObjects = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberObjects(); const memberObjects2 = await graph.me.getMemberObjects(); // Returns only security enabled groups const memberObjects3 = await graph.me.getMemberObjects(true); const memberObjects4 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').getMemberObjects();","title":"Returns all the groups, administrative units and directory roles that a user, group, or directory object is a member of. Add true parameter to return only security enabled groups"},{"location":"graph/directoryobjects/#check-for-membership-in-a-specified-list-of-groups","text":"And returns from that list those groups of which the specified user, group, or directory object is a member import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const checkedMembers = await graph.users.getById('user@tenant.onmicrosoft.com').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers2 = await graph.me.checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers3 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]);","title":"Check for membership in a specified list of groups"},{"location":"graph/directoryobjects/#get-directoryobject-by-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const dirObject = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26');","title":"Get directoryObject by Id"},{"location":"graph/directoryobjects/#delete-directoryobject","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const deleted = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').delete()","title":"Delete directoryObject"},{"location":"graph/groups/","text":"@pnp/graph/groups \u00b6 Groups are collections of users and other principals who share access to resources in Microsoft services or in your app. All group-related operations in Microsoft Graph require administrator consent. Note: Groups can only be created through work or school accounts. Personal Microsoft accounts don't support groups. You can learn more about Microsoft Graph Groups by reading the Official Microsoft Graph Documentation . IGroup, IGroups \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups} from \"@pnp/graph/groups\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; Preset: All import { graph, Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups } from \"@pnp/graph/presets/all\"; Add a Group \u00b6 Add a new group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import { GroupType } from '@pnp/graph/groups'; const groupAddResult = await graph.groups.add(\"GroupName\", \"Mail_NickName\", GroupType.Office365); const group = await groupAddResult.group(); Delete a Group \u00b6 Deletes an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").delete(); Update Group Properties \u00b6 Updates an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").update({ displayName: newName, propertyName: updatedValue}); Add favorite \u00b6 Add the group to the list of the current user's favorite groups. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").addFavorite(); Remove favorite \u00b6 Remove the group from the list of the current user's favorite groups. Supported for Office 365 Groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").removeFavorite(); Reset Unseen Count \u00b6 Reset the unseenCount of all the posts that the current user has not seen since their last visit. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").resetUnseenCount(); Subscribe By Mail \u00b6 Calling this method will enable the current user to receive email notifications for this group, about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").subscribeByMail(); Unsubscribe By Mail \u00b6 Calling this method will prevent the current user from receiving email notifications for this group about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").unsubscribeByMail(); Get Calendar View \u00b6 Get the occurrences, exceptions, and single instances of events in a calendar view defined by a time range, from the default calendar of a group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; const startDate = new Date(\"2020-04-01\"); const endDate = new Date(\"2020-03-01\"); const events = graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").getCalendarView(startDate, endDate); Group Photo Operations \u00b6 See Photos Get the Team Site for a Group \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/sites/group\"; const teamSite = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").sites.root(); const url = teamSite.webUrl","title":"groups"},{"location":"graph/groups/#pnpgraphgroups","text":"Groups are collections of users and other principals who share access to resources in Microsoft services or in your app. All group-related operations in Microsoft Graph require administrator consent. Note: Groups can only be created through work or school accounts. Personal Microsoft accounts don't support groups. You can learn more about Microsoft Graph Groups by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/groups"},{"location":"graph/groups/#igroup-igroups","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups} from \"@pnp/graph/groups\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; Preset: All import { graph, Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups } from \"@pnp/graph/presets/all\";","title":"IGroup, IGroups"},{"location":"graph/groups/#add-a-group","text":"Add a new group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import { GroupType } from '@pnp/graph/groups'; const groupAddResult = await graph.groups.add(\"GroupName\", \"Mail_NickName\", GroupType.Office365); const group = await groupAddResult.group();","title":"Add a Group"},{"location":"graph/groups/#delete-a-group","text":"Deletes an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").delete();","title":"Delete a Group"},{"location":"graph/groups/#update-group-properties","text":"Updates an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").update({ displayName: newName, propertyName: updatedValue});","title":"Update Group Properties"},{"location":"graph/groups/#add-favorite","text":"Add the group to the list of the current user's favorite groups. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").addFavorite();","title":"Add favorite"},{"location":"graph/groups/#remove-favorite","text":"Remove the group from the list of the current user's favorite groups. Supported for Office 365 Groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").removeFavorite();","title":"Remove favorite"},{"location":"graph/groups/#reset-unseen-count","text":"Reset the unseenCount of all the posts that the current user has not seen since their last visit. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").resetUnseenCount();","title":"Reset Unseen Count"},{"location":"graph/groups/#subscribe-by-mail","text":"Calling this method will enable the current user to receive email notifications for this group, about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").subscribeByMail();","title":"Subscribe By Mail"},{"location":"graph/groups/#unsubscribe-by-mail","text":"Calling this method will prevent the current user from receiving email notifications for this group about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").unsubscribeByMail();","title":"Unsubscribe By Mail"},{"location":"graph/groups/#get-calendar-view","text":"Get the occurrences, exceptions, and single instances of events in a calendar view defined by a time range, from the default calendar of a group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; const startDate = new Date(\"2020-04-01\"); const endDate = new Date(\"2020-03-01\"); const events = graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").getCalendarView(startDate, endDate);","title":"Get Calendar View"},{"location":"graph/groups/#group-photo-operations","text":"See Photos","title":"Group Photo Operations"},{"location":"graph/groups/#get-the-team-site-for-a-group","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/sites/group\"; const teamSite = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").sites.root(); const url = teamSite.webUrl","title":"Get the Team Site for a Group"},{"location":"graph/insights/","text":"@pnp/graph/insights \u00b6 This module helps you get Insights in form of Trending , Used and Shared . The results are based on relationships calculated using advanced analytics and machine learning techniques. IInsights \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; Preset: All import \"@pnp/graph/presets/all\"; Get all Trending documents \u00b6 Returns documents from OneDrive and SharePoint sites trending around a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trending = await graph.me.insights.trending() const trending = await graph.users.getById(\"userId\").insights.trending() Get a Trending document by Id \u00b6 Using the getById method to get a trending document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trendingDoc = await graph.me.insights.trending.getById('Id')() const trendingDoc = await graph.users.getById(\"userId\").insights.trending.getById('Id')() Get the resource from Trending document \u00b6 Using the resources method to get the resource from a trending document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.trending.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.trending.getById('Id').resource() Get all Used documents \u00b6 Returns documents viewed and modified by a user. Includes documents the user used in OneDrive for Business, SharePoint, opened as email attachments, and as link attachments from sources like Box, DropBox and Google Drive. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const used = await graph.me.insights.used() const used = await graph.users.getById(\"userId\").insights.used() Get a Used document by Id \u00b6 Using the getById method to get a used document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const usedDoc = await graph.me.insights.used.getById('Id')() const usedDoc = await graph.users.getById(\"userId\").insights.used.getById('Id')() Get the resource from Used document \u00b6 Using the resources method to get the resource from a used document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.used.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.used.getById('Id').resource() Get all Shared documents \u00b6 Returns documents shared with a user. Documents can be shared as email attachments or as OneDrive for Business links sent in emails. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const shared = await graph.me.insights.shared() const shared = await graph.users.getById(\"userId\").insights.shared() Get a Shared document by Id \u00b6 Using the getById method to get a shared document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const sharedDoc = await graph.me.insights.shared.getById('Id')() const sharedDoc = await graph.users.getById(\"userId\").insights.shared.getById('Id')() Get the resource from a Shared document \u00b6 Using the resources method to get the resource from a shared document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.shared.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.shared.getById('Id').resource()","title":"insights"},{"location":"graph/insights/#pnpgraphinsights","text":"This module helps you get Insights in form of Trending , Used and Shared . The results are based on relationships calculated using advanced analytics and machine learning techniques.","title":"@pnp/graph/insights"},{"location":"graph/insights/#iinsights","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInsights"},{"location":"graph/insights/#get-all-trending-documents","text":"Returns documents from OneDrive and SharePoint sites trending around a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trending = await graph.me.insights.trending() const trending = await graph.users.getById(\"userId\").insights.trending()","title":"Get all Trending documents"},{"location":"graph/insights/#get-a-trending-document-by-id","text":"Using the getById method to get a trending document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trendingDoc = await graph.me.insights.trending.getById('Id')() const trendingDoc = await graph.users.getById(\"userId\").insights.trending.getById('Id')()","title":"Get a Trending document by Id"},{"location":"graph/insights/#get-the-resource-from-trending-document","text":"Using the resources method to get the resource from a trending document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.trending.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.trending.getById('Id').resource()","title":"Get the resource from Trending document"},{"location":"graph/insights/#get-all-used-documents","text":"Returns documents viewed and modified by a user. Includes documents the user used in OneDrive for Business, SharePoint, opened as email attachments, and as link attachments from sources like Box, DropBox and Google Drive. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const used = await graph.me.insights.used() const used = await graph.users.getById(\"userId\").insights.used()","title":"Get all Used documents"},{"location":"graph/insights/#get-a-used-document-by-id","text":"Using the getById method to get a used document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const usedDoc = await graph.me.insights.used.getById('Id')() const usedDoc = await graph.users.getById(\"userId\").insights.used.getById('Id')()","title":"Get a Used document by Id"},{"location":"graph/insights/#get-the-resource-from-used-document","text":"Using the resources method to get the resource from a used document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.used.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.used.getById('Id').resource()","title":"Get the resource from Used document"},{"location":"graph/insights/#get-all-shared-documents","text":"Returns documents shared with a user. Documents can be shared as email attachments or as OneDrive for Business links sent in emails. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const shared = await graph.me.insights.shared() const shared = await graph.users.getById(\"userId\").insights.shared()","title":"Get all Shared documents"},{"location":"graph/insights/#get-a-shared-document-by-id","text":"Using the getById method to get a shared document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const sharedDoc = await graph.me.insights.shared.getById('Id')() const sharedDoc = await graph.users.getById(\"userId\").insights.shared.getById('Id')()","title":"Get a Shared document by Id"},{"location":"graph/insights/#get-the-resource-from-a-shared-document","text":"Using the resources method to get the resource from a shared document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.shared.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.shared.getById('Id').resource()","title":"Get the resource from a Shared document"},{"location":"graph/invitations/","text":"@pnp/graph/invitations \u00b6 The ability invite an external user via the invitation manager IInvitations \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\"; Preset: All import \"@pnp/graph/presets/all\"; Create Invitation \u00b6 Using the invitations.create() you can create an Invitation. We need the email address of the user being invited and the URL user should be redirected to once the invitation is redeemed (redirect URL). import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\" const invitationResult = await graph.invitations.create('external.user@email-address.com', 'https://tenant.sharepoint.com/sites/redirecturi');","title":"invitations"},{"location":"graph/invitations/#pnpgraphinvitations","text":"The ability invite an external user via the invitation manager","title":"@pnp/graph/invitations"},{"location":"graph/invitations/#iinvitations","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInvitations"},{"location":"graph/invitations/#create-invitation","text":"Using the invitations.create() you can create an Invitation. We need the email address of the user being invited and the URL user should be redirected to once the invitation is redeemed (redirect URL). import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\" const invitationResult = await graph.invitations.create('external.user@email-address.com', 'https://tenant.sharepoint.com/sites/redirecturi');","title":"Create Invitation"},{"location":"graph/onedrive/","text":"@pnp/graph/onedrive \u00b6 The ability to manage drives and drive items in Onedrive is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can manage drives and drive items in Onedrive. IInvitations \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; Preset: All import \"@pnp/graph/presets/all\"; Get the default drive \u00b6 Using the drive() you can get the default drive from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives(); Get all of the drives \u00b6 Using the drives() you can get the users available drives from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives(); Get drive by Id \u00b6 Using the drives.getById() you can get one of the available drives in Outlook import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drive = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId'); const drive = await graph.me.drives.getById('driveId'); Get the associated list of a drive \u00b6 Using the list() you get the associated list import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const list = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').list(); const list = await graph.me.drives.getById('driveId').list(); Get the recent files \u00b6 Using the recent() you get the recent files import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const files = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').recent(); const files = await graph.me.drives.getById('driveId').recent(); Get the files shared with me \u00b6 Using the sharedWithMe() you get the files shared with the user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const shared = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').sharedWithMe(); const shared = await graph.me.drives.getById('driveId').sharedWithMe(); Get the Root folder \u00b6 Using the root() you get the root folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const root = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root(); const root = await graph.me.drives.getById('driveId').root(); Get the Children \u00b6 Using the children() you get the children import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const rootChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children(); const rootChildren = await graph.me.drives.getById('driveId').root.children(); const itemChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').children(); const itemChildren = await graph.me.drives.getById('driveId').root.items.getById('itemId').children(); Add folder or item \u00b6 Using the add you can add a folder or an item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; import { DriveItem as IDriveItem } from \"@microsoft/microsoft-graph-types\"; const addFolder = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}}); const addFolder = await graph.me.drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}}); Search items \u00b6 Using the search() you can search for items, and optionally select properties import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const search = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId')root.search('queryText')(); const search = await graph.me.drives.getById('driveId')root.search('queryText')(); Get specific item in drive \u00b6 Using the items.getById() you can get a specific item from the current drive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const item = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId'); const item = await graph.me.drives.getById('driveId').items.getById('itemId'); Get thumbnails \u00b6 Using the thumbnails() you get the thumbnails import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').thumbnails(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').thumbnails(); Delete drive item \u00b6 Using the delete() you delete the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').delete(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').delete(); Update drive item \u00b6 Using the update() you update the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const update = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"}); const update = await graph.me.drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"}); Move drive item \u00b6 Using the move() you move the current item, and optionally update it import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; // Requires a parentReference to the new folder location const move = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"}); const move = await graph.me.drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"});","title":"onedrive"},{"location":"graph/onedrive/#pnpgraphonedrive","text":"The ability to manage drives and drive items in Onedrive is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can manage drives and drive items in Onedrive.","title":"@pnp/graph/onedrive"},{"location":"graph/onedrive/#iinvitations","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInvitations"},{"location":"graph/onedrive/#get-the-default-drive","text":"Using the drive() you can get the default drive from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives();","title":"Get the default drive"},{"location":"graph/onedrive/#get-all-of-the-drives","text":"Using the drives() you can get the users available drives from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives();","title":"Get all of the drives"},{"location":"graph/onedrive/#get-drive-by-id","text":"Using the drives.getById() you can get one of the available drives in Outlook import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drive = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId'); const drive = await graph.me.drives.getById('driveId');","title":"Get drive by Id"},{"location":"graph/onedrive/#get-the-associated-list-of-a-drive","text":"Using the list() you get the associated list import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const list = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').list(); const list = await graph.me.drives.getById('driveId').list();","title":"Get the associated list of a drive"},{"location":"graph/onedrive/#get-the-recent-files","text":"Using the recent() you get the recent files import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const files = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').recent(); const files = await graph.me.drives.getById('driveId').recent();","title":"Get the recent files"},{"location":"graph/onedrive/#get-the-files-shared-with-me","text":"Using the sharedWithMe() you get the files shared with the user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const shared = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').sharedWithMe(); const shared = await graph.me.drives.getById('driveId').sharedWithMe();","title":"Get the files shared with me"},{"location":"graph/onedrive/#get-the-root-folder","text":"Using the root() you get the root folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const root = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root(); const root = await graph.me.drives.getById('driveId').root();","title":"Get the Root folder"},{"location":"graph/onedrive/#get-the-children","text":"Using the children() you get the children import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const rootChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children(); const rootChildren = await graph.me.drives.getById('driveId').root.children(); const itemChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').children(); const itemChildren = await graph.me.drives.getById('driveId').root.items.getById('itemId').children();","title":"Get the Children"},{"location":"graph/onedrive/#add-folder-or-item","text":"Using the add you can add a folder or an item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; import { DriveItem as IDriveItem } from \"@microsoft/microsoft-graph-types\"; const addFolder = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}}); const addFolder = await graph.me.drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}});","title":"Add folder or item"},{"location":"graph/onedrive/#search-items","text":"Using the search() you can search for items, and optionally select properties import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const search = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId')root.search('queryText')(); const search = await graph.me.drives.getById('driveId')root.search('queryText')();","title":"Search items"},{"location":"graph/onedrive/#get-specific-item-in-drive","text":"Using the items.getById() you can get a specific item from the current drive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const item = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId'); const item = await graph.me.drives.getById('driveId').items.getById('itemId');","title":"Get specific item in drive"},{"location":"graph/onedrive/#get-thumbnails","text":"Using the thumbnails() you get the thumbnails import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').thumbnails(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').thumbnails();","title":"Get thumbnails"},{"location":"graph/onedrive/#delete-drive-item","text":"Using the delete() you delete the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').delete(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').delete();","title":"Delete drive item"},{"location":"graph/onedrive/#update-drive-item","text":"Using the update() you update the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const update = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"}); const update = await graph.me.drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"});","title":"Update drive item"},{"location":"graph/onedrive/#move-drive-item","text":"Using the move() you move the current item, and optionally update it import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; // Requires a parentReference to the new folder location const move = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"}); const move = await graph.me.drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"});","title":"Move drive item"},{"location":"graph/outlook/","text":"@pnp/graph/outlook \u00b6 Represents the Outlook services available to a user. Currently, only interacting with categories is supported. You can learn more by reading the Official Microsoft Graph Documentation . IUsers, IUser, IPeople \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Outlook, IOutlook, MasterCategories, IMasterCategories, OutlookCategory, IOutlookCategory} from \"@pnp/graph/outlook\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/outlook\"; Preset: All import { graph, Outlook, IOutlook, MasterCategories, IMasterCategories } from \"@pnp/graph/presets/all\"; Get All Categories User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories(); Add Category User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions await graph.me.outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' }); // Application permissions await graph.users.getById('{user id}').outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' }); Update Category \u00b6 Testing has shown that displayName cannot be updated. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; import { OutlookCategory } from \"@microsoft/microsoft-graph-types\"; const categoryUpdate: OutlookCategory = { color: \"preset5\" } // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').update(categoryUpdate); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').update(categoryUpdate); Delete Category \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').delete(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').delete();","title":"outlook"},{"location":"graph/outlook/#pnpgraphoutlook","text":"Represents the Outlook services available to a user. Currently, only interacting with categories is supported. You can learn more by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/outlook"},{"location":"graph/outlook/#iusers-iuser-ipeople","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Outlook, IOutlook, MasterCategories, IMasterCategories, OutlookCategory, IOutlookCategory} from \"@pnp/graph/outlook\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/outlook\"; Preset: All import { graph, Outlook, IOutlook, MasterCategories, IMasterCategories } from \"@pnp/graph/presets/all\";","title":"IUsers, IUser, IPeople"},{"location":"graph/outlook/#get-all-categories-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories();","title":"Get All Categories User"},{"location":"graph/outlook/#add-category-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions await graph.me.outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' }); // Application permissions await graph.users.getById('{user id}').outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' });","title":"Add Category User"},{"location":"graph/outlook/#update-category","text":"Testing has shown that displayName cannot be updated. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; import { OutlookCategory } from \"@microsoft/microsoft-graph-types\"; const categoryUpdate: OutlookCategory = { color: \"preset5\" } // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').update(categoryUpdate); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').update(categoryUpdate);","title":"Update Category"},{"location":"graph/outlook/#delete-category","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').delete(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').delete();","title":"Delete Category"},{"location":"graph/photos/","text":"@pnp/graph/photos \u00b6 A profile photo of a user, group or an Outlook contact accessed from Exchange Online or Azure Active Directory (AAD). It's binary data not encoded in base-64. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation . IPhoto \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IPhoto, Photo} from \"@pnp/graph/photos\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/photos\"; Preset: All import { graph, IPhoto, Photo } from \"@pnp/sp/presets/all\"; Current User Photo \u00b6 This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const photoValue = await graph.me.photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl); Current Group Photo \u00b6 This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/photos\"; const photoValue = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl); Set User Photo \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file); Set Group Photo \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file);","title":"photos"},{"location":"graph/photos/#pnpgraphphotos","text":"A profile photo of a user, group or an Outlook contact accessed from Exchange Online or Azure Active Directory (AAD). It's binary data not encoded in base-64. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/photos"},{"location":"graph/photos/#iphoto","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IPhoto, Photo} from \"@pnp/graph/photos\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/photos\"; Preset: All import { graph, IPhoto, Photo } from \"@pnp/sp/presets/all\";","title":"IPhoto"},{"location":"graph/photos/#current-user-photo","text":"This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const photoValue = await graph.me.photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl);","title":"Current User Photo"},{"location":"graph/photos/#current-group-photo","text":"This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/photos\"; const photoValue = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl);","title":"Current Group Photo"},{"location":"graph/photos/#set-user-photo","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file);","title":"Set User Photo"},{"location":"graph/photos/#set-group-photo","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file);","title":"Set Group Photo"},{"location":"graph/planner/","text":"@pnp/graph/planner \u00b6 The ability to manage plans and tasks in Planner is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can add, update and delete items in Planner. IInvitations \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\"; Preset: All import \"@pnp/graph/presets/all\"; Get Plans by Id \u00b6 Using the planner.plans.getById() you can get a specific Plan. Planner.plans is not an available endpoint, you need to get a specific Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const plan = await graph.planner.plans.getById('planId')(); Add new Plan \u00b6 Using the planner.plans.add() you can create a new Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newPlan = await graph.planner.plans.add('groupObjectId', 'title'); Get Tasks in Plan \u00b6 Using the tasks() you can get the Tasks in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planTasks = await graph.planner.plans.getById('planId').tasks(); Get Buckets in Plan \u00b6 Using the buckets() you can get the Buckets in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planBuckets = await graph.planner.plans.getById('planId').buckets(); Get Details in Plan \u00b6 Using the details() you can get the details in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planDetails = await graph.planner.plans.getById('planId').details(); Delete Plan \u00b6 Using the delete() you can get delete a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delPlan = await graph.planner.plans.getById('planId').delete('planEtag'); Update Plan \u00b6 Using the update() you can get update a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updPlan = await graph.planner.plans.getById('planId').update({title: 'New Title', eTag: 'planEtag'}); Get Task by Id \u00b6 Using the planner.tasks.getById() you can get a specific Task. Planner.tasks is not an available endpoint, you need to get a specific Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const task = await graph.planner.tasks.getById('taskId')(); Add new Task \u00b6 Using the planner.tasks.add() you can create a new Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newTask = await graph.planner.tasks.add('planId', 'title'); Get Details in Task \u00b6 Using the details() you can get the details in a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const taskDetails = await graph.planner.tasks.getById('taskId').details(); Delete Task \u00b6 Using the delete() you can get delete a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delTask = await graph.planner.tasks.getById('taskId').delete('taskEtag'); Update Task \u00b6 Using the update() you can get update a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updTask = await graph.planner.tasks.getById('taskId').update({properties, eTag:'taskEtag'}); Get Buckets by Id \u00b6 Using the planner.buckets.getById() you can get a specific Bucket. planner.buckets is not an available endpoint, you need to get a specific Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucket = await graph.planner.buckets.getById('bucketId')(); Add new Bucket \u00b6 Using the planner.buckets.add() you can create a new Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newBucket = await graph.planner.buckets.add('name', 'planId'); Update Bucket \u00b6 Using the update() you can get update a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updBucket = await graph.planner.buckets.getById('bucketId').update({name: \"Name\", eTag:'bucketEtag'}); Delete Bucket \u00b6 Using the delete() you can get delete a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delBucket = await graph.planner.buckets.getById('bucketId').delete(eTag:'bucketEtag'); Get Bucket Tasks \u00b6 Using the tasks() you can get Tasks in a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucketTasks = await graph.planner.buckets.getById('bucketId').tasks();","title":"planner"},{"location":"graph/planner/#pnpgraphplanner","text":"The ability to manage plans and tasks in Planner is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can add, update and delete items in Planner.","title":"@pnp/graph/planner"},{"location":"graph/planner/#iinvitations","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInvitations"},{"location":"graph/planner/#get-plans-by-id","text":"Using the planner.plans.getById() you can get a specific Plan. Planner.plans is not an available endpoint, you need to get a specific Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const plan = await graph.planner.plans.getById('planId')();","title":"Get Plans by Id"},{"location":"graph/planner/#add-new-plan","text":"Using the planner.plans.add() you can create a new Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newPlan = await graph.planner.plans.add('groupObjectId', 'title');","title":"Add new Plan"},{"location":"graph/planner/#get-tasks-in-plan","text":"Using the tasks() you can get the Tasks in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planTasks = await graph.planner.plans.getById('planId').tasks();","title":"Get Tasks in Plan"},{"location":"graph/planner/#get-buckets-in-plan","text":"Using the buckets() you can get the Buckets in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planBuckets = await graph.planner.plans.getById('planId').buckets();","title":"Get Buckets in Plan"},{"location":"graph/planner/#get-details-in-plan","text":"Using the details() you can get the details in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planDetails = await graph.planner.plans.getById('planId').details();","title":"Get Details in Plan"},{"location":"graph/planner/#delete-plan","text":"Using the delete() you can get delete a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delPlan = await graph.planner.plans.getById('planId').delete('planEtag');","title":"Delete Plan"},{"location":"graph/planner/#update-plan","text":"Using the update() you can get update a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updPlan = await graph.planner.plans.getById('planId').update({title: 'New Title', eTag: 'planEtag'});","title":"Update Plan"},{"location":"graph/planner/#get-task-by-id","text":"Using the planner.tasks.getById() you can get a specific Task. Planner.tasks is not an available endpoint, you need to get a specific Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const task = await graph.planner.tasks.getById('taskId')();","title":"Get Task by Id"},{"location":"graph/planner/#add-new-task","text":"Using the planner.tasks.add() you can create a new Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newTask = await graph.planner.tasks.add('planId', 'title');","title":"Add new Task"},{"location":"graph/planner/#get-details-in-task","text":"Using the details() you can get the details in a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const taskDetails = await graph.planner.tasks.getById('taskId').details();","title":"Get Details in Task"},{"location":"graph/planner/#delete-task","text":"Using the delete() you can get delete a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delTask = await graph.planner.tasks.getById('taskId').delete('taskEtag');","title":"Delete Task"},{"location":"graph/planner/#update-task","text":"Using the update() you can get update a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updTask = await graph.planner.tasks.getById('taskId').update({properties, eTag:'taskEtag'});","title":"Update Task"},{"location":"graph/planner/#get-buckets-by-id","text":"Using the planner.buckets.getById() you can get a specific Bucket. planner.buckets is not an available endpoint, you need to get a specific Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucket = await graph.planner.buckets.getById('bucketId')();","title":"Get Buckets by Id"},{"location":"graph/planner/#add-new-bucket","text":"Using the planner.buckets.add() you can create a new Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newBucket = await graph.planner.buckets.add('name', 'planId');","title":"Add new Bucket"},{"location":"graph/planner/#update-bucket","text":"Using the update() you can get update a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updBucket = await graph.planner.buckets.getById('bucketId').update({name: \"Name\", eTag:'bucketEtag'});","title":"Update Bucket"},{"location":"graph/planner/#delete-bucket","text":"Using the delete() you can get delete a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delBucket = await graph.planner.buckets.getById('bucketId').delete(eTag:'bucketEtag');","title":"Delete Bucket"},{"location":"graph/planner/#get-bucket-tasks","text":"Using the tasks() you can get Tasks in a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucketTasks = await graph.planner.buckets.getById('bucketId').tasks();","title":"Get Bucket Tasks"},{"location":"graph/search/","text":"@pnp/graph/search \u00b6 The search module allows you to access the Microsoft Graph Search API. You can read full details of using the API, for library examples please see below. Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; Preset: All import \"@pnp/graph/presets/all\"; Call graph.query \u00b6 This example shows calling the search API via the query method of the root graph object. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; const results = await graph.query({ entityTypes: [\"site\"], query: { queryString: \"test\" }, }); Note: This library allows you to pass multiple search requests to the query method as the value consumed by the server is an array, but it only a single requests works at this time. Eventually this may change and no updates will be required.","title":"search"},{"location":"graph/search/#pnpgraphsearch","text":"The search module allows you to access the Microsoft Graph Search API. You can read full details of using the API, for library examples please see below. Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; Preset: All import \"@pnp/graph/presets/all\";","title":"@pnp/graph/search"},{"location":"graph/search/#call-graphquery","text":"This example shows calling the search API via the query method of the root graph object. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; const results = await graph.query({ entityTypes: [\"site\"], query: { queryString: \"test\" }, }); Note: This library allows you to pass multiple search requests to the query method as the value consumed by the server is an array, but it only a single requests works at this time. Eventually this may change and no updates will be required.","title":"Call graph.query"},{"location":"graph/subscriptions/","text":"@pnp/graph/subscriptions \u00b6 The ability to manage subscriptions is a capability introduced in version 1.2.9 of @pnp/graph. A subscription allows a client app to receive notifications about changes to data in Microsoft Graph. Currently, subscriptions are enabled for the following resources: Mail, events, and contacts from Outlook. Conversations from Office Groups. Drive root items from OneDrive. Users and Groups from Azure Active Directory. Alerts from the Microsoft Graph Security API. Get all of the Subscriptions \u00b6 Using the subscriptions(). If successful this method returns a 200 OK response code and a list of subscription objects in the response body. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscriptions = await graph.subscriptions(); Create a new Subscription \u00b6 Using the subscriptions.add(). Creating a subscription requires read scope to the resource. For example, to get notifications messages, your app needs the Mail.Read permission. To learn more about the scopes visit this url. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const addedSubscription = await graph.subscriptions.add(\"created,updated\", \"https://webhook.azurewebsites.net/api/send/myNotifyClient\", \"me/mailFolders('Inbox')/messages\", \"2019-11-20T18:23:45.9356913Z\"); Get Subscription by Id \u00b6 Using the subscriptions.getById() you can get one of the subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscription = await graph.subscriptions.getById('subscriptionId')(); Delete a Subscription \u00b6 Using the subscriptions.getById().delete() you can remove one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const delSubscription = await graph.subscriptions.getById('subscriptionId').delete(); Update a Subscription \u00b6 Using the subscriptions.getById().update() you can update one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const updSubscription = await graph.subscriptions.getById('subscriptionId').update({changeType: \"created,updated,deleted\" });","title":"subscriptions"},{"location":"graph/subscriptions/#pnpgraphsubscriptions","text":"The ability to manage subscriptions is a capability introduced in version 1.2.9 of @pnp/graph. A subscription allows a client app to receive notifications about changes to data in Microsoft Graph. Currently, subscriptions are enabled for the following resources: Mail, events, and contacts from Outlook. Conversations from Office Groups. Drive root items from OneDrive. Users and Groups from Azure Active Directory. Alerts from the Microsoft Graph Security API.","title":"@pnp/graph/subscriptions"},{"location":"graph/subscriptions/#get-all-of-the-subscriptions","text":"Using the subscriptions(). If successful this method returns a 200 OK response code and a list of subscription objects in the response body. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscriptions = await graph.subscriptions();","title":"Get all of the Subscriptions"},{"location":"graph/subscriptions/#create-a-new-subscription","text":"Using the subscriptions.add(). Creating a subscription requires read scope to the resource. For example, to get notifications messages, your app needs the Mail.Read permission. To learn more about the scopes visit this url. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const addedSubscription = await graph.subscriptions.add(\"created,updated\", \"https://webhook.azurewebsites.net/api/send/myNotifyClient\", \"me/mailFolders('Inbox')/messages\", \"2019-11-20T18:23:45.9356913Z\");","title":"Create a new Subscription"},{"location":"graph/subscriptions/#get-subscription-by-id","text":"Using the subscriptions.getById() you can get one of the subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscription = await graph.subscriptions.getById('subscriptionId')();","title":"Get Subscription by Id"},{"location":"graph/subscriptions/#delete-a-subscription","text":"Using the subscriptions.getById().delete() you can remove one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const delSubscription = await graph.subscriptions.getById('subscriptionId').delete();","title":"Delete a Subscription"},{"location":"graph/subscriptions/#update-a-subscription","text":"Using the subscriptions.getById().update() you can update one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const updSubscription = await graph.subscriptions.getById('subscriptionId').update({changeType: \"created,updated,deleted\" });","title":"Update a Subscription"},{"location":"graph/teams/","text":"@pnp/graph/teams \u00b6 The ability to manage Team is a capability introduced in the 1.2.7 of @pnp/graph. Through the methods described you can add, update and delete items in Teams. Teams the user is a member of \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/teams\" const joinedTeams = await graph.users.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').joinedTeams(); const myJoinedTeams = await graph.me.joinedTeams(); Get Teams by Id \u00b6 Using the teams.getById() you can get a specific Team. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528')(); Create new Team/Group - Method #1 \u00b6 The first way to create a new Team and corresponding Group is to first create the group and then create the team. Follow the example in Groups to create the group and get the GroupID. Then make a call to create the team from the group. Create a Team via a specific group \u00b6 Here we get the group via id and use createTeam import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" import \"@pnp/graph/groups\" const createdTeam = await graph.groups.getById('679c8ff4-f07d-40de-b02b-60ec332472dd').createTeam({ \"memberSettings\": { \"allowCreateUpdateChannels\": true }, \"messagingSettings\": { \"allowUserEditMessages\": true, \"allowUserDeleteMessages\": true }, \"funSettings\": { \"allowGiphy\": true, \"giphyContentRating\": \"strict\" }}); Create new Team/Group - Method #2 \u00b6 The second way to create a new Team and corresponding Group is to do so in one call. This can be done by using the createTeam method. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = { \"template@odata.bind\": \"https://graph.microsoft.com/v1.0/teamsTemplates('standard')\", \"displayName\": \"PnPJS Test Team\", \"description\": \"PnPJS Test Team\u2019s Description\", \"members\": [ { \"@odata.type\": \"#microsoft.graph.aadUserConversationMember\", \"roles\": [\"owner\"], \"user@odata.bind\": \"https://graph.microsoft.com/v1.0/users('{owners user id}')\", }, ], }; const createdTeam: ITeamCreateResultAsync = await graph.teams.create(team); //To check the status of the team creation, call getOperationById for the newly created team. const createdTeamStatus = await graph.teams.getById(createdTeam.teamId).getOperationById(createdTeam.operationId); Clone a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public'); Get Teams Async Operation \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public'); const clonedTeamStatus = await graph.teams.getById(clonedTeam.teamId).getOperationById(clonedTeam.operationId); Archive a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').archive(); Unarchive a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').unarchive(); Get all channels of a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channels = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels(); Get channel by Id \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype')(); Create a new Channel \u00b6 import { graph } from \"@pnp/graph\"; const newChannel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.create('New Channel', 'Description'); Get installed Apps \u00b6 import { graph } from \"@pnp/graph\"; const installedApps = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps(); Add an App \u00b6 import { graph } from \"@pnp/graph\"; const addedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.add('https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a'); Remove an App \u00b6 import { graph } from \"@pnp/graph\"; const removedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.remove(); Get Tabs from a Channel \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tabs = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs(); Get Tab by Id \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.getById('Id')(); Add a new Tab \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const newTab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.add('Tab','https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a',<TabsConfiguration>{});","title":"teams"},{"location":"graph/teams/#pnpgraphteams","text":"The ability to manage Team is a capability introduced in the 1.2.7 of @pnp/graph. Through the methods described you can add, update and delete items in Teams.","title":"@pnp/graph/teams"},{"location":"graph/teams/#teams-the-user-is-a-member-of","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/teams\" const joinedTeams = await graph.users.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').joinedTeams(); const myJoinedTeams = await graph.me.joinedTeams();","title":"Teams the user is a member of"},{"location":"graph/teams/#get-teams-by-id","text":"Using the teams.getById() you can get a specific Team. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528')();","title":"Get Teams by Id"},{"location":"graph/teams/#create-new-teamgroup-method-1","text":"The first way to create a new Team and corresponding Group is to first create the group and then create the team. Follow the example in Groups to create the group and get the GroupID. Then make a call to create the team from the group.","title":"Create new Team/Group - Method #1"},{"location":"graph/teams/#create-a-team-via-a-specific-group","text":"Here we get the group via id and use createTeam import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" import \"@pnp/graph/groups\" const createdTeam = await graph.groups.getById('679c8ff4-f07d-40de-b02b-60ec332472dd').createTeam({ \"memberSettings\": { \"allowCreateUpdateChannels\": true }, \"messagingSettings\": { \"allowUserEditMessages\": true, \"allowUserDeleteMessages\": true }, \"funSettings\": { \"allowGiphy\": true, \"giphyContentRating\": \"strict\" }});","title":"Create a Team via a specific group"},{"location":"graph/teams/#create-new-teamgroup-method-2","text":"The second way to create a new Team and corresponding Group is to do so in one call. This can be done by using the createTeam method. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = { \"template@odata.bind\": \"https://graph.microsoft.com/v1.0/teamsTemplates('standard')\", \"displayName\": \"PnPJS Test Team\", \"description\": \"PnPJS Test Team\u2019s Description\", \"members\": [ { \"@odata.type\": \"#microsoft.graph.aadUserConversationMember\", \"roles\": [\"owner\"], \"user@odata.bind\": \"https://graph.microsoft.com/v1.0/users('{owners user id}')\", }, ], }; const createdTeam: ITeamCreateResultAsync = await graph.teams.create(team); //To check the status of the team creation, call getOperationById for the newly created team. const createdTeamStatus = await graph.teams.getById(createdTeam.teamId).getOperationById(createdTeam.operationId);","title":"Create new Team/Group - Method #2"},{"location":"graph/teams/#clone-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public');","title":"Clone a Team"},{"location":"graph/teams/#get-teams-async-operation","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public'); const clonedTeamStatus = await graph.teams.getById(clonedTeam.teamId).getOperationById(clonedTeam.operationId);","title":"Get Teams Async Operation"},{"location":"graph/teams/#archive-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').archive();","title":"Archive a Team"},{"location":"graph/teams/#unarchive-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').unarchive();","title":"Unarchive a Team"},{"location":"graph/teams/#get-all-channels-of-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channels = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels();","title":"Get all channels of a Team"},{"location":"graph/teams/#get-channel-by-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype')();","title":"Get channel by Id"},{"location":"graph/teams/#create-a-new-channel","text":"import { graph } from \"@pnp/graph\"; const newChannel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.create('New Channel', 'Description');","title":"Create a new Channel"},{"location":"graph/teams/#get-installed-apps","text":"import { graph } from \"@pnp/graph\"; const installedApps = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps();","title":"Get installed Apps"},{"location":"graph/teams/#add-an-app","text":"import { graph } from \"@pnp/graph\"; const addedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.add('https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a');","title":"Add an App"},{"location":"graph/teams/#remove-an-app","text":"import { graph } from \"@pnp/graph\"; const removedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.remove();","title":"Remove an App"},{"location":"graph/teams/#get-tabs-from-a-channel","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tabs = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs();","title":"Get Tabs from a Channel"},{"location":"graph/teams/#get-tab-by-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.getById('Id')();","title":"Get Tab by Id"},{"location":"graph/teams/#add-a-new-tab","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const newTab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.add('Tab','https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a',<TabsConfiguration>{});","title":"Add a new Tab"},{"location":"graph/users/","text":"@pnp/graph/users \u00b6 Users are Azure Active Directory objects representing users in the organizations. They represent the single identity for a person across Microsoft 365 services. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation . IUsers, IUser, IPeople \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IUser, IUsers, User, Users, IPeople, People} from \"@pnp/graph/users\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; Preset: All import { graph,IUser, IUsers, User, Users, IPeople, People } from \"@pnp/graph/presets/all\"; Current User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const currentUser = await graph.me(); Get All Users in the Organization \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const allUsers = await graph.users(); Get a User by email address (or user id) \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const matchingUser = await graph.users.getById('jane@contoso.com')(); Update Current User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; await graph.me.update({ displayName: 'John Doe' }); People \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)(); People \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)(); Manager \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const manager = await graph.me.manager(); Direct Reports \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const reports = await graph.me.directReports(); Photo \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const currentUser = await graph.me.photo(); const specificUser = await graph.users.getById('jane@contoso.com').photo(); User Photo Operations \u00b6 See Photos","title":"users"},{"location":"graph/users/#pnpgraphusers","text":"Users are Azure Active Directory objects representing users in the organizations. They represent the single identity for a person across Microsoft 365 services. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/users"},{"location":"graph/users/#iusers-iuser-ipeople","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IUser, IUsers, User, Users, IPeople, People} from \"@pnp/graph/users\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; Preset: All import { graph,IUser, IUsers, User, Users, IPeople, People } from \"@pnp/graph/presets/all\";","title":"IUsers, IUser, IPeople"},{"location":"graph/users/#current-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const currentUser = await graph.me();","title":"Current User"},{"location":"graph/users/#get-all-users-in-the-organization","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const allUsers = await graph.users();","title":"Get All Users in the Organization"},{"location":"graph/users/#get-a-user-by-email-address-or-user-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const matchingUser = await graph.users.getById('jane@contoso.com')();","title":"Get a User by email address (or user id)"},{"location":"graph/users/#update-current-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; await graph.me.update({ displayName: 'John Doe' });","title":"Update Current User"},{"location":"graph/users/#people","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)();","title":"People"},{"location":"graph/users/#people_1","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)();","title":"People"},{"location":"graph/users/#manager","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const manager = await graph.me.manager();","title":"Manager"},{"location":"graph/users/#direct-reports","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const reports = await graph.me.directReports();","title":"Direct Reports"},{"location":"graph/users/#photo","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const currentUser = await graph.me.photo(); const specificUser = await graph.users.getById('jane@contoso.com').photo();","title":"Photo"},{"location":"graph/users/#user-photo-operations","text":"See Photos","title":"User Photo Operations"},{"location":"logging/","text":"@pnp/logging \u00b6 The logging module provides light weight subscribable and extensible logging framework which is used internally and available for use in your projects. This article outlines how to setup logging and use the various loggers. Getting Started \u00b6 Install the logging module, it has no other dependencies npm install @pnp/logging --save Understanding the Logging Framework \u00b6 The logging framework is centered on the Logger class to which any number of listeners can be subscribed. Each of these listeners will receive each of the messages logged. Each listener must implement the ILogListener interface, shown below. There is only one method to implement and it takes an instance of the LogEntry interface as a parameter. /** * Interface that defines a log listener * */ export interface ILogListener { /** * Any associated data that a given logging listener may choose to log or ignore * * @param entry The information to be logged */ log(entry: ILogEntry): void; } /** * Interface that defines a log entry * */ export interface ILogEntry { /** * The main message to be logged */ message: string; /** * The level of information this message represents */ level: LogLevel; /** * Any associated data that a given logging listener may choose to log or ignore */ data?: any; } Log Levels \u00b6 export const enum LogLevel { Verbose = 0, Info = 1, Warning = 2, Error = 3, Off = 99, } Writing to the Logger \u00b6 To write information to a logger you can use either write, writeJSON, or log. import { Logger, LogLevel } from \"@pnp/logging\"; // write logs a simple string as the message value of the LogEntry Logger.write(\"This is logging a simple string\"); // optionally passing a level, default level is Verbose Logger.write(\"This is logging a simple string\", LogLevel.Error); // this will convert the object to a string using JSON.stringify and set the message with the result Logger.writeJSON({ name: \"value\", name2: \"value2\"}); // optionally passing a level, default level is Verbose Logger.writeJSON({ name: \"value\", name2: \"value2\"}, LogLevel.Warning); // specify the entire LogEntry interface using log Logger.log({ data: { name: \"value\", name2: \"value2\"}, level: LogLevel.Warning, message: \"This is my message\" }); Log an error \u00b6 There exists a shortcut method to log an error to the Logger. This will log an entry to the subscribed loggers where the data property will be the Error instance passed in, the level will be 'Error', and the message will be the Error instance's message property. const e = Error(\"An Error\"); Logger.error(e); Subscribing a Listener \u00b6 By default no listeners are subscribed, so if you would like to get logging information you need to subscribe at least one listener. This is done as shown below by importing the Logger and your listener(s) of choice. Here we are using the provided ConsoleListener. We are also setting the active log level, which controls the level of logging that will be output. Be aware that Verbose produces a substantial amount of data about each request. import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; // subscribe a listener Logger.subscribe(new ConsoleListener()); // set the active log level Logger.activeLogLevel = LogLevel.Info; Available Listeners \u00b6 There are two listeners included in the library, ConsoleListener and FunctionListener. ConsoleListener \u00b6 This listener outputs information to the console and works in Node as well as within browsers. It can be used without settings and writes to the appropriate console method based on message level. For example a LogEntry with level Warning will be written to console.warn. Basic usage is shown in the example above. Configuration Options \u00b6 Although ConsoleListener can be used without configuration, there are some additional options available to you. ConsoleListener supports adding a prefix to every output (helpful for filtering console messages) and specifying text color for messages (including by LogLevel). Using a Prefix \u00b6 To add a prefix to all output, supply a string in the constructor: import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE)); Logger.activeLogLevel = LogLevel.Info; With the above configuration, Logger.write(\"My special message\"); will be output to the console as: MyAwesomeWebPart - My special message Customizing Text Color \u00b6 You can also specify text color for your messages by supplying an IConsoleListenerColors object. You can simply specify color to set the default color for all logging levels or you can set one or more logging level specific text colors (if you only want to set color for a specific logging level(s), leave color out and all other log levels will use the default color). Colors can be specified the same way color values are specified in CSS (named colors, hex values, rgb, rgba, hsl, hsla, etc.): import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE, {color:'#0b6a0b',warningColor:'magenta'})); Logger.activeLogLevel = LogLevel.Info; With the above configuration: Logger.write(\"My special message\"); Logger.write(\"A warning!\", LogLevel.Warning); Will result in messages that look like this: Color options: color : Default text color for all logging levels unless they're specified verboseColor : Text color to use for messages with LogLevel.Verbose infoColor : Text color to use for messages with LogLevel.Info warningColor : Text color to use for messages with LogLevel.Warning errorColor : Text color to use for messages with LogLevel.Error To set colors without a prefix, specify either undefined or an empty string for the first parameter: Logger.subscribe(new ConsoleListener(undefined, {color:'purple'})); FunctionListener \u00b6 The FunctionListener allows you to wrap any functionality by creating a function that takes a LogEntry as its single argument. This produces the same result as implementing the LogListener interface, but is useful if you already have a logging method or framework to which you want to pass the messages. import { Logger, FunctionListener, ILogEntry } from \"@pnp/logging\"; let listener = new FunctionListener((entry: ILogEntry) => { // pass all logging data to an existing framework MyExistingCompanyLoggingFramework.log(entry.message); }); Logger.subscribe(listener); Create a Custom Listener \u00b6 If desirable for your project you can create a custom listener to perform any logging action you would like. This is done by implementing the ILogListener interface. import { Logger, ILogListener, ILogEntry } from \"@pnp/logging\"; class MyListener implements ILogListener { log(entry: ILogEntry): void { // here you would do something with the entry } } Logger.subscribe(new MyListener());","title":"logging"},{"location":"logging/#pnplogging","text":"The logging module provides light weight subscribable and extensible logging framework which is used internally and available for use in your projects. This article outlines how to setup logging and use the various loggers.","title":"@pnp/logging"},{"location":"logging/#getting-started","text":"Install the logging module, it has no other dependencies npm install @pnp/logging --save","title":"Getting Started"},{"location":"logging/#understanding-the-logging-framework","text":"The logging framework is centered on the Logger class to which any number of listeners can be subscribed. Each of these listeners will receive each of the messages logged. Each listener must implement the ILogListener interface, shown below. There is only one method to implement and it takes an instance of the LogEntry interface as a parameter. /** * Interface that defines a log listener * */ export interface ILogListener { /** * Any associated data that a given logging listener may choose to log or ignore * * @param entry The information to be logged */ log(entry: ILogEntry): void; } /** * Interface that defines a log entry * */ export interface ILogEntry { /** * The main message to be logged */ message: string; /** * The level of information this message represents */ level: LogLevel; /** * Any associated data that a given logging listener may choose to log or ignore */ data?: any; }","title":"Understanding the Logging Framework"},{"location":"logging/#log-levels","text":"export const enum LogLevel { Verbose = 0, Info = 1, Warning = 2, Error = 3, Off = 99, }","title":"Log Levels"},{"location":"logging/#writing-to-the-logger","text":"To write information to a logger you can use either write, writeJSON, or log. import { Logger, LogLevel } from \"@pnp/logging\"; // write logs a simple string as the message value of the LogEntry Logger.write(\"This is logging a simple string\"); // optionally passing a level, default level is Verbose Logger.write(\"This is logging a simple string\", LogLevel.Error); // this will convert the object to a string using JSON.stringify and set the message with the result Logger.writeJSON({ name: \"value\", name2: \"value2\"}); // optionally passing a level, default level is Verbose Logger.writeJSON({ name: \"value\", name2: \"value2\"}, LogLevel.Warning); // specify the entire LogEntry interface using log Logger.log({ data: { name: \"value\", name2: \"value2\"}, level: LogLevel.Warning, message: \"This is my message\" });","title":"Writing to the Logger"},{"location":"logging/#log-an-error","text":"There exists a shortcut method to log an error to the Logger. This will log an entry to the subscribed loggers where the data property will be the Error instance passed in, the level will be 'Error', and the message will be the Error instance's message property. const e = Error(\"An Error\"); Logger.error(e);","title":"Log an error"},{"location":"logging/#subscribing-a-listener","text":"By default no listeners are subscribed, so if you would like to get logging information you need to subscribe at least one listener. This is done as shown below by importing the Logger and your listener(s) of choice. Here we are using the provided ConsoleListener. We are also setting the active log level, which controls the level of logging that will be output. Be aware that Verbose produces a substantial amount of data about each request. import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; // subscribe a listener Logger.subscribe(new ConsoleListener()); // set the active log level Logger.activeLogLevel = LogLevel.Info;","title":"Subscribing a Listener"},{"location":"logging/#available-listeners","text":"There are two listeners included in the library, ConsoleListener and FunctionListener.","title":"Available Listeners"},{"location":"logging/#consolelistener","text":"This listener outputs information to the console and works in Node as well as within browsers. It can be used without settings and writes to the appropriate console method based on message level. For example a LogEntry with level Warning will be written to console.warn. Basic usage is shown in the example above.","title":"ConsoleListener"},{"location":"logging/#configuration-options","text":"Although ConsoleListener can be used without configuration, there are some additional options available to you. ConsoleListener supports adding a prefix to every output (helpful for filtering console messages) and specifying text color for messages (including by LogLevel).","title":"Configuration Options"},{"location":"logging/#using-a-prefix","text":"To add a prefix to all output, supply a string in the constructor: import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE)); Logger.activeLogLevel = LogLevel.Info; With the above configuration, Logger.write(\"My special message\"); will be output to the console as: MyAwesomeWebPart - My special message","title":"Using a Prefix"},{"location":"logging/#customizing-text-color","text":"You can also specify text color for your messages by supplying an IConsoleListenerColors object. You can simply specify color to set the default color for all logging levels or you can set one or more logging level specific text colors (if you only want to set color for a specific logging level(s), leave color out and all other log levels will use the default color). Colors can be specified the same way color values are specified in CSS (named colors, hex values, rgb, rgba, hsl, hsla, etc.): import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE, {color:'#0b6a0b',warningColor:'magenta'})); Logger.activeLogLevel = LogLevel.Info; With the above configuration: Logger.write(\"My special message\"); Logger.write(\"A warning!\", LogLevel.Warning); Will result in messages that look like this: Color options: color : Default text color for all logging levels unless they're specified verboseColor : Text color to use for messages with LogLevel.Verbose infoColor : Text color to use for messages with LogLevel.Info warningColor : Text color to use for messages with LogLevel.Warning errorColor : Text color to use for messages with LogLevel.Error To set colors without a prefix, specify either undefined or an empty string for the first parameter: Logger.subscribe(new ConsoleListener(undefined, {color:'purple'}));","title":"Customizing Text Color"},{"location":"logging/#functionlistener","text":"The FunctionListener allows you to wrap any functionality by creating a function that takes a LogEntry as its single argument. This produces the same result as implementing the LogListener interface, but is useful if you already have a logging method or framework to which you want to pass the messages. import { Logger, FunctionListener, ILogEntry } from \"@pnp/logging\"; let listener = new FunctionListener((entry: ILogEntry) => { // pass all logging data to an existing framework MyExistingCompanyLoggingFramework.log(entry.message); }); Logger.subscribe(listener);","title":"FunctionListener"},{"location":"logging/#create-a-custom-listener","text":"If desirable for your project you can create a custom listener to perform any logging action you would like. This is done by implementing the ILogListener interface. import { Logger, ILogListener, ILogEntry } from \"@pnp/logging\"; class MyListener implements ILogListener { log(entry: ILogEntry): void { // here you would do something with the entry } } Logger.subscribe(new MyListener());","title":"Create a Custom Listener"},{"location":"news/2020-year-in-review/","text":"2020 Year End Report \u00b6 Welcome to our first year in review report for PnPjs. This year has marked usage milestones, seen more contributors than ever, and expanded the core maintainers team. But none of this would be possible without everyones support and participation - so we start by saying Thank You! We deeply appreciate everyone that has used, helped us grow, and improved the library over the last year. This year we introduced MSAL clients for node and browser, improved our testing/local development plumbing, and updated the libraries to work with the node 15 module resolution rules. We fixed 43 reported bugs, answered 131 questions, and made 55 suggested enhancements to the library - all driven by feedback from users and the community. Planned for release in January 2021 we also undertook the work to enable isolated runtimes, a long requested feature. This allows you to operate on multiple independently configured \"roots\" such as \"sp\" or \"graph\" from the same application. Previously the library was configured globally, so this opens new possibilities for both client and server side scenarios. Finally we made many tooling and project improvements such as moving to GitHub actions, updating the tests to use MSAL, and exploring ways to enhance the developer experience. Usage \u00b6 In 2020 we tracked steady month/month growth in raw usage measured by requests as well as in the number of tenants deploying the library. Starting the year we were used in 14605 tenants and by December that number grew to 21,227. These tenants generated 6.1 billion requests to the service in January growing to 9.2 billion by December, peaking at 10.1 billion requests in November. 1) There was a data glitch in October so the numbers do not fully represent usage. 2) These numbers only include public cloud SPO usage, true usage is higher than we can track due to on-premesis and gov/sovereign clouds Releases \u00b6 We continued our monthly release cadence as it represents a good pace for addressing issues while not expecting folks to update too often and keeping each update to a reasonable size. All changes can be tracked in our change log , updated with each release. You can check our scheduled releases through project milestones , understanding there are occasionally delays. Monthly releases allows us to ensure bugs do not linger and we continually improve and expand the capabilities of the libraries. NPM Package download statistics (@pnp/sp): \u00b6 Month Count * Month Count January 100,686 * July 36,805 February 34,437 * August 38,897 March 34,574 * September 45,968 April 32,436 * October 46,655 May 34,482 * November 45,511 June 34,408 * December 58,977 Grand Total 543,836 With 2020 our total all time downloads of @pnp/sp is now at: 949,638 Stats from https://npm-stat.com/ Future Plans \u00b6 Looking to the future we will continue to actively grow and improve v2 of the library, guided by feedback and reported issues. Additionally, we are beginning to discuss v3 and doing initial planning and prototyping. The v3 work will continue through 2021 with no currently set release date, though we will keep everyone up to date. Additionally in 2021 there will be a general focus on improving not just the code but our tooling, build pipeline, and library contributor experience. We will also look at automatic canary releases with each merge, and other improvements. New Lead Maintainer \u00b6 With the close of 2020 we are very excited to announce a new lead maintainer for PnPjs, Julie Turner ! Julie brings deep expertise with SharePoint Framework, TypeScript, and SharePoint development to the team, coupled with dedication and care in the work. Over the last year she has gotten more involved with handling releases, responding to issues, and helping to keep the code updated and clean. We are very lucky to have her working on the project and look forward to seeing her lead the growth and direction for years to come. Contributors \u00b6 As always we have abundant thanks and appreciation for your contributors. Taking your time to help improve PnPjs for the community is massive and valuable to ensure our sustainability. Thank you for all your help in 2020! If you are interested in becoming a contributor check out our guide on ways to get started. Sponsors \u00b6 We want to thank our sponsors for their support in 2020! This year we put the money towards helping offset the cost and shipping of hoodies to contributors and sponsors. Your continued generosity makes a big difference in our ability to recognize and reward the folks building PnPjs. Thank You Closing \u00b6 In closing we want say Thank You to everyone who uses, contributes to, and participates in PnPjs and the SharePoint Patterns and Practices program. Wishing you the very best for 2021, The PnPjs Team","title":"2020 Year In Review"},{"location":"news/2020-year-in-review/#2020-year-end-report","text":"Welcome to our first year in review report for PnPjs. This year has marked usage milestones, seen more contributors than ever, and expanded the core maintainers team. But none of this would be possible without everyones support and participation - so we start by saying Thank You! We deeply appreciate everyone that has used, helped us grow, and improved the library over the last year. This year we introduced MSAL clients for node and browser, improved our testing/local development plumbing, and updated the libraries to work with the node 15 module resolution rules. We fixed 43 reported bugs, answered 131 questions, and made 55 suggested enhancements to the library - all driven by feedback from users and the community. Planned for release in January 2021 we also undertook the work to enable isolated runtimes, a long requested feature. This allows you to operate on multiple independently configured \"roots\" such as \"sp\" or \"graph\" from the same application. Previously the library was configured globally, so this opens new possibilities for both client and server side scenarios. Finally we made many tooling and project improvements such as moving to GitHub actions, updating the tests to use MSAL, and exploring ways to enhance the developer experience.","title":"2020 Year End Report"},{"location":"news/2020-year-in-review/#usage","text":"In 2020 we tracked steady month/month growth in raw usage measured by requests as well as in the number of tenants deploying the library. Starting the year we were used in 14605 tenants and by December that number grew to 21,227. These tenants generated 6.1 billion requests to the service in January growing to 9.2 billion by December, peaking at 10.1 billion requests in November. 1) There was a data glitch in October so the numbers do not fully represent usage. 2) These numbers only include public cloud SPO usage, true usage is higher than we can track due to on-premesis and gov/sovereign clouds","title":"Usage"},{"location":"news/2020-year-in-review/#releases","text":"We continued our monthly release cadence as it represents a good pace for addressing issues while not expecting folks to update too often and keeping each update to a reasonable size. All changes can be tracked in our change log , updated with each release. You can check our scheduled releases through project milestones , understanding there are occasionally delays. Monthly releases allows us to ensure bugs do not linger and we continually improve and expand the capabilities of the libraries.","title":"Releases"},{"location":"news/2020-year-in-review/#npm-package-download-statistics-pnpsp","text":"Month Count * Month Count January 100,686 * July 36,805 February 34,437 * August 38,897 March 34,574 * September 45,968 April 32,436 * October 46,655 May 34,482 * November 45,511 June 34,408 * December 58,977 Grand Total 543,836 With 2020 our total all time downloads of @pnp/sp is now at: 949,638 Stats from https://npm-stat.com/","title":"NPM Package download statistics (@pnp/sp):"},{"location":"news/2020-year-in-review/#future-plans","text":"Looking to the future we will continue to actively grow and improve v2 of the library, guided by feedback and reported issues. Additionally, we are beginning to discuss v3 and doing initial planning and prototyping. The v3 work will continue through 2021 with no currently set release date, though we will keep everyone up to date. Additionally in 2021 there will be a general focus on improving not just the code but our tooling, build pipeline, and library contributor experience. We will also look at automatic canary releases with each merge, and other improvements.","title":"Future Plans"},{"location":"news/2020-year-in-review/#new-lead-maintainer","text":"With the close of 2020 we are very excited to announce a new lead maintainer for PnPjs, Julie Turner ! Julie brings deep expertise with SharePoint Framework, TypeScript, and SharePoint development to the team, coupled with dedication and care in the work. Over the last year she has gotten more involved with handling releases, responding to issues, and helping to keep the code updated and clean. We are very lucky to have her working on the project and look forward to seeing her lead the growth and direction for years to come.","title":"New Lead Maintainer"},{"location":"news/2020-year-in-review/#contributors","text":"As always we have abundant thanks and appreciation for your contributors. Taking your time to help improve PnPjs for the community is massive and valuable to ensure our sustainability. Thank you for all your help in 2020! If you are interested in becoming a contributor check out our guide on ways to get started.","title":"Contributors"},{"location":"news/2020-year-in-review/#sponsors","text":"We want to thank our sponsors for their support in 2020! This year we put the money towards helping offset the cost and shipping of hoodies to contributors and sponsors. Your continued generosity makes a big difference in our ability to recognize and reward the folks building PnPjs. Thank You","title":"Sponsors"},{"location":"news/2020-year-in-review/#closing","text":"In closing we want say Thank You to everyone who uses, contributes to, and participates in PnPjs and the SharePoint Patterns and Practices program. Wishing you the very best for 2021, The PnPjs Team","title":"Closing"},{"location":"nodejs/","text":"@pnp/nodejs \u00b6 This package supplies helper code when using the @pnp libraries within the context of nodejs. Primarily these consist of clients to enable use of the libraries in nodejs. Getting Started \u00b6 Install the library and required dependencies. You will also need to install other libraries such as @pnp/sp or @pnp/graph to use the exported functionality. npm install @pnp/sp @pnp/nodejs --save AdalFetchClient SPFetchClient BearerTokenFetchClient Proxy SP Extensions \u00b6 Added in 2.0.9 A set of nodejs specific extensions for the @pnp/sp library. SP Extensions","title":"nodejs"},{"location":"nodejs/#pnpnodejs","text":"This package supplies helper code when using the @pnp libraries within the context of nodejs. Primarily these consist of clients to enable use of the libraries in nodejs.","title":"@pnp/nodejs"},{"location":"nodejs/#getting-started","text":"Install the library and required dependencies. You will also need to install other libraries such as @pnp/sp or @pnp/graph to use the exported functionality. npm install @pnp/sp @pnp/nodejs --save AdalFetchClient SPFetchClient BearerTokenFetchClient Proxy","title":"Getting Started"},{"location":"nodejs/#sp-extensions","text":"Added in 2.0.9 A set of nodejs specific extensions for the @pnp/sp library. SP Extensions","title":"SP Extensions"},{"location":"nodejs/adal-fetch-client/","text":"@pnp/nodejs/adalfetchclient \u00b6 The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"AdalFetchClient"},{"location":"nodejs/adal-fetch-client/#pnpnodejsadalfetchclient","text":"The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"@pnp/nodejs/adalfetchclient"},{"location":"nodejs/bearer-token-fetch-client/","text":"@pnp/nodejs/BearerTokenFetchClient \u00b6 The BearerTokenFetchClient class allows you to easily specify your own Bearer tokens to be used in the requests. How you derive the token is up to you. import { BearerTokenFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new BearerTokenFetchClient(\"{Bearer Token}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"BearerTokenFetchClient"},{"location":"nodejs/bearer-token-fetch-client/#pnpnodejsbearertokenfetchclient","text":"The BearerTokenFetchClient class allows you to easily specify your own Bearer tokens to be used in the requests. How you derive the token is up to you. import { BearerTokenFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new BearerTokenFetchClient(\"{Bearer Token}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"@pnp/nodejs/BearerTokenFetchClient"},{"location":"nodejs/provider-hosted-app/","text":"@pnp/nodejs/providerhostedrequestcontext \u00b6 The ProviderHostedRequestContext enables the creation of provider-hosted add-ins built in node.js to use pnpjs to interact with SharePoint. The context is associated to a SharePoint user, allowing requests to be made by the add-in on the behalf of the user. The usage of this class assumes the provider-hosted add-in is called from SharePoint with a valid SPAppToken. This is typically done by means of accessing /_layouts/15/AppRedirect.aspx with the app's client ID and app's redirect URI. Note : To support concurrent requests by different users and/or add-ins on different tenants, do not use the SPFetchClient class. Instead, use the more generic NodeFetchClient class. The downside is that you have to manually configure each request to use the desired user/app context. import { sp, SPRest } from \"@pnp/sp/presets/all\"; import { NodeFetchClient, ProviderHostedRequestContext } from \"@pnp/nodejs\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new NodeFetchClient(); }, }, }); // get request data generated by /_layouts/15/AppRedirect.aspx const spAppToken = request.body.SPAppToken; const spSiteUrl = request.body.SPSiteUrl; // create a context based on the add-in details and SPAppToken const ctx = await ProviderHostedRequestContext.create(spSiteUrl, \"{client id}\", \"{client secret}\", spAppToken); // create an SPRest object configured to use our context // this is used in place of the global sp object const userSP = new SPRest().configure(await ctx.getUserConfig(), spSiteUrl); const addinSP = new SPRest().configure(await ctx.getAddInOnlyConfig(), spSiteUrl); // make a request on behalf of the user const user = await userSP.web.currentUser(); console.log(`Hello ${user.Title}`); // make an add-in only request const app = await addinSP.web.currentUser(); console.log(`Add-in principal: ${app.Title}`);","title":"ProviderHostedRequestContext"},{"location":"nodejs/provider-hosted-app/#pnpnodejsproviderhostedrequestcontext","text":"The ProviderHostedRequestContext enables the creation of provider-hosted add-ins built in node.js to use pnpjs to interact with SharePoint. The context is associated to a SharePoint user, allowing requests to be made by the add-in on the behalf of the user. The usage of this class assumes the provider-hosted add-in is called from SharePoint with a valid SPAppToken. This is typically done by means of accessing /_layouts/15/AppRedirect.aspx with the app's client ID and app's redirect URI. Note : To support concurrent requests by different users and/or add-ins on different tenants, do not use the SPFetchClient class. Instead, use the more generic NodeFetchClient class. The downside is that you have to manually configure each request to use the desired user/app context. import { sp, SPRest } from \"@pnp/sp/presets/all\"; import { NodeFetchClient, ProviderHostedRequestContext } from \"@pnp/nodejs\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new NodeFetchClient(); }, }, }); // get request data generated by /_layouts/15/AppRedirect.aspx const spAppToken = request.body.SPAppToken; const spSiteUrl = request.body.SPSiteUrl; // create a context based on the add-in details and SPAppToken const ctx = await ProviderHostedRequestContext.create(spSiteUrl, \"{client id}\", \"{client secret}\", spAppToken); // create an SPRest object configured to use our context // this is used in place of the global sp object const userSP = new SPRest().configure(await ctx.getUserConfig(), spSiteUrl); const addinSP = new SPRest().configure(await ctx.getAddInOnlyConfig(), spSiteUrl); // make a request on behalf of the user const user = await userSP.web.currentUser(); console.log(`Hello ${user.Title}`); // make an add-in only request const app = await addinSP.web.currentUser(); console.log(`Add-in principal: ${app.Title}`);","title":"@pnp/nodejs/providerhostedrequestcontext"},{"location":"nodejs/proxy/","text":"@pnp/nodejs/proxy \u00b6 In some cases when deploying on node you may need to use a proxy as governed by corporate policy, or perhaps you want to examine the traffic using a tool such as Fiddler. setProxyUrl \u00b6 Basic Usage \u00b6 You need to import the setProxyUrl function from @pnp/nodejs library and call it with your proxy url. Once done an https-proxy-agent will be used with each request. This works across all clients within the @pnp/nodejs library. import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // call the set proxy url function and it will be used for all requests regardless of client setProxyUrl(\"{your proxy url}\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, }); Use with Fiddler \u00b6 To get Fiddler to work you may need to set an environment variable. This should only be done for testing! import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // ignore certificate errors: ONLY FOR TESTING!! process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\"; // this is my fiddler url locally setProxyUrl(\"http://127.0.0.1:8888\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, }); setProxyAgent \u00b6 Added in 2.0.11 You need to import the setProxyAgent function from @pnp/nodejs library and call it with your proxy url. You can supply any valid proxy and it will be used. import { SPFetchClient, SPOAuthEnv, setProxyAgent } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { const myAgent = new MyAgentOfSomeType({}); // call the set proxy agent function and it will be used for all requests regardless of client setProxyAgent(myAgent); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"proxy"},{"location":"nodejs/proxy/#pnpnodejsproxy","text":"In some cases when deploying on node you may need to use a proxy as governed by corporate policy, or perhaps you want to examine the traffic using a tool such as Fiddler.","title":"@pnp/nodejs/proxy"},{"location":"nodejs/proxy/#setproxyurl","text":"","title":"setProxyUrl"},{"location":"nodejs/proxy/#basic-usage","text":"You need to import the setProxyUrl function from @pnp/nodejs library and call it with your proxy url. Once done an https-proxy-agent will be used with each request. This works across all clients within the @pnp/nodejs library. import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // call the set proxy url function and it will be used for all requests regardless of client setProxyUrl(\"{your proxy url}\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"Basic Usage"},{"location":"nodejs/proxy/#use-with-fiddler","text":"To get Fiddler to work you may need to set an environment variable. This should only be done for testing! import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // ignore certificate errors: ONLY FOR TESTING!! process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\"; // this is my fiddler url locally setProxyUrl(\"http://127.0.0.1:8888\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"Use with Fiddler"},{"location":"nodejs/proxy/#setproxyagent","text":"Added in 2.0.11 You need to import the setProxyAgent function from @pnp/nodejs library and call it with your proxy url. You can supply any valid proxy and it will be used. import { SPFetchClient, SPOAuthEnv, setProxyAgent } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { const myAgent = new MyAgentOfSomeType({}); // call the set proxy agent function and it will be used for all requests regardless of client setProxyAgent(myAgent); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"setProxyAgent"},{"location":"nodejs/sp-extensions/","text":"@pnp/nodejs - sp extensions \u00b6 By importing anything from the @pnp/nodejs library you automatically get nodejs specific extension methods added into the sp fluent api. This article describes them. These examples use the *-commonjs version of the libraries as they target node, you can read more about the differences . IFile.getStream \u00b6 Allows you to read a response body as a nodejs PassThrough stream. // by importing the the library the node specific extensions are automatically applied import { SPFetchClient, SPNS } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{url}\", \"{id}\", \"{secret}\"); }, }, }); // get the stream const streamResult: SPNS.IResponseBodyStream = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream(); // see if we have a known length console.log(streamResult.knownLength); // read the stream // this is a very basic example - you can do tons more with streams in node const txt = await new Promise<string>((resolve) => { let data = \"\"; stream.body.on(\"data\", (chunk) => data += chunk); stream.body.on(\"end\", () => resolve(data)); }); IFiles.addChunked \u00b6 Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const files = sp.web.defaultDocumentLibrary.rootFolder.files; await files.addChunked(name, stream, null, true, 10); IFile.setStreamContentChunked \u00b6 Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const file = sp.web.defaultDocumentLibrary.rootFolder.files..getByName(\"file-name.txt\"); await file.setStreamContentChunked(stream); Explicit import \u00b6 If you don't need to import anything from the library, but would like to include the extensions just import the library as shown. // ES Modules: import \"@pnp/nodejs\"; import \"@pnp/nodejs-commonjs\"; // get the stream const streamResult = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream(); Accessing SP Extension Namespace \u00b6 There are classes and interfaces included in extension modules, which you can access through a namespace, \"SPNS\". import { SPNS } from \"@pnp/nodejs-commonjs\"; const parser = new SPNS.StreamParser();","title":"sp Extensions"},{"location":"nodejs/sp-extensions/#pnpnodejs-sp-extensions","text":"By importing anything from the @pnp/nodejs library you automatically get nodejs specific extension methods added into the sp fluent api. This article describes them. These examples use the *-commonjs version of the libraries as they target node, you can read more about the differences .","title":"@pnp/nodejs - sp extensions"},{"location":"nodejs/sp-extensions/#ifilegetstream","text":"Allows you to read a response body as a nodejs PassThrough stream. // by importing the the library the node specific extensions are automatically applied import { SPFetchClient, SPNS } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{url}\", \"{id}\", \"{secret}\"); }, }, }); // get the stream const streamResult: SPNS.IResponseBodyStream = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream(); // see if we have a known length console.log(streamResult.knownLength); // read the stream // this is a very basic example - you can do tons more with streams in node const txt = await new Promise<string>((resolve) => { let data = \"\"; stream.body.on(\"data\", (chunk) => data += chunk); stream.body.on(\"end\", () => resolve(data)); });","title":"IFile.getStream"},{"location":"nodejs/sp-extensions/#ifilesaddchunked","text":"Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const files = sp.web.defaultDocumentLibrary.rootFolder.files; await files.addChunked(name, stream, null, true, 10);","title":"IFiles.addChunked"},{"location":"nodejs/sp-extensions/#ifilesetstreamcontentchunked","text":"Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const file = sp.web.defaultDocumentLibrary.rootFolder.files..getByName(\"file-name.txt\"); await file.setStreamContentChunked(stream);","title":"IFile.setStreamContentChunked"},{"location":"nodejs/sp-extensions/#explicit-import","text":"If you don't need to import anything from the library, but would like to include the extensions just import the library as shown. // ES Modules: import \"@pnp/nodejs\"; import \"@pnp/nodejs-commonjs\"; // get the stream const streamResult = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream();","title":"Explicit import"},{"location":"nodejs/sp-extensions/#accessing-sp-extension-namespace","text":"There are classes and interfaces included in extension modules, which you can access through a namespace, \"SPNS\". import { SPNS } from \"@pnp/nodejs-commonjs\"; const parser = new SPNS.StreamParser();","title":"Accessing SP Extension Namespace"},{"location":"nodejs/sp-fetch-client/","text":"@pnp/nodejs/spfetchclient \u00b6 The SPFetchClient is used to authentication to SharePoint as a provider hosted add-in using a client and secret in nodejs. Remember it is not a good practice to expose client ids and secrets on the client and use of this class is intended for nodejs exclusively. See: How to register a legacy SharePoint application import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web(); console.log(JSON.stringify(w, null, 4)); Set Authentication Environment \u00b6 For some areas such as Germany, China, and US Gov clouds you need to specify a different authentication url to the service. This is done by specifying the correct SPOAuthEnv enumeration to the SPFetchClient constructor. The options are listed below. If you are not sure which option to specify the default is likely OK. SPO : (default) for all *.sharepoint.com urls China: for China hosted cloud Germany: for Germany local cloud USDef: USA Defense cloud USGov: USA Government cloud import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.China); }, }, }); Set Realm \u00b6 In some cases automatically resolving the realm may not work. In this case you can set the realm parameter in the SPFetchClient constructor. You can determine the correct value for the realm by navigating to https://{site name}-admin.sharepoint.com/_layouts/15/TA_AllAppPrincipals.aspx and copying the GUID value that appears after the \"@\" - this is the realm id. import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.SPO, \"{realm}\"); }, }, });","title":"SPFetchClient"},{"location":"nodejs/sp-fetch-client/#pnpnodejsspfetchclient","text":"The SPFetchClient is used to authentication to SharePoint as a provider hosted add-in using a client and secret in nodejs. Remember it is not a good practice to expose client ids and secrets on the client and use of this class is intended for nodejs exclusively. See: How to register a legacy SharePoint application import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web(); console.log(JSON.stringify(w, null, 4));","title":"@pnp/nodejs/spfetchclient"},{"location":"nodejs/sp-fetch-client/#set-authentication-environment","text":"For some areas such as Germany, China, and US Gov clouds you need to specify a different authentication url to the service. This is done by specifying the correct SPOAuthEnv enumeration to the SPFetchClient constructor. The options are listed below. If you are not sure which option to specify the default is likely OK. SPO : (default) for all *.sharepoint.com urls China: for China hosted cloud Germany: for Germany local cloud USDef: USA Defense cloud USGov: USA Government cloud import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.China); }, }, });","title":"Set Authentication Environment"},{"location":"nodejs/sp-fetch-client/#set-realm","text":"In some cases automatically resolving the realm may not work. In this case you can set the realm parameter in the SPFetchClient constructor. You can determine the correct value for the realm by navigating to https://{site name}-admin.sharepoint.com/_layouts/15/TA_AllAppPrincipals.aspx and copying the GUID value that appears after the \"@\" - this is the realm id. import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.SPO, \"{realm}\"); }, }, });","title":"Set Realm"},{"location":"odata/","text":"@pnp/queryable \u00b6 This modules contains the abstract core classes used to process odata requests. They can also be used to build your own odata library should you wish to. By sharing the core functionality across libraries we can provide a consistent API as well as ensure the core code is solid and well tested, with any updates benefitting all inheriting libraries. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable --save Library Topics \u00b6 caching core OData Batching Parsers Pipeline Queryable","title":"odata"},{"location":"odata/#pnpqueryable","text":"This modules contains the abstract core classes used to process odata requests. They can also be used to build your own odata library should you wish to. By sharing the core functionality across libraries we can provide a consistent API as well as ensure the core code is solid and well tested, with any updates benefitting all inheriting libraries.","title":"@pnp/queryable"},{"location":"odata/#getting-started","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable --save","title":"Getting Started"},{"location":"odata/#library-topics","text":"caching core OData Batching Parsers Pipeline Queryable","title":"Library Topics"},{"location":"odata/caching/","text":"@pnp/queryable/caching \u00b6 Often times data doesn't change that quickly, especially in the case of rolling up corporate news or upcoming events. These types of things can be cached for minutes if not hours. To help make caching easy you just need to insert the usingCaching method in your chain. This only applies to get requests. The usingCaching method can be used with the inBatch method as well to cache the results of batched requests. The below examples uses the @pnp/sp library as the example - but this works equally well for any library making use of the @pnp/queryable base classes, such as @pnp/graph. Basic example \u00b6 You can use the method without any additional configuration. We have made some default choices for you and will discuss ways to override them later. The code below will get items from a list, first checking the cache for the value. You can also use it with OData operators such as top and orderBy. The usingCaching() method should always be the last method in the chain before the get() (OR if you are using batching these methods can be transposed, more details below). import { sp } from \"@pnp/sp\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.usingCaching()(); console.log(r); const r2 = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r2); Globally Configure Cache Settings \u00b6 If you would not like to use the default values, but don't want to clutter your code by setting the caching values on each request you can configure custom options globally. These will be applied to all calls to usingCaching() throughout your application. import { sp } from \"@pnp/sp\"; sp.setup({ defaultCachingStore: \"session\", // or \"local\" defaultCachingTimeoutSeconds: 30, globalCacheDisable: false // or true to disable caching in case of debugging/testing }); const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r); Per Call Configuration \u00b6 If you prefer more verbose code or have a need to manage the cache settings on a per request basis you can include individual caching settings for each request. These settings are passed to the usingCaching method call and are defined in the following interface. If you want to use the per-request options you must include the key. export interface ICachingOptions { expiration?: Date; storeName?: \"session\" | \"local\"; key: string; } import { sp } from \"@pnp/sp\"; import { dateAdd } from \"@pnp/core\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching({ expiration: dateAdd(new Date(), \"minute\", 20), key: \"My Key\", storeName: \"local\" })(); console.log(r); Using Batching with Caching \u00b6 You can use batching and caching together, but remember caching is only applied to get requests. When you use them together the methods can be transposed, the below example is valid. import { sp } from \"@pnp/sp\"; let batch = sp.createBatch(); sp.web.lists.inBatch(batch).usingCaching()().then(r => { console.log(r) }); sp.web.lists.getByTitle(\"Tasks\").items.usingCaching().inBatch(batch)().then(r => { console.log(r) }); batch.execute().then(() => console.log(\"All done!\")); Implement Custom Caching \u00b6 You may desire to use a different caching strategy than the one we implemented within the library. The easiest way to achieve this is to wrap the request in your custom caching functionality using the unresolved promise as needed. Here we show how to implement the Stale While Revalidate pattern as discussed here . Implement caching helper method \u00b6 We create a map to act as our cache storage and a function to wrap the request caching logic const map = new Map<string, any>(); async function staleWhileRevalidate<T>(key: string, p: Promise<T>): Promise<T> { if (map.has(key)) { // In Cache p.then(u => { // Update Cache once we have a result map.set(key, u); }); // Return from Cache return map.get(key); } // Not In Cache so we need to wait for the value const r = await p; // Set Cache map.set(key, r); // Return from Promise return r; } Usage \u00b6 Don't call usingCaching just apply the helper method // this one will wait for the request to finish const r1 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r2, null, 2)); Wrapper Function \u00b6 You can wrap this call into a single function you can reuse within your application each time you need the web data for example. You can update the select and interface to match your needs as well. interface WebData { Title: string; Description: string; } function getWebData(): Promise<WebData> { return staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); } // this one will wait for the request to finish const r1 = await getWebData(); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await getWebData(); console.log(JSON.stringify(r2, null, 2));","title":"caching"},{"location":"odata/caching/#pnpqueryablecaching","text":"Often times data doesn't change that quickly, especially in the case of rolling up corporate news or upcoming events. These types of things can be cached for minutes if not hours. To help make caching easy you just need to insert the usingCaching method in your chain. This only applies to get requests. The usingCaching method can be used with the inBatch method as well to cache the results of batched requests. The below examples uses the @pnp/sp library as the example - but this works equally well for any library making use of the @pnp/queryable base classes, such as @pnp/graph.","title":"@pnp/queryable/caching"},{"location":"odata/caching/#basic-example","text":"You can use the method without any additional configuration. We have made some default choices for you and will discuss ways to override them later. The code below will get items from a list, first checking the cache for the value. You can also use it with OData operators such as top and orderBy. The usingCaching() method should always be the last method in the chain before the get() (OR if you are using batching these methods can be transposed, more details below). import { sp } from \"@pnp/sp\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.usingCaching()(); console.log(r); const r2 = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r2);","title":"Basic example"},{"location":"odata/caching/#globally-configure-cache-settings","text":"If you would not like to use the default values, but don't want to clutter your code by setting the caching values on each request you can configure custom options globally. These will be applied to all calls to usingCaching() throughout your application. import { sp } from \"@pnp/sp\"; sp.setup({ defaultCachingStore: \"session\", // or \"local\" defaultCachingTimeoutSeconds: 30, globalCacheDisable: false // or true to disable caching in case of debugging/testing }); const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r);","title":"Globally Configure Cache Settings"},{"location":"odata/caching/#per-call-configuration","text":"If you prefer more verbose code or have a need to manage the cache settings on a per request basis you can include individual caching settings for each request. These settings are passed to the usingCaching method call and are defined in the following interface. If you want to use the per-request options you must include the key. export interface ICachingOptions { expiration?: Date; storeName?: \"session\" | \"local\"; key: string; } import { sp } from \"@pnp/sp\"; import { dateAdd } from \"@pnp/core\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching({ expiration: dateAdd(new Date(), \"minute\", 20), key: \"My Key\", storeName: \"local\" })(); console.log(r);","title":"Per Call Configuration"},{"location":"odata/caching/#using-batching-with-caching","text":"You can use batching and caching together, but remember caching is only applied to get requests. When you use them together the methods can be transposed, the below example is valid. import { sp } from \"@pnp/sp\"; let batch = sp.createBatch(); sp.web.lists.inBatch(batch).usingCaching()().then(r => { console.log(r) }); sp.web.lists.getByTitle(\"Tasks\").items.usingCaching().inBatch(batch)().then(r => { console.log(r) }); batch.execute().then(() => console.log(\"All done!\"));","title":"Using Batching with Caching"},{"location":"odata/caching/#implement-custom-caching","text":"You may desire to use a different caching strategy than the one we implemented within the library. The easiest way to achieve this is to wrap the request in your custom caching functionality using the unresolved promise as needed. Here we show how to implement the Stale While Revalidate pattern as discussed here .","title":"Implement Custom Caching"},{"location":"odata/caching/#implement-caching-helper-method","text":"We create a map to act as our cache storage and a function to wrap the request caching logic const map = new Map<string, any>(); async function staleWhileRevalidate<T>(key: string, p: Promise<T>): Promise<T> { if (map.has(key)) { // In Cache p.then(u => { // Update Cache once we have a result map.set(key, u); }); // Return from Cache return map.get(key); } // Not In Cache so we need to wait for the value const r = await p; // Set Cache map.set(key, r); // Return from Promise return r; }","title":"Implement caching helper method"},{"location":"odata/caching/#usage","text":"Don't call usingCaching just apply the helper method // this one will wait for the request to finish const r1 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r2, null, 2));","title":"Usage"},{"location":"odata/caching/#wrapper-function","text":"You can wrap this call into a single function you can reuse within your application each time you need the web data for example. You can update the select and interface to match your needs as well. interface WebData { Title: string; Description: string; } function getWebData(): Promise<WebData> { return staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); } // this one will wait for the request to finish const r1 = await getWebData(); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await getWebData(); console.log(JSON.stringify(r2, null, 2));","title":"Wrapper Function"},{"location":"odata/core/","text":"@pnp/queryable/core \u00b6 This module contains shared interfaces and abstract classes used within the @pnp/queryable package and those items that inherit from it. ProcessHttpClientResponseException \u00b6 The exception thrown when a response is returned and cannot be processed. interface ODataParser \u00b6 Base interface used to describe a class that that will parse incoming responses. It takes a single type parameter representing the type of the value to be returned. It has two methods, one is optional: parse(r: Response): Promise - main method use to parse a response and return a Promise resolving to an object of type T hydrate?: (d: any) => T - optional method used when getting an object from the cache if it requires calling a constructor ODataParserBase \u00b6 The base class used by all parsers in the @pnp libraries. It is optional to use when creating your own custom parsers, but does contain several helper methods. Create a custom parser from ODataParserBase \u00b6 You can always create custom parsers for your projects, however it is likely you will not require this step as the default parsers should work for most cases. class MyParser extends ODataParserBase<any> { // we need to override the parse method to do our custom stuff public parse(r: Response): Promise<T> { // we wrap everything in a promise return new Promise((resolve, reject) => { // lets use the default error handling which returns true for no error // and will call reject with an error if one exists if (this.handleError(r, reject)) { // now we add our custom parsing here r.text().then(txt => { // here we call a made up function to parse the result // this is where we would do our parsing as required myCustomerUnencode(txt).then(v => { resolve(v); }); }); } }); } }","title":"core"},{"location":"odata/core/#pnpqueryablecore","text":"This module contains shared interfaces and abstract classes used within the @pnp/queryable package and those items that inherit from it.","title":"@pnp/queryable/core"},{"location":"odata/core/#processhttpclientresponseexception","text":"The exception thrown when a response is returned and cannot be processed.","title":"ProcessHttpClientResponseException"},{"location":"odata/core/#interface-odataparser","text":"Base interface used to describe a class that that will parse incoming responses. It takes a single type parameter representing the type of the value to be returned. It has two methods, one is optional: parse(r: Response): Promise - main method use to parse a response and return a Promise resolving to an object of type T hydrate?: (d: any) => T - optional method used when getting an object from the cache if it requires calling a constructor","title":"interface ODataParser"},{"location":"odata/core/#odataparserbase","text":"The base class used by all parsers in the @pnp libraries. It is optional to use when creating your own custom parsers, but does contain several helper methods.","title":"ODataParserBase"},{"location":"odata/core/#create-a-custom-parser-from-odataparserbase","text":"You can always create custom parsers for your projects, however it is likely you will not require this step as the default parsers should work for most cases. class MyParser extends ODataParserBase<any> { // we need to override the parse method to do our custom stuff public parse(r: Response): Promise<T> { // we wrap everything in a promise return new Promise((resolve, reject) => { // lets use the default error handling which returns true for no error // and will call reject with an error if one exists if (this.handleError(r, reject)) { // now we add our custom parsing here r.text().then(txt => { // here we call a made up function to parse the result // this is where we would do our parsing as required myCustomerUnencode(txt).then(v => { resolve(v); }); }); } }); } }","title":"Create a custom parser from ODataParserBase"},{"location":"odata/debug/","text":"Debugging Proxy Objects \u00b6 Because all queryables are now represented as Proxy objects you can't immediately see the properties/method of the object or the data stored about the request. In certain debugging scenarios it can help to get visibility into the object that is wrapped by the proxy. To enable this we provide a set of extensions to help. The debug extensions are added by including the import \"@pnp/queryable/debug\"; statement in your project. It should be removed for production. This module provides several methods to help with debugging Queryable Proxy objects. Unwrap \u00b6 The __unwrap() method returns the concrete Queryable instance wrapped by the Proxy. You can then examine this object in various ways or dump it to the console for debugging. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // unwrap the underlying concrete queryable instance const unwrapped = sp.web.__unwrap(); console.log(JSON.stringify(unwrapped, null, 2)); Note: It is not supported to unwrap objects and then use them. It may work in some cases, but this behavior may change as what is contained with the Proxy is an implementation detail and should not be relied upon. Without the Proxy wrapper we make no guarantees. Data \u00b6 All of the information related to a queryable's request is contained within the \"data\" property. If you need to grab that information you can use the __data property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's data const data = sp.web.__data; console.log(JSON.stringify(data, null, 2)); JSON \u00b6 You can also get a representation of the wrapped instance in JSON format consisting of all its own properties and values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's as JSON const data = sp.web.__json(); console.log(JSON.stringify(data, null, 2)); Deep Trace \u00b6 Deep tracing is the ability to write every property and method access to the log. This produces VERY verbose output but can be helpful in situations where you need to trace how things are called and when within the Proxy. You enable deep tracing using the __enableDeepTrace method and disable using __disableDeepTrace . import { Logger, ConsoleListener } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; Logger.subscribe(new ConsoleListener()); // grab an instance to enable deep trace const web = sp.web; // enable deep trace on the instance web.__enableDeepTrace(); const y = await web.lists(); // disable deep trace web.__disableDeepTrace(); The example above produces the following output: Message: get ::> lists Message: get ::> lists Message: get ::> toUrl Message: get ::> toUrl Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> query Message: get ::> query Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: get ::> __disableDeepTrace Message: get ::> __disableDeepTrace","title":"Debugging Proxy Objects"},{"location":"odata/debug/#debugging-proxy-objects","text":"Because all queryables are now represented as Proxy objects you can't immediately see the properties/method of the object or the data stored about the request. In certain debugging scenarios it can help to get visibility into the object that is wrapped by the proxy. To enable this we provide a set of extensions to help. The debug extensions are added by including the import \"@pnp/queryable/debug\"; statement in your project. It should be removed for production. This module provides several methods to help with debugging Queryable Proxy objects.","title":"Debugging Proxy Objects"},{"location":"odata/debug/#unwrap","text":"The __unwrap() method returns the concrete Queryable instance wrapped by the Proxy. You can then examine this object in various ways or dump it to the console for debugging. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // unwrap the underlying concrete queryable instance const unwrapped = sp.web.__unwrap(); console.log(JSON.stringify(unwrapped, null, 2)); Note: It is not supported to unwrap objects and then use them. It may work in some cases, but this behavior may change as what is contained with the Proxy is an implementation detail and should not be relied upon. Without the Proxy wrapper we make no guarantees.","title":"Unwrap"},{"location":"odata/debug/#data","text":"All of the information related to a queryable's request is contained within the \"data\" property. If you need to grab that information you can use the __data property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's data const data = sp.web.__data; console.log(JSON.stringify(data, null, 2));","title":"Data"},{"location":"odata/debug/#json","text":"You can also get a representation of the wrapped instance in JSON format consisting of all its own properties and values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's as JSON const data = sp.web.__json(); console.log(JSON.stringify(data, null, 2));","title":"JSON"},{"location":"odata/debug/#deep-trace","text":"Deep tracing is the ability to write every property and method access to the log. This produces VERY verbose output but can be helpful in situations where you need to trace how things are called and when within the Proxy. You enable deep tracing using the __enableDeepTrace method and disable using __disableDeepTrace . import { Logger, ConsoleListener } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; Logger.subscribe(new ConsoleListener()); // grab an instance to enable deep trace const web = sp.web; // enable deep trace on the instance web.__enableDeepTrace(); const y = await web.lists(); // disable deep trace web.__disableDeepTrace(); The example above produces the following output: Message: get ::> lists Message: get ::> lists Message: get ::> toUrl Message: get ::> toUrl Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> query Message: get ::> query Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: get ::> __disableDeepTrace Message: get ::> __disableDeepTrace","title":"Deep Trace"},{"location":"odata/extensions/","text":"Extensions \u00b6 introduced in 2.0.0 Extending is the concept of overriding or adding functionality into an object or environment without altering the underlying class instances. This can be useful for debugging, testing, or injecting custom functionality. Extensions work with any invocable . You can control any behavior of the library with extensions. Extensions do not work in ie11 compatibility mode. This is by design. Types of Extensions \u00b6 There are three types of Extensions available as well as three methods for registration. You can register any type of extension with any of the registration options. Function Extensions \u00b6 The first type is a simple function with a signature: (op: \"apply\" | \"get\" | \"has\" | \"set\", target: T, ...rest: any[]): void This function is passed the current operation as the first argument, currently one of \"apply\", \"get\", \"has\", or \"set\". The second argument is the target instance upon which the operation is being invoked. The remaining parameters vary by the operation being performed, but will match their respective ProxyHandler method signatures. Named Extensions \u00b6 Named extensions are designed to add or replace a single property or method, though you can register multiple using the same object. These extensions are defined by using an object which has the property/methods you want to override described. Registering named extensions globally will override that operation to all invokables. import { extendFactory } from \"@pnp/queryable\"; import { sp, List, Lists, IWeb, ILists, List, IList, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeQueryStrValue\"; // create a plain object with the props and methods we want to add/change const myExtensions = { // override the lists property get lists(this: IWeb): ILists { // we will always order our lists by title and select just the Title for ALL calls (just as an example) return Lists(this).orderBy(\"Title\").select(\"Title\"); }, // override the getByTitle method getByTitle: function (this: ILists, title: string): IList { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, `getByTitle('List2')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; // register all the named Extensions extendFactory(Web, myExtensions); // this will use our extension to ensure the lists are ordered const lists = await sp.web.lists(); console.log(JSON.stringify(lists, null, 2)); // we will get the items from List1 but within the extension it is rewritten as List2 const items = await sp.web.lists.getByTitle(\"List1\").items(); console.log(JSON.stringify(items.length, null, 2)); ProxyHandler Extensions \u00b6 You can also register a partial ProxyHandler implementation as an extension. You can implement one or more of the ProxyHandler methods as needed. Here we implement the same override of getByTitle globally. This is the most complicated method of creating an extension and assumes an understanding of how ProxyHandlers work. import { extendFactory } from \"@pnp/queryable\"; import { sp, Lists, IWeb, ILists, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeSingleQuote\"; const myExtensions = { get: (target, p: string | number | symbol, _receiver: any) => { switch (p) { case \"getByTitle\": return (title: string) => { // in our example our list has moved, so we rewrite the request on the fly if (title === \"LookupList\") { return List(target, `getByTitle('OrderByList')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(target, `getByTitle('${escapeQueryStrValue(title)}')`); } }; } }, }; extendFactory(Web, myExtensions); const lists = sp.web.lists; const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2)); Registering Extensions \u00b6 You can register Extensions either globally, on an invocable factory, or on a per-object basis, and you can register a single extension or an array of Extensions. Global Registration \u00b6 Globally registering an extension allows you to inject functionality into every invocable that is instantiated within your application. It is important to remember that processing extensions happens on ALL property access and method invocation operations - so global extensions should be used sparingly. import { extendGlobal } from \"@pnp/queryable\"; // we can add a logging method to very verbosely track what things are called in our application extendGlobal((op: string, _target: any, ...rest: any[]): void => { switch (op) { case \"apply\": Logger.write(`${op} ::> ()`, LogLevel.Info); break; case \"has\": case \"get\": case \"set\": Logger.write(`${op} ::> ${rest[0]}`, LogLevel.Info); break; default: Logger.write(`unknown ${op}`, LogLevel.Info); } }); Factory Registration \u00b6 The pattern you will likely find most useful is the ability to extend an invocable factory. This will apply your extensions to all instances created with that factory, meaning all IWebs or ILists will have the extension methods. The example below shows how to add a property to IWeb as well as a method to IList. import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import { IWeb, Web } from \"@pnp/sp/webs\"; import { ILists, Lists } from \"@pnp/sp/lists\"; import { extendFactory } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // sets up the types correctly when importing across your application declare module \"@pnp/sp/webs/types\" { // we need to extend the interface interface IWeb { orderedLists: ILists; } } // sets up the types correctly when importing across your application declare module \"@pnp/sp/lists/types\" { // we need to extend the interface interface ILists { getOrderedListsQuery: (this: ILists) => ILists; } } extendFactory(Web, { // add an ordered lists property get orderedLists(this: IWeb): ILists { return this.lists.getOrderedListsQuery(); }, }); extendFactory(Lists, { // add an ordered lists property getOrderedListsQuery(this: ILists): ILists { return this.top(10).orderBy(\"Title\").select(\"Title\"); }, }); // regardless of how we access the web and lists collections our extensions remain with all new instance based on const web = Web(\"https://tenant.sharepoint.com/sites/dev/\"); const lists1 = await web.orderedLists(); console.log(JSON.stringify(lists1, null, 2)); const lists2 = await Web(\"https://tenant.sharepoint.com/sites/dev/\").orderedLists(); console.log(JSON.stringify(lists2, null, 2)); const lists3 = await sp.web.orderedLists(); console.log(JSON.stringify(lists3, null, 2)); Instance Registration \u00b6 You can also register Extensions on a single object instance, which is often the preferred approach as it will have less of a performance impact across your whole application. This is useful for debugging, overriding methods/properties, or controlling the behavior of specific object instances. Extensions are not transferred to child objects in a fluent chain, be sure you are extending the instance you think you are. Here we show the same override operation of getByTitle on the lists collection, but safely only overriding the single instance. import { extendObj } from \"@pnp/queryable\"; import { sp, List, ILists } from \"@pnp/sp/presets/all\"; const myExtensions = { getByTitle: function (this: ILists, title: string) { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, \"getByTitle('List2')\"); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; const lists = extendObj(sp.web.lists, myExtensions); const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2)); Enable & Disable Extensions and Clear Global Extensions \u00b6 Extensions are automatically enabled when you set an extension through any of the above outlined methods. You can disable and enable extensions on demand if needed. import { enableExtensions, disableExtensions, clearGlobalExtensions } from \"@pnp/queryable\"; // disable Extensions disableExtensions(); // enable Extensions enableExtensions(); // clear all the globally registered extensions clearGlobalExtensions(); Order of Operations \u00b6 It is important to understand the order in which extensions are executed and when a value is returned. Instance extensions* are always called first, followed by global Extensions - in both cases they are called in the order they were registered. This allows you to perhaps have some global functionality while maintaining the ability to override it again at the instance level. IF an extension returns a value other than undefined that value is returned and no other extensions are processed. *extensions applied via an extended factory are considered instance extensions","title":"Extending an OData library"},{"location":"odata/extensions/#extensions","text":"introduced in 2.0.0 Extending is the concept of overriding or adding functionality into an object or environment without altering the underlying class instances. This can be useful for debugging, testing, or injecting custom functionality. Extensions work with any invocable . You can control any behavior of the library with extensions. Extensions do not work in ie11 compatibility mode. This is by design.","title":"Extensions"},{"location":"odata/extensions/#types-of-extensions","text":"There are three types of Extensions available as well as three methods for registration. You can register any type of extension with any of the registration options.","title":"Types of Extensions"},{"location":"odata/extensions/#function-extensions","text":"The first type is a simple function with a signature: (op: \"apply\" | \"get\" | \"has\" | \"set\", target: T, ...rest: any[]): void This function is passed the current operation as the first argument, currently one of \"apply\", \"get\", \"has\", or \"set\". The second argument is the target instance upon which the operation is being invoked. The remaining parameters vary by the operation being performed, but will match their respective ProxyHandler method signatures.","title":"Function Extensions"},{"location":"odata/extensions/#named-extensions","text":"Named extensions are designed to add or replace a single property or method, though you can register multiple using the same object. These extensions are defined by using an object which has the property/methods you want to override described. Registering named extensions globally will override that operation to all invokables. import { extendFactory } from \"@pnp/queryable\"; import { sp, List, Lists, IWeb, ILists, List, IList, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeQueryStrValue\"; // create a plain object with the props and methods we want to add/change const myExtensions = { // override the lists property get lists(this: IWeb): ILists { // we will always order our lists by title and select just the Title for ALL calls (just as an example) return Lists(this).orderBy(\"Title\").select(\"Title\"); }, // override the getByTitle method getByTitle: function (this: ILists, title: string): IList { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, `getByTitle('List2')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; // register all the named Extensions extendFactory(Web, myExtensions); // this will use our extension to ensure the lists are ordered const lists = await sp.web.lists(); console.log(JSON.stringify(lists, null, 2)); // we will get the items from List1 but within the extension it is rewritten as List2 const items = await sp.web.lists.getByTitle(\"List1\").items(); console.log(JSON.stringify(items.length, null, 2));","title":"Named Extensions"},{"location":"odata/extensions/#proxyhandler-extensions","text":"You can also register a partial ProxyHandler implementation as an extension. You can implement one or more of the ProxyHandler methods as needed. Here we implement the same override of getByTitle globally. This is the most complicated method of creating an extension and assumes an understanding of how ProxyHandlers work. import { extendFactory } from \"@pnp/queryable\"; import { sp, Lists, IWeb, ILists, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeSingleQuote\"; const myExtensions = { get: (target, p: string | number | symbol, _receiver: any) => { switch (p) { case \"getByTitle\": return (title: string) => { // in our example our list has moved, so we rewrite the request on the fly if (title === \"LookupList\") { return List(target, `getByTitle('OrderByList')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(target, `getByTitle('${escapeQueryStrValue(title)}')`); } }; } }, }; extendFactory(Web, myExtensions); const lists = sp.web.lists; const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2));","title":"ProxyHandler Extensions"},{"location":"odata/extensions/#registering-extensions","text":"You can register Extensions either globally, on an invocable factory, or on a per-object basis, and you can register a single extension or an array of Extensions.","title":"Registering Extensions"},{"location":"odata/extensions/#global-registration","text":"Globally registering an extension allows you to inject functionality into every invocable that is instantiated within your application. It is important to remember that processing extensions happens on ALL property access and method invocation operations - so global extensions should be used sparingly. import { extendGlobal } from \"@pnp/queryable\"; // we can add a logging method to very verbosely track what things are called in our application extendGlobal((op: string, _target: any, ...rest: any[]): void => { switch (op) { case \"apply\": Logger.write(`${op} ::> ()`, LogLevel.Info); break; case \"has\": case \"get\": case \"set\": Logger.write(`${op} ::> ${rest[0]}`, LogLevel.Info); break; default: Logger.write(`unknown ${op}`, LogLevel.Info); } });","title":"Global Registration"},{"location":"odata/extensions/#factory-registration","text":"The pattern you will likely find most useful is the ability to extend an invocable factory. This will apply your extensions to all instances created with that factory, meaning all IWebs or ILists will have the extension methods. The example below shows how to add a property to IWeb as well as a method to IList. import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import { IWeb, Web } from \"@pnp/sp/webs\"; import { ILists, Lists } from \"@pnp/sp/lists\"; import { extendFactory } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // sets up the types correctly when importing across your application declare module \"@pnp/sp/webs/types\" { // we need to extend the interface interface IWeb { orderedLists: ILists; } } // sets up the types correctly when importing across your application declare module \"@pnp/sp/lists/types\" { // we need to extend the interface interface ILists { getOrderedListsQuery: (this: ILists) => ILists; } } extendFactory(Web, { // add an ordered lists property get orderedLists(this: IWeb): ILists { return this.lists.getOrderedListsQuery(); }, }); extendFactory(Lists, { // add an ordered lists property getOrderedListsQuery(this: ILists): ILists { return this.top(10).orderBy(\"Title\").select(\"Title\"); }, }); // regardless of how we access the web and lists collections our extensions remain with all new instance based on const web = Web(\"https://tenant.sharepoint.com/sites/dev/\"); const lists1 = await web.orderedLists(); console.log(JSON.stringify(lists1, null, 2)); const lists2 = await Web(\"https://tenant.sharepoint.com/sites/dev/\").orderedLists(); console.log(JSON.stringify(lists2, null, 2)); const lists3 = await sp.web.orderedLists(); console.log(JSON.stringify(lists3, null, 2));","title":"Factory Registration"},{"location":"odata/extensions/#instance-registration","text":"You can also register Extensions on a single object instance, which is often the preferred approach as it will have less of a performance impact across your whole application. This is useful for debugging, overriding methods/properties, or controlling the behavior of specific object instances. Extensions are not transferred to child objects in a fluent chain, be sure you are extending the instance you think you are. Here we show the same override operation of getByTitle on the lists collection, but safely only overriding the single instance. import { extendObj } from \"@pnp/queryable\"; import { sp, List, ILists } from \"@pnp/sp/presets/all\"; const myExtensions = { getByTitle: function (this: ILists, title: string) { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, \"getByTitle('List2')\"); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; const lists = extendObj(sp.web.lists, myExtensions); const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2));","title":"Instance Registration"},{"location":"odata/extensions/#enable-disable-extensions-and-clear-global-extensions","text":"Extensions are automatically enabled when you set an extension through any of the above outlined methods. You can disable and enable extensions on demand if needed. import { enableExtensions, disableExtensions, clearGlobalExtensions } from \"@pnp/queryable\"; // disable Extensions disableExtensions(); // enable Extensions enableExtensions(); // clear all the globally registered extensions clearGlobalExtensions();","title":"Enable &amp; Disable Extensions and Clear Global Extensions"},{"location":"odata/extensions/#order-of-operations","text":"It is important to understand the order in which extensions are executed and when a value is returned. Instance extensions* are always called first, followed by global Extensions - in both cases they are called in the order they were registered. This allows you to perhaps have some global functionality while maintaining the ability to override it again at the instance level. IF an extension returns a value other than undefined that value is returned and no other extensions are processed. *extensions applied via an extended factory are considered instance extensions","title":"Order of Operations"},{"location":"odata/odata-batch/","text":"@pnp/queryable/odatabatch \u00b6 This module contains an abstract class used as a base when inheriting libraries support batching. ODataBatchRequestInfo \u00b6 This interface defines what each batch needs to know about each request. It is generic in that any library can provide the information but will be responsible for processing that info by implementing the abstract executeImpl method. ODataBatch \u00b6 Base class for building batching support for a library inheriting from @pnp/queryable. You can see implementations of this abstract class in the @pnp/sp and @pnp/graph modules.","title":"OData Batching"},{"location":"odata/odata-batch/#pnpqueryableodatabatch","text":"This module contains an abstract class used as a base when inheriting libraries support batching.","title":"@pnp/queryable/odatabatch"},{"location":"odata/odata-batch/#odatabatchrequestinfo","text":"This interface defines what each batch needs to know about each request. It is generic in that any library can provide the information but will be responsible for processing that info by implementing the abstract executeImpl method.","title":"ODataBatchRequestInfo"},{"location":"odata/odata-batch/#odatabatch","text":"Base class for building batching support for a library inheriting from @pnp/queryable. You can see implementations of this abstract class in the @pnp/sp and @pnp/graph modules.","title":"ODataBatch"},{"location":"odata/parsers/","text":"@pnp/queryable/parsers \u00b6 This modules contains a set of generic parsers. These can be used or extended as needed, though it is likely in most cases the default parser will be all you need. ODataDefaultParser \u00b6 The simplest parser used to transform a Response into its JSON representation. The default parser will handle errors in a consistent manner throwing an HttpRequestError instance. This class extends Error and adds the response, status, and statusText properties. The response object is unread. You can use this custom error as shown below to gather more information about what went wrong in the request. import { sp } from \"@pnp/sp\"; import { JSONParser } from \"@pnp/queryable\"; try { const parser = new JSONParser(); // this always throws a 404 error await sp.web.getList(\"doesn't exist\").get(parser); } catch (e) { // we can check for the property \"isHttpRequestError\" to see if this is an instance of our class // this gets by all the many limitations of subclassing Error and type detection in JavaScript if (e.hasOwnProperty(\"isHttpRequestError\")) { console.log(\"e is HttpRequestError\"); // now we can access the various properties and make use of the response object. // at this point the body is unread console.log(`status: ${e.status}`); console.log(`statusText: ${e.statusText}`); const json = await e.response.clone().json(); console.log(JSON.stringify(json)); const text = await e.response.clone().text(); console.log(text); const headers = e.response.headers; } console.error(e); } TextParser \u00b6 Specialized parser used to parse the response using the .text() method with no other processing. Used primarily for files. BlobParser \u00b6 Specialized parser used to parse the response using the .blob() method with no other processing. Used primarily for files. JSONParser \u00b6 Specialized parser used to parse the response using the .json() method with no other processing. Used primarily for files. BufferParser \u00b6 Specialized parser used to parse the response using the .arrayBuffer() [node] for .buffer() [browser] method with no other processing. Used primarily for files. LambdaParser \u00b6 Allows you to pass in any handler function you want, called if the request does not result in an error that transforms the raw, unread request into the result type. import { LambdaParser } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // here a simple parser duplicating the functionality of the JSONParser const parser = new LambdaParser((r: Response) => r.json()); const webDataJson = await sp.web.get(parser); console.log(webDataJson);","title":"Parsers"},{"location":"odata/parsers/#pnpqueryableparsers","text":"This modules contains a set of generic parsers. These can be used or extended as needed, though it is likely in most cases the default parser will be all you need.","title":"@pnp/queryable/parsers"},{"location":"odata/parsers/#odatadefaultparser","text":"The simplest parser used to transform a Response into its JSON representation. The default parser will handle errors in a consistent manner throwing an HttpRequestError instance. This class extends Error and adds the response, status, and statusText properties. The response object is unread. You can use this custom error as shown below to gather more information about what went wrong in the request. import { sp } from \"@pnp/sp\"; import { JSONParser } from \"@pnp/queryable\"; try { const parser = new JSONParser(); // this always throws a 404 error await sp.web.getList(\"doesn't exist\").get(parser); } catch (e) { // we can check for the property \"isHttpRequestError\" to see if this is an instance of our class // this gets by all the many limitations of subclassing Error and type detection in JavaScript if (e.hasOwnProperty(\"isHttpRequestError\")) { console.log(\"e is HttpRequestError\"); // now we can access the various properties and make use of the response object. // at this point the body is unread console.log(`status: ${e.status}`); console.log(`statusText: ${e.statusText}`); const json = await e.response.clone().json(); console.log(JSON.stringify(json)); const text = await e.response.clone().text(); console.log(text); const headers = e.response.headers; } console.error(e); }","title":"ODataDefaultParser"},{"location":"odata/parsers/#textparser","text":"Specialized parser used to parse the response using the .text() method with no other processing. Used primarily for files.","title":"TextParser"},{"location":"odata/parsers/#blobparser","text":"Specialized parser used to parse the response using the .blob() method with no other processing. Used primarily for files.","title":"BlobParser"},{"location":"odata/parsers/#jsonparser","text":"Specialized parser used to parse the response using the .json() method with no other processing. Used primarily for files.","title":"JSONParser"},{"location":"odata/parsers/#bufferparser","text":"Specialized parser used to parse the response using the .arrayBuffer() [node] for .buffer() [browser] method with no other processing. Used primarily for files.","title":"BufferParser"},{"location":"odata/parsers/#lambdaparser","text":"Allows you to pass in any handler function you want, called if the request does not result in an error that transforms the raw, unread request into the result type. import { LambdaParser } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // here a simple parser duplicating the functionality of the JSONParser const parser = new LambdaParser((r: Response) => r.json()); const webDataJson = await sp.web.get(parser); console.log(webDataJson);","title":"LambdaParser"},{"location":"odata/pipeline/","text":"@pnp/queryable/pipeline \u00b6 All of the odata requests processed by @pnp/queryable pass through an extensible request pipeline. Each request is executed in a specific request context defined by the RequestContext<T> interface with the type parameter representing the type ultimately returned at the end a successful processing through the pipeline. Unless you are writing a pipeline method it is unlikely you will ever interact directly with the request pipeline. interface RequestContext<T> \u00b6 The interface that defines the context within which all requests are executed. Note that the pipeline methods to be executed are part of the context. This allows full control over the methods called during a request, and allows for the insertion of any custom methods required. interface RequestContext<T> { batch: ODataBatch; batchDependency: () => void; cachingOptions: ICachingOptions; hasResult?: boolean; isBatched: boolean; isCached: boolean; options: FetchOptions; parser: ODataParser<T>; pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>; requestAbsoluteUrl: string; requestId: string; result?: T; verb: string; clientFactory: () => RequestClient; } requestPipelineMethod decorator \u00b6 The requestPipelineMethod decorator is used to tag a pipeline method and add functionality to bypass processing if a result is already present in the pipeline. If you would like your method to always run regardless of the existence of a result you can pass true to ensure it will always run. Each pipeline method takes a single argument of the current RequestContext and returns a promise resolving to the RequestContext updated as needed. @requestPipelineMethod(true) public static myPipelineMethod<T>(context: RequestContext<T>): Promise<RequestContext<T>> { return new Promise<RequestContext<T>>(resolve => { // do something resolve(context); }); } Default Pipeline \u00b6 logs the start of the request checks the cache for a value based on the context's cache settings sends the request if no value from found in the cache logs the end of the request","title":"Pipeline"},{"location":"odata/pipeline/#pnpqueryablepipeline","text":"All of the odata requests processed by @pnp/queryable pass through an extensible request pipeline. Each request is executed in a specific request context defined by the RequestContext<T> interface with the type parameter representing the type ultimately returned at the end a successful processing through the pipeline. Unless you are writing a pipeline method it is unlikely you will ever interact directly with the request pipeline.","title":"@pnp/queryable/pipeline"},{"location":"odata/pipeline/#interface-requestcontextt","text":"The interface that defines the context within which all requests are executed. Note that the pipeline methods to be executed are part of the context. This allows full control over the methods called during a request, and allows for the insertion of any custom methods required. interface RequestContext<T> { batch: ODataBatch; batchDependency: () => void; cachingOptions: ICachingOptions; hasResult?: boolean; isBatched: boolean; isCached: boolean; options: FetchOptions; parser: ODataParser<T>; pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>; requestAbsoluteUrl: string; requestId: string; result?: T; verb: string; clientFactory: () => RequestClient; }","title":"interface RequestContext&lt;T&gt;"},{"location":"odata/pipeline/#requestpipelinemethod-decorator","text":"The requestPipelineMethod decorator is used to tag a pipeline method and add functionality to bypass processing if a result is already present in the pipeline. If you would like your method to always run regardless of the existence of a result you can pass true to ensure it will always run. Each pipeline method takes a single argument of the current RequestContext and returns a promise resolving to the RequestContext updated as needed. @requestPipelineMethod(true) public static myPipelineMethod<T>(context: RequestContext<T>): Promise<RequestContext<T>> { return new Promise<RequestContext<T>>(resolve => { // do something resolve(context); }); }","title":"requestPipelineMethod decorator"},{"location":"odata/pipeline/#default-pipeline","text":"logs the start of the request checks the cache for a value based on the context's cache settings sends the request if no value from found in the cache logs the end of the request","title":"Default Pipeline"},{"location":"odata/queryable/","text":"@pnp/queryable/queryable \u00b6 The Queryable class is the base class for all of the libraries building fluent request apis. abstract class ODataQueryable<BatchType extends ODataBatch> \u00b6 This class takes a single type parameter representing the type of the batch implementation object. If your api will not support batching you can create a dummy class here and simply not use the batching calls. Properties \u00b6 query \u00b6 Provides access to the query string builder for this url Public Methods \u00b6 concat \u00b6 Directly concatenates the supplied string to the current url, not normalizing \"/\" chars configure \u00b6 Sets custom options for current object and all derived objects accessible via chaining import { ConfigOptions } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; const headers: ConfigOptions = { Accept: 'application/json;odata=nometadata' }; // here we use configure to set the headers value for all child requests of the list instance const list = sp.web.lists.getByTitle(\"List1\").configure({ headers }); // this will use the values set in configure list.items().then(items => console.log(JSON.stringify(items, null, 2)); For reference the ConfigOptions interface is shown below: export interface ConfigOptions { headers?: string[][] | { [key: string]: string } | Headers; mode?: \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\"; credentials?: \"omit\" | \"same-origin\" | \"include\"; cache?: \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\"; } configureFrom \u00b6 Sets custom options from another queryable instance's options. Identical to configure except the options are derived from the supplied instance. usingCaching \u00b6 Enables caching for this request. See caching for more details. import { sp } from \"@pnp/sp\" sp.web.usingCaching()().then(...); inBatch \u00b6 Adds this query to the supplied batch toUrl \u00b6 Gets the current url abstract toUrlAndQuery() \u00b6 When implemented by an inheriting class will build the full url with appropriate query string used to make the actual request get \u00b6 Execute the current request. Takes an optional type parameter allowing for the typing of the value or the user of parsers that will create specific object instances.","title":"Queryable"},{"location":"odata/queryable/#pnpqueryablequeryable","text":"The Queryable class is the base class for all of the libraries building fluent request apis.","title":"@pnp/queryable/queryable"},{"location":"odata/queryable/#abstract-class-odataqueryablebatchtype-extends-odatabatch","text":"This class takes a single type parameter representing the type of the batch implementation object. If your api will not support batching you can create a dummy class here and simply not use the batching calls.","title":"abstract class ODataQueryable&lt;BatchType extends ODataBatch&gt;"},{"location":"odata/queryable/#properties","text":"","title":"Properties"},{"location":"odata/queryable/#query","text":"Provides access to the query string builder for this url","title":"query"},{"location":"odata/queryable/#public-methods","text":"","title":"Public Methods"},{"location":"odata/queryable/#concat","text":"Directly concatenates the supplied string to the current url, not normalizing \"/\" chars","title":"concat"},{"location":"odata/queryable/#configure","text":"Sets custom options for current object and all derived objects accessible via chaining import { ConfigOptions } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; const headers: ConfigOptions = { Accept: 'application/json;odata=nometadata' }; // here we use configure to set the headers value for all child requests of the list instance const list = sp.web.lists.getByTitle(\"List1\").configure({ headers }); // this will use the values set in configure list.items().then(items => console.log(JSON.stringify(items, null, 2)); For reference the ConfigOptions interface is shown below: export interface ConfigOptions { headers?: string[][] | { [key: string]: string } | Headers; mode?: \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\"; credentials?: \"omit\" | \"same-origin\" | \"include\"; cache?: \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\"; }","title":"configure"},{"location":"odata/queryable/#configurefrom","text":"Sets custom options from another queryable instance's options. Identical to configure except the options are derived from the supplied instance.","title":"configureFrom"},{"location":"odata/queryable/#usingcaching","text":"Enables caching for this request. See caching for more details. import { sp } from \"@pnp/sp\" sp.web.usingCaching()().then(...);","title":"usingCaching"},{"location":"odata/queryable/#inbatch","text":"Adds this query to the supplied batch","title":"inBatch"},{"location":"odata/queryable/#tourl","text":"Gets the current url","title":"toUrl"},{"location":"odata/queryable/#abstract-tourlandquery","text":"When implemented by an inheriting class will build the full url with appropriate query string used to make the actual request","title":"abstract toUrlAndQuery()"},{"location":"odata/queryable/#get","text":"Execute the current request. Takes an optional type parameter allowing for the typing of the value or the user of parsers that will create specific object instances.","title":"get"},{"location":"pnpjs/","text":"PnPjs \u00b6 This package is a rollup package of all the other libraries for scenarios where you would prefer to access all of the code from a single file. Examples would be importing a single file into a script editor webpart or using the library in other ways that benefit from a single file. You will not be able to take advantage of selective imports using this bundle. Our recommendation is to import the packages directly into your project, or to create a custom bundle . This package is mostly provided to help folks with backward-compatibility needs. Script Editor Webpart \u00b6 The below is an example of using the pnp.js bundle within a Script Editor webpart. This script editor example is provided for folks on older version of SharePoint - when possible your first choice is SharePoint Framework. You will need to grab the pnp.js bundle file from the dist folder of the pnpjs package and upload it to a location where you can reference it from without your script editor webparts. *This is included as a reference for backward compatibility. The script editor webpart is no longer available in SharePoint online. In addition, see our General Statement on Polyfills and IE11 <script src=\"https://mytenant.sharepoint.com/sites/dev/Shared%20Documents/pnp2bundle/pnp.js\"></script> <!-- Optional to include the IE11 polyfill package --> <script src=\"https://unpkg.com/@pnp/polyfill-ie11\"></script> <script> document.onreadystatechange = async function() { if(document.readyState === \"complete\") { // because this is a UMD bundle there is a global root object named \"pnp\" const a = await pnp.sp.web.lists(); document.getElementById(\"pnpexample\").innerHTML = JSON.stringify(a); } } </script> <div id=\"pnpexample\"></div> Access Library Features \u00b6 Within the bundle all of the classes and methods are exported at the root object, with the exports from sp and graph libraries contained with NS variables to avoid naming conflicts. So if you need to access say the \"Web\" factory you can do so: const web = pnp.SPNS.Web(\"https://something.sharepoint.com\"); const lists = await web.lists(); pnp.GraphNS.* Individual libraries can also be accessed for their exports: pnp.Logger.subscribe(new pnp.ConsoleListener()); pnp.log.write(\"hello\");","title":"pnpjs"},{"location":"pnpjs/#pnpjs","text":"This package is a rollup package of all the other libraries for scenarios where you would prefer to access all of the code from a single file. Examples would be importing a single file into a script editor webpart or using the library in other ways that benefit from a single file. You will not be able to take advantage of selective imports using this bundle. Our recommendation is to import the packages directly into your project, or to create a custom bundle . This package is mostly provided to help folks with backward-compatibility needs.","title":"PnPjs"},{"location":"pnpjs/#script-editor-webpart","text":"The below is an example of using the pnp.js bundle within a Script Editor webpart. This script editor example is provided for folks on older version of SharePoint - when possible your first choice is SharePoint Framework. You will need to grab the pnp.js bundle file from the dist folder of the pnpjs package and upload it to a location where you can reference it from without your script editor webparts. *This is included as a reference for backward compatibility. The script editor webpart is no longer available in SharePoint online. In addition, see our General Statement on Polyfills and IE11 <script src=\"https://mytenant.sharepoint.com/sites/dev/Shared%20Documents/pnp2bundle/pnp.js\"></script> <!-- Optional to include the IE11 polyfill package --> <script src=\"https://unpkg.com/@pnp/polyfill-ie11\"></script> <script> document.onreadystatechange = async function() { if(document.readyState === \"complete\") { // because this is a UMD bundle there is a global root object named \"pnp\" const a = await pnp.sp.web.lists(); document.getElementById(\"pnpexample\").innerHTML = JSON.stringify(a); } } </script> <div id=\"pnpexample\"></div>","title":"Script Editor Webpart"},{"location":"pnpjs/#access-library-features","text":"Within the bundle all of the classes and methods are exported at the root object, with the exports from sp and graph libraries contained with NS variables to avoid naming conflicts. So if you need to access say the \"Web\" factory you can do so: const web = pnp.SPNS.Web(\"https://something.sharepoint.com\"); const lists = await web.lists(); pnp.GraphNS.* Individual libraries can also be accessed for their exports: pnp.Logger.subscribe(new pnp.ConsoleListener()); pnp.log.write(\"hello\");","title":"Access Library Features"},{"location":"sp/","text":"@pnp/sp \u00b6 This package contains the fluent api used to call the SharePoint rest services. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/sp --save Import the library into your application and access the root sp object import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; (function main() { // here we will load the current web's title const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`); )() Getting Started: SharePoint Framework \u00b6 Install the library and required dependencies npm install @pnp/sp --save Import the library into your application, update OnInit, and access the root sp object in render import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; const w = await sp.web.select(\"Title\")(); this.domElement.innerHTML = `Web Title: ${w.Title}`; } Getting Started: Nodejs \u00b6 Install the library and required dependencies npm install @pnp/sp @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { SPFetchClient } from \"@pnp/nodejs\"; // do this once per page load sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{your site url}\", \"{your client id}\", \"{your client secret}\"); }, }, }); // now make any calls you need using the configured client const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`);","title":"sp"},{"location":"sp/#pnpsp","text":"This package contains the fluent api used to call the SharePoint rest services.","title":"@pnp/sp"},{"location":"sp/#getting-started","text":"Install the library and required dependencies npm install @pnp/sp --save Import the library into your application and access the root sp object import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; (function main() { // here we will load the current web's title const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`); )()","title":"Getting Started"},{"location":"sp/#getting-started-sharepoint-framework","text":"Install the library and required dependencies npm install @pnp/sp --save Import the library into your application, update OnInit, and access the root sp object in render import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; const w = await sp.web.select(\"Title\")(); this.domElement.innerHTML = `Web Title: ${w.Title}`; }","title":"Getting Started: SharePoint Framework"},{"location":"sp/#getting-started-nodejs","text":"Install the library and required dependencies npm install @pnp/sp @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { SPFetchClient } from \"@pnp/nodejs\"; // do this once per page load sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{your site url}\", \"{your client id}\", \"{your client secret}\"); }, }, }); // now make any calls you need using the configured client const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`);","title":"Getting Started: Nodejs"},{"location":"sp/alias-parameters/","text":"@pnp/sp - Aliased Parameters \u00b6 Within the @pnp/sp api you can alias any of the parameters so they will be written into the querystring. This is most helpful if you are hitting up against the url length limits when working with files and folders. To alias a parameter you include the label name, a separator (\"::\") and the value in the string. You also need to prepend a \"!\" to the string to trigger the replacement. You can see this below, as well as the string that will be generated. Labels must start with a \"@\" followed by a letter. It is also your responsibility to ensure that the aliases you supply do not conflict, for example if you use \"@p1\" you should use \"@p2\" for a second parameter alias in the same query. Construct a parameter alias \u00b6 Pattern: !@{label name}::{value} Example: \"!@p1::\\sites\\dev\" or \"!@p2::\\text.txt\" Example without aliasing \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // still works as expected, no aliasing const query = sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files?$select=Title&$top=3 const r = await query(); console.log(r);; Example with aliasing \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 const r = await query(); console.log(r); Example with aliasing and batching \u00b6 Aliasing is supported with batching as well: import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing and batching const batch = sp.web.createBatch(); const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 query.inBatch(batch)().then(r => { console.log(r); }); batch.execute();","title":"Alias Parameters"},{"location":"sp/alias-parameters/#pnpsp-aliased-parameters","text":"Within the @pnp/sp api you can alias any of the parameters so they will be written into the querystring. This is most helpful if you are hitting up against the url length limits when working with files and folders. To alias a parameter you include the label name, a separator (\"::\") and the value in the string. You also need to prepend a \"!\" to the string to trigger the replacement. You can see this below, as well as the string that will be generated. Labels must start with a \"@\" followed by a letter. It is also your responsibility to ensure that the aliases you supply do not conflict, for example if you use \"@p1\" you should use \"@p2\" for a second parameter alias in the same query.","title":"@pnp/sp - Aliased Parameters"},{"location":"sp/alias-parameters/#construct-a-parameter-alias","text":"Pattern: !@{label name}::{value} Example: \"!@p1::\\sites\\dev\" or \"!@p2::\\text.txt\"","title":"Construct a parameter alias"},{"location":"sp/alias-parameters/#example-without-aliasing","text":"import { sp } from \"@pnp/sp/presets/all\"; // still works as expected, no aliasing const query = sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files?$select=Title&$top=3 const r = await query(); console.log(r);;","title":"Example without aliasing"},{"location":"sp/alias-parameters/#example-with-aliasing","text":"import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 const r = await query(); console.log(r);","title":"Example with aliasing"},{"location":"sp/alias-parameters/#example-with-aliasing-and-batching","text":"Aliasing is supported with batching as well: import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing and batching const batch = sp.web.createBatch(); const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 query.inBatch(batch)().then(r => { console.log(r); }); batch.execute();","title":"Example with aliasing and batching"},{"location":"sp/alm/","text":"@pnp/sp/appcatalog \u00b6 The ALM api allows you to manage app installations both in the tenant app catalog and individual site app catalogs. Some of the methods are still in beta and as such may change in the future. This article outlines how to call this api using @pnp/sp. Remember all these actions are bound by permissions so it is likely most users will not have the rights to perform these ALM actions. Understanding the App Catalog Hierarchy \u00b6 Before you begin provisioning applications it is important to understand the relationship between a local web catalog and the tenant app catalog. Some of the methods described below only work within the context of the tenant app catalog web, such as adding an app to the catalog and the app actions retract, remove, and deploy. You can install, uninstall, and upgrade an app in any web. Read more in the official documentation . Referencing an App Catalog \u00b6 There are several ways using @pnp/sp to get a reference to an app catalog. These methods are to provide you the greatest amount of flexibility in gaining access to the app catalog. Ultimately each method produces an AppCatalog instance differentiated only by the web to which it points. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // get the current context web's app catalog const catalog = await sp.web.getAppCatalog()(); // you can also chain off the app catalog const apps = await sp.web.getAppCatalog()(); console.log(apps); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // you can get the tenant app catalog (or any app catalog) by using the getTenantAppCatalogWeb method const appCatWeb = await sp.getTenantAppCatalogWeb()(); const appCatalog = await appCatWeb.getAppCatalog()(); // you can get the tenant app catalog (or any app catalog) by passing in a url // get the tenant app catalog const tenantCatalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/appcatalog\")(); // get a different app catalog const catalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/anothersite\")(); // alternatively you can create a new app catalog instance directly by importing the AppCatalog class import { IAppCatalog, AppCatalog } from '@pnp/sp/appcatalog'; const catalog: IAppCatalog = await AppCatalog(\"https://mytenant.sharepoint.com/sites/apps\")(); // and finally you can combine use of the Web and AppCatalog classes to create an AppCatalog instance from an existing Web import { Web } from '@pnp/sp/webs'; import { AppCatalog } from '@pnp/sp/appcatalog'; const web = Web(\"https://mytenant.sharepoint.com/sites/apps\"); const catalog = await AppCatalog(web)(); The following examples make use of a variable \"catalog\" which is assumed to represent an AppCatalog instance obtained using one of the above methods, supporting code is omitted for brevity. List Available Apps \u00b6 The AppCatalog is itself a queryable collection so you can query this object directly to get a list of available apps. Also, the odata operators work on the catalog to sort, filter, and select. // get available apps await catalog(); // get available apps selecting two fields await catalog.select(\"Title\", \"Deployed\")(); Add an App \u00b6 This action must be performed in the context of the tenant app catalog // this represents the file bytes of the app package file const blob = new Blob(); // there is an optional third argument to control overwriting existing files const r = await catalog.add(\"myapp.app\", blob); // this is at its core a file add operation so you have access to the response data as well // as a File instance representing the created file console.log(JSON.stringify(r.data, null, 4)); // all file operations are available const nameData = await r.file.select(\"Name\")(); Get an App \u00b6 You can get the details of a single app by GUID id. This is also the branch point to perform specific app actions const app = await catalog.getAppById(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\")(); Perform app actions \u00b6 Remember: retract, deploy, and remove only work in the context of the tenant app catalog web. All of these methods return void and you can monitor success by wrapping the call in a try/catch block. const myAppId = \"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"; // deploy await catalog.getAppById(myAppId).deploy(); // retract await catalog.getAppById(myAppId).retract(); // install await catalog.getAppById(myAppId).install(); // uninstall await catalog.getAppById(myAppId).uninstall(); // upgrade await catalog.getAppById(myAppId).upgrade(); // remove await catalog.getAppById(myAppId).remove(); Synchronize a solution/app to the Microsoft Teams App Catalog \u00b6 By default this REST call requires the SharePoint item id of the app, not the app id. PnPjs will try to fetch the SharePoint item id by default. You can still use this the second parameter useSharePointItemId to pass your own item id in the first parameter id . // Using the app id await catalog.syncSolutionToTeams(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"); // Using the SharePoint apps item id await catalog.syncSolutionToTeams(\"123\", true); Notes \u00b6 The app catalog is just a document library under the hood, so you can also perform non-ALM actions on the library if needed. But you should be aware of possible side-effects to the ALM life-cycle when doing so.","title":"ALM api"},{"location":"sp/alm/#pnpspappcatalog","text":"The ALM api allows you to manage app installations both in the tenant app catalog and individual site app catalogs. Some of the methods are still in beta and as such may change in the future. This article outlines how to call this api using @pnp/sp. Remember all these actions are bound by permissions so it is likely most users will not have the rights to perform these ALM actions.","title":"@pnp/sp/appcatalog"},{"location":"sp/alm/#understanding-the-app-catalog-hierarchy","text":"Before you begin provisioning applications it is important to understand the relationship between a local web catalog and the tenant app catalog. Some of the methods described below only work within the context of the tenant app catalog web, such as adding an app to the catalog and the app actions retract, remove, and deploy. You can install, uninstall, and upgrade an app in any web. Read more in the official documentation .","title":"Understanding the App Catalog Hierarchy"},{"location":"sp/alm/#referencing-an-app-catalog","text":"There are several ways using @pnp/sp to get a reference to an app catalog. These methods are to provide you the greatest amount of flexibility in gaining access to the app catalog. Ultimately each method produces an AppCatalog instance differentiated only by the web to which it points. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // get the current context web's app catalog const catalog = await sp.web.getAppCatalog()(); // you can also chain off the app catalog const apps = await sp.web.getAppCatalog()(); console.log(apps); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // you can get the tenant app catalog (or any app catalog) by using the getTenantAppCatalogWeb method const appCatWeb = await sp.getTenantAppCatalogWeb()(); const appCatalog = await appCatWeb.getAppCatalog()(); // you can get the tenant app catalog (or any app catalog) by passing in a url // get the tenant app catalog const tenantCatalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/appcatalog\")(); // get a different app catalog const catalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/anothersite\")(); // alternatively you can create a new app catalog instance directly by importing the AppCatalog class import { IAppCatalog, AppCatalog } from '@pnp/sp/appcatalog'; const catalog: IAppCatalog = await AppCatalog(\"https://mytenant.sharepoint.com/sites/apps\")(); // and finally you can combine use of the Web and AppCatalog classes to create an AppCatalog instance from an existing Web import { Web } from '@pnp/sp/webs'; import { AppCatalog } from '@pnp/sp/appcatalog'; const web = Web(\"https://mytenant.sharepoint.com/sites/apps\"); const catalog = await AppCatalog(web)(); The following examples make use of a variable \"catalog\" which is assumed to represent an AppCatalog instance obtained using one of the above methods, supporting code is omitted for brevity.","title":"Referencing an App Catalog"},{"location":"sp/alm/#list-available-apps","text":"The AppCatalog is itself a queryable collection so you can query this object directly to get a list of available apps. Also, the odata operators work on the catalog to sort, filter, and select. // get available apps await catalog(); // get available apps selecting two fields await catalog.select(\"Title\", \"Deployed\")();","title":"List Available Apps"},{"location":"sp/alm/#add-an-app","text":"This action must be performed in the context of the tenant app catalog // this represents the file bytes of the app package file const blob = new Blob(); // there is an optional third argument to control overwriting existing files const r = await catalog.add(\"myapp.app\", blob); // this is at its core a file add operation so you have access to the response data as well // as a File instance representing the created file console.log(JSON.stringify(r.data, null, 4)); // all file operations are available const nameData = await r.file.select(\"Name\")();","title":"Add an App"},{"location":"sp/alm/#get-an-app","text":"You can get the details of a single app by GUID id. This is also the branch point to perform specific app actions const app = await catalog.getAppById(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\")();","title":"Get an App"},{"location":"sp/alm/#perform-app-actions","text":"Remember: retract, deploy, and remove only work in the context of the tenant app catalog web. All of these methods return void and you can monitor success by wrapping the call in a try/catch block. const myAppId = \"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"; // deploy await catalog.getAppById(myAppId).deploy(); // retract await catalog.getAppById(myAppId).retract(); // install await catalog.getAppById(myAppId).install(); // uninstall await catalog.getAppById(myAppId).uninstall(); // upgrade await catalog.getAppById(myAppId).upgrade(); // remove await catalog.getAppById(myAppId).remove();","title":"Perform app actions"},{"location":"sp/alm/#synchronize-a-solutionapp-to-the-microsoft-teams-app-catalog","text":"By default this REST call requires the SharePoint item id of the app, not the app id. PnPjs will try to fetch the SharePoint item id by default. You can still use this the second parameter useSharePointItemId to pass your own item id in the first parameter id . // Using the app id await catalog.syncSolutionToTeams(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"); // Using the SharePoint apps item id await catalog.syncSolutionToTeams(\"123\", true);","title":"Synchronize a solution/app to the Microsoft Teams App Catalog"},{"location":"sp/alm/#notes","text":"The app catalog is just a document library under the hood, so you can also perform non-ALM actions on the library if needed. But you should be aware of possible side-effects to the ALM life-cycle when doing so.","title":"Notes"},{"location":"sp/attachments/","text":"@pnp/sp/attachments \u00b6 The ability to attach file to list items allows users to track documents outside of a document library. You can use the PnP JS Core library to work with attachments as outlined below. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/attachments\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\"; Get attachments \u00b6 import { sp } from \"@pnp/sp\"; import { IAttachmentInfo } from \"@pnp/sp/attachments\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); // get all the attachments const info: IAttachmentInfo[] = await item.attachmentFiles(); // get a single file by file name const info2: IAttachmentInfo = await item.attachmentFiles.getByName(\"file.txt\")(); // select specific properties using odata operators and use Pick to type the result const info3: Pick<IAttachmentInfo, \"ServerRelativeUrl\">[] = await item.attachmentFiles.select(\"ServerRelativeUrl\")(); Add an Attachment \u00b6 You can add an attachment to a list item using the add method. This method takes either a string, Blob, or ArrayBuffer. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.add(\"file2.txt\", \"Here is my content\"); Add Multiple \u00b6 This method allows you to pass an array of AttachmentFileInfo plain objects that will be added one at a time as attachments. Essentially automating the promise chaining. import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists\"; import { IAttachmentFileInfo } from \"@pnp/sp/attachments\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); let fileInfos: IAttachmentFileInfo[] = []; fileInfos.push({ name: \"My file name 1\", content: \"string, blob, or array\" }); fileInfos.push({ name: \"My file name 2\", content: \"string, blob, or array\" }); await list.items.getById(2).attachmentFiles.addMultiple(fileInfos); Delete Multiple \u00b6 import { sp } from \"@pnp/sp\"; import { IList } from \"./@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.deleteMultiple(\"1.txt\", \"2.txt\"); Read Attachment Content \u00b6 You can read the content of an attachment as a string, Blob, ArrayBuffer, or json using the methods supplied. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); const text = await item.attachmentFiles.getByName(\"file.txt\").getText(); // use this in the browser, does not work in nodejs const blob = await item.attachmentFiles.getByName(\"file.mp4\").getBlob(); // use this in nodejs const buffer = await item.attachmentFiles.getByName(\"file.mp4\").getBuffer(); // file must be valid json const json = await item.attachmentFiles.getByName(\"file.json\").getJSON(); Update Attachment Content \u00b6 You can also update the content of an attachment. This API is limited compared to the full file API - so if you need to upload large files consider using a document library. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").setContent(\"My new content!!!\"); Delete Attachment \u00b6 import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").delete(); Recycle Attachment \u00b6 Delete the attachment and send it to recycle bin import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").recycle(); Recycle Multiple Attachments \u00b6 Delete multiple attachments and send them to recycle bin import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.recycleMultiple(\"1.txt\",\"2.txt\");","title":"Attachments"},{"location":"sp/attachments/#pnpspattachments","text":"The ability to attach file to list items allows users to track documents outside of a document library. You can use the PnP JS Core library to work with attachments as outlined below. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/attachments\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/attachments"},{"location":"sp/attachments/#get-attachments","text":"import { sp } from \"@pnp/sp\"; import { IAttachmentInfo } from \"@pnp/sp/attachments\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); // get all the attachments const info: IAttachmentInfo[] = await item.attachmentFiles(); // get a single file by file name const info2: IAttachmentInfo = await item.attachmentFiles.getByName(\"file.txt\")(); // select specific properties using odata operators and use Pick to type the result const info3: Pick<IAttachmentInfo, \"ServerRelativeUrl\">[] = await item.attachmentFiles.select(\"ServerRelativeUrl\")();","title":"Get attachments"},{"location":"sp/attachments/#add-an-attachment","text":"You can add an attachment to a list item using the add method. This method takes either a string, Blob, or ArrayBuffer. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.add(\"file2.txt\", \"Here is my content\");","title":"Add an Attachment"},{"location":"sp/attachments/#add-multiple","text":"This method allows you to pass an array of AttachmentFileInfo plain objects that will be added one at a time as attachments. Essentially automating the promise chaining. import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists\"; import { IAttachmentFileInfo } from \"@pnp/sp/attachments\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); let fileInfos: IAttachmentFileInfo[] = []; fileInfos.push({ name: \"My file name 1\", content: \"string, blob, or array\" }); fileInfos.push({ name: \"My file name 2\", content: \"string, blob, or array\" }); await list.items.getById(2).attachmentFiles.addMultiple(fileInfos);","title":"Add Multiple"},{"location":"sp/attachments/#delete-multiple","text":"import { sp } from \"@pnp/sp\"; import { IList } from \"./@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.deleteMultiple(\"1.txt\", \"2.txt\");","title":"Delete Multiple"},{"location":"sp/attachments/#read-attachment-content","text":"You can read the content of an attachment as a string, Blob, ArrayBuffer, or json using the methods supplied. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); const text = await item.attachmentFiles.getByName(\"file.txt\").getText(); // use this in the browser, does not work in nodejs const blob = await item.attachmentFiles.getByName(\"file.mp4\").getBlob(); // use this in nodejs const buffer = await item.attachmentFiles.getByName(\"file.mp4\").getBuffer(); // file must be valid json const json = await item.attachmentFiles.getByName(\"file.json\").getJSON();","title":"Read Attachment Content"},{"location":"sp/attachments/#update-attachment-content","text":"You can also update the content of an attachment. This API is limited compared to the full file API - so if you need to upload large files consider using a document library. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").setContent(\"My new content!!!\");","title":"Update Attachment Content"},{"location":"sp/attachments/#delete-attachment","text":"import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").delete();","title":"Delete Attachment"},{"location":"sp/attachments/#recycle-attachment","text":"Delete the attachment and send it to recycle bin import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").recycle();","title":"Recycle Attachment"},{"location":"sp/attachments/#recycle-multiple-attachments","text":"Delete multiple attachments and send them to recycle bin import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.recycleMultiple(\"1.txt\",\"2.txt\");","title":"Recycle Multiple Attachments"},{"location":"sp/clientside-pages/","text":"@pnp/sp/clientside-pages \u00b6 The 'clientside-pages' module allows you to create, edit, and delete modern SharePoint pages. There are methods to update the page settings and add/remove client-side web parts. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/clientside-pages\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/clientside-pages\"; Preset: All import { sp, ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/presets/all\"; Create a new Page \u00b6 You can create a new client-side page in several ways, all are equivalent. Create using IWeb.addClientsidePage \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { PromotedState } from \"@pnp/sp/clientside-pages\"; // Create a page providing a file name const page = await sp.web.addClientsidePage(\"mypage1\"); // ... other operations on the page as outlined below // the page is initially not published, you must publish it so it appears for others users await page.save(); // include title and page layout const page2 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // include title, page layout, and specifying the publishing status (Added in 2.0.4) const page3 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page3.save(); Create using CreateClientsidePage method \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import { CreateClientsidePage, PromotedState } from \"@pnp/sp/clientside-pages\"; const page1 = await CreateClientsidePage(sp.web, \"mypage2\", \"My Page Title\"); // you must publish the new page await page1.save(true); // specify the page layout type parameter const page2 = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // specify the page layout type parameter while also specifying the publishing status (Added in 2.0.4) const page2half = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page2half.save(); // use the web factory to create a page in a specific web const page3 = await CreateClientsidePage(Web(\"https://{absolute web url}\"), \"mypage4\", \"My Page Title\"); // you must publish the new page await page3.save(); Load Pages \u00b6 There are a few ways to load pages, each of which results in an IClientsidePage instance being returned. Load using IWeb.loadClientsidePage \u00b6 This method takes a server relative path to the page to load. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // use from the sp.web fluent chain const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); // use the web factory to target a specific web const page2 = await Web(\"https://{absolute web url}\").loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); Load using ClientsidePageFromFile \u00b6 This method takes an IFile instance and loads an IClientsidePage instance. import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const page = await ClientsidePageFromFile(sp.web.getFileByServerRelativePath(\"/sites/dev/sitepages/mypage3.aspx\")); Edit Sections and Columns \u00b6 Client-side pages are made up of sections, columns, and controls. Sections contain columns which contain controls. There are methods to operate on these within the page, in addition to the standard array methods available in JavaScript. These samples use a variable page that is understood to be an IClientsidePage instance which is either created or loaded as outlined in previous sections. // our page instance const page: IClientsidePage; // add two columns with factor 6 - this is a two column layout as the total factor in a section should add up to 12 const section1 = page.addSection(); section1.addColumn(6); section1.addColumn(6); // create a three column layout in a new section const section2 = page.addSection(); section2.addColumn(4); section2.addColumn(4); section2.addColumn(4); // publish our changes await page.save(); Manipulate Sections and Columns \u00b6 // our page instance const page: IClientsidePage; // drop all the columns in this section // this will also DELETE all controls contained in the columns page.sections[1].columns.length = 0; // create a new column layout page.sections[1].addColumn(4); page.sections[1].addColumn(8); // publish our changes await page.save(); Vertical Section \u00b6 The vertical section, if on the page, is stored within the sections array. However, you access it slightly differently to make things easier. // our page instance const page: IClientsidePage; // add or get a vertical section (handles case where section already exists) const vertSection = page.addVerticalSection(); // **************************************************************** // if you know or want to test if a vertical section is present: if (page.hasVerticalSection) { // access the vertical section (this method will NOT create the section if it does not exist) page.verticalSection.addControl(new ClientsideText(\"hello\")); } else { const vertSection = page.addVerticalSection(); vertSection.addControl(new ClientsideText(\"hello\")); } Reorder Sections \u00b6 // our page instance const page: IClientsidePage; // swap the order of two sections // this will preserve the controls within the columns page.sections = [page.sections[1], page.sections[0]]; // publish our changes await page.save(); Reorder Columns \u00b6 The sections and columns are arrays, so normal array operations work as expected // our page instance const page: IClientsidePage; // swap the order of two columns // this will preserve the controls within the columns page.sections[1].columns = [page.sections[1].columns[1], page.sections[1].columns[0]]; // publish our changes await page.save(); Clientside Controls \u00b6 Once you have your sections and columns defined you will want to add/edit controls within those columns. Add Text Content \u00b6 import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; page.addSection().addControl(new ClientsideText(\"@pnp/sp is a great library!\")); await page.save(); Add Controls \u00b6 Adding controls involves loading the available client-side part definitions from the server or creating a text part. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // this will be a ClientsidePageComponent array // this can be cached on the client in production scenarios const partDefs = await sp.web.getClientsideWebParts(); // find the definition we want, here by id const partDef = partDefs.filter(c => c.Id === \"490d7c76-1824-45b2-9de3-676421c997fa\"); // optionally ensure you found the def if (partDef.length < 1) { // we didn't find it so we throw an error throw new Error(\"Could not find the web part\"); } // create a ClientWebPart instance from the definition const part = ClientsideWebpart.fromComponentDef(partDef[0]); // set the properties on the web part. Here for the embed web part we only have to supply an embedCode - in this case a YouTube video. // the structure of the properties varies for each web part and each version of a web part, so you will need to ensure you are setting // the properties correctly part.setProperties<{ embedCode: string }>({ embedCode: \"https://www.youtube.com/watch?v=IWQFZ7Lx-rg\", }); // we add that part to a new section page.addSection().addControl(part); await page.save(); Handle Different Webpart's Settings \u00b6 There are many ways that client side web parts are implemented and we can't provide handling within the library for all possibilities. This example shows how to handle a property set within the serverProcessedContent, in this case a List part's display title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // we create a class to wrap our functionality in a reusable way class ListWebpart extends ClientsideWebpart { constructor(control: ClientsideWebpart) { super((<any>control).json); } // add property getter/setter for what we need, in this case \"listTitle\" within searchablePlainTexts public get DisplayTitle(): string { return this.json.webPartData?.serverProcessedContent?.searchablePlainTexts?.listTitle || \"\"; } public set DisplayTitle(value: string) { this.json.webPartData.serverProcessedContent.searchablePlainTexts.listTitle = value; } } // now we load our page const page = await sp.web.loadClientsidePage(\"/sites/dev/SitePages/List-Web-Part.aspx\"); // get our part and pass it to the constructor of our wrapper class const part = new ListWebpart(page.sections[0].columns[0].getControl(0)); part.DisplayTitle = \"My New Title!\"; await page.save(); Unfortunately each webpart can be authored differently, so there isn't a way to know how the setting for a given webpart are stored without loading it and examining the properties. Page Operations \u00b6 There are other operation you can perform on a page in addition to manipulating the content. pageLayout \u00b6 You can get and set the page layout. Changing the layout after creating the page may have side effects and should be done cautiously. // our page instance const page: IClientsidePage; // get the current value const value = page.pageLayout; // set the value page.pageLayout = \"Article\"; await page.save(); bannerImageUrl \u00b6 // our page instance const page: IClientsidePage; // get the current value const value = page.bannerImageUrl; // set the value page.bannerImageUrl = \"/server/relative/path/to/image.png\"; await page.save(); Banner images need to exist within the same site collection as the page where you want to use them. thumbnailUrl \u00b6 Allows you to set the thumbnail used for the page independently of the banner. If you set the bannerImageUrl property and not thumbnailUrl the thumbnail will be reset to match the banner, mimicking the UI functionality. // our page instance const page: IClientsidePage; // get the current value const value = page.thumbnailUrl; // set the value page.thumbnailUrl = \"/server/relative/path/to/image.png\"; await page.save(); topicHeader \u00b6 // our page instance const page: IClientsidePage; // get the current value const value = page.topicHeader; // set the value page.topicHeader = \"My cool header!\"; await page.save(); // clear the topic header and hide it page.topicHeader = \"\"; await page.save(); title \u00b6 // our page instance const page: IClientsidePage; // get the current value const value = page.title; // set the value page.title = \"My page title\"; await page.save(); description \u00b6 Descriptions are limited to 255 chars // our page instance const page: IClientsidePage; // get the current value const value = page.description; // set the value page.description = \"A description\"; await page.save(); layoutType \u00b6 Sets the layout type of the page. The valid values are: \"FullWidthImage\", \"NoImage\", \"ColorBlock\", \"CutInShape\" // our page instance const page: IClientsidePage; // get the current value const value = page.layoutType; // set the value page.layoutType = \"ColorBlock\"; await page.save(); headerTextAlignment \u00b6 Sets the header text alignment to one of \"Left\" or \"Center\" // our page instance const page: IClientsidePage; // get the current value const value = page.headerTextAlignment; // set the value page.headerTextAlignment = \"Center\"; await page.save(); showTopicHeader \u00b6 Sets if the topic header is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showTopicHeader; // show the header page.showTopicHeader = true; await page.save(); // hide the header page.showTopicHeader = false; await page.save(); showPublishDate \u00b6 Sets if the publish date is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showPublishDate; // show the date page.showPublishDate = true; await page.save(); // hide the date page.showPublishDate = false; await page.save(); Get / Set author details \u00b6 Added in 2.0.4 // our page instance const page: IClientsidePage; // get the author details (string | null) const value = page.authorByLine; // set the author by user id const user = await web.currentUser.select(\"Id\", \"LoginName\")(); const userId = user.Id; const userLogin = user.LoginName; await page.setAuthorById(userId); await page.save(); await page.setAuthorByLoginName(userLogin); await page.save(); you must still save the page after setting the author to persist your changes as shown in the example. load \u00b6 Loads the page from the server. This will overwrite any local unsaved changes. // our page instance const page: IClientsidePage; await page.load(); save \u00b6 Saves any changes to the page, optionally keeping them in draft state. // our page instance const page: IClientsidePage; // changes are published await page.save(); // changes remain in draft await page.save(false); discardPageCheckout \u00b6 Discards any current checkout of the page by the current user. // our page instance const page: IClientsidePage; await page.discardPageCheckout(); promoteToNews \u00b6 Promotes the page as a news article. // our page instance const page: IClientsidePage; await page.promoteToNews(); enableComments & disableComments \u00b6 Used to control the availability of comments on a page. // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments(); findControlById \u00b6 Finds a control within the page by id. import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; const control = page.findControlById(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\"); // you can also type the control const control = page.findControlById<ClientsideText>(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\"); findControl \u00b6 Finds a control within the page using the supplied delegate. Can also be used to iterate through all controls in the page. // our page instance const page: IClientsidePage; // find the first control whose order is 9 const control = page.findControl((c) => c.order === 9); // iterate all the controls and output the id to the console page.findControl((c) => { console.log(c.id); return false; }); like & unlike \u00b6 Updates the page's like value for the current user. // our page instance const page: IClientsidePage; // like this page await page.like(); // unlike this page await page.unlike(); getLikedByInformation \u00b6 Gets the likes information for this page. // our page instance const page: IClientsidePage; const info = await page.getLikedByInformation(); copy \u00b6 Creates a copy of the page, including all controls. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instance const page: IClientsidePage; // creates a published copy of the page const pageCopy = await page.copy(sp.web, \"newpagename\", \"New Page Title\"); // creates a draft (unpublished) copy of the page const pageCopy2 = await page.copy(sp.web, \"newpagename\", \"New Page Title\", false); // edits to pageCopy2 ... // publish the page pageCopy2.save(); copyTo \u00b6 Copies the contents of a page to another existing page instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instances, loaded in any of the ways shown above const source: IClientsidePage; const target: IClientsidePage; const target2: IClientsidePage; // creates a published copy of the page await source.copyTo(target); // creates a draft (unpublished) copy of the page await source.copyTo(target2, false); // edits to target2... // publish the page target2.save(); setBannerImage \u00b6 Sets the banner image url and optionally additional properties. Allows you to set additional properties if needed, if you do not need to set the additional properties they are equivalent. Banner images need to exist within the same site collection as the page where you want to use them. // our page instance const page: IClientsidePage; page.setBannerImage(\"/server/relative/path/to/image.png\"); // save the changes await page.save(); // set additional props page.setBannerImage(\"/server/relative/path/to/image.png\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save(); This sample shows the full process of adding a page, image file, and setting the banner image in nodejs. The same code would work in a browser with an update on how you get the file - likely from a file input or similar. import { SPFetchClient } from \"@pnp/nodejs\"; import { join } from \"path\"; import { readFileSync } from \"fs\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/clientside-pages\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{Site Url}\", \"{Client Id}\", \"{Client Secret}\"); }, }, }); // add the banner image const dirname = join(\"C:/path/to/file\", \"img-file.jpg\"); const file: Uint8Array = new Uint8Array(readFileSync(dirname)); const far = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents\").files.add(\"banner.jpg\", file, true); // add the page const page = await sp.web.addClientsidePage(\"MyPage\", \"Page Title\"); // set the banner image page.setBannerImage(far.data.ServerRelativeUrl); // publish the page await page.save(); setBannerImageFromExternalUrl \u00b6 Added in 2.0.12 Allows you to set the banner image from a source outside the current site collection. The image file will be copied to the SiteAssets library and referenced from there. // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\"); // save the changes await page.save(); You can optionally supply additional props for the banner image, these match the properties when calling setBannerImage // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save();","title":"Client-side Pages"},{"location":"sp/clientside-pages/#pnpspclientside-pages","text":"The 'clientside-pages' module allows you to create, edit, and delete modern SharePoint pages. There are methods to update the page settings and add/remove client-side web parts. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/clientside-pages\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/clientside-pages\"; Preset: All import { sp, ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/clientside-pages"},{"location":"sp/clientside-pages/#create-a-new-page","text":"You can create a new client-side page in several ways, all are equivalent.","title":"Create a new Page"},{"location":"sp/clientside-pages/#create-using-iwebaddclientsidepage","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { PromotedState } from \"@pnp/sp/clientside-pages\"; // Create a page providing a file name const page = await sp.web.addClientsidePage(\"mypage1\"); // ... other operations on the page as outlined below // the page is initially not published, you must publish it so it appears for others users await page.save(); // include title and page layout const page2 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // include title, page layout, and specifying the publishing status (Added in 2.0.4) const page3 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page3.save();","title":"Create using IWeb.addClientsidePage"},{"location":"sp/clientside-pages/#create-using-createclientsidepage-method","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import { CreateClientsidePage, PromotedState } from \"@pnp/sp/clientside-pages\"; const page1 = await CreateClientsidePage(sp.web, \"mypage2\", \"My Page Title\"); // you must publish the new page await page1.save(true); // specify the page layout type parameter const page2 = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // specify the page layout type parameter while also specifying the publishing status (Added in 2.0.4) const page2half = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page2half.save(); // use the web factory to create a page in a specific web const page3 = await CreateClientsidePage(Web(\"https://{absolute web url}\"), \"mypage4\", \"My Page Title\"); // you must publish the new page await page3.save();","title":"Create using CreateClientsidePage method"},{"location":"sp/clientside-pages/#load-pages","text":"There are a few ways to load pages, each of which results in an IClientsidePage instance being returned.","title":"Load Pages"},{"location":"sp/clientside-pages/#load-using-iwebloadclientsidepage","text":"This method takes a server relative path to the page to load. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // use from the sp.web fluent chain const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); // use the web factory to target a specific web const page2 = await Web(\"https://{absolute web url}\").loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\");","title":"Load using IWeb.loadClientsidePage"},{"location":"sp/clientside-pages/#load-using-clientsidepagefromfile","text":"This method takes an IFile instance and loads an IClientsidePage instance. import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const page = await ClientsidePageFromFile(sp.web.getFileByServerRelativePath(\"/sites/dev/sitepages/mypage3.aspx\"));","title":"Load using ClientsidePageFromFile"},{"location":"sp/clientside-pages/#edit-sections-and-columns","text":"Client-side pages are made up of sections, columns, and controls. Sections contain columns which contain controls. There are methods to operate on these within the page, in addition to the standard array methods available in JavaScript. These samples use a variable page that is understood to be an IClientsidePage instance which is either created or loaded as outlined in previous sections. // our page instance const page: IClientsidePage; // add two columns with factor 6 - this is a two column layout as the total factor in a section should add up to 12 const section1 = page.addSection(); section1.addColumn(6); section1.addColumn(6); // create a three column layout in a new section const section2 = page.addSection(); section2.addColumn(4); section2.addColumn(4); section2.addColumn(4); // publish our changes await page.save();","title":"Edit Sections and Columns"},{"location":"sp/clientside-pages/#manipulate-sections-and-columns","text":"// our page instance const page: IClientsidePage; // drop all the columns in this section // this will also DELETE all controls contained in the columns page.sections[1].columns.length = 0; // create a new column layout page.sections[1].addColumn(4); page.sections[1].addColumn(8); // publish our changes await page.save();","title":"Manipulate Sections and Columns"},{"location":"sp/clientside-pages/#vertical-section","text":"The vertical section, if on the page, is stored within the sections array. However, you access it slightly differently to make things easier. // our page instance const page: IClientsidePage; // add or get a vertical section (handles case where section already exists) const vertSection = page.addVerticalSection(); // **************************************************************** // if you know or want to test if a vertical section is present: if (page.hasVerticalSection) { // access the vertical section (this method will NOT create the section if it does not exist) page.verticalSection.addControl(new ClientsideText(\"hello\")); } else { const vertSection = page.addVerticalSection(); vertSection.addControl(new ClientsideText(\"hello\")); }","title":"Vertical Section"},{"location":"sp/clientside-pages/#reorder-sections","text":"// our page instance const page: IClientsidePage; // swap the order of two sections // this will preserve the controls within the columns page.sections = [page.sections[1], page.sections[0]]; // publish our changes await page.save();","title":"Reorder Sections"},{"location":"sp/clientside-pages/#reorder-columns","text":"The sections and columns are arrays, so normal array operations work as expected // our page instance const page: IClientsidePage; // swap the order of two columns // this will preserve the controls within the columns page.sections[1].columns = [page.sections[1].columns[1], page.sections[1].columns[0]]; // publish our changes await page.save();","title":"Reorder Columns"},{"location":"sp/clientside-pages/#clientside-controls","text":"Once you have your sections and columns defined you will want to add/edit controls within those columns.","title":"Clientside Controls"},{"location":"sp/clientside-pages/#add-text-content","text":"import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; page.addSection().addControl(new ClientsideText(\"@pnp/sp is a great library!\")); await page.save();","title":"Add Text Content"},{"location":"sp/clientside-pages/#add-controls","text":"Adding controls involves loading the available client-side part definitions from the server or creating a text part. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // this will be a ClientsidePageComponent array // this can be cached on the client in production scenarios const partDefs = await sp.web.getClientsideWebParts(); // find the definition we want, here by id const partDef = partDefs.filter(c => c.Id === \"490d7c76-1824-45b2-9de3-676421c997fa\"); // optionally ensure you found the def if (partDef.length < 1) { // we didn't find it so we throw an error throw new Error(\"Could not find the web part\"); } // create a ClientWebPart instance from the definition const part = ClientsideWebpart.fromComponentDef(partDef[0]); // set the properties on the web part. Here for the embed web part we only have to supply an embedCode - in this case a YouTube video. // the structure of the properties varies for each web part and each version of a web part, so you will need to ensure you are setting // the properties correctly part.setProperties<{ embedCode: string }>({ embedCode: \"https://www.youtube.com/watch?v=IWQFZ7Lx-rg\", }); // we add that part to a new section page.addSection().addControl(part); await page.save();","title":"Add Controls"},{"location":"sp/clientside-pages/#handle-different-webparts-settings","text":"There are many ways that client side web parts are implemented and we can't provide handling within the library for all possibilities. This example shows how to handle a property set within the serverProcessedContent, in this case a List part's display title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // we create a class to wrap our functionality in a reusable way class ListWebpart extends ClientsideWebpart { constructor(control: ClientsideWebpart) { super((<any>control).json); } // add property getter/setter for what we need, in this case \"listTitle\" within searchablePlainTexts public get DisplayTitle(): string { return this.json.webPartData?.serverProcessedContent?.searchablePlainTexts?.listTitle || \"\"; } public set DisplayTitle(value: string) { this.json.webPartData.serverProcessedContent.searchablePlainTexts.listTitle = value; } } // now we load our page const page = await sp.web.loadClientsidePage(\"/sites/dev/SitePages/List-Web-Part.aspx\"); // get our part and pass it to the constructor of our wrapper class const part = new ListWebpart(page.sections[0].columns[0].getControl(0)); part.DisplayTitle = \"My New Title!\"; await page.save(); Unfortunately each webpart can be authored differently, so there isn't a way to know how the setting for a given webpart are stored without loading it and examining the properties.","title":"Handle Different Webpart's Settings"},{"location":"sp/clientside-pages/#page-operations","text":"There are other operation you can perform on a page in addition to manipulating the content.","title":"Page Operations"},{"location":"sp/clientside-pages/#pagelayout","text":"You can get and set the page layout. Changing the layout after creating the page may have side effects and should be done cautiously. // our page instance const page: IClientsidePage; // get the current value const value = page.pageLayout; // set the value page.pageLayout = \"Article\"; await page.save();","title":"pageLayout"},{"location":"sp/clientside-pages/#bannerimageurl","text":"// our page instance const page: IClientsidePage; // get the current value const value = page.bannerImageUrl; // set the value page.bannerImageUrl = \"/server/relative/path/to/image.png\"; await page.save(); Banner images need to exist within the same site collection as the page where you want to use them.","title":"bannerImageUrl"},{"location":"sp/clientside-pages/#thumbnailurl","text":"Allows you to set the thumbnail used for the page independently of the banner. If you set the bannerImageUrl property and not thumbnailUrl the thumbnail will be reset to match the banner, mimicking the UI functionality. // our page instance const page: IClientsidePage; // get the current value const value = page.thumbnailUrl; // set the value page.thumbnailUrl = \"/server/relative/path/to/image.png\"; await page.save();","title":"thumbnailUrl"},{"location":"sp/clientside-pages/#topicheader","text":"// our page instance const page: IClientsidePage; // get the current value const value = page.topicHeader; // set the value page.topicHeader = \"My cool header!\"; await page.save(); // clear the topic header and hide it page.topicHeader = \"\"; await page.save();","title":"topicHeader"},{"location":"sp/clientside-pages/#title","text":"// our page instance const page: IClientsidePage; // get the current value const value = page.title; // set the value page.title = \"My page title\"; await page.save();","title":"title"},{"location":"sp/clientside-pages/#description","text":"Descriptions are limited to 255 chars // our page instance const page: IClientsidePage; // get the current value const value = page.description; // set the value page.description = \"A description\"; await page.save();","title":"description"},{"location":"sp/clientside-pages/#layouttype","text":"Sets the layout type of the page. The valid values are: \"FullWidthImage\", \"NoImage\", \"ColorBlock\", \"CutInShape\" // our page instance const page: IClientsidePage; // get the current value const value = page.layoutType; // set the value page.layoutType = \"ColorBlock\"; await page.save();","title":"layoutType"},{"location":"sp/clientside-pages/#headertextalignment","text":"Sets the header text alignment to one of \"Left\" or \"Center\" // our page instance const page: IClientsidePage; // get the current value const value = page.headerTextAlignment; // set the value page.headerTextAlignment = \"Center\"; await page.save();","title":"headerTextAlignment"},{"location":"sp/clientside-pages/#showtopicheader","text":"Sets if the topic header is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showTopicHeader; // show the header page.showTopicHeader = true; await page.save(); // hide the header page.showTopicHeader = false; await page.save();","title":"showTopicHeader"},{"location":"sp/clientside-pages/#showpublishdate","text":"Sets if the publish date is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showPublishDate; // show the date page.showPublishDate = true; await page.save(); // hide the date page.showPublishDate = false; await page.save();","title":"showPublishDate"},{"location":"sp/clientside-pages/#get-set-author-details","text":"Added in 2.0.4 // our page instance const page: IClientsidePage; // get the author details (string | null) const value = page.authorByLine; // set the author by user id const user = await web.currentUser.select(\"Id\", \"LoginName\")(); const userId = user.Id; const userLogin = user.LoginName; await page.setAuthorById(userId); await page.save(); await page.setAuthorByLoginName(userLogin); await page.save(); you must still save the page after setting the author to persist your changes as shown in the example.","title":"Get / Set author details"},{"location":"sp/clientside-pages/#load","text":"Loads the page from the server. This will overwrite any local unsaved changes. // our page instance const page: IClientsidePage; await page.load();","title":"load"},{"location":"sp/clientside-pages/#save","text":"Saves any changes to the page, optionally keeping them in draft state. // our page instance const page: IClientsidePage; // changes are published await page.save(); // changes remain in draft await page.save(false);","title":"save"},{"location":"sp/clientside-pages/#discardpagecheckout","text":"Discards any current checkout of the page by the current user. // our page instance const page: IClientsidePage; await page.discardPageCheckout();","title":"discardPageCheckout"},{"location":"sp/clientside-pages/#promotetonews","text":"Promotes the page as a news article. // our page instance const page: IClientsidePage; await page.promoteToNews();","title":"promoteToNews"},{"location":"sp/clientside-pages/#enablecomments-disablecomments","text":"Used to control the availability of comments on a page. // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments();","title":"enableComments &amp; disableComments"},{"location":"sp/clientside-pages/#findcontrolbyid","text":"Finds a control within the page by id. import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; const control = page.findControlById(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\"); // you can also type the control const control = page.findControlById<ClientsideText>(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\");","title":"findControlById"},{"location":"sp/clientside-pages/#findcontrol","text":"Finds a control within the page using the supplied delegate. Can also be used to iterate through all controls in the page. // our page instance const page: IClientsidePage; // find the first control whose order is 9 const control = page.findControl((c) => c.order === 9); // iterate all the controls and output the id to the console page.findControl((c) => { console.log(c.id); return false; });","title":"findControl"},{"location":"sp/clientside-pages/#like-unlike","text":"Updates the page's like value for the current user. // our page instance const page: IClientsidePage; // like this page await page.like(); // unlike this page await page.unlike();","title":"like &amp; unlike"},{"location":"sp/clientside-pages/#getlikedbyinformation","text":"Gets the likes information for this page. // our page instance const page: IClientsidePage; const info = await page.getLikedByInformation();","title":"getLikedByInformation"},{"location":"sp/clientside-pages/#copy","text":"Creates a copy of the page, including all controls. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instance const page: IClientsidePage; // creates a published copy of the page const pageCopy = await page.copy(sp.web, \"newpagename\", \"New Page Title\"); // creates a draft (unpublished) copy of the page const pageCopy2 = await page.copy(sp.web, \"newpagename\", \"New Page Title\", false); // edits to pageCopy2 ... // publish the page pageCopy2.save();","title":"copy"},{"location":"sp/clientside-pages/#copyto","text":"Copies the contents of a page to another existing page instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instances, loaded in any of the ways shown above const source: IClientsidePage; const target: IClientsidePage; const target2: IClientsidePage; // creates a published copy of the page await source.copyTo(target); // creates a draft (unpublished) copy of the page await source.copyTo(target2, false); // edits to target2... // publish the page target2.save();","title":"copyTo"},{"location":"sp/clientside-pages/#setbannerimage","text":"Sets the banner image url and optionally additional properties. Allows you to set additional properties if needed, if you do not need to set the additional properties they are equivalent. Banner images need to exist within the same site collection as the page where you want to use them. // our page instance const page: IClientsidePage; page.setBannerImage(\"/server/relative/path/to/image.png\"); // save the changes await page.save(); // set additional props page.setBannerImage(\"/server/relative/path/to/image.png\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save(); This sample shows the full process of adding a page, image file, and setting the banner image in nodejs. The same code would work in a browser with an update on how you get the file - likely from a file input or similar. import { SPFetchClient } from \"@pnp/nodejs\"; import { join } from \"path\"; import { readFileSync } from \"fs\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/clientside-pages\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{Site Url}\", \"{Client Id}\", \"{Client Secret}\"); }, }, }); // add the banner image const dirname = join(\"C:/path/to/file\", \"img-file.jpg\"); const file: Uint8Array = new Uint8Array(readFileSync(dirname)); const far = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents\").files.add(\"banner.jpg\", file, true); // add the page const page = await sp.web.addClientsidePage(\"MyPage\", \"Page Title\"); // set the banner image page.setBannerImage(far.data.ServerRelativeUrl); // publish the page await page.save();","title":"setBannerImage"},{"location":"sp/clientside-pages/#setbannerimagefromexternalurl","text":"Added in 2.0.12 Allows you to set the banner image from a source outside the current site collection. The image file will be copied to the SiteAssets library and referenced from there. // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\"); // save the changes await page.save(); You can optionally supply additional props for the banner image, these match the properties when calling setBannerImage // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save();","title":"setBannerImageFromExternalUrl"},{"location":"sp/column-defaults/","text":"@pnp/sp/column-defaults \u00b6 The column defaults sub-module allows you to manage the default column values on a library or library folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/column-defaults\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/column-defaults\"; Preset: All import { sp, IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/presents/all\"; Get Folder Defaults \u00b6 You can get the default values for a specific folder as shown below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" } ] */ Set Folder Defaults \u00b6 When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").setDefaultColumnValues([{ name: \"TextField\", value: \"Something\", }, { name: \"NumberField\", value: 14, }]); Get Library Defaults \u00b6 You can also get all of the defaults for the entire library. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.lists.getByTitle(\"DefaultColumnValues\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{a different default value}\" } ] */ Set Library Defaults \u00b6 You can also set the defaults for an entire library at once (root and all sub-folders). This may be helpful in provisioning a library or other scenarios. When setting the defaults for the entire library you must also include the path value with is the server relative path to the folder. When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([{ name: \"TextField\", path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }]); Clear Folder Defaults \u00b6 If you want to clear all of the folder defaults you can use the clear method: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").clearDefaultColumnValues(); Clear Library Defaults \u00b6 If you need to clear all of the default column values in a library you can pass an empty array to the list's setDefaultColumnValues method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([]); Pattern for setting defaults on various column types \u00b6 The following is an example of the structure for setting the default column value when using the setDefaultColumnValues that covers the various field types. [{ // Text/Boolean/CurrencyDateTime/Choice/User name: \"TextField\": path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }, { //Number name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: 42, }, { //Date name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"1900-01-01T00:00:00Z\", }, { //Date - Today name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"[today]\", }, { //MultiChoice name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues\", value: [\"Item 1\", \"Item 2\"], }, { //MultiChoice - single value name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues/folder2\", value: [\"Item 1\"], }, { //Taxonomy - single value name: \"TaxonomyField\", path: \"/sites/dev/DefaultColumnValues\", value: { wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" } }, { //Taxonomy - multiple value name: \"TaxonomyMultiField\", path: \"/sites/dev/DefaultColumnValues\", value: [{ wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" },{ wssId:\"-1\", termName: \"TaxValueName2\", termId: \"95d4c307-dde5-49d8-b861-392e145d94d3\" },] }]); Taxonomy Full Example \u00b6 This example shows fully how to get the taxonomy values and set them as a default column value using PnPjs. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/column-defaults\"; import \"@pnp/sp/taxonomy\"; // get the term's info we want to use as the default const term = await sp.termStore.sets.getById(\"ea6fc521-d293-4f3d-9e84-f3a5bc0936ce\").getTermById(\"775c9cf6-c3cd-4db9-8cfa-fc0aeefad93a\")(); // get the default term label const defLabel = term.labels.find(v => v.isDefault); // set the default value using -1, the term id, and the term's default label name await sp.web.lists.getByTitle(\"MetaDataDocLib\").rootFolder.setDefaultColumnValues([{ name: \"MetaDataColumnInternalName\", value: { wssId: \"-1\", termId: term.id, termName: defLabel.name, } }]) // check that the defaults have updated const newDefaults = await sp.web.lists.getByTitle(\"MetaDataDocLib\").getDefaultColumnValues();","title":"Column Defaults"},{"location":"sp/column-defaults/#pnpspcolumn-defaults","text":"The column defaults sub-module allows you to manage the default column values on a library or library folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/column-defaults\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/column-defaults\"; Preset: All import { sp, IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/presents/all\";","title":"@pnp/sp/column-defaults"},{"location":"sp/column-defaults/#get-folder-defaults","text":"You can get the default values for a specific folder as shown below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" } ] */","title":"Get Folder Defaults"},{"location":"sp/column-defaults/#set-folder-defaults","text":"When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").setDefaultColumnValues([{ name: \"TextField\", value: \"Something\", }, { name: \"NumberField\", value: 14, }]);","title":"Set Folder Defaults"},{"location":"sp/column-defaults/#get-library-defaults","text":"You can also get all of the defaults for the entire library. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.lists.getByTitle(\"DefaultColumnValues\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{a different default value}\" } ] */","title":"Get Library Defaults"},{"location":"sp/column-defaults/#set-library-defaults","text":"You can also set the defaults for an entire library at once (root and all sub-folders). This may be helpful in provisioning a library or other scenarios. When setting the defaults for the entire library you must also include the path value with is the server relative path to the folder. When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([{ name: \"TextField\", path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }]);","title":"Set Library Defaults"},{"location":"sp/column-defaults/#clear-folder-defaults","text":"If you want to clear all of the folder defaults you can use the clear method: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").clearDefaultColumnValues();","title":"Clear Folder Defaults"},{"location":"sp/column-defaults/#clear-library-defaults","text":"If you need to clear all of the default column values in a library you can pass an empty array to the list's setDefaultColumnValues method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([]);","title":"Clear Library Defaults"},{"location":"sp/column-defaults/#pattern-for-setting-defaults-on-various-column-types","text":"The following is an example of the structure for setting the default column value when using the setDefaultColumnValues that covers the various field types. [{ // Text/Boolean/CurrencyDateTime/Choice/User name: \"TextField\": path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }, { //Number name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: 42, }, { //Date name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"1900-01-01T00:00:00Z\", }, { //Date - Today name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"[today]\", }, { //MultiChoice name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues\", value: [\"Item 1\", \"Item 2\"], }, { //MultiChoice - single value name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues/folder2\", value: [\"Item 1\"], }, { //Taxonomy - single value name: \"TaxonomyField\", path: \"/sites/dev/DefaultColumnValues\", value: { wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" } }, { //Taxonomy - multiple value name: \"TaxonomyMultiField\", path: \"/sites/dev/DefaultColumnValues\", value: [{ wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" },{ wssId:\"-1\", termName: \"TaxValueName2\", termId: \"95d4c307-dde5-49d8-b861-392e145d94d3\" },] }]);","title":"Pattern for setting defaults on various column types"},{"location":"sp/column-defaults/#taxonomy-full-example","text":"This example shows fully how to get the taxonomy values and set them as a default column value using PnPjs. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/column-defaults\"; import \"@pnp/sp/taxonomy\"; // get the term's info we want to use as the default const term = await sp.termStore.sets.getById(\"ea6fc521-d293-4f3d-9e84-f3a5bc0936ce\").getTermById(\"775c9cf6-c3cd-4db9-8cfa-fc0aeefad93a\")(); // get the default term label const defLabel = term.labels.find(v => v.isDefault); // set the default value using -1, the term id, and the term's default label name await sp.web.lists.getByTitle(\"MetaDataDocLib\").rootFolder.setDefaultColumnValues([{ name: \"MetaDataColumnInternalName\", value: { wssId: \"-1\", termId: term.id, termName: defLabel.name, } }]) // check that the defaults have updated const newDefaults = await sp.web.lists.getByTitle(\"MetaDataDocLib\").getDefaultColumnValues();","title":"Taxonomy Full Example"},{"location":"sp/comments-likes/","text":"@pnp/sp/comments and likes \u00b6 Comments can be accessed through either IItem or IClientsidePage instances, though in slightly different ways. For information on loading clientside pages or items please refer to those articles. These APIs are currently in BETA and are subject to change or may not work on all tenants. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; ClientsidePage Comments \u00b6 The IClientsidePage interface has three methods to provide easier access to the comments for a page, without requiring that you load the item separately. Add Comments \u00b6 You can add a comment using the addComment method as shown import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\"); Get Page Comments \u00b6 import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); const comments = await page.getComments(); enableComments & disableComments \u00b6 Used to control the availability of comments on a page // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments(); GetById \u00b6 import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\"); const commentData = await page.getCommentById(parseInt(comment.id, 10)); Clear Comments \u00b6 Item Comments \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/comments/item\"; const item = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/SitePages/Test_8q5L.aspx\").getItem(); // as an example, or any of the below options await item.like(); The below examples use a variable named \"item\" which is taken to represent an IItem instance. Comments \u00b6 Get Item Comments \u00b6 const comments = await item.comments(); You can also get the comments merged with instances of the Comment class to immediately start accessing the properties and methods: import { spODataEntityArray } from \"@pnp/sp/odata\"; import { Comment, ICommentData } from \"@pnp/sp/comments\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" }); //load the top 20 replies and comments for an item including likedBy information const comments = await item.comments.expand(\"replies\", \"likedBy\", \"replies/likedBy\").top(20)(); Add Comment \u00b6 // you can add a comment as a string item.comments.add(\"string comment\"); // or you can add it as an object to include mentions item.comments.add({ text: \"comment from object property\" }); Delete a Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].delete() Like Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].like() Unlike Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); comments[0].unlike() Reply to a Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const comment: Comment & CommentData = await comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" }); Load Replies to a Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const replies = await comments[0].replies(); Like \u00b6 You can like/unlike client-side pages, items, and comments on items. See above for how to like or unlike a comment. Below you can see how to like and unlike an items, as well as get the liked by data. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/item\"; import { ILikeData, ILikedByInformation } from \"@pnp/sp/comments\"; // like an item await item.like(); // unlike an item await item.unlike(); // get the liked by data const likedByData: ILikeData[] = await item.getLikedBy(); // get the liked by information const likedByInfo: ILikedByInformation = await item.getLikedByInformation(); To like/unlike a client-side page and get liked by information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/clientside-page\"; import { ILikedByInformation } from \"@pnp/sp/comments\"; // like a page await page.like(); // unlike a page await page.unlike(); // get the liked by information const likedByInfo: ILikedByInformation = await page.getLikedByInformation();","title":"Comments and Likes"},{"location":"sp/comments-likes/#pnpspcomments-and-likes","text":"Comments can be accessed through either IItem or IClientsidePage instances, though in slightly different ways. For information on loading clientside pages or items please refer to those articles. These APIs are currently in BETA and are subject to change or may not work on all tenants. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/comments and likes"},{"location":"sp/comments-likes/#clientsidepage-comments","text":"The IClientsidePage interface has three methods to provide easier access to the comments for a page, without requiring that you load the item separately.","title":"ClientsidePage Comments"},{"location":"sp/comments-likes/#add-comments","text":"You can add a comment using the addComment method as shown import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\");","title":"Add Comments"},{"location":"sp/comments-likes/#get-page-comments","text":"import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); const comments = await page.getComments();","title":"Get Page Comments"},{"location":"sp/comments-likes/#enablecomments-disablecomments","text":"Used to control the availability of comments on a page // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments();","title":"enableComments &amp; disableComments"},{"location":"sp/comments-likes/#getbyid","text":"import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\"); const commentData = await page.getCommentById(parseInt(comment.id, 10));","title":"GetById"},{"location":"sp/comments-likes/#clear-comments","text":"","title":"Clear Comments"},{"location":"sp/comments-likes/#item-comments","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/comments/item\"; const item = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/SitePages/Test_8q5L.aspx\").getItem(); // as an example, or any of the below options await item.like(); The below examples use a variable named \"item\" which is taken to represent an IItem instance.","title":"Item Comments"},{"location":"sp/comments-likes/#comments","text":"","title":"Comments"},{"location":"sp/comments-likes/#get-item-comments","text":"const comments = await item.comments(); You can also get the comments merged with instances of the Comment class to immediately start accessing the properties and methods: import { spODataEntityArray } from \"@pnp/sp/odata\"; import { Comment, ICommentData } from \"@pnp/sp/comments\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" }); //load the top 20 replies and comments for an item including likedBy information const comments = await item.comments.expand(\"replies\", \"likedBy\", \"replies/likedBy\").top(20)();","title":"Get Item Comments"},{"location":"sp/comments-likes/#add-comment","text":"// you can add a comment as a string item.comments.add(\"string comment\"); // or you can add it as an object to include mentions item.comments.add({ text: \"comment from object property\" });","title":"Add Comment"},{"location":"sp/comments-likes/#delete-a-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].delete()","title":"Delete a Comment"},{"location":"sp/comments-likes/#like-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].like()","title":"Like Comment"},{"location":"sp/comments-likes/#unlike-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); comments[0].unlike()","title":"Unlike Comment"},{"location":"sp/comments-likes/#reply-to-a-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const comment: Comment & CommentData = await comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" });","title":"Reply to a Comment"},{"location":"sp/comments-likes/#load-replies-to-a-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const replies = await comments[0].replies();","title":"Load Replies to a Comment"},{"location":"sp/comments-likes/#like","text":"You can like/unlike client-side pages, items, and comments on items. See above for how to like or unlike a comment. Below you can see how to like and unlike an items, as well as get the liked by data. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/item\"; import { ILikeData, ILikedByInformation } from \"@pnp/sp/comments\"; // like an item await item.like(); // unlike an item await item.unlike(); // get the liked by data const likedByData: ILikeData[] = await item.getLikedBy(); // get the liked by information const likedByInfo: ILikedByInformation = await item.getLikedByInformation(); To like/unlike a client-side page and get liked by information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/clientside-page\"; import { ILikedByInformation } from \"@pnp/sp/comments\"; // like a page await page.like(); // unlike a page await page.unlike(); // get the liked by information const likedByInfo: ILikedByInformation = await page.getLikedByInformation();","title":"Like"},{"location":"sp/content-types/","text":"@pnp/sp/content-types \u00b6 Content Types are used to define sets of columns in SharePoint. IContentTypes \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { ContentTypes, IContentTypes } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentTypes, IContentTypes } from \"@pnp/sp/presets/all\"; Add an existing Content Type to a collection \u00b6 The following example shows how to add the built in Picture Content Type to the Documents library. sp.web.lists.getByTitle(\"Documents\").contentTypes.addAvailableContentType(\"0x010102\"); Get a Content Type by Id \u00b6 const d: IContentType = await sp.web.contentTypes.getById(\"0x01\")(); // log content type name to console console.log(d.name); Add a new Content Type \u00b6 To add a new Content Type to a collection, parameters id and name are required. For more information on creating content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\"); It is also possible to provide a description and group parameter. For other settings, we can use the parameter named 'additionalSettings' which is a TypedHash, meaning you can send whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). //Adding a content type with id, name, description, group and setting it to read only mode (using additionalsettings) sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\", \"This is my content type.\", \"_PnP Content Types\", { ReadOnly: true }); IContentType \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ContentType, IContentType } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentType, IContentType } from \"@pnp/sp/presets/all\"; Get the field links \u00b6 Use this method to get a collection containing all the field links (SP.FieldLink) for a Content Type. // get field links from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fieldLinks(); // log collection of fieldlinks to console console.log(d); Get Content Type fields \u00b6 To get a collection with all fields on the Content Type, simply use this method. // get fields from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fields(); // log collection of fields to console console.log(d); Get parent Content Type \u00b6 // get parent Content Type from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").parent(); // log name of parent Content Type to console console.log(d.Name) Get Content Type Workflow associations \u00b6 // get workflow associations from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").workflowAssociations(); // log collection of workflow associations to console console.log(d);","title":"Content Types"},{"location":"sp/content-types/#pnpspcontent-types","text":"Content Types are used to define sets of columns in SharePoint.","title":"@pnp/sp/content-types"},{"location":"sp/content-types/#icontenttypes","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { ContentTypes, IContentTypes } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentTypes, IContentTypes } from \"@pnp/sp/presets/all\";","title":"IContentTypes"},{"location":"sp/content-types/#add-an-existing-content-type-to-a-collection","text":"The following example shows how to add the built in Picture Content Type to the Documents library. sp.web.lists.getByTitle(\"Documents\").contentTypes.addAvailableContentType(\"0x010102\");","title":"Add an existing Content Type to a collection"},{"location":"sp/content-types/#get-a-content-type-by-id","text":"const d: IContentType = await sp.web.contentTypes.getById(\"0x01\")(); // log content type name to console console.log(d.name);","title":"Get a Content Type by Id"},{"location":"sp/content-types/#add-a-new-content-type","text":"To add a new Content Type to a collection, parameters id and name are required. For more information on creating content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\"); It is also possible to provide a description and group parameter. For other settings, we can use the parameter named 'additionalSettings' which is a TypedHash, meaning you can send whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). //Adding a content type with id, name, description, group and setting it to read only mode (using additionalsettings) sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\", \"This is my content type.\", \"_PnP Content Types\", { ReadOnly: true });","title":"Add a new Content Type"},{"location":"sp/content-types/#icontenttype","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ContentType, IContentType } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentType, IContentType } from \"@pnp/sp/presets/all\";","title":"IContentType"},{"location":"sp/content-types/#get-the-field-links","text":"Use this method to get a collection containing all the field links (SP.FieldLink) for a Content Type. // get field links from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fieldLinks(); // log collection of fieldlinks to console console.log(d);","title":"Get the field links"},{"location":"sp/content-types/#get-content-type-fields","text":"To get a collection with all fields on the Content Type, simply use this method. // get fields from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fields(); // log collection of fields to console console.log(d);","title":"Get Content Type fields"},{"location":"sp/content-types/#get-parent-content-type","text":"// get parent Content Type from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").parent(); // log name of parent Content Type to console console.log(d.Name)","title":"Get parent Content Type"},{"location":"sp/content-types/#get-content-type-workflow-associations","text":"// get workflow associations from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").workflowAssociations(); // log collection of workflow associations to console console.log(d);","title":"Get Content Type Workflow associations"},{"location":"sp/custom-irequestclient/","text":"Custom IRequestClient \u00b6 Scenario: You have some special requirements involving auth scenarios or other needs that the library can't directly support. You may need to create a custom IRequestClient implementation to meet those needs as we can't customize the library to handle every case. This article walks you through how to create a custom IRequestClient and register it for use by the library. It is very unlikely this is a step you ever need to take and we encourage you to ask a question in the issues list before going down this path. Create the Client \u00b6 The easiest way to create a new IRequestClient is to subclass the existing SPHttpClient. You can always write a full client from scratch so long as it supports the IRequestClient interface but you need to handle all of the logic for retry, headers, and the request digest. Here we show implementing a client to solve the need discussed in pull request 1264 as an example. // we subclass SPHttpClient class CustomSPHttpClient extends SPHttpClient { // optionally add a constructor, done here as an example constructor(impl?: IHttpClientImpl) { super(impl); } // override the fetchRaw method to ensure we always include the credentials = \"include\" option // you could also override fetch, but fetchRaw ensures no matter what all requests get your custom logic is applied public fetchRaw(url: string, options?: IFetchOptions): Promise<Response> { options.credentials = \"include\"; return super.fetchRaw(url, options); } } The final step is to register the custom client with the library so it is used instead of the default. For that we import the registerCustomRequestClientFactory function and call it before our request generating code. You can reset to the default client factory by passing null to this same function. import { sp, registerCustomRequestClientFactory } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; registerCustomRequestClientFactory(() => new CustomSPHttpClient()); // configure your other options sp.setup({ // ... }); // this request will be executed through your custom client const w = await sp.web(); Unregister Custom Client \u00b6 // unregister custom client factory registerCustomRequestClientFactory(null); IRequestClient Interface \u00b6 If you want to 100% roll your own client you need to implement the below interface, found in common. import { IRequestClient } from \"@pnp/core\"; export interface IRequestClient { fetch(url: string, options?: IFetchOptions): Promise<Response>; fetchRaw(url: string, options?: IFetchOptions): Promise<Response>; get(url: string, options?: IFetchOptions): Promise<Response>; post(url: string, options?: IFetchOptions): Promise<Response>; patch(url: string, options?: IFetchOptions): Promise<Response>; delete(url: string, options?: IFetchOptions): Promise<Response>; } Supportability Note \u00b6 We cannot provide support for your custom client implementation, and creating your own client assumes an intimate knowledge of how SharePoint requests work. Again, this is very likely something you will never need to do - and we recommend exhausting all other options before taking this route.","title":"Custom Request Client"},{"location":"sp/custom-irequestclient/#custom-irequestclient","text":"Scenario: You have some special requirements involving auth scenarios or other needs that the library can't directly support. You may need to create a custom IRequestClient implementation to meet those needs as we can't customize the library to handle every case. This article walks you through how to create a custom IRequestClient and register it for use by the library. It is very unlikely this is a step you ever need to take and we encourage you to ask a question in the issues list before going down this path.","title":"Custom IRequestClient"},{"location":"sp/custom-irequestclient/#create-the-client","text":"The easiest way to create a new IRequestClient is to subclass the existing SPHttpClient. You can always write a full client from scratch so long as it supports the IRequestClient interface but you need to handle all of the logic for retry, headers, and the request digest. Here we show implementing a client to solve the need discussed in pull request 1264 as an example. // we subclass SPHttpClient class CustomSPHttpClient extends SPHttpClient { // optionally add a constructor, done here as an example constructor(impl?: IHttpClientImpl) { super(impl); } // override the fetchRaw method to ensure we always include the credentials = \"include\" option // you could also override fetch, but fetchRaw ensures no matter what all requests get your custom logic is applied public fetchRaw(url: string, options?: IFetchOptions): Promise<Response> { options.credentials = \"include\"; return super.fetchRaw(url, options); } } The final step is to register the custom client with the library so it is used instead of the default. For that we import the registerCustomRequestClientFactory function and call it before our request generating code. You can reset to the default client factory by passing null to this same function. import { sp, registerCustomRequestClientFactory } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; registerCustomRequestClientFactory(() => new CustomSPHttpClient()); // configure your other options sp.setup({ // ... }); // this request will be executed through your custom client const w = await sp.web();","title":"Create the Client"},{"location":"sp/custom-irequestclient/#unregister-custom-client","text":"// unregister custom client factory registerCustomRequestClientFactory(null);","title":"Unregister Custom Client"},{"location":"sp/custom-irequestclient/#irequestclient-interface","text":"If you want to 100% roll your own client you need to implement the below interface, found in common. import { IRequestClient } from \"@pnp/core\"; export interface IRequestClient { fetch(url: string, options?: IFetchOptions): Promise<Response>; fetchRaw(url: string, options?: IFetchOptions): Promise<Response>; get(url: string, options?: IFetchOptions): Promise<Response>; post(url: string, options?: IFetchOptions): Promise<Response>; patch(url: string, options?: IFetchOptions): Promise<Response>; delete(url: string, options?: IFetchOptions): Promise<Response>; }","title":"IRequestClient Interface"},{"location":"sp/custom-irequestclient/#supportability-note","text":"We cannot provide support for your custom client implementation, and creating your own client assumes an intimate knowledge of how SharePoint requests work. Again, this is very likely something you will never need to do - and we recommend exhausting all other options before taking this route.","title":"Supportability Note"},{"location":"sp/entity-merging/","text":"@pnp/sp - entity merging \u00b6 Sometimes when we make a query entity's data we would like then to immediately run other commands on the returned entity. To have data returned as its representing type we make use of the spODataEntity and spODataEntityArray parsers. The below approach works for all instance types such as List, Web, Item, or Field as examples. Importing spODataEntity and spODataEntityArray \u00b6 You can import spODataEntity and spODataEntityArray in two ways, depending on your use case. The simplest way is to use the presets/all import as shown in the examples. The downside of this approach is that you can't take advantage of selective imports. If you want to take advantage of selective imports while using either of the entity parsers you can use: import { spODataEntity, spODataEntityArray } from \"@pnp/sp/odata\"; The full selective import for the first sample would be: import { sp } from \"@pnp/sp\"; import { spODataEntity } from \"@pnp/sp/odata\"; import { Item, IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; Request a single entity \u00b6 If we are loading a single entity we use the spODataEntity method. Here we show loading a list item using the Item class and a simple get query. import { sp, spODataEntity, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; } try { // get a list item loaded with data and merged into an instance of Item const item = await sp.web.lists.getByTitle(\"ListTitle\").items.getById(1).usingParser(spODataEntity<IItem, MyProps>(Item))(); // log the item id, all properties specified in MyProps will be type checked Logger.write(`Item id: ${item.Id}`); // now we can call update because we have an instance of the Item type to work with as well await item.update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); } Request a collection \u00b6 The same pattern works when requesting a collection of objects with the exception of using the spODataEntityArray method. import { sp, spODataEntityArray, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; Title: string; } try { // get a list item loaded with data and merged into an instance of Item const items = await sp.web.lists.getByTitle(\"OrderByList\").items.select(\"Id\", \"Title\").usingParser(spODataEntityArray<IItem, MyProps>(Item))(); Logger.write(`Item id: ${items.length}`); Logger.write(`Item id: ${items[0].Title}`); // now we can call update because we have an instance of the Item type to work with as well await items[0].update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); }","title":"Entity Merging"},{"location":"sp/entity-merging/#pnpsp-entity-merging","text":"Sometimes when we make a query entity's data we would like then to immediately run other commands on the returned entity. To have data returned as its representing type we make use of the spODataEntity and spODataEntityArray parsers. The below approach works for all instance types such as List, Web, Item, or Field as examples.","title":"@pnp/sp - entity merging"},{"location":"sp/entity-merging/#importing-spodataentity-and-spodataentityarray","text":"You can import spODataEntity and spODataEntityArray in two ways, depending on your use case. The simplest way is to use the presets/all import as shown in the examples. The downside of this approach is that you can't take advantage of selective imports. If you want to take advantage of selective imports while using either of the entity parsers you can use: import { spODataEntity, spODataEntityArray } from \"@pnp/sp/odata\"; The full selective import for the first sample would be: import { sp } from \"@pnp/sp\"; import { spODataEntity } from \"@pnp/sp/odata\"; import { Item, IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\";","title":"Importing spODataEntity and spODataEntityArray"},{"location":"sp/entity-merging/#request-a-single-entity","text":"If we are loading a single entity we use the spODataEntity method. Here we show loading a list item using the Item class and a simple get query. import { sp, spODataEntity, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; } try { // get a list item loaded with data and merged into an instance of Item const item = await sp.web.lists.getByTitle(\"ListTitle\").items.getById(1).usingParser(spODataEntity<IItem, MyProps>(Item))(); // log the item id, all properties specified in MyProps will be type checked Logger.write(`Item id: ${item.Id}`); // now we can call update because we have an instance of the Item type to work with as well await item.update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); }","title":"Request a single entity"},{"location":"sp/entity-merging/#request-a-collection","text":"The same pattern works when requesting a collection of objects with the exception of using the spODataEntityArray method. import { sp, spODataEntityArray, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; Title: string; } try { // get a list item loaded with data and merged into an instance of Item const items = await sp.web.lists.getByTitle(\"OrderByList\").items.select(\"Id\", \"Title\").usingParser(spODataEntityArray<IItem, MyProps>(Item))(); Logger.write(`Item id: ${items.length}`); Logger.write(`Item id: ${items[0].Title}`); // now we can call update because we have an instance of the Item type to work with as well await items[0].update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); }","title":"Request a collection"},{"location":"sp/features/","text":"@pnp/sp/features \u00b6 Features module provides method to get the details of activated features. And to activate/deactivate features scoped at Site Collection and Web. IFeatures \u00b6 Represents a collection of features. SharePoint Sites and Webs will have a collection of features Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\"; getById \u00b6 Gets the information about a feature for the given GUID import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; const webFeature = await sp.web.features.getById(webFeatureId)(); const siteFeatureId = \"guid-of-site-scope-feature\"; const siteFeature = await sp.site.features.getById(siteFeatureId)(); add \u00b6 Adds (activates) a feature at the Site or Web level import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.add(webFeatureId); // Activate with force res = await sp.web.features.add(webFeatureId, true); remove \u00b6 Removes and deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.remove(webFeatureId); // Deactivate with force res = await sp.web.features.remove(webFeatureId, true); IFeature \u00b6 Represents an instance of a SharePoint feature. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features, IFeature, Feature } from \"@pnp/sp/presets/all\"; deactivate \u00b6 Deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; sp.web.features.getById(webFeatureId).deactivate() // Deactivate with force sp.web.features.getById(webFeatureId).deactivate(true)","title":"Features"},{"location":"sp/features/#pnpspfeatures","text":"Features module provides method to get the details of activated features. And to activate/deactivate features scoped at Site Collection and Web.","title":"@pnp/sp/features"},{"location":"sp/features/#ifeatures","text":"Represents a collection of features. SharePoint Sites and Webs will have a collection of features Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\";","title":"IFeatures"},{"location":"sp/features/#getbyid","text":"Gets the information about a feature for the given GUID import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; const webFeature = await sp.web.features.getById(webFeatureId)(); const siteFeatureId = \"guid-of-site-scope-feature\"; const siteFeature = await sp.site.features.getById(siteFeatureId)();","title":"getById"},{"location":"sp/features/#add","text":"Adds (activates) a feature at the Site or Web level import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.add(webFeatureId); // Activate with force res = await sp.web.features.add(webFeatureId, true);","title":"add"},{"location":"sp/features/#remove","text":"Removes and deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.remove(webFeatureId); // Deactivate with force res = await sp.web.features.remove(webFeatureId, true);","title":"remove"},{"location":"sp/features/#ifeature","text":"Represents an instance of a SharePoint feature. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features, IFeature, Feature } from \"@pnp/sp/presets/all\";","title":"IFeature"},{"location":"sp/features/#deactivate","text":"Deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; sp.web.features.getById(webFeatureId).deactivate() // Deactivate with force sp.web.features.getById(webFeatureId).deactivate(true)","title":"deactivate"},{"location":"sp/fields/","text":"@pnp/sp/lists \u00b6 Fields in SharePoint can be applied to both webs and lists. When referencing a webs' fields you are effectively looking at site columns which are common fields that can be utilized in any list/library in the site. When referencing a lists' fields you are looking at the fields only associated to that particular list. IFields \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Fields, IFields } from \"@pnp/sp/fields\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; Preset: All import { sp, Fields, IFields } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Fields, IFields } from \"@pnp/sp/presets/core\"; Get Field by Id \u00b6 Gets a field from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/fields\"; // get the field by Id for web const field: IField = sp.web.fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // get the field by Id for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\")(); // we can use this 'field' variable to execute more queries on the field: const r = await field.select(\"Title\")(); // show the response from the server console.log(r.Title); Get Field by Title \u00b6 You can also get a field from the collection by title. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the title 'Author' for web const field: IField = sp.web.fields.getByTitle(\"Author\"); // get the field with the title 'Author' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"Author\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Get Field by Internal Name or Title \u00b6 You can also get a field from the collection regardless of if the string is the fields internal name or title which can be different. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the internal name 'ModifiedBy' for web const field: IField = sp.web.fields.getByInternalNameOrTitle(\"ModifiedBy\"); // get the field with the internal name 'ModifiedBy' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByInternalNameOrTitle(\"ModifiedBy\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Create a Field using an XML schema \u00b6 Create a new field by defining an XML schema that assigns all the properties for the field. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // define the schema for your new field, in this case a date field with a default date of today. const fieldSchema = `<Field ID=\"{03b09ff4-d99d-45ed-841d-3855f77a2483}\" StaticName=\"MyField\" Name=\"MyField\" DisplayName=\"My New Field\" FriendlyDisplayFormat=\"Disabled\" Format=\"DateOnly\" Type=\"DateTime\" Group=\"My Group\"><Default>[today]</Default></Field>`; // create the new field in the web const field: IFieldAddResult = await sp.web.fields.createFieldAsXml(fieldSchema); // create the new field in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(fieldSchema); // we can use this 'field' variable to run more queries on the list: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a New Field \u00b6 Use the add method to create a new field where you define the field type import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // create a new field called 'My Field' in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Site Field to a List \u00b6 Use the createFieldAsXml method to add a site field to a list. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // add the site field 'My Field' to the list 'My List' const r = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(field.data.SchemaXml); // log the field Id to console console.log(r.data.Id); Add a Text Field \u00b6 Use the addText method to create a new text field. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new text field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // create a new text field called 'My Field' in the list 'My List'. const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Calculated Field \u00b6 Use the addCalculated method to create a new calculated field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, FieldTypes } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new calculated field called 'My Field' in web const field = await sp.web.fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // create a new calculated field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Date/Time Field \u00b6 Use the addDateTime method to create a new date/time field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, CalendarType, DateTimeFieldFriendlyFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new date/time field called 'My Field' in web const field = await sp.web.fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // create a new date/time field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Currency Field \u00b6 Use the addCurrency method to create a new currency field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new currency field called 'My Field' in web const field = await sp.web.fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // create a new currency field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Multi-line Text Field \u00b6 Use the addMultilineText method to create a new multi-line text field. For Enhanced Rich Text mode, see the next section. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new multi-line text field called 'My Field' in web const field = await sp.web.fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // create a new multi-line text field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Multi-line Text Field with Enhanced Rich Text \u00b6 The REST endpoint doesn't support setting the RichTextMode field therefore you will need to revert to Xml to create the field. The following is an example that will create a multi-line text field in Enhanced Rich Text mode. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; //Create a new multi-line text field called 'My Field' in web const field = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml( `<Field Type=\"Note\" Name=\"MyField\" DisplayName=\"My Field\" Required=\"FALSE\" RichText=\"TRUE\" RichTextMode=\"FullHtml\" />` ); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Number Field \u00b6 Use the addNumber method to create a new number field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new number field called 'My Field' in web const field = await sp.web.fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // create a new number field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a URL Field \u00b6 Use the addUrl method to create a new url field. import { sp } from \"@pnp/sp\"; import { UrlFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new url field called 'My Field' in web const field = await sp.web.fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // create a new url field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a User Field \u00b6 Use the addUser method to create a new user field. import { sp } from \"@pnp/sp\"; import { FieldUserSelectionMode } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new user field called 'My Field' in web const field = await sp.web.fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // create a new user field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Lookup Field \u00b6 Use the addLookup method to create a new lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const list = await sp.web.lists.getByTitle(\"My Lookup List\")(); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in web. const field = await sp.web.fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); // ** // Adding a lookup that supports multiple values takes two calls: const fieldAddResult = await sp.web.fields.addLookup(\"Test Lookup 124\", \"GUID\", \"Title\"); await fieldAddResult.field.update({ Description: 'New Description' }, \"SP.FieldLookup\"); Add a Choice Field \u00b6 Use the addChoice method to create a new choice field. import { sp } from \"@pnp/sp\"; import { ChoiceFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new choice field called 'My Field' in web const field = await sp.web.fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // create a new choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Multi-Choice Field \u00b6 Use the addMultiChoice method to create a new multi-choice field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new multi-choice field called 'My Field' in web const field = await sp.web.fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // create a new multi-choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Boolean Field \u00b6 Use the addBoolean method to create a new boolean field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new boolean field called 'My Field' in web const field = await sp.web.fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // create a new boolean field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Dependent Lookup Field \u00b6 Use the addDependentLookupField method to create a new dependent lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in web. const field = await sp.web.fields.getByTitle(\"My Field\")(); const fieldDep = await sp.web.fields.addDependentLookupField(\"My Dep Field\", field.Id, \"Description\"); // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\")(); const fieldDep2 = await sp.web.lists.getByTitle(\"My List\").fields.addDependentLookupField(\"My Dep Field\", field2.Id, \"Description\"); // we can use this 'fieldDep' variable to run more queries on the field: const r = await fieldDep.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Location Field \u00b6 Use the addLocation method to create a new location field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new location field called 'My Field' in web const field = await sp.web.fields.addLocation(\"My Field\", { Group: \"My Group\" }); // create a new location field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLocation(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Delete a Field \u00b6 Use the delete method to delete a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; // delete one or more fields from web, returns boolean const result = await sp.web.fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.fields.getByTitle(\"My Field 2\").delete(); // delete one or more fields from list 'My List', returns boolean const result = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field 2\").delete(); Update a Field \u00b6 Use the update method to update a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // update the field called 'My Field' with a description in web, returns FieldUpdateResult const fieldUpdate = await sp.web.fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // update the field called 'My Field' with a description in list 'My List', returns FieldUpdateResult const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // if you need to update a field with properties for a specific field type you can optionally include the field type as a second param // if you do not include it we will look up the type, but that adds a call to the server const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Look up Field\").update({ RelationshipDeleteBehavior: 1 }, \"SP.FieldLookup\"); Show a Field in the Display Form \u00b6 Use the setShowInDisplayForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in display form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInDisplayForm(true); // show field called 'My Field' in display form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInDisplayForm(true); Show a Field in the Edit Form \u00b6 Use the setShowInEditForm method to add a field to the edit form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in edit form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInEditForm(true); // show field called 'My Field' in edit form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInEditForm(true); Show a Field in the New Form \u00b6 Use the setShowInNewForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in new form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInNewForm(true); // show field called 'My Field' in new form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInNewForm(true);","title":"Fields"},{"location":"sp/fields/#pnpsplists","text":"Fields in SharePoint can be applied to both webs and lists. When referencing a webs' fields you are effectively looking at site columns which are common fields that can be utilized in any list/library in the site. When referencing a lists' fields you are looking at the fields only associated to that particular list.","title":"@pnp/sp/lists"},{"location":"sp/fields/#ifields","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Fields, IFields } from \"@pnp/sp/fields\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; Preset: All import { sp, Fields, IFields } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Fields, IFields } from \"@pnp/sp/presets/core\";","title":"IFields"},{"location":"sp/fields/#get-field-by-id","text":"Gets a field from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/fields\"; // get the field by Id for web const field: IField = sp.web.fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // get the field by Id for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\")(); // we can use this 'field' variable to execute more queries on the field: const r = await field.select(\"Title\")(); // show the response from the server console.log(r.Title);","title":"Get Field by Id"},{"location":"sp/fields/#get-field-by-title","text":"You can also get a field from the collection by title. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the title 'Author' for web const field: IField = sp.web.fields.getByTitle(\"Author\"); // get the field with the title 'Author' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"Author\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Get Field by Title"},{"location":"sp/fields/#get-field-by-internal-name-or-title","text":"You can also get a field from the collection regardless of if the string is the fields internal name or title which can be different. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the internal name 'ModifiedBy' for web const field: IField = sp.web.fields.getByInternalNameOrTitle(\"ModifiedBy\"); // get the field with the internal name 'ModifiedBy' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByInternalNameOrTitle(\"ModifiedBy\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Get Field by Internal Name or Title"},{"location":"sp/fields/#create-a-field-using-an-xml-schema","text":"Create a new field by defining an XML schema that assigns all the properties for the field. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // define the schema for your new field, in this case a date field with a default date of today. const fieldSchema = `<Field ID=\"{03b09ff4-d99d-45ed-841d-3855f77a2483}\" StaticName=\"MyField\" Name=\"MyField\" DisplayName=\"My New Field\" FriendlyDisplayFormat=\"Disabled\" Format=\"DateOnly\" Type=\"DateTime\" Group=\"My Group\"><Default>[today]</Default></Field>`; // create the new field in the web const field: IFieldAddResult = await sp.web.fields.createFieldAsXml(fieldSchema); // create the new field in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(fieldSchema); // we can use this 'field' variable to run more queries on the list: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Create a Field using an XML schema"},{"location":"sp/fields/#add-a-new-field","text":"Use the add method to create a new field where you define the field type import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // create a new field called 'My Field' in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a New Field"},{"location":"sp/fields/#add-a-site-field-to-a-list","text":"Use the createFieldAsXml method to add a site field to a list. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // add the site field 'My Field' to the list 'My List' const r = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(field.data.SchemaXml); // log the field Id to console console.log(r.data.Id);","title":"Add a Site Field to a List"},{"location":"sp/fields/#add-a-text-field","text":"Use the addText method to create a new text field. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new text field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // create a new text field called 'My Field' in the list 'My List'. const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Text Field"},{"location":"sp/fields/#add-a-calculated-field","text":"Use the addCalculated method to create a new calculated field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, FieldTypes } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new calculated field called 'My Field' in web const field = await sp.web.fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // create a new calculated field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Calculated Field"},{"location":"sp/fields/#add-a-datetime-field","text":"Use the addDateTime method to create a new date/time field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, CalendarType, DateTimeFieldFriendlyFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new date/time field called 'My Field' in web const field = await sp.web.fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // create a new date/time field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Date/Time Field"},{"location":"sp/fields/#add-a-currency-field","text":"Use the addCurrency method to create a new currency field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new currency field called 'My Field' in web const field = await sp.web.fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // create a new currency field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Currency Field"},{"location":"sp/fields/#add-a-multi-line-text-field","text":"Use the addMultilineText method to create a new multi-line text field. For Enhanced Rich Text mode, see the next section. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new multi-line text field called 'My Field' in web const field = await sp.web.fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // create a new multi-line text field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Multi-line Text Field"},{"location":"sp/fields/#add-a-multi-line-text-field-with-enhanced-rich-text","text":"The REST endpoint doesn't support setting the RichTextMode field therefore you will need to revert to Xml to create the field. The following is an example that will create a multi-line text field in Enhanced Rich Text mode. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; //Create a new multi-line text field called 'My Field' in web const field = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml( `<Field Type=\"Note\" Name=\"MyField\" DisplayName=\"My Field\" Required=\"FALSE\" RichText=\"TRUE\" RichTextMode=\"FullHtml\" />` ); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Multi-line Text Field with Enhanced Rich Text"},{"location":"sp/fields/#add-a-number-field","text":"Use the addNumber method to create a new number field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new number field called 'My Field' in web const field = await sp.web.fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // create a new number field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Number Field"},{"location":"sp/fields/#add-a-url-field","text":"Use the addUrl method to create a new url field. import { sp } from \"@pnp/sp\"; import { UrlFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new url field called 'My Field' in web const field = await sp.web.fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // create a new url field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a URL Field"},{"location":"sp/fields/#add-a-user-field","text":"Use the addUser method to create a new user field. import { sp } from \"@pnp/sp\"; import { FieldUserSelectionMode } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new user field called 'My Field' in web const field = await sp.web.fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // create a new user field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a User Field"},{"location":"sp/fields/#add-a-lookup-field","text":"Use the addLookup method to create a new lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const list = await sp.web.lists.getByTitle(\"My Lookup List\")(); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in web. const field = await sp.web.fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); // ** // Adding a lookup that supports multiple values takes two calls: const fieldAddResult = await sp.web.fields.addLookup(\"Test Lookup 124\", \"GUID\", \"Title\"); await fieldAddResult.field.update({ Description: 'New Description' }, \"SP.FieldLookup\");","title":"Add a Lookup Field"},{"location":"sp/fields/#add-a-choice-field","text":"Use the addChoice method to create a new choice field. import { sp } from \"@pnp/sp\"; import { ChoiceFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new choice field called 'My Field' in web const field = await sp.web.fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // create a new choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Choice Field"},{"location":"sp/fields/#add-a-multi-choice-field","text":"Use the addMultiChoice method to create a new multi-choice field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new multi-choice field called 'My Field' in web const field = await sp.web.fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // create a new multi-choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Multi-Choice Field"},{"location":"sp/fields/#add-a-boolean-field","text":"Use the addBoolean method to create a new boolean field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new boolean field called 'My Field' in web const field = await sp.web.fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // create a new boolean field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Boolean Field"},{"location":"sp/fields/#add-a-dependent-lookup-field","text":"Use the addDependentLookupField method to create a new dependent lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in web. const field = await sp.web.fields.getByTitle(\"My Field\")(); const fieldDep = await sp.web.fields.addDependentLookupField(\"My Dep Field\", field.Id, \"Description\"); // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\")(); const fieldDep2 = await sp.web.lists.getByTitle(\"My List\").fields.addDependentLookupField(\"My Dep Field\", field2.Id, \"Description\"); // we can use this 'fieldDep' variable to run more queries on the field: const r = await fieldDep.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Dependent Lookup Field"},{"location":"sp/fields/#add-a-location-field","text":"Use the addLocation method to create a new location field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new location field called 'My Field' in web const field = await sp.web.fields.addLocation(\"My Field\", { Group: \"My Group\" }); // create a new location field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLocation(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Location Field"},{"location":"sp/fields/#delete-a-field","text":"Use the delete method to delete a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; // delete one or more fields from web, returns boolean const result = await sp.web.fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.fields.getByTitle(\"My Field 2\").delete(); // delete one or more fields from list 'My List', returns boolean const result = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field 2\").delete();","title":"Delete a Field"},{"location":"sp/fields/#update-a-field","text":"Use the update method to update a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // update the field called 'My Field' with a description in web, returns FieldUpdateResult const fieldUpdate = await sp.web.fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // update the field called 'My Field' with a description in list 'My List', returns FieldUpdateResult const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // if you need to update a field with properties for a specific field type you can optionally include the field type as a second param // if you do not include it we will look up the type, but that adds a call to the server const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Look up Field\").update({ RelationshipDeleteBehavior: 1 }, \"SP.FieldLookup\");","title":"Update a Field"},{"location":"sp/fields/#show-a-field-in-the-display-form","text":"Use the setShowInDisplayForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in display form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInDisplayForm(true); // show field called 'My Field' in display form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInDisplayForm(true);","title":"Show a Field in the Display Form"},{"location":"sp/fields/#show-a-field-in-the-edit-form","text":"Use the setShowInEditForm method to add a field to the edit form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in edit form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInEditForm(true); // show field called 'My Field' in edit form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInEditForm(true);","title":"Show a Field in the Edit Form"},{"location":"sp/fields/#show-a-field-in-the-new-form","text":"Use the setShowInNewForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in new form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInNewForm(true); // show field called 'My Field' in new form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInNewForm(true);","title":"Show a Field in the New Form"},{"location":"sp/files/","text":"@pnp/sp/files \u00b6 One of the more challenging tasks on the client side is working with SharePoint files, especially if they are large files. We have added some methods to the library to help and their use is outlined below. Reading Files \u00b6 Reading files from the client using REST is covered in the below examples. The important thing to remember is choosing which format you want the file in so you can appropriately process it. You can retrieve a file as Blob, Buffer, JSON, or Text. If you have a special requirement you could also write your own parser . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const blob: Blob = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBlob(); const buffer: ArrayBuffer = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBuffer(); const json: any = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.json\").getJSON(); const text: string = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.txt\").getText(); // all of these also work from a file object no matter how you access it const text2: string = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/documents\").files.getByName(\"file.txt\").getText(); getFileByUrl \u00b6 Added in 2.0.4 This method supports opening files from sharing links or absolute urls. The file must reside in the site from which you are trying to open the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const url = \"{absolute file url OR sharing url}\"; // file is an IFile and supports all the file operations const file = sp.web.getFileByUrl(url); // for example const fileContent = await file.getText(); Adding Files \u00b6 Likewise you can add files using one of two methods, add or addChunked. AddChunked is appropriate for larger files, generally larger than 10 MB but this may differ based on your bandwidth/latency so you can adjust the code to use the chunked method. The below example shows getting the file object from an input and uploading it to SharePoint, choosing the upload method based on file size. declare var require: (s: string) => any; import { ConsoleListener, Logger, LogLevel } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import { auth } from \"./auth\"; let $ = require(\"jquery\"); // <-- used here for illustration let siteUrl = \"https://mytenant.sharepoint.com/sites/dev\"; // comment this out for non-node execution // auth(siteUrl); Logger.subscribe(new ConsoleListener()); Logger.activeLogLevel = LogLevel.Verbose; let web = Web(siteUrl); $(() => { $(\"#testingdiv\").append(\"<button id='thebuttontodoit'>Do It</button>\"); $(\"#thebuttontodoit\").on('click', async (e) => { e.preventDefault(); let input = <HTMLInputElement>document.getElementById(\"thefileinput\"); let file = input.files[0]; // you can adjust this number to control what size files are uploaded in chunks if (file.size <= 10485760) { // small upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(file.name, file, true); Logger.write(\"done\"); } else { // large upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addChunked(file.name, file, data => { Logger.log({ data: data, level: LogLevel.Verbose, message: \"progress\" }); }, true); Logger.write(\"done!\") } }); }); Adding a file using Nodejs Streams \u00b6 If you are working in nodejs you can also add a file using a stream. This example makes a copy of a file using streams. // triggers auto-application of extensions, in this case to add getStream import \"@pnp/nodejs\"; // get a stream of an existing file const sr = await sp.web.getFileByServerRelativePath(\"/sites/dev/shared documents/old.md\").getStream(); // now add the stream as a new file, remember to set the content-length header const fr = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.configure({ headers: { \"content-length\": `${sr.knownLength}`, }, }).add(\"new.md\", sr.body); Setting Associated Item Values \u00b6 You can also update the file properties of a newly uploaded file using code similar to the below snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(\"file.name\", \"file\", true); const item = await file.file.getItem(); await item.update({ Title: \"A Title\", OtherField: \"My Other Value\" }); AddUsingPath \u00b6 If you need to support the percent or pound characters you can use the addUsingPath method of IFiles import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addUsingPath(\"file%#%.name\", \"content\"); Update File Content \u00b6 You can of course use similar methods to update existing files as shown below. This overwrites the existing content in the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.txt\").setContent(\"New string content for the file.\"); await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.mp4\").setContentChunked(file); Check in, Check out, and Approve & Deny \u00b6 The library provides helper methods for checking in, checking out, and approving files. Examples of these methods are shown below. Check In \u00b6 Check in takes two optional arguments, comment and check in type. import { sp } from \"@pnp/sp\"; import { CheckinType } from \"@pnp/sp/files\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // default options with empty comment and CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(); console.log(\"File checked in!\"); // supply a comment (< 1024 chars) and using default check in type CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\"); console.log(\"File checked in!\"); // Supply both comment and check in type await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\", CheckinType.Overwrite); console.log(\"File checked in!\"); Check Out \u00b6 Check out takes no arguments. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkout(); console.log(\"File checked out!\"); Approve and Deny \u00b6 You can also approve or deny files in libraries that use approval. Approve takes a single required argument of comment, the comment is optional for deny. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").approve(\"Approval Comment\"); console.log(\"File approved!\"); // deny with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(); console.log(\"File denied!\"); // deny with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(\"Deny comment\"); console.log(\"File denied!\"); Publish and Unpublish \u00b6 You can both publish and unpublish a file using the library. Both methods take an optional comment argument. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // publish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(); console.log(\"File published!\"); // publish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(\"Publish comment\"); console.log(\"File published!\"); // unpublish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(); console.log(\"File unpublished!\"); // unpublish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(\"Unpublish comment\"); console.log(\"File unpublished!\"); Advanced Upload Options \u00b6 Both the addChunked and setContentChunked methods support options beyond just supplying the file content. progress function \u00b6 A method that is called each time a chunk is uploaded and provides enough information to report progress or update a progress bar easily. The method has the signature: (data: ChunkedFileUploadProgressData) => void The data interface is: export interface ChunkedFileUploadProgressData { stage: \"starting\" | \"continue\" | \"finishing\"; blockNumber: number; totalBlocks: number; chunkSize: number; currentPointer: number; fileSize: number; } chunkSize \u00b6 This property controls the size of the individual chunks and is defaulted to 10485760 bytes (10 MB). You can adjust this based on your bandwidth needs - especially if writing code for mobile uploads or you are seeing frequent timeouts. getItem \u00b6 This method allows you to get the item associated with this file. You can optionally specify one or more select fields. The result will be merged with a new Item instance so you will have both the returned property values and chaining ability in a single object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/security\"; const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(); console.log(item); const item2 = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(\"Title\", \"Modified\"); console.log(item2); // you can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms); You can also supply a generic typing parameter and the resulting type will be a union type of Item and the generic type parameter. This allows you to have proper intellisense and type checking. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/items\"; import \"@pnp/sp/security\"; // also supports typing the objects so your type will be a union type const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem<{ Id: number, Title: string }>(\"Id\", \"Title\"); // You get intellisense and proper typing of the returned object console.log(`Id: ${item.Id} -- ${item.Title}`); // You can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms); move \u00b6 It's possible to move a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveTo(destinationUrl); copy \u00b6 It's possible to copy a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyTo(destinationUrl, false); move by path \u00b6 It's possible to move a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveByPath(destinationUrl, false, true); copy by path \u00b6 It's possible to copy a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyByPath(destinationUrl, false, true); getFileById \u00b6 You can get a file by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import { IFile } from \"@pnp/sp/files\"; const file: IFile = sp.web.getFileById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); delete \u00b6 Deletes a file import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").delete(); delete with params \u00b6 Added in 2.0.9 Deletes a file with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").deleteWithParams({ BypassSharedLock: true, }); exists \u00b6 Added in 2.0.9 Checks to see if a file exists import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; const exists = await sp.web.rootFolder.files.getByName(\"name.txt\").exists();","title":"Files"},{"location":"sp/files/#pnpspfiles","text":"One of the more challenging tasks on the client side is working with SharePoint files, especially if they are large files. We have added some methods to the library to help and their use is outlined below.","title":"@pnp/sp/files"},{"location":"sp/files/#reading-files","text":"Reading files from the client using REST is covered in the below examples. The important thing to remember is choosing which format you want the file in so you can appropriately process it. You can retrieve a file as Blob, Buffer, JSON, or Text. If you have a special requirement you could also write your own parser . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const blob: Blob = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBlob(); const buffer: ArrayBuffer = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBuffer(); const json: any = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.json\").getJSON(); const text: string = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.txt\").getText(); // all of these also work from a file object no matter how you access it const text2: string = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/documents\").files.getByName(\"file.txt\").getText();","title":"Reading Files"},{"location":"sp/files/#getfilebyurl","text":"Added in 2.0.4 This method supports opening files from sharing links or absolute urls. The file must reside in the site from which you are trying to open the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const url = \"{absolute file url OR sharing url}\"; // file is an IFile and supports all the file operations const file = sp.web.getFileByUrl(url); // for example const fileContent = await file.getText();","title":"getFileByUrl"},{"location":"sp/files/#adding-files","text":"Likewise you can add files using one of two methods, add or addChunked. AddChunked is appropriate for larger files, generally larger than 10 MB but this may differ based on your bandwidth/latency so you can adjust the code to use the chunked method. The below example shows getting the file object from an input and uploading it to SharePoint, choosing the upload method based on file size. declare var require: (s: string) => any; import { ConsoleListener, Logger, LogLevel } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import { auth } from \"./auth\"; let $ = require(\"jquery\"); // <-- used here for illustration let siteUrl = \"https://mytenant.sharepoint.com/sites/dev\"; // comment this out for non-node execution // auth(siteUrl); Logger.subscribe(new ConsoleListener()); Logger.activeLogLevel = LogLevel.Verbose; let web = Web(siteUrl); $(() => { $(\"#testingdiv\").append(\"<button id='thebuttontodoit'>Do It</button>\"); $(\"#thebuttontodoit\").on('click', async (e) => { e.preventDefault(); let input = <HTMLInputElement>document.getElementById(\"thefileinput\"); let file = input.files[0]; // you can adjust this number to control what size files are uploaded in chunks if (file.size <= 10485760) { // small upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(file.name, file, true); Logger.write(\"done\"); } else { // large upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addChunked(file.name, file, data => { Logger.log({ data: data, level: LogLevel.Verbose, message: \"progress\" }); }, true); Logger.write(\"done!\") } }); });","title":"Adding Files"},{"location":"sp/files/#adding-a-file-using-nodejs-streams","text":"If you are working in nodejs you can also add a file using a stream. This example makes a copy of a file using streams. // triggers auto-application of extensions, in this case to add getStream import \"@pnp/nodejs\"; // get a stream of an existing file const sr = await sp.web.getFileByServerRelativePath(\"/sites/dev/shared documents/old.md\").getStream(); // now add the stream as a new file, remember to set the content-length header const fr = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.configure({ headers: { \"content-length\": `${sr.knownLength}`, }, }).add(\"new.md\", sr.body);","title":"Adding a file using Nodejs Streams"},{"location":"sp/files/#setting-associated-item-values","text":"You can also update the file properties of a newly uploaded file using code similar to the below snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(\"file.name\", \"file\", true); const item = await file.file.getItem(); await item.update({ Title: \"A Title\", OtherField: \"My Other Value\" });","title":"Setting Associated Item Values"},{"location":"sp/files/#addusingpath","text":"If you need to support the percent or pound characters you can use the addUsingPath method of IFiles import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addUsingPath(\"file%#%.name\", \"content\");","title":"AddUsingPath"},{"location":"sp/files/#update-file-content","text":"You can of course use similar methods to update existing files as shown below. This overwrites the existing content in the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.txt\").setContent(\"New string content for the file.\"); await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.mp4\").setContentChunked(file);","title":"Update File Content"},{"location":"sp/files/#check-in-check-out-and-approve-deny","text":"The library provides helper methods for checking in, checking out, and approving files. Examples of these methods are shown below.","title":"Check in, Check out, and Approve &amp; Deny"},{"location":"sp/files/#check-in","text":"Check in takes two optional arguments, comment and check in type. import { sp } from \"@pnp/sp\"; import { CheckinType } from \"@pnp/sp/files\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // default options with empty comment and CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(); console.log(\"File checked in!\"); // supply a comment (< 1024 chars) and using default check in type CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\"); console.log(\"File checked in!\"); // Supply both comment and check in type await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\", CheckinType.Overwrite); console.log(\"File checked in!\");","title":"Check In"},{"location":"sp/files/#check-out","text":"Check out takes no arguments. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkout(); console.log(\"File checked out!\");","title":"Check Out"},{"location":"sp/files/#approve-and-deny","text":"You can also approve or deny files in libraries that use approval. Approve takes a single required argument of comment, the comment is optional for deny. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").approve(\"Approval Comment\"); console.log(\"File approved!\"); // deny with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(); console.log(\"File denied!\"); // deny with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(\"Deny comment\"); console.log(\"File denied!\");","title":"Approve and Deny"},{"location":"sp/files/#publish-and-unpublish","text":"You can both publish and unpublish a file using the library. Both methods take an optional comment argument. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // publish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(); console.log(\"File published!\"); // publish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(\"Publish comment\"); console.log(\"File published!\"); // unpublish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(); console.log(\"File unpublished!\"); // unpublish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(\"Unpublish comment\"); console.log(\"File unpublished!\");","title":"Publish and Unpublish"},{"location":"sp/files/#advanced-upload-options","text":"Both the addChunked and setContentChunked methods support options beyond just supplying the file content.","title":"Advanced Upload Options"},{"location":"sp/files/#progress-function","text":"A method that is called each time a chunk is uploaded and provides enough information to report progress or update a progress bar easily. The method has the signature: (data: ChunkedFileUploadProgressData) => void The data interface is: export interface ChunkedFileUploadProgressData { stage: \"starting\" | \"continue\" | \"finishing\"; blockNumber: number; totalBlocks: number; chunkSize: number; currentPointer: number; fileSize: number; }","title":"progress function"},{"location":"sp/files/#chunksize","text":"This property controls the size of the individual chunks and is defaulted to 10485760 bytes (10 MB). You can adjust this based on your bandwidth needs - especially if writing code for mobile uploads or you are seeing frequent timeouts.","title":"chunkSize"},{"location":"sp/files/#getitem","text":"This method allows you to get the item associated with this file. You can optionally specify one or more select fields. The result will be merged with a new Item instance so you will have both the returned property values and chaining ability in a single object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/security\"; const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(); console.log(item); const item2 = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(\"Title\", \"Modified\"); console.log(item2); // you can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms); You can also supply a generic typing parameter and the resulting type will be a union type of Item and the generic type parameter. This allows you to have proper intellisense and type checking. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/items\"; import \"@pnp/sp/security\"; // also supports typing the objects so your type will be a union type const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem<{ Id: number, Title: string }>(\"Id\", \"Title\"); // You get intellisense and proper typing of the returned object console.log(`Id: ${item.Id} -- ${item.Title}`); // You can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms);","title":"getItem"},{"location":"sp/files/#move","text":"It's possible to move a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveTo(destinationUrl);","title":"move"},{"location":"sp/files/#copy","text":"It's possible to copy a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyTo(destinationUrl, false);","title":"copy"},{"location":"sp/files/#move-by-path","text":"It's possible to move a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveByPath(destinationUrl, false, true);","title":"move by path"},{"location":"sp/files/#copy-by-path","text":"It's possible to copy a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyByPath(destinationUrl, false, true);","title":"copy by path"},{"location":"sp/files/#getfilebyid","text":"You can get a file by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import { IFile } from \"@pnp/sp/files\"; const file: IFile = sp.web.getFileById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\");","title":"getFileById"},{"location":"sp/files/#delete","text":"Deletes a file import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").delete();","title":"delete"},{"location":"sp/files/#delete-with-params","text":"Added in 2.0.9 Deletes a file with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").deleteWithParams({ BypassSharedLock: true, });","title":"delete with params"},{"location":"sp/files/#exists","text":"Added in 2.0.9 Checks to see if a file exists import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; const exists = await sp.web.rootFolder.files.getByName(\"name.txt\").exists();","title":"exists"},{"location":"sp/folders/","text":"@pnp/sp/folders \u00b6 Folders serve as a container for your files and list items. IFolders \u00b6 Represents a collection of folders. SharePoint webs, lists, and list items have a collection of folders under their properties. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\"; Get folders collection for various SharePoint objects \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; // gets web's folders const webFolders = await sp.web.folders(); // gets list's folders const listFolders = await sp.web.lists.getByTitle(\"My List\").rootFolder.folders(); // gets item's folders const itemFolders = await sp.web.lists.getByTitle(\"My List\").items.getById(1).folder.folders(); add \u00b6 Adds a new folder to collection of folders import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // creates a new folder for web with specified url const folderAddResult = await sp.web.folders.add(\"folder url\"); getByName \u00b6 Gets a folder instance from a collection by folder's name import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = await sp.web.folders.getByName(\"folder name\")(); IFolder \u00b6 Represents an instance of a SharePoint folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\"; Get a folder object associated with different SharePoint artifacts (web, list, list item) \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // web's folder const rootFolder = await sp.web.rootFolder(); // list's folder const listRootFolder = await sp.web.lists.getByTitle(\"234\").rootFolder(); // item's folder const itemFolder = await sp.web.lists.getByTitle(\"234\").items.getById(1).folder(); getItem \u00b6 Gets list item associated with a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folderItem = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").getItem(); move \u00b6 It's possible to move a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveTo(destinationUrl); copy \u00b6 It's possible to copy a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyTo(destinationUrl); move by path \u00b6 It's possible to move a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveByPath(destinationUrl, true); copy by path \u00b6 It's possible to copy a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyByPath(destinationUrl, true); delete \u00b6 Deletes a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").delete(); delete with params \u00b6 Added in 2.0.9 Deletes a folder with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").deleteWithParams({ BypassSharedLock: true, DeleteIfEmpty: true, }); recycle \u00b6 Recycles a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").recycle(); serverRelativeUrl \u00b6 Gets folder's server relative url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const relUrl = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").serverRelativeUrl(); update \u00b6 Updates folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").update({ \"Name\": \"New name\", }); contentTypeOrder \u00b6 Gets content type order of a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const order = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").contentTypeOrder(); folders \u00b6 Gets all child folders associated with the current folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folders = await sp.web.rootFolder.folders(); files \u00b6 Gets all files inside a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files/folder\"; const files = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").files(); listItemAllFields \u00b6 Gets this folder's list item field values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const itemFields = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").listItemAllFields(); parentFolder \u00b6 Gets the parent folder, if available import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const parentFolder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").parentFolder(); properties \u00b6 Gets this folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const properties = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").properties(); uniqueContentTypeOrder \u00b6 Gets a value that specifies the content type order. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const contentTypeOrder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").uniqueContentTypeOrder(); Rename a folder \u00b6 You can rename a folder by updating FileLeafRef property: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\"); const item = await folder.getItem(); const result = await item.update({ FileLeafRef: \"Folder2\" }); Create a folder with custom content type \u00b6 Below code creates a new folder under Document library and assigns custom folder content type to a newly created folder. Additionally it sets a field of a custom folder content type. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; const newFolderResult = await sp.web.rootFolder.folders.getByName(\"Shared Documents\").folders.add(\"My New Folder\"); const item = await newFolderResult.folder.listItemAllFields(); await sp.web.lists.getByTitle(\"Documents\").items.getById(item.ID).update({ ContentTypeId: \"0x0120001E76ED75A3E3F3408811F0BF56C4CDDD\", MyFolderField: \"field value\", Title: \"My New Folder\", }); addSubFolderUsingPath \u00b6 Added in 2.0.9 You can use the addSubFolderUsingPath method to add a folder with some special chars supported import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; // add a folder to site assets const folder: IFolder = await web.rootFolder.folders.getByName(\"SiteAssets\").addSubFolderUsingPath(\"folder name\"); getFolderById \u00b6 You can get a folder by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); getParentInfos \u00b6 Added in 2.0.12 Gets information about folder, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); await folder.getParentInfos();","title":"Folders"},{"location":"sp/folders/#pnpspfolders","text":"Folders serve as a container for your files and list items.","title":"@pnp/sp/folders"},{"location":"sp/folders/#ifolders","text":"Represents a collection of folders. SharePoint webs, lists, and list items have a collection of folders under their properties. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\";","title":"IFolders"},{"location":"sp/folders/#get-folders-collection-for-various-sharepoint-objects","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; // gets web's folders const webFolders = await sp.web.folders(); // gets list's folders const listFolders = await sp.web.lists.getByTitle(\"My List\").rootFolder.folders(); // gets item's folders const itemFolders = await sp.web.lists.getByTitle(\"My List\").items.getById(1).folder.folders();","title":"Get folders collection for various SharePoint objects"},{"location":"sp/folders/#add","text":"Adds a new folder to collection of folders import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // creates a new folder for web with specified url const folderAddResult = await sp.web.folders.add(\"folder url\");","title":"add"},{"location":"sp/folders/#getbyname","text":"Gets a folder instance from a collection by folder's name import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = await sp.web.folders.getByName(\"folder name\")();","title":"getByName"},{"location":"sp/folders/#ifolder","text":"Represents an instance of a SharePoint folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\";","title":"IFolder"},{"location":"sp/folders/#get-a-folder-object-associated-with-different-sharepoint-artifacts-web-list-list-item","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // web's folder const rootFolder = await sp.web.rootFolder(); // list's folder const listRootFolder = await sp.web.lists.getByTitle(\"234\").rootFolder(); // item's folder const itemFolder = await sp.web.lists.getByTitle(\"234\").items.getById(1).folder();","title":"Get a folder object associated with different SharePoint artifacts (web, list, list item)"},{"location":"sp/folders/#getitem","text":"Gets list item associated with a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folderItem = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").getItem();","title":"getItem"},{"location":"sp/folders/#move","text":"It's possible to move a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveTo(destinationUrl);","title":"move"},{"location":"sp/folders/#copy","text":"It's possible to copy a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyTo(destinationUrl);","title":"copy"},{"location":"sp/folders/#move-by-path","text":"It's possible to move a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveByPath(destinationUrl, true);","title":"move by path"},{"location":"sp/folders/#copy-by-path","text":"It's possible to copy a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyByPath(destinationUrl, true);","title":"copy by path"},{"location":"sp/folders/#delete","text":"Deletes a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").delete();","title":"delete"},{"location":"sp/folders/#delete-with-params","text":"Added in 2.0.9 Deletes a folder with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").deleteWithParams({ BypassSharedLock: true, DeleteIfEmpty: true, });","title":"delete with params"},{"location":"sp/folders/#recycle","text":"Recycles a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").recycle();","title":"recycle"},{"location":"sp/folders/#serverrelativeurl","text":"Gets folder's server relative url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const relUrl = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").serverRelativeUrl();","title":"serverRelativeUrl"},{"location":"sp/folders/#update","text":"Updates folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").update({ \"Name\": \"New name\", });","title":"update"},{"location":"sp/folders/#contenttypeorder","text":"Gets content type order of a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const order = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").contentTypeOrder();","title":"contentTypeOrder"},{"location":"sp/folders/#folders","text":"Gets all child folders associated with the current folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folders = await sp.web.rootFolder.folders();","title":"folders"},{"location":"sp/folders/#files","text":"Gets all files inside a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files/folder\"; const files = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").files();","title":"files"},{"location":"sp/folders/#listitemallfields","text":"Gets this folder's list item field values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const itemFields = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").listItemAllFields();","title":"listItemAllFields"},{"location":"sp/folders/#parentfolder","text":"Gets the parent folder, if available import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const parentFolder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").parentFolder();","title":"parentFolder"},{"location":"sp/folders/#properties","text":"Gets this folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const properties = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").properties();","title":"properties"},{"location":"sp/folders/#uniquecontenttypeorder","text":"Gets a value that specifies the content type order. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const contentTypeOrder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").uniqueContentTypeOrder();","title":"uniqueContentTypeOrder"},{"location":"sp/folders/#rename-a-folder","text":"You can rename a folder by updating FileLeafRef property: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\"); const item = await folder.getItem(); const result = await item.update({ FileLeafRef: \"Folder2\" });","title":"Rename a folder"},{"location":"sp/folders/#create-a-folder-with-custom-content-type","text":"Below code creates a new folder under Document library and assigns custom folder content type to a newly created folder. Additionally it sets a field of a custom folder content type. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; const newFolderResult = await sp.web.rootFolder.folders.getByName(\"Shared Documents\").folders.add(\"My New Folder\"); const item = await newFolderResult.folder.listItemAllFields(); await sp.web.lists.getByTitle(\"Documents\").items.getById(item.ID).update({ ContentTypeId: \"0x0120001E76ED75A3E3F3408811F0BF56C4CDDD\", MyFolderField: \"field value\", Title: \"My New Folder\", });","title":"Create a folder with custom content type"},{"location":"sp/folders/#addsubfolderusingpath","text":"Added in 2.0.9 You can use the addSubFolderUsingPath method to add a folder with some special chars supported import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; // add a folder to site assets const folder: IFolder = await web.rootFolder.folders.getByName(\"SiteAssets\").addSubFolderUsingPath(\"folder name\");","title":"addSubFolderUsingPath"},{"location":"sp/folders/#getfolderbyid","text":"You can get a folder by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\");","title":"getFolderById"},{"location":"sp/folders/#getparentinfos","text":"Added in 2.0.12 Gets information about folder, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); await folder.getParentInfos();","title":"getParentInfos"},{"location":"sp/forms/","text":"@pnp/sp/forms \u00b6 Forms in SharePoint are the Display, New, and Edit forms associated with a list. IFields \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\"; Get Form by Id \u00b6 Gets a form from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\"; // get the field by Id for web const form = sp.web.lists.getByTitle(\"Documents\").forms.getById(\"{c4486774-f1e2-4804-96f3-91edf3e22a19}\")();","title":"Forms"},{"location":"sp/forms/#pnpspforms","text":"Forms in SharePoint are the Display, New, and Edit forms associated with a list.","title":"@pnp/sp/forms"},{"location":"sp/forms/#ifields","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\";","title":"IFields"},{"location":"sp/forms/#get-form-by-id","text":"Gets a form from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\"; // get the field by Id for web const form = sp.web.lists.getByTitle(\"Documents\").forms.getById(\"{c4486774-f1e2-4804-96f3-91edf3e22a19}\")();","title":"Get Form by Id"},{"location":"sp/hubsites/","text":"@pnp/sp/hubsites \u00b6 This module helps you with working with hub sites in your tenant. IHubSites \u00b6 Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/hubsites\"; Preset: All import { sp, HubSites, IHubSites } from \"@pnp/sp/presets/all\"; Get a Listing of All Hub sites \u00b6 import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; // invoke the hub sites object const hubsites: IHubSiteInfo[] = await sp.hubSites(); // you can also use select to only return certain fields: const hubsites2: IHubSiteInfo[] = await sp.hubSites.select(\"ID\", \"Title\", \"RelatedHubSiteIds\")(); Get Hub site by Id \u00b6 Using the getById method on the hubsites module to get a hub site by site Id (guid). import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; const hubsite: IHubSiteInfo = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\")(); // log hub site title to console console.log(hubsite.Title); Get ISite instance \u00b6 We provide a helper method to load the ISite instance from the HubSite import { sp } from \"@pnp/sp\"; import { ISite } from \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites\"; const site: ISite = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\").getSite(); const siteData = await site(); console.log(siteData.Title); Get Hub site data for a web \u00b6 import { sp } from \"@pnp/sp\"; import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; const webData: Partial<IHubSiteWebData> = await sp.web.hubSiteData(); // you can also force a refresh of the hub site data const webData2: Partial<IHubSiteWebData> = await sp.web.hubSiteData(true); syncHubSiteTheme \u00b6 Allows you to apply theme updates from the parent hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; await sp.web.syncHubSiteTheme(); Hub site Site Methods \u00b6 You manage hub sites at the Site level. joinHubSite \u00b6 Id of the hub site collection you want to join. If you want to disassociate the site collection from hub site, then pass the siteId as 00000000-0000-0000-0000-000000000000 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // join a site to a hub site await sp.site.joinHubSite(\"{parent hub site id}\"); // remove a site from a hub site await sp.site.joinHubSite(\"00000000-0000-0000-0000-000000000000\"); registerHubSite \u00b6 Registers the current site collection as hub site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // register current site as a hub site await sp.site.registerHubSite(); unRegisterHubSite \u00b6 Un-registers the current site collection as hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // make a site no longer a hub await sp.site.unRegisterHubSite();","title":"Hubsites"},{"location":"sp/hubsites/#pnpsphubsites","text":"This module helps you with working with hub sites in your tenant.","title":"@pnp/sp/hubsites"},{"location":"sp/hubsites/#ihubsites","text":"Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/hubsites\"; Preset: All import { sp, HubSites, IHubSites } from \"@pnp/sp/presets/all\";","title":"IHubSites"},{"location":"sp/hubsites/#get-a-listing-of-all-hub-sites","text":"import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; // invoke the hub sites object const hubsites: IHubSiteInfo[] = await sp.hubSites(); // you can also use select to only return certain fields: const hubsites2: IHubSiteInfo[] = await sp.hubSites.select(\"ID\", \"Title\", \"RelatedHubSiteIds\")();","title":"Get a Listing of All Hub sites"},{"location":"sp/hubsites/#get-hub-site-by-id","text":"Using the getById method on the hubsites module to get a hub site by site Id (guid). import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; const hubsite: IHubSiteInfo = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\")(); // log hub site title to console console.log(hubsite.Title);","title":"Get Hub site by Id"},{"location":"sp/hubsites/#get-isite-instance","text":"We provide a helper method to load the ISite instance from the HubSite import { sp } from \"@pnp/sp\"; import { ISite } from \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites\"; const site: ISite = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\").getSite(); const siteData = await site(); console.log(siteData.Title);","title":"Get ISite instance"},{"location":"sp/hubsites/#get-hub-site-data-for-a-web","text":"import { sp } from \"@pnp/sp\"; import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; const webData: Partial<IHubSiteWebData> = await sp.web.hubSiteData(); // you can also force a refresh of the hub site data const webData2: Partial<IHubSiteWebData> = await sp.web.hubSiteData(true);","title":"Get Hub site data for a web"},{"location":"sp/hubsites/#synchubsitetheme","text":"Allows you to apply theme updates from the parent hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; await sp.web.syncHubSiteTheme();","title":"syncHubSiteTheme"},{"location":"sp/hubsites/#hub-site-site-methods","text":"You manage hub sites at the Site level.","title":"Hub site Site Methods"},{"location":"sp/hubsites/#joinhubsite","text":"Id of the hub site collection you want to join. If you want to disassociate the site collection from hub site, then pass the siteId as 00000000-0000-0000-0000-000000000000 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // join a site to a hub site await sp.site.joinHubSite(\"{parent hub site id}\"); // remove a site from a hub site await sp.site.joinHubSite(\"00000000-0000-0000-0000-000000000000\");","title":"joinHubSite"},{"location":"sp/hubsites/#registerhubsite","text":"Registers the current site collection as hub site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // register current site as a hub site await sp.site.registerHubSite();","title":"registerHubSite"},{"location":"sp/hubsites/#unregisterhubsite","text":"Un-registers the current site collection as hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // make a site no longer a hub await sp.site.unRegisterHubSite();","title":"unRegisterHubSite"},{"location":"sp/items/","text":"@pnp/sp/items \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\"; GET \u00b6 Getting items from a list is one of the basic actions that most applications require. This is made easy through the library and the following examples demonstrate these actions. Basic Get \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // get all the items from a list const items: any[] = await sp.web.lists.getByTitle(\"My List\").items(); console.log(items); // get a specific item by id. const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); console.log(item); // use odata operators for more efficient queries const items2: any[] = await sp.web.lists.getByTitle(\"My List\").items.select(\"Title\", \"Description\").top(5).orderBy(\"Modified\", true)(); console.log(items2); Get Paged Items \u00b6 Working with paging can be a challenge as it is based on skip tokens and item ids, something that is hard to guess at runtime. To simplify things you can use the getPaged method on the Items class to assist. Note that there isn't a way to move backwards in the collection, this is by design. The pattern you should use to support backwards navigation in the results is to cache the results into a local array and use the standard array operators to get previous pages. Alternatively you can append the results to the UI, but this can have performance impact for large result sets. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic case to get paged items form a list let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged(); // you can also provide a type for the returned values instead of any let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged<{Title: string}[]>(); // the query also works with select to choose certain fields and top to set the page size let items = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\", \"Description\").top(50).getPaged<{Title: string}[]>(); // the results object will have two properties and one method: // the results property will be an array of the items returned if (items.results.length > 0) { console.log(\"We got results!\"); for (let i = 0; i < items.results.length; i++) { // type checking works here if we specify the return type console.log(items.results[i].Title); } } // the hasNext property is used with the getNext method to handle paging // hasNext will be true so long as there are additional results if (items.hasNext) { // this will carry over the type specified in the original query for the results array items = await items.getNext(); console.log(items.results.length); } getListItemChangesSinceToken \u00b6 The GetListItemChangesSinceToken method allows clients to track changes on a list. Changes, including deleted items, are returned along with a token that represents the moment in time when those changes were requested. By including this token when you call GetListItemChangesSinceToken, the server looks for only those changes that have occurred since the token was generated. Sending a GetListItemChangesSinceToken request without including a token returns the list schema, the full list contents and a token. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // Using RowLimit. Enables paging let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({RowLimit: '5'}); // Use QueryOptions to make a XML-style query. // Because it's XML we need to escape special characters // Instead of & we use &amp; in the query let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({QueryOptions: '<Paging ListItemCollectionPositionNext=\"Paged=TRUE&amp;p_ID=5\" />'}); // Get everything. Using null with ChangeToken gets everything let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({ChangeToken: null}); Get All Items \u00b6 Using the items collection's getAll method you can get all of the items in a list regardless of the size of the list. Sample usage is shown below. Only the odata operations top, select, and filter are supported. usingCaching and inBatch are ignored - you will need to handle caching the results on your own. This method will write a warning to the Logger and should not frequently be used. Instead the standard paging operations should be used. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic usage const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(); console.log(allItems.length); // set page size const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(4000); console.log(allItems.length); // use select and top. top will set page size and override the any value passed to getAll const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").top(4000).getAll(); console.log(allItems.length); // we can also use filter as a supported odata operation, but this will likely fail on large lists const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").filter(\"Title eq 'Test'\").getAll(); console.log(allItems.length); Retrieving Lookup Fields \u00b6 When working with lookup fields you need to use the expand operator along with select to get the related fields from the lookup column. This works for both the items collection and item instances. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const items = await sp.web.lists.getByTitle(\"LookupList\").items.select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(items); const item = await sp.web.lists.getByTitle(\"LookupList\").items.getById(1).select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(item); Filter using Metadata fields \u00b6 To filter on a metadata field you must use the getItemsByCAMLQuery method as $filter does not support these fields. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; const r = await sp.web.lists.getByTitle(\"TaxonomyList\").getItemsByCAMLQuery({ ViewXml: `<View><Query><Where><Eq><FieldRef Name=\"MetaData\"/><Value Type=\"TaxonomyFieldType\">Term 2</Value></Eq></Where></Query></View>`, }); Retrieving PublishingPageImage \u00b6 The PublishingPageImage and some other publishing-related fields aren't stored in normal fields, rather in the MetaInfo field. To get these values you need to use the technique shown below, and originally outlined in this thread . Note that a lot of information can be stored in this field so will pull back potentially a significant amount of data, so limit the rows as possible to aid performance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { Web } from \"@pnp/sp/webs\"; try { const w = Web(\"https://{publishing site url}\"); const r = await w.lists.getByTitle(\"Pages\").items .select(\"Title\", \"FileRef\", \"FieldValuesAsText/MetaInfo\") .expand(\"FieldValuesAsText\") (); // look through the returned items. for (var i = 0; i < r.length; i++) { // the title field value console.log(r[i].Title); // find the value in the MetaInfo string using regex const matches = /PublishingPageImage:SW\\|(.*?)\\r\\n/ig.exec(r[i].FieldValuesAsText.MetaInfo); if (matches !== null && matches.length > 1) { // this wil be the value of the PublishingPageImage field console.log(matches[1]); } } } catch (e) { console.error(e); } Add Items \u00b6 There are several ways to add items to a list. The simplest just uses the add method of the items collection passing in the properties as a plain object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { IItemAddResult } from \"@pnp/sp/items\"; // add an item to the list const iar: IItemAddResult = await sp.web.lists.getByTitle(\"My List\").items.add({ Title: \"Title\", Description: \"Description\" }); console.log(iar); Content Type \u00b6 You can also set the content type id when you create an item as shown in the example below. For more information on content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; await sp.web.lists.getById(\"4D5A36EA-6E84-4160-8458-65C436DB765C\").items.add({ Title: \"Test 1\", ContentTypeId: \"0x01030058FD86C279252341AB303852303E4DAF\" }); User Fields \u00b6 There are two types of user fields, those that allow a single value and those that allow multiple. For both types, you first need to determine the Id field name, which you can do by doing a GET REST request on an existing item. Typically the value will be the user field internal name with \"Id\" appended. So in our example, we have two fields User1 and User2 so the Id fields are User1Id and User2Id. Next, you need to remember there are two types of user fields, those that take a single value and those that allow multiple - these are updated in different ways. For single value user fields you supply just the user's id. For multiple value fields, you need to supply an object with a \"results\" property and an array. Examples for both are shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; const i = await sp.web.lists.getByTitle(\"PeopleFields\").items.add({ Title: getGUID(), User1Id: 9, // allows a single user User2Id: { results: [16, 45] // allows multiple users } }); console.log(i); If you want to update or add user field values when using validateUpdateListItem you need to use the form shown below. You can specify multiple values in the array. import { sp } from \"@pnp/sp\"; const result = await sp.web.lists.getByTitle(\"UserFieldList\").items.getById(1).validateUpdateListItem([{ FieldName: \"UserField\", FieldValue: JSON.stringify([{ \"Key\": \"i:0#.f|membership|person@tenant.com\" }]), }, { FieldName: \"Title\", FieldValue: \"Test - Updated\", }]); Lookup Fields \u00b6 What is said for User Fields is, in general, relevant to Lookup Fields: Lookup Field types: Single-valued lookup Multiple-valued lookup Id suffix should be appended to the end of lookups EntityPropertyName in payloads Numeric Ids for lookups' items should be passed as values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; await sp.web.lists.getByTitle(\"LookupFields\").items.add({ Title: getGUID(), LookupFieldId: 2, // allows a single lookup value MultiLookupFieldId: { results: [ 1, 56 ] // allows multiple lookup value } }); Add Multiple Items \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidadd\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: \"Batch 6\" }, entityTypeFullName).then(b => { console.log(b); }); list.items.inBatch(batch).add({ Title: \"Batch 7\" }, entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\"); Update \u00b6 The update method is very similar to the add method in that it takes a plain object representing the fields to update. The property names are the internal names of the fields. If you aren't sure you can always do a get request for an item in the list and see the field names that come back - you would use these same names to update the item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const i = await list.items.getById(1).update({ Title: \"My New Title\", Description: \"Here is a new description\" }); console.log(i); Getting and updating a collection using filter \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // you are getting back a collection here const items: any[] = await sp.web.lists.getByTitle(\"MyList\").items.top(1).filter(\"Title eq 'A Title'\")(); // see if we got something if (items.length > 0) { const updatedItem = await sp.web.lists.getByTitle(\"MyList\").items.getById(items[0].Id).update({ Title: \"Updated Title\", }); console.log(JSON.stringify(updatedItem)); } Update Multiple Items \u00b6 This approach avoids multiple calls for the same list's entity type name. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidupdate\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); // note requirement of \"*\" eTag param - or use a specific eTag value as needed list.items.getById(1).inBatch(batch).update({ Title: \"Batch 6\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); list.items.getById(2).inBatch(batch).update({ Title: \"Batch 7\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\") Recycle \u00b6 To send an item to the recycle bin use recycle. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const recycleBinIdentifier = await list.items.getById(1).recycle(); Delete \u00b6 Delete is as simple as calling the .delete method. It optionally takes an eTag if you need to manage concurrency. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).delete(); Delete With Params \u00b6 Added in 2.0.9 Deletes the item object with options. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).deleteWithParams({ BypassSharedLock: true, }); The deleteWithParams method can only be used by accounts where UserToken.IsSystemAccount is true Resolving field names \u00b6 It's a very common mistake trying wrong field names in the requests. Field's EntityPropertyName value should be used. The easiest way to get know EntityPropertyName is to use the following snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import \"@pnp/sp/fields\"; const response = await sp.web.lists .getByTitle('[Lists_Title]') .fields .select('Title, EntityPropertyName') .filter(`Hidden eq false and Title eq '[Field's_Display_Name]'`) (); console.log(response.map(field => { return { Title: field.Title, EntityPropertyName: field.EntityPropertyName }; })); Lookup fields' names should be ended with additional Id suffix. E.g. for Editor EntityPropertyName EditorId should be used. getParentInfos \u00b6 Added in 2.0.12 Gets information about an item, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); await item.getParentInfos();","title":"List Items"},{"location":"sp/items/#pnpspitems","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\";","title":"@pnp/sp/items"},{"location":"sp/items/#get","text":"Getting items from a list is one of the basic actions that most applications require. This is made easy through the library and the following examples demonstrate these actions.","title":"GET"},{"location":"sp/items/#basic-get","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // get all the items from a list const items: any[] = await sp.web.lists.getByTitle(\"My List\").items(); console.log(items); // get a specific item by id. const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); console.log(item); // use odata operators for more efficient queries const items2: any[] = await sp.web.lists.getByTitle(\"My List\").items.select(\"Title\", \"Description\").top(5).orderBy(\"Modified\", true)(); console.log(items2);","title":"Basic Get"},{"location":"sp/items/#get-paged-items","text":"Working with paging can be a challenge as it is based on skip tokens and item ids, something that is hard to guess at runtime. To simplify things you can use the getPaged method on the Items class to assist. Note that there isn't a way to move backwards in the collection, this is by design. The pattern you should use to support backwards navigation in the results is to cache the results into a local array and use the standard array operators to get previous pages. Alternatively you can append the results to the UI, but this can have performance impact for large result sets. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic case to get paged items form a list let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged(); // you can also provide a type for the returned values instead of any let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged<{Title: string}[]>(); // the query also works with select to choose certain fields and top to set the page size let items = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\", \"Description\").top(50).getPaged<{Title: string}[]>(); // the results object will have two properties and one method: // the results property will be an array of the items returned if (items.results.length > 0) { console.log(\"We got results!\"); for (let i = 0; i < items.results.length; i++) { // type checking works here if we specify the return type console.log(items.results[i].Title); } } // the hasNext property is used with the getNext method to handle paging // hasNext will be true so long as there are additional results if (items.hasNext) { // this will carry over the type specified in the original query for the results array items = await items.getNext(); console.log(items.results.length); }","title":"Get Paged Items"},{"location":"sp/items/#getlistitemchangessincetoken","text":"The GetListItemChangesSinceToken method allows clients to track changes on a list. Changes, including deleted items, are returned along with a token that represents the moment in time when those changes were requested. By including this token when you call GetListItemChangesSinceToken, the server looks for only those changes that have occurred since the token was generated. Sending a GetListItemChangesSinceToken request without including a token returns the list schema, the full list contents and a token. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // Using RowLimit. Enables paging let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({RowLimit: '5'}); // Use QueryOptions to make a XML-style query. // Because it's XML we need to escape special characters // Instead of & we use &amp; in the query let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({QueryOptions: '<Paging ListItemCollectionPositionNext=\"Paged=TRUE&amp;p_ID=5\" />'}); // Get everything. Using null with ChangeToken gets everything let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({ChangeToken: null});","title":"getListItemChangesSinceToken"},{"location":"sp/items/#get-all-items","text":"Using the items collection's getAll method you can get all of the items in a list regardless of the size of the list. Sample usage is shown below. Only the odata operations top, select, and filter are supported. usingCaching and inBatch are ignored - you will need to handle caching the results on your own. This method will write a warning to the Logger and should not frequently be used. Instead the standard paging operations should be used. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic usage const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(); console.log(allItems.length); // set page size const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(4000); console.log(allItems.length); // use select and top. top will set page size and override the any value passed to getAll const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").top(4000).getAll(); console.log(allItems.length); // we can also use filter as a supported odata operation, but this will likely fail on large lists const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").filter(\"Title eq 'Test'\").getAll(); console.log(allItems.length);","title":"Get All Items"},{"location":"sp/items/#retrieving-lookup-fields","text":"When working with lookup fields you need to use the expand operator along with select to get the related fields from the lookup column. This works for both the items collection and item instances. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const items = await sp.web.lists.getByTitle(\"LookupList\").items.select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(items); const item = await sp.web.lists.getByTitle(\"LookupList\").items.getById(1).select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(item);","title":"Retrieving Lookup Fields"},{"location":"sp/items/#filter-using-metadata-fields","text":"To filter on a metadata field you must use the getItemsByCAMLQuery method as $filter does not support these fields. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; const r = await sp.web.lists.getByTitle(\"TaxonomyList\").getItemsByCAMLQuery({ ViewXml: `<View><Query><Where><Eq><FieldRef Name=\"MetaData\"/><Value Type=\"TaxonomyFieldType\">Term 2</Value></Eq></Where></Query></View>`, });","title":"Filter using Metadata fields"},{"location":"sp/items/#retrieving-publishingpageimage","text":"The PublishingPageImage and some other publishing-related fields aren't stored in normal fields, rather in the MetaInfo field. To get these values you need to use the technique shown below, and originally outlined in this thread . Note that a lot of information can be stored in this field so will pull back potentially a significant amount of data, so limit the rows as possible to aid performance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { Web } from \"@pnp/sp/webs\"; try { const w = Web(\"https://{publishing site url}\"); const r = await w.lists.getByTitle(\"Pages\").items .select(\"Title\", \"FileRef\", \"FieldValuesAsText/MetaInfo\") .expand(\"FieldValuesAsText\") (); // look through the returned items. for (var i = 0; i < r.length; i++) { // the title field value console.log(r[i].Title); // find the value in the MetaInfo string using regex const matches = /PublishingPageImage:SW\\|(.*?)\\r\\n/ig.exec(r[i].FieldValuesAsText.MetaInfo); if (matches !== null && matches.length > 1) { // this wil be the value of the PublishingPageImage field console.log(matches[1]); } } } catch (e) { console.error(e); }","title":"Retrieving PublishingPageImage"},{"location":"sp/items/#add-items","text":"There are several ways to add items to a list. The simplest just uses the add method of the items collection passing in the properties as a plain object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { IItemAddResult } from \"@pnp/sp/items\"; // add an item to the list const iar: IItemAddResult = await sp.web.lists.getByTitle(\"My List\").items.add({ Title: \"Title\", Description: \"Description\" }); console.log(iar);","title":"Add Items"},{"location":"sp/items/#content-type","text":"You can also set the content type id when you create an item as shown in the example below. For more information on content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; await sp.web.lists.getById(\"4D5A36EA-6E84-4160-8458-65C436DB765C\").items.add({ Title: \"Test 1\", ContentTypeId: \"0x01030058FD86C279252341AB303852303E4DAF\" });","title":"Content Type"},{"location":"sp/items/#user-fields","text":"There are two types of user fields, those that allow a single value and those that allow multiple. For both types, you first need to determine the Id field name, which you can do by doing a GET REST request on an existing item. Typically the value will be the user field internal name with \"Id\" appended. So in our example, we have two fields User1 and User2 so the Id fields are User1Id and User2Id. Next, you need to remember there are two types of user fields, those that take a single value and those that allow multiple - these are updated in different ways. For single value user fields you supply just the user's id. For multiple value fields, you need to supply an object with a \"results\" property and an array. Examples for both are shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; const i = await sp.web.lists.getByTitle(\"PeopleFields\").items.add({ Title: getGUID(), User1Id: 9, // allows a single user User2Id: { results: [16, 45] // allows multiple users } }); console.log(i); If you want to update or add user field values when using validateUpdateListItem you need to use the form shown below. You can specify multiple values in the array. import { sp } from \"@pnp/sp\"; const result = await sp.web.lists.getByTitle(\"UserFieldList\").items.getById(1).validateUpdateListItem([{ FieldName: \"UserField\", FieldValue: JSON.stringify([{ \"Key\": \"i:0#.f|membership|person@tenant.com\" }]), }, { FieldName: \"Title\", FieldValue: \"Test - Updated\", }]);","title":"User Fields"},{"location":"sp/items/#lookup-fields","text":"What is said for User Fields is, in general, relevant to Lookup Fields: Lookup Field types: Single-valued lookup Multiple-valued lookup Id suffix should be appended to the end of lookups EntityPropertyName in payloads Numeric Ids for lookups' items should be passed as values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; await sp.web.lists.getByTitle(\"LookupFields\").items.add({ Title: getGUID(), LookupFieldId: 2, // allows a single lookup value MultiLookupFieldId: { results: [ 1, 56 ] // allows multiple lookup value } });","title":"Lookup Fields"},{"location":"sp/items/#add-multiple-items","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidadd\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: \"Batch 6\" }, entityTypeFullName).then(b => { console.log(b); }); list.items.inBatch(batch).add({ Title: \"Batch 7\" }, entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\");","title":"Add Multiple Items"},{"location":"sp/items/#update","text":"The update method is very similar to the add method in that it takes a plain object representing the fields to update. The property names are the internal names of the fields. If you aren't sure you can always do a get request for an item in the list and see the field names that come back - you would use these same names to update the item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const i = await list.items.getById(1).update({ Title: \"My New Title\", Description: \"Here is a new description\" }); console.log(i);","title":"Update"},{"location":"sp/items/#getting-and-updating-a-collection-using-filter","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // you are getting back a collection here const items: any[] = await sp.web.lists.getByTitle(\"MyList\").items.top(1).filter(\"Title eq 'A Title'\")(); // see if we got something if (items.length > 0) { const updatedItem = await sp.web.lists.getByTitle(\"MyList\").items.getById(items[0].Id).update({ Title: \"Updated Title\", }); console.log(JSON.stringify(updatedItem)); }","title":"Getting and updating a collection using filter"},{"location":"sp/items/#update-multiple-items","text":"This approach avoids multiple calls for the same list's entity type name. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidupdate\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); // note requirement of \"*\" eTag param - or use a specific eTag value as needed list.items.getById(1).inBatch(batch).update({ Title: \"Batch 6\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); list.items.getById(2).inBatch(batch).update({ Title: \"Batch 7\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\")","title":"Update Multiple Items"},{"location":"sp/items/#recycle","text":"To send an item to the recycle bin use recycle. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const recycleBinIdentifier = await list.items.getById(1).recycle();","title":"Recycle"},{"location":"sp/items/#delete","text":"Delete is as simple as calling the .delete method. It optionally takes an eTag if you need to manage concurrency. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).delete();","title":"Delete"},{"location":"sp/items/#delete-with-params","text":"Added in 2.0.9 Deletes the item object with options. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).deleteWithParams({ BypassSharedLock: true, }); The deleteWithParams method can only be used by accounts where UserToken.IsSystemAccount is true","title":"Delete With Params"},{"location":"sp/items/#resolving-field-names","text":"It's a very common mistake trying wrong field names in the requests. Field's EntityPropertyName value should be used. The easiest way to get know EntityPropertyName is to use the following snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import \"@pnp/sp/fields\"; const response = await sp.web.lists .getByTitle('[Lists_Title]') .fields .select('Title, EntityPropertyName') .filter(`Hidden eq false and Title eq '[Field's_Display_Name]'`) (); console.log(response.map(field => { return { Title: field.Title, EntityPropertyName: field.EntityPropertyName }; })); Lookup fields' names should be ended with additional Id suffix. E.g. for Editor EntityPropertyName EditorId should be used.","title":"Resolving field names"},{"location":"sp/items/#getparentinfos","text":"Added in 2.0.12 Gets information about an item, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); await item.getParentInfos();","title":"getParentInfos"},{"location":"sp/lists/","text":"@pnp/sp/lists \u00b6 Lists in SharePoint are collections of information built in a structural way using columns and rows. Columns for metadata, and rows representing each entry. Visually, it reminds us a lot of a database table or an Excel spreadsheet. ILists \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Lists, ILists } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; Preset: All import { sp, Lists, ILists } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Lists, ILists } from \"@pnp/sp/presets/core\"; Get List by Id \u00b6 Gets a list from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the list by Id const list = sp.web.lists.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // we can use this 'list' variable to execute more queries on the list: const r = await list.select(\"Title\")(); // show the response from the server console.log(r.Title); Get List by Title \u00b6 You can also get a list from the collection by title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the default document library 'Documents' const list = sp.web.lists.getByTitle(\"Documents\"); // we can use this 'list' variable to run more queries on the list: const r = await list.select(\"Id\")(); // log the list Id to console console.log(r.Id); Add List \u00b6 You can add a list to the web's list collection using the .add-method. To invoke this method in its most simple form, you can provide only a title as a parameter. This will result in a standard out of the box list with all default settings, and the title you provide. // create a new list, passing only the title const listAddResult = await sp.web.lists.add(\"My new list\"); // we can work with the list created using the IListAddResult.list property: const r = await listAddResult.list.select(\"Title\")(); // log newly created list title to console console.log(r.Title); }); You can also provide other (optional) parameters like description, template and enableContentTypes. If that is not enough for you, you can use the parameter named 'additionalSettings' which is just a TypedHash, meaning you can sent whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). You can find a listing of list template codes in the official docs. // this will create a list with template 101 (Document library), content types enabled and show it on the quick launch (using additionalSettings) const listAddResult = await sp.web.lists.add(\"My Doc Library\", \"This is a description of doc lib.\", 101, true, { OnQuickLaunch: true }); // get the Id of the newly added document library const r = await listAddResult.list.select(\"Id\")(); // log id to console console.log(r.Id); Ensure that a List exists (by title) \u00b6 Ensures that the specified list exists in the collection (note: this method not supported for batching). Just like with the add-method (see examples above) you can provide only the title, or any or all of the optional parameters desc, template, enableContentTypes and additionalSettings. // ensure that a list exists. If it doesn't it will be created with the provided title (the rest of the settings will be default): const listEnsureResult = await sp.web.lists.ensure(\"My List\"); // check if the list was created, or if it already existed: if (listEnsureResult.created) { console.log(\"My List was created!\"); } else { console.log(\"My List already existed!\"); } // work on the created/updated list const r = await listEnsureResult.list.select(\"Id\")(); // log the Id console.log(r.Id); If the list already exists, the other settings you provide will be used to update the existing list. // add a new list to the lists collection of the web sp.web.lists.add(\"My List 2\").then(async () => { // then call ensure on the created list with an updated description const listEnsureResult = await sp.web.lists.ensure(\"My List 2\", \"Updated description\"); // get the updated description const r = await listEnsureResult.list.select(\"Description\")(); // log the updated description console.log(r.Description); }); Ensure Site Assets Library exist \u00b6 Gets a list that is the default asset location for images or other files, which the users upload to their wiki pages. // get Site Assets library const siteAssetsList = await sp.web.lists.ensureSiteAssetsLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title); Ensure Site Pages Library exist \u00b6 Gets a list that is the default location for wiki pages. // get Site Pages library const siteAssetsList = await sp.web.lists.ensureSitePagesLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title); IList \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { List, IList } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists\"; Preset: All import { sp, List, IList } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, List, IList } from \"@pnp/sp/presets/core\"; Update a list \u00b6 Update an existing list with the provided properties. You can also provide an eTag value that will be used in the IF-Match header (default is \"*\") import { IListUpdateResult } from \"@pnp/sp/lists\"; // create a TypedHash object with the properties to update const updateProperties = { Description: \"This list title and description has been updated using PnPjs.\", Title: \"Updated title\", }; // update the list with the properties above list.update(updateProperties).then(async (l: IListUpdateResult) => { // get the updated title and description const r = await l.list.select(\"Title\", \"Description\")(); // log the updated properties to the console console.log(r.Title); console.log(r.Description); }); Get changes on a list \u00b6 From the change log, you can get a collection of changes that have occurred within the list based on the specified query. import { sp, IChangeQuery } from \"@pnp/sp\"; // build the changeQuery object, here we look att changes regarding Add, DeleteObject and Restore const changeQuery: IChangeQuery = { Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Rename: true, Restore: true, }; // get list changes const r = await list.getChanges(changeQuery); // log changes to console console.log(r); Get list items using a CAML Query \u00b6 You can get items from SharePoint using a CAML Query. import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml); // log resulting array to console console.log(r); If you need to get and expand a lookup field, there is a spread array parameter on the getItemsByCAMLQuery. This means that you can provide multiple properties to this method depending on how many lookup fields you are working with on your list. Below is a minimal example showing how to expand one field (RoleAssignment) import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /><FieldRef Name='RoleAssignments' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml, \"RoleAssignments\"); // log resulting item array to console console.log(r); Get list items changes using a Token \u00b6 import { IChangeLogItemQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const changeLogItemQuery: IChangeLogItemQuery = { Contains: `<Contains><FieldRef Name=\"Title\"/><Value Type=\"Text\">Item16</Value></Contains>`, QueryOptions: `<QueryOptions> <IncludeMandatoryColumns>FALSE</IncludeMandatoryColumns> <DateInUtc>False</DateInUtc> <IncludePermissions>TRUE</IncludePermissions> <IncludeAttachmentUrls>FALSE</IncludeAttachmentUrls> <Folder>My List</Folder></QueryOptions>`, }; // get list items const r = await list.getListItemChangesSinceToken(changeLogItemQuery); // log resulting XML to console console.log(r); Recycle a list \u00b6 Removes the list from the web's list collection and puts it in the recycle bin. await list.recycle(); Render list data \u00b6 import { IRenderListData } from \"@pnp/sp/lists\"; // render list data, top 5 items const r: IRenderListData = await list.renderListData(\"<View><RowLimit>5</RowLimit></View>\"); // log array of items in response console.log(r.Row); Render list data as stream \u00b6 import { IRenderListDataParameters } from \"@pnp/sp/lists\"; // setup parameters object const renderListDataParams: IRenderListDataParameters = { ViewXml: \"<View><RowLimit>5</RowLimit></View>\", }; // render list data as stream const r = await list.renderListDataAsStream(renderListDataParams); // log array of items in response console.log(r.Row); Reserve list item Id for idempotent list item creation \u00b6 const listItemId = await list.reserveListItemId(); // log id to console console.log(listItemId); Get list item entity type name \u00b6 const entityTypeFullName = await list.getListItemEntityTypeFullName(); // log entity type name console.log(entityTypeFullName); Add a list item using path (folder), validation and set field values \u00b6 const list = await sp.webs.lists.getByTitle(\"MyList\").select(\"Title\", \"ParentWebUrl\")(); const formValues: IListItemFormUpdateValue[] = [ { FieldName: \"Title\", FieldValue: title, }, ]; list.addValidateUpdateItemUsingPath(formValues,`${list.ParentWebUrl}/Lists/${list.Title}/MyFolder`) content-types imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; contentTypes \u00b6 Get all content types for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.contentTypes(); fields imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; fields \u00b6 Get all the fields for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.fields(); Add a field to the site, then add the site field to a list const fld = await sp.site.rootWeb.fields.addText(\"MyField\"); await sp.web.lists.getByTitle(\"MyList\").fields.createFieldAsXml(fld.data.SchemaXml); folders imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; folders \u00b6 Get the root folder of a list. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.rootFolder(); forms imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/forms\"; Selective 2 import \"@pnp/sp/forms/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; forms \u00b6 const r = await list.forms(); items imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/items\"; Selective 2 import \"@pnp/sp/items/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; items \u00b6 Get a collection of list items. const r = await list.items(); views imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/views\"; Selective 2 import \"@pnp/sp/views/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; views \u00b6 Get the default view of the list const list = sp.web.lists.getByTitle(\"Documents\"); const views = await list.views(); const defaultView = await list.defaultView(); Get a list view by Id const view = await list.getView(defaultView.Id).select(\"Title\")(); security imports \u00b6 To work with list security, you can import the list methods as follows: import \"@pnp/sp/security/list\"; For more information on how to call security methods for lists, please refer to the @pnp/sp/security documentation. subscriptions imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/subscriptions\"; Selective 2 import \"@pnp/sp/subscriptions/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; subscriptions \u00b6 Get all subscriptions on the list const list = sp.web.lists.getByTitle(\"Documents\"); const subscriptions = await list.subscriptions(); user-custom-actions imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; userCustomActions \u00b6 Get a collection of the list's user custom actions. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.userCustomActions(); getParentInfos \u00b6 Added in 2.0.12 Gets information about an list, including details about the parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const list = sp.web.lists.getByTitle(\"Documents\"); await list.getParentInfos();","title":"Lists"},{"location":"sp/lists/#pnpsplists","text":"Lists in SharePoint are collections of information built in a structural way using columns and rows. Columns for metadata, and rows representing each entry. Visually, it reminds us a lot of a database table or an Excel spreadsheet.","title":"@pnp/sp/lists"},{"location":"sp/lists/#ilists","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Lists, ILists } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; Preset: All import { sp, Lists, ILists } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Lists, ILists } from \"@pnp/sp/presets/core\";","title":"ILists"},{"location":"sp/lists/#get-list-by-id","text":"Gets a list from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the list by Id const list = sp.web.lists.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // we can use this 'list' variable to execute more queries on the list: const r = await list.select(\"Title\")(); // show the response from the server console.log(r.Title);","title":"Get List by Id"},{"location":"sp/lists/#get-list-by-title","text":"You can also get a list from the collection by title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the default document library 'Documents' const list = sp.web.lists.getByTitle(\"Documents\"); // we can use this 'list' variable to run more queries on the list: const r = await list.select(\"Id\")(); // log the list Id to console console.log(r.Id);","title":"Get List by Title"},{"location":"sp/lists/#add-list","text":"You can add a list to the web's list collection using the .add-method. To invoke this method in its most simple form, you can provide only a title as a parameter. This will result in a standard out of the box list with all default settings, and the title you provide. // create a new list, passing only the title const listAddResult = await sp.web.lists.add(\"My new list\"); // we can work with the list created using the IListAddResult.list property: const r = await listAddResult.list.select(\"Title\")(); // log newly created list title to console console.log(r.Title); }); You can also provide other (optional) parameters like description, template and enableContentTypes. If that is not enough for you, you can use the parameter named 'additionalSettings' which is just a TypedHash, meaning you can sent whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). You can find a listing of list template codes in the official docs. // this will create a list with template 101 (Document library), content types enabled and show it on the quick launch (using additionalSettings) const listAddResult = await sp.web.lists.add(\"My Doc Library\", \"This is a description of doc lib.\", 101, true, { OnQuickLaunch: true }); // get the Id of the newly added document library const r = await listAddResult.list.select(\"Id\")(); // log id to console console.log(r.Id);","title":"Add List"},{"location":"sp/lists/#ensure-that-a-list-exists-by-title","text":"Ensures that the specified list exists in the collection (note: this method not supported for batching). Just like with the add-method (see examples above) you can provide only the title, or any or all of the optional parameters desc, template, enableContentTypes and additionalSettings. // ensure that a list exists. If it doesn't it will be created with the provided title (the rest of the settings will be default): const listEnsureResult = await sp.web.lists.ensure(\"My List\"); // check if the list was created, or if it already existed: if (listEnsureResult.created) { console.log(\"My List was created!\"); } else { console.log(\"My List already existed!\"); } // work on the created/updated list const r = await listEnsureResult.list.select(\"Id\")(); // log the Id console.log(r.Id); If the list already exists, the other settings you provide will be used to update the existing list. // add a new list to the lists collection of the web sp.web.lists.add(\"My List 2\").then(async () => { // then call ensure on the created list with an updated description const listEnsureResult = await sp.web.lists.ensure(\"My List 2\", \"Updated description\"); // get the updated description const r = await listEnsureResult.list.select(\"Description\")(); // log the updated description console.log(r.Description); });","title":"Ensure that a List exists (by title)"},{"location":"sp/lists/#ensure-site-assets-library-exist","text":"Gets a list that is the default asset location for images or other files, which the users upload to their wiki pages. // get Site Assets library const siteAssetsList = await sp.web.lists.ensureSiteAssetsLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title);","title":"Ensure Site Assets Library exist"},{"location":"sp/lists/#ensure-site-pages-library-exist","text":"Gets a list that is the default location for wiki pages. // get Site Pages library const siteAssetsList = await sp.web.lists.ensureSitePagesLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title);","title":"Ensure Site Pages Library exist"},{"location":"sp/lists/#ilist","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { List, IList } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists\"; Preset: All import { sp, List, IList } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, List, IList } from \"@pnp/sp/presets/core\";","title":"IList"},{"location":"sp/lists/#update-a-list","text":"Update an existing list with the provided properties. You can also provide an eTag value that will be used in the IF-Match header (default is \"*\") import { IListUpdateResult } from \"@pnp/sp/lists\"; // create a TypedHash object with the properties to update const updateProperties = { Description: \"This list title and description has been updated using PnPjs.\", Title: \"Updated title\", }; // update the list with the properties above list.update(updateProperties).then(async (l: IListUpdateResult) => { // get the updated title and description const r = await l.list.select(\"Title\", \"Description\")(); // log the updated properties to the console console.log(r.Title); console.log(r.Description); });","title":"Update a list"},{"location":"sp/lists/#get-changes-on-a-list","text":"From the change log, you can get a collection of changes that have occurred within the list based on the specified query. import { sp, IChangeQuery } from \"@pnp/sp\"; // build the changeQuery object, here we look att changes regarding Add, DeleteObject and Restore const changeQuery: IChangeQuery = { Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Rename: true, Restore: true, }; // get list changes const r = await list.getChanges(changeQuery); // log changes to console console.log(r);","title":"Get changes on a list"},{"location":"sp/lists/#get-list-items-using-a-caml-query","text":"You can get items from SharePoint using a CAML Query. import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml); // log resulting array to console console.log(r); If you need to get and expand a lookup field, there is a spread array parameter on the getItemsByCAMLQuery. This means that you can provide multiple properties to this method depending on how many lookup fields you are working with on your list. Below is a minimal example showing how to expand one field (RoleAssignment) import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /><FieldRef Name='RoleAssignments' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml, \"RoleAssignments\"); // log resulting item array to console console.log(r);","title":"Get list items using a CAML Query"},{"location":"sp/lists/#get-list-items-changes-using-a-token","text":"import { IChangeLogItemQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const changeLogItemQuery: IChangeLogItemQuery = { Contains: `<Contains><FieldRef Name=\"Title\"/><Value Type=\"Text\">Item16</Value></Contains>`, QueryOptions: `<QueryOptions> <IncludeMandatoryColumns>FALSE</IncludeMandatoryColumns> <DateInUtc>False</DateInUtc> <IncludePermissions>TRUE</IncludePermissions> <IncludeAttachmentUrls>FALSE</IncludeAttachmentUrls> <Folder>My List</Folder></QueryOptions>`, }; // get list items const r = await list.getListItemChangesSinceToken(changeLogItemQuery); // log resulting XML to console console.log(r);","title":"Get list items changes using a Token"},{"location":"sp/lists/#recycle-a-list","text":"Removes the list from the web's list collection and puts it in the recycle bin. await list.recycle();","title":"Recycle a list"},{"location":"sp/lists/#render-list-data","text":"import { IRenderListData } from \"@pnp/sp/lists\"; // render list data, top 5 items const r: IRenderListData = await list.renderListData(\"<View><RowLimit>5</RowLimit></View>\"); // log array of items in response console.log(r.Row);","title":"Render list data"},{"location":"sp/lists/#render-list-data-as-stream","text":"import { IRenderListDataParameters } from \"@pnp/sp/lists\"; // setup parameters object const renderListDataParams: IRenderListDataParameters = { ViewXml: \"<View><RowLimit>5</RowLimit></View>\", }; // render list data as stream const r = await list.renderListDataAsStream(renderListDataParams); // log array of items in response console.log(r.Row);","title":"Render list data as stream"},{"location":"sp/lists/#reserve-list-item-id-for-idempotent-list-item-creation","text":"const listItemId = await list.reserveListItemId(); // log id to console console.log(listItemId);","title":"Reserve list item Id for idempotent list item creation"},{"location":"sp/lists/#get-list-item-entity-type-name","text":"const entityTypeFullName = await list.getListItemEntityTypeFullName(); // log entity type name console.log(entityTypeFullName);","title":"Get list item entity type name"},{"location":"sp/lists/#add-a-list-item-using-path-folder-validation-and-set-field-values","text":"const list = await sp.webs.lists.getByTitle(\"MyList\").select(\"Title\", \"ParentWebUrl\")(); const formValues: IListItemFormUpdateValue[] = [ { FieldName: \"Title\", FieldValue: title, }, ]; list.addValidateUpdateItemUsingPath(formValues,`${list.ParentWebUrl}/Lists/${list.Title}/MyFolder`)","title":"Add a list item using path (folder), validation and set field values"},{"location":"sp/lists/#content-types-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"content-types imports"},{"location":"sp/lists/#contenttypes","text":"Get all content types for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.contentTypes();","title":"contentTypes"},{"location":"sp/lists/#fields-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"fields imports"},{"location":"sp/lists/#fields","text":"Get all the fields for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.fields(); Add a field to the site, then add the site field to a list const fld = await sp.site.rootWeb.fields.addText(\"MyField\"); await sp.web.lists.getByTitle(\"MyList\").fields.createFieldAsXml(fld.data.SchemaXml);","title":"fields"},{"location":"sp/lists/#folders-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"folders imports"},{"location":"sp/lists/#folders","text":"Get the root folder of a list. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.rootFolder();","title":"folders"},{"location":"sp/lists/#forms-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/forms\"; Selective 2 import \"@pnp/sp/forms/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"forms imports"},{"location":"sp/lists/#forms","text":"const r = await list.forms();","title":"forms"},{"location":"sp/lists/#items-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/items\"; Selective 2 import \"@pnp/sp/items/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"items imports"},{"location":"sp/lists/#items","text":"Get a collection of list items. const r = await list.items();","title":"items"},{"location":"sp/lists/#views-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/views\"; Selective 2 import \"@pnp/sp/views/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"views imports"},{"location":"sp/lists/#views","text":"Get the default view of the list const list = sp.web.lists.getByTitle(\"Documents\"); const views = await list.views(); const defaultView = await list.defaultView(); Get a list view by Id const view = await list.getView(defaultView.Id).select(\"Title\")();","title":"views"},{"location":"sp/lists/#security-imports","text":"To work with list security, you can import the list methods as follows: import \"@pnp/sp/security/list\"; For more information on how to call security methods for lists, please refer to the @pnp/sp/security documentation.","title":"security imports"},{"location":"sp/lists/#subscriptions-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/subscriptions\"; Selective 2 import \"@pnp/sp/subscriptions/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"subscriptions imports"},{"location":"sp/lists/#subscriptions","text":"Get all subscriptions on the list const list = sp.web.lists.getByTitle(\"Documents\"); const subscriptions = await list.subscriptions();","title":"subscriptions"},{"location":"sp/lists/#user-custom-actions-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"user-custom-actions imports"},{"location":"sp/lists/#usercustomactions","text":"Get a collection of the list's user custom actions. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.userCustomActions();","title":"userCustomActions"},{"location":"sp/lists/#getparentinfos","text":"Added in 2.0.12 Gets information about an list, including details about the parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const list = sp.web.lists.getByTitle(\"Documents\"); await list.getParentInfos();","title":"getParentInfos"},{"location":"sp/navigation/","text":"@pnp/sp - navigation \u00b6 Navigation Service \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; getMenuState \u00b6 The MenuState service operation returns a Menu-State (dump) of a SiteMapProvider on a site. It will return an exception if the SiteMapProvider cannot be found on the site, the SiteMapProvider does not implement the IEditableSiteMapProvider interface or the SiteMapNode key cannot be found within the provider hierarchy. The IEditableSiteMapProvider also supports Custom Properties which is an optional feature. What will be return in the custom properties is up to the IEditableSiteMapProvider implementation and can differ for for each SiteMapProvider implementation. The custom properties can be requested by providing a comma separated string of property names like: property1,property2,property3\\,containingcomma NOTE: the , separator can be escaped using the \\ as escape character as done in the example above. The string above would split like: property1 property2 property3,containingcomma import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; // Will return a menu state of the default SiteMapProvider 'SPSiteMapProvider' where the dump starts a the RootNode (within the site) with a depth of 10 levels. const state = await sp.navigation.getMenuState(); // Will return the menu state of the 'SPSiteMapProvider', starting with the node with the key '1002' with a depth of 5 const state2 = await sp.navigation.getMenuState(\"1002\", 5); // Will return the menu state of the 'CurrentNavSiteMapProviderNoEncode' from the root node of the provider with a depth of 5 const state3 = await sp.navigation.getMenuState(null, 5, \"CurrentNavSiteMapProviderNoEncode\"); getMenuNodeKey \u00b6 Tries to get a SiteMapNode.Key for a given URL within a site collection. If the SiteMapNode cannot be found an Exception is returned. The method is using SiteMapProvider.FindSiteMapNodeFromKey(string rawUrl) to lookup the SiteMapNode. Depending on the actual implementation of FindSiteMapNodeFromKey the matching can differ for different SiteMapProviders. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; const key = await sp.navigation.getMenuNodeKey(\"/sites/dev/Lists/SPPnPJSExampleList/AllItems.aspx\"); Web Navigation \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; The navigation object contains two properties \"quicklaunch\" and \"topnavigationbar\". Both have the same set of methods so our examples below show use of only quicklaunch but apply equally to topnavigationbar. Get navigation \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const top = await sp.web.navigation.topNavigationBar(); const quick = await sp.web.navigation.quicklaunch(); For the following examples we will refer to a variable named \"nav\" that is understood to be one of topNavigationBar or quicklaunch. getById \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node = await nav.getById(3)(); add \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const result = await nav.add(\"Node Title\", \"/sites/dev/pages/mypage.aspx\", true); const nodeDataRaw = result.data; // request the data from the created node const nodeData = result.node(); moveAfter \u00b6 Places a navigation node after another node in the tree import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)} (1)`, url, true); const node2result = await nav.add(`Testing - ${getRandomString(4)} (2)`, url, true); const node1 = await node1result.node(); const node2 = await node2result.node(); await nav.moveAfter(node1.Id, node2.Id); Delete \u00b6 Deletes a given node import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)}`, url, true); let nodes = await nav(); // check we added a node let index = nodes.findIndex(n => n.Id === node1result.data.Id) // index >= 0 // delete a node await nav.getById(node1result.data.Id).delete(); nodes = await nav(); index = nodes.findIndex(n => n.Id === node1result.data.Id) // index = -1 Update \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; await nav.getById(4).update({ Title: \"A new title\", }); Children \u00b6 The children property of a Navigation Node represents a collection with all the same properties and methods available on topNavigationBar or quicklaunch. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const childrenData = await nav.getById(1).children(); // add a child await nav.getById(1).children.add(\"Title\", \"Url\", true);","title":"Navigation"},{"location":"sp/navigation/#pnpsp-navigation","text":"","title":"@pnp/sp - navigation"},{"location":"sp/navigation/#navigation-service","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\";","title":"Navigation Service"},{"location":"sp/navigation/#getmenustate","text":"The MenuState service operation returns a Menu-State (dump) of a SiteMapProvider on a site. It will return an exception if the SiteMapProvider cannot be found on the site, the SiteMapProvider does not implement the IEditableSiteMapProvider interface or the SiteMapNode key cannot be found within the provider hierarchy. The IEditableSiteMapProvider also supports Custom Properties which is an optional feature. What will be return in the custom properties is up to the IEditableSiteMapProvider implementation and can differ for for each SiteMapProvider implementation. The custom properties can be requested by providing a comma separated string of property names like: property1,property2,property3\\,containingcomma NOTE: the , separator can be escaped using the \\ as escape character as done in the example above. The string above would split like: property1 property2 property3,containingcomma import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; // Will return a menu state of the default SiteMapProvider 'SPSiteMapProvider' where the dump starts a the RootNode (within the site) with a depth of 10 levels. const state = await sp.navigation.getMenuState(); // Will return the menu state of the 'SPSiteMapProvider', starting with the node with the key '1002' with a depth of 5 const state2 = await sp.navigation.getMenuState(\"1002\", 5); // Will return the menu state of the 'CurrentNavSiteMapProviderNoEncode' from the root node of the provider with a depth of 5 const state3 = await sp.navigation.getMenuState(null, 5, \"CurrentNavSiteMapProviderNoEncode\");","title":"getMenuState"},{"location":"sp/navigation/#getmenunodekey","text":"Tries to get a SiteMapNode.Key for a given URL within a site collection. If the SiteMapNode cannot be found an Exception is returned. The method is using SiteMapProvider.FindSiteMapNodeFromKey(string rawUrl) to lookup the SiteMapNode. Depending on the actual implementation of FindSiteMapNodeFromKey the matching can differ for different SiteMapProviders. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; const key = await sp.navigation.getMenuNodeKey(\"/sites/dev/Lists/SPPnPJSExampleList/AllItems.aspx\");","title":"getMenuNodeKey"},{"location":"sp/navigation/#web-navigation","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; The navigation object contains two properties \"quicklaunch\" and \"topnavigationbar\". Both have the same set of methods so our examples below show use of only quicklaunch but apply equally to topnavigationbar.","title":"Web Navigation"},{"location":"sp/navigation/#get-navigation","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const top = await sp.web.navigation.topNavigationBar(); const quick = await sp.web.navigation.quicklaunch(); For the following examples we will refer to a variable named \"nav\" that is understood to be one of topNavigationBar or quicklaunch.","title":"Get navigation"},{"location":"sp/navigation/#getbyid","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node = await nav.getById(3)();","title":"getById"},{"location":"sp/navigation/#add","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const result = await nav.add(\"Node Title\", \"/sites/dev/pages/mypage.aspx\", true); const nodeDataRaw = result.data; // request the data from the created node const nodeData = result.node();","title":"add"},{"location":"sp/navigation/#moveafter","text":"Places a navigation node after another node in the tree import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)} (1)`, url, true); const node2result = await nav.add(`Testing - ${getRandomString(4)} (2)`, url, true); const node1 = await node1result.node(); const node2 = await node2result.node(); await nav.moveAfter(node1.Id, node2.Id);","title":"moveAfter"},{"location":"sp/navigation/#delete","text":"Deletes a given node import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)}`, url, true); let nodes = await nav(); // check we added a node let index = nodes.findIndex(n => n.Id === node1result.data.Id) // index >= 0 // delete a node await nav.getById(node1result.data.Id).delete(); nodes = await nav(); index = nodes.findIndex(n => n.Id === node1result.data.Id) // index = -1","title":"Delete"},{"location":"sp/navigation/#update","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; await nav.getById(4).update({ Title: \"A new title\", });","title":"Update"},{"location":"sp/navigation/#children","text":"The children property of a Navigation Node represents a collection with all the same properties and methods available on topNavigationBar or quicklaunch. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const childrenData = await nav.getById(1).children(); // add a child await nav.getById(1).children.add(\"Title\", \"Url\", true);","title":"Children"},{"location":"sp/permissions/","text":"@pnp/sp - permissions \u00b6 A common task is to determine if a user or the current user has a certain permission level. It is a great idea to check before performing a task such as creating a list to ensure a user can without getting back an error. This allows you to provide a better experience to the user. Permissions in SharePoint are assigned to the set of securable objects which include Site, Web, List, and List Item. These are the four level to which unique permissions can be assigned. As such @pnp/sp provides a set of methods defined in the QueryableSecurable class to handle these permissions. These examples all use the Web to get the values, however the methods work identically on all securables. Get Role Assignments \u00b6 This gets a collection of all the role assignments on a given securable. The property returns a RoleAssignments collection which supports the OData collection operators. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const roles = await sp.web.roleAssignments(); Logger.writeJSON(roles); First Unique Ancestor Securable Object \u00b6 This method can be used to find the securable parent up the hierarchy that has unique permissions. If everything inherits permissions this will be the Site. If a sub web has unique permissions it will be the web, and so on. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const obj = await sp.web.firstUniqueAncestorSecurableObject(); Logger.writeJSON(obj); User Effective Permissions \u00b6 This method returns the BasePermissions for a given user or the current user. This value contains the High and Low values for a user on the securable you have queried. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const perms = await sp.web.getUserEffectivePermissions(\"i:0#.f|membership|user@site.com\"); Logger.writeJSON(perms); const perms2 = await sp.web.getCurrentUserEffectivePermissions(); Logger.writeJSON(perms2); User Has Permissions \u00b6 Because the High and Low values in the BasePermission don't obviously mean anything you can use these methods along with the PermissionKind enumeration to check actual rights on the securable. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.userHasPermissions(\"i:0#.f|membership|user@site.com\", PermissionKind.ApproveItems); console.log(perms); const perms2 = await sp.web.currentUserHasPermissions(PermissionKind.ApproveItems); console.log(perms2); Has Permissions \u00b6 If you need to check multiple permissions it can be more efficient to get the BasePermissions once and then use the hasPermissions method to check them as shown below. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.getCurrentUserEffectivePermissions(); if (sp.web.hasPermissions(perms, PermissionKind.AddListItems) && sp.web.hasPermissions(perms, PermissionKind.DeleteVersions)) { // ... }","title":"Permissions"},{"location":"sp/permissions/#pnpsp-permissions","text":"A common task is to determine if a user or the current user has a certain permission level. It is a great idea to check before performing a task such as creating a list to ensure a user can without getting back an error. This allows you to provide a better experience to the user. Permissions in SharePoint are assigned to the set of securable objects which include Site, Web, List, and List Item. These are the four level to which unique permissions can be assigned. As such @pnp/sp provides a set of methods defined in the QueryableSecurable class to handle these permissions. These examples all use the Web to get the values, however the methods work identically on all securables.","title":"@pnp/sp - permissions"},{"location":"sp/permissions/#get-role-assignments","text":"This gets a collection of all the role assignments on a given securable. The property returns a RoleAssignments collection which supports the OData collection operators. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const roles = await sp.web.roleAssignments(); Logger.writeJSON(roles);","title":"Get Role Assignments"},{"location":"sp/permissions/#first-unique-ancestor-securable-object","text":"This method can be used to find the securable parent up the hierarchy that has unique permissions. If everything inherits permissions this will be the Site. If a sub web has unique permissions it will be the web, and so on. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const obj = await sp.web.firstUniqueAncestorSecurableObject(); Logger.writeJSON(obj);","title":"First Unique Ancestor Securable Object"},{"location":"sp/permissions/#user-effective-permissions","text":"This method returns the BasePermissions for a given user or the current user. This value contains the High and Low values for a user on the securable you have queried. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const perms = await sp.web.getUserEffectivePermissions(\"i:0#.f|membership|user@site.com\"); Logger.writeJSON(perms); const perms2 = await sp.web.getCurrentUserEffectivePermissions(); Logger.writeJSON(perms2);","title":"User Effective Permissions"},{"location":"sp/permissions/#user-has-permissions","text":"Because the High and Low values in the BasePermission don't obviously mean anything you can use these methods along with the PermissionKind enumeration to check actual rights on the securable. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.userHasPermissions(\"i:0#.f|membership|user@site.com\", PermissionKind.ApproveItems); console.log(perms); const perms2 = await sp.web.currentUserHasPermissions(PermissionKind.ApproveItems); console.log(perms2);","title":"User Has Permissions"},{"location":"sp/permissions/#has-permissions","text":"If you need to check multiple permissions it can be more efficient to get the BasePermissions once and then use the hasPermissions method to check them as shown below. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.getCurrentUserEffectivePermissions(); if (sp.web.hasPermissions(perms, PermissionKind.AddListItems) && sp.web.hasPermissions(perms, PermissionKind.DeleteVersions)) { // ... }","title":"Has Permissions"},{"location":"sp/profiles/","text":"@pnp/sp/profiles \u00b6 The profile services allows you to work with the SharePoint User Profile Store. Profiles \u00b6 Profiles is accessed directly from the root sp object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/profiles\"; Get edit profile link for the current user \u00b6 editProfileLink(): Promise<string> const editProfileLink = await sp.profiles.editProfileLink(); console.log(\"My edit profile link =\" + editProfileLink); Is My People List Public \u00b6 Provides a boolean that indicates if the current users \"People I'm Following\" list is public or not isMyPeopleListPublic(): Promise<boolean> const isPublic = await sp.profiles.isMyPeopleListPublic(); console.log(\"Is my Following list Public =\" + isPubic); Find out if the current user is followed by another user \u00b6 Provides a boolean that indicates if the current users is followed by a specific user. amIFollowedBy(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const isFollowedBy = await sp.profiles.amIFollowedBy(loginName); console.log(\"Is \" + loginName + \" following me? \" + isFollowedBy); Find out if I am following a specific user \u00b6 Provides a boolean that indicates if the current users is followed by a specific user. amIFollowing(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const following = await sp.profiles.amIFollowing(loginName); console.log(\"Am I following \" + loginName + \"? \" + following); Get the tags I follow \u00b6 Gets the tags the current user is following. Accepts max count, default is 20. getFollowedTags(maxCount = 20): Promise<string[]> const tags = await sp.profiles.getFollowedTags(); console.log(tags); Get followers for a specific user \u00b6 Gets the people who are following the specified user. getFollowersFor(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); }); Get followers for the current \u00b6 Gets the people who are following the current user. myFollowers(): ISharePointQueryableCollection const folowers = await sp.profiles.myFollowers(); console.log(folowers); Get the properties for the current user \u00b6 Gets user properties for the current user. myProperties(): _SharePointQueryableInstance const profile = await sp.profiles.myProperties(); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName); Gets people specified user is following \u00b6 getPeopleFollowedBy(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const folowers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); }); Gets properties for a specified user \u00b6 getPropertiesFor(loginName: string): Promise<any> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const profile = await sp.profiles.getPropertiesFor(loginName); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in inconvenient Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName); Gets most popular tags \u00b6 Gets the 20 most popular hash tags over the past week, sorted so that the most popular tag appears first trendingTags(): Promise<IHashTagCollection> const tags = await sp.profiles.trendingTags(); tags.Items.forEach((tag) => { console.log(tag); }); Gets specified user profile property for the specified user \u00b6 getUserProfilePropertyFor(loginName: string, propertyName: string): Promise<string> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"AccountName\"; const property = await sp.profiles.getUserProfilePropertyFor(loginName, propertyName); console.log(property); Hide specific user from list of suggested people \u00b6 Removes the specified user from the user's list of suggested people to follow. hideSuggestion(loginName: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.hideSuggestion(loginName); Is one user following another \u00b6 Indicates whether the first user is following the second user. First parameter is the account name of the user who might be following the followee. Second parameter is the account name of the user who might be followed by the follower. isFollowing(follower: string, followee: string): Promise<boolean> const follower = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followee = \"i:0#.f|membership|testuser2@mytenant.onmicrosoft.com\"; const isFollowing = await sp.profiles.isFollowing(follower, followee); console.log(isFollowing); Set User Profile Picture \u00b6 Uploads and sets the user profile picture (Users can upload a picture to their own profile only). Not supported for batching. Accepts the profilePicSource Blob data representing the user's picture in BMP, JPEG, or PNG format of up to 4.76MB. setMyProfilePic(profilePicSource: Blob): Promise<void> import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/profiles\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files\"; // get the blob object through a request or from a file input const blob = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.getByName(\"profile.jpg\").getBlob(); await sp.profiles.setMyProfilePic(blob); Sets single value User Profile property \u00b6 accountName The account name of the user propertyName Property name propertyValue Property value setSingleValueProfileProperty(accountName: string, propertyName: string, propertyValue: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.setSingleValueProfileProperty(loginName, \"CellPhone\", \"(123) 555-1212\"); Sets a mult-value User Profile property \u00b6 accountName The account name of the user propertyName Property name propertyValues Property values setMultiValuedProfileProperty(accountName: string, propertyName: string, propertyValues: string[]): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"SPS-Skills\"; const propertyValues = [\"SharePoint\", \"Office 365\", \"Architecture\", \"Azure\"]; await sp.profiles.setMultiValuedProfileProperty(loginName, propertyName, propertyValues); const profile = await sp.profiles.getPropertiesFor(loginName); var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(profile.userProperties[propertyName]); Create Personal Site for specified users \u00b6 Provisions one or more users' personal sites. (My Site administrator on SharePoint Online only) Emails The email addresses of the users to provision sites for createPersonalSiteEnqueueBulk(...emails: string[]): Promise<void> let userEmails: string[] = [\"testuser1@mytenant.onmicrosoft.com\", \"testuser2@mytenant.onmicrosoft.com\"]; await sp.profiles.createPersonalSiteEnqueueBulk(userEmails); Get the user profile of the owner for the current site \u00b6 ownerUserProfile(): Promise<IUserProfile> const profile = await sp.profiles.ownerUserProfile(); console.log(profile); Get the user profile of the current user \u00b6 userProfile(): Promise<any> const profile = await sp.profiles.userProfile(); console.log(profile); Create personal site for current user \u00b6 createPersonalSite(interactiveRequest = false): Promise<void> await sp.profiles.createPersonalSite(); Make all profile data public or private \u00b6 Set the privacy settings for all social data. shareAllSocialData(share: boolean): Promise<void> await sp.profiles.shareAllSocialData(true); Resolve a user or group \u00b6 Resolves user or group using specified query parameters clientPeoplePickerResolveUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result); Search a user or group \u00b6 Searches for users or groups using specified query parameters clientPeoplePickerSearchUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity[]> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result);","title":"Profiles"},{"location":"sp/profiles/#pnpspprofiles","text":"The profile services allows you to work with the SharePoint User Profile Store.","title":"@pnp/sp/profiles"},{"location":"sp/profiles/#profiles","text":"Profiles is accessed directly from the root sp object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/profiles\";","title":"Profiles"},{"location":"sp/profiles/#get-edit-profile-link-for-the-current-user","text":"editProfileLink(): Promise<string> const editProfileLink = await sp.profiles.editProfileLink(); console.log(\"My edit profile link =\" + editProfileLink);","title":"Get edit profile link for the current user"},{"location":"sp/profiles/#is-my-people-list-public","text":"Provides a boolean that indicates if the current users \"People I'm Following\" list is public or not isMyPeopleListPublic(): Promise<boolean> const isPublic = await sp.profiles.isMyPeopleListPublic(); console.log(\"Is my Following list Public =\" + isPubic);","title":"Is My People List Public"},{"location":"sp/profiles/#find-out-if-the-current-user-is-followed-by-another-user","text":"Provides a boolean that indicates if the current users is followed by a specific user. amIFollowedBy(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const isFollowedBy = await sp.profiles.amIFollowedBy(loginName); console.log(\"Is \" + loginName + \" following me? \" + isFollowedBy);","title":"Find out if the current user is followed by another user"},{"location":"sp/profiles/#find-out-if-i-am-following-a-specific-user","text":"Provides a boolean that indicates if the current users is followed by a specific user. amIFollowing(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const following = await sp.profiles.amIFollowing(loginName); console.log(\"Am I following \" + loginName + \"? \" + following);","title":"Find out if I am following a specific user"},{"location":"sp/profiles/#get-the-tags-i-follow","text":"Gets the tags the current user is following. Accepts max count, default is 20. getFollowedTags(maxCount = 20): Promise<string[]> const tags = await sp.profiles.getFollowedTags(); console.log(tags);","title":"Get the tags I follow"},{"location":"sp/profiles/#get-followers-for-a-specific-user","text":"Gets the people who are following the specified user. getFollowersFor(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); });","title":"Get followers for a specific user"},{"location":"sp/profiles/#get-followers-for-the-current","text":"Gets the people who are following the current user. myFollowers(): ISharePointQueryableCollection const folowers = await sp.profiles.myFollowers(); console.log(folowers);","title":"Get followers for the current"},{"location":"sp/profiles/#get-the-properties-for-the-current-user","text":"Gets user properties for the current user. myProperties(): _SharePointQueryableInstance const profile = await sp.profiles.myProperties(); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName);","title":"Get the properties for the current user"},{"location":"sp/profiles/#gets-people-specified-user-is-following","text":"getPeopleFollowedBy(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const folowers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); });","title":"Gets people specified user is following"},{"location":"sp/profiles/#gets-properties-for-a-specified-user","text":"getPropertiesFor(loginName: string): Promise<any> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const profile = await sp.profiles.getPropertiesFor(loginName); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in inconvenient Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName);","title":"Gets properties for a specified user"},{"location":"sp/profiles/#gets-most-popular-tags","text":"Gets the 20 most popular hash tags over the past week, sorted so that the most popular tag appears first trendingTags(): Promise<IHashTagCollection> const tags = await sp.profiles.trendingTags(); tags.Items.forEach((tag) => { console.log(tag); });","title":"Gets most popular tags"},{"location":"sp/profiles/#gets-specified-user-profile-property-for-the-specified-user","text":"getUserProfilePropertyFor(loginName: string, propertyName: string): Promise<string> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"AccountName\"; const property = await sp.profiles.getUserProfilePropertyFor(loginName, propertyName); console.log(property);","title":"Gets specified user profile property for the specified user"},{"location":"sp/profiles/#hide-specific-user-from-list-of-suggested-people","text":"Removes the specified user from the user's list of suggested people to follow. hideSuggestion(loginName: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.hideSuggestion(loginName);","title":"Hide specific user from list of suggested people"},{"location":"sp/profiles/#is-one-user-following-another","text":"Indicates whether the first user is following the second user. First parameter is the account name of the user who might be following the followee. Second parameter is the account name of the user who might be followed by the follower. isFollowing(follower: string, followee: string): Promise<boolean> const follower = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followee = \"i:0#.f|membership|testuser2@mytenant.onmicrosoft.com\"; const isFollowing = await sp.profiles.isFollowing(follower, followee); console.log(isFollowing);","title":"Is one user following another"},{"location":"sp/profiles/#set-user-profile-picture","text":"Uploads and sets the user profile picture (Users can upload a picture to their own profile only). Not supported for batching. Accepts the profilePicSource Blob data representing the user's picture in BMP, JPEG, or PNG format of up to 4.76MB. setMyProfilePic(profilePicSource: Blob): Promise<void> import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/profiles\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files\"; // get the blob object through a request or from a file input const blob = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.getByName(\"profile.jpg\").getBlob(); await sp.profiles.setMyProfilePic(blob);","title":"Set User Profile Picture"},{"location":"sp/profiles/#sets-single-value-user-profile-property","text":"accountName The account name of the user propertyName Property name propertyValue Property value setSingleValueProfileProperty(accountName: string, propertyName: string, propertyValue: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.setSingleValueProfileProperty(loginName, \"CellPhone\", \"(123) 555-1212\");","title":"Sets single value User Profile property"},{"location":"sp/profiles/#sets-a-mult-value-user-profile-property","text":"accountName The account name of the user propertyName Property name propertyValues Property values setMultiValuedProfileProperty(accountName: string, propertyName: string, propertyValues: string[]): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"SPS-Skills\"; const propertyValues = [\"SharePoint\", \"Office 365\", \"Architecture\", \"Azure\"]; await sp.profiles.setMultiValuedProfileProperty(loginName, propertyName, propertyValues); const profile = await sp.profiles.getPropertiesFor(loginName); var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(profile.userProperties[propertyName]);","title":"Sets a mult-value User Profile property"},{"location":"sp/profiles/#create-personal-site-for-specified-users","text":"Provisions one or more users' personal sites. (My Site administrator on SharePoint Online only) Emails The email addresses of the users to provision sites for createPersonalSiteEnqueueBulk(...emails: string[]): Promise<void> let userEmails: string[] = [\"testuser1@mytenant.onmicrosoft.com\", \"testuser2@mytenant.onmicrosoft.com\"]; await sp.profiles.createPersonalSiteEnqueueBulk(userEmails);","title":"Create Personal Site for specified users"},{"location":"sp/profiles/#get-the-user-profile-of-the-owner-for-the-current-site","text":"ownerUserProfile(): Promise<IUserProfile> const profile = await sp.profiles.ownerUserProfile(); console.log(profile);","title":"Get the user profile of the owner for the current site"},{"location":"sp/profiles/#get-the-user-profile-of-the-current-user","text":"userProfile(): Promise<any> const profile = await sp.profiles.userProfile(); console.log(profile);","title":"Get the user profile of the current user"},{"location":"sp/profiles/#create-personal-site-for-current-user","text":"createPersonalSite(interactiveRequest = false): Promise<void> await sp.profiles.createPersonalSite();","title":"Create personal site for current user"},{"location":"sp/profiles/#make-all-profile-data-public-or-private","text":"Set the privacy settings for all social data. shareAllSocialData(share: boolean): Promise<void> await sp.profiles.shareAllSocialData(true);","title":"Make all profile data public or private"},{"location":"sp/profiles/#resolve-a-user-or-group","text":"Resolves user or group using specified query parameters clientPeoplePickerResolveUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result);","title":"Resolve a user or group"},{"location":"sp/profiles/#search-a-user-or-group","text":"Searches for users or groups using specified query parameters clientPeoplePickerSearchUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity[]> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result);","title":"Search a user or group"},{"location":"sp/regional-settings/","text":"@pnp/sp/regional-settings \u00b6 The regional settings module helps with managing dates and times across various timezones. IRegionalSettings \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IRegionalSettings, ITimeZone, ITimeZones, RegionalSettings, TimeZone, TimeZones, } from \"@pnp/sp/regional-settings\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get all the web's regional settings const s = await sp.web.regionalSettings(); // select only some settings to return const s2 = await sp.web.regionalSettings.select(\"DecimalSeparator\", \"ListSeparator\", \"IsUIRightToLeft\")(); Installed Languages \u00b6 You can get a list of the installed languages in the web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; const s = await sp.web.regionalSettings.getInstalledLanguages(); The installedLanguages property accessor is deprecated after 2.0.4 in favor of getInstalledLanguages and will be removed in future versions. TimeZones \u00b6 You can also get information about the selected timezone in the web and all of the defined timezones. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get the web's configured timezone const s = await sp.web.regionalSettings.timeZone(); // select just the Description and Id const s2 = await sp.web.regionalSettings.timeZone.select(\"Description\", \"Id\")(); // get all the timezones const s3 = await sp.web.regionalSettings.timeZones(); // get a specific timezone by id // list of ids: https://msdn.microsoft.com/en-us/library/office/jj247008.aspx const s4 = await sp.web.regionalSettings.timeZones.getById(23); const s5 = await s.localTimeToUTC(new Date()); // convert a given date from web's local time to UTC time const s6 = await sp.web.regionalSettings.timeZone.localTimeToUTC(new Date()); // convert a given date from UTC time to web's local time const s6 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date()) const s7 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date(2019, 6, 10, 10, 0, 0, 0)) Title and Description Resources \u00b6 Added in 2.0.4 Some objects allow you to read language specific title information as shown in the following sample. This applies to Web, List, Field, Content Type, and User Custom Actions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; // // The below methods appears on // - Web // - List // - Field // - ContentType // - User Custom Action // // after you import @pnp/sp/regional-settings // // you can also import just parts of the regional settings: // import \"@pnp/sp/regional-settings/web\"; // import \"@pnp/sp/regional-settings/list\"; // import \"@pnp/sp/regional-settings/content-type\"; // import \"@pnp/sp/regional-settings/field\"; // import \"@pnp/sp/regional-settings/user-custom-actions\"; const title = await sp.web.titleResource(\"en-us\"); const title2 = await sp.web.titleResource(\"de-de\"); const description = await sp.web.descriptionResource(\"en-us\"); const description2 = await sp.web.descriptionResource(\"de-de\"); You can only read the values through the REST API, not set the value.","title":"Regional Settings"},{"location":"sp/regional-settings/#pnpspregional-settings","text":"The regional settings module helps with managing dates and times across various timezones.","title":"@pnp/sp/regional-settings"},{"location":"sp/regional-settings/#iregionalsettings","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IRegionalSettings, ITimeZone, ITimeZones, RegionalSettings, TimeZone, TimeZones, } from \"@pnp/sp/regional-settings\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get all the web's regional settings const s = await sp.web.regionalSettings(); // select only some settings to return const s2 = await sp.web.regionalSettings.select(\"DecimalSeparator\", \"ListSeparator\", \"IsUIRightToLeft\")();","title":"IRegionalSettings"},{"location":"sp/regional-settings/#installed-languages","text":"You can get a list of the installed languages in the web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; const s = await sp.web.regionalSettings.getInstalledLanguages(); The installedLanguages property accessor is deprecated after 2.0.4 in favor of getInstalledLanguages and will be removed in future versions.","title":"Installed Languages"},{"location":"sp/regional-settings/#timezones","text":"You can also get information about the selected timezone in the web and all of the defined timezones. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get the web's configured timezone const s = await sp.web.regionalSettings.timeZone(); // select just the Description and Id const s2 = await sp.web.regionalSettings.timeZone.select(\"Description\", \"Id\")(); // get all the timezones const s3 = await sp.web.regionalSettings.timeZones(); // get a specific timezone by id // list of ids: https://msdn.microsoft.com/en-us/library/office/jj247008.aspx const s4 = await sp.web.regionalSettings.timeZones.getById(23); const s5 = await s.localTimeToUTC(new Date()); // convert a given date from web's local time to UTC time const s6 = await sp.web.regionalSettings.timeZone.localTimeToUTC(new Date()); // convert a given date from UTC time to web's local time const s6 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date()) const s7 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date(2019, 6, 10, 10, 0, 0, 0))","title":"TimeZones"},{"location":"sp/regional-settings/#title-and-description-resources","text":"Added in 2.0.4 Some objects allow you to read language specific title information as shown in the following sample. This applies to Web, List, Field, Content Type, and User Custom Actions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; // // The below methods appears on // - Web // - List // - Field // - ContentType // - User Custom Action // // after you import @pnp/sp/regional-settings // // you can also import just parts of the regional settings: // import \"@pnp/sp/regional-settings/web\"; // import \"@pnp/sp/regional-settings/list\"; // import \"@pnp/sp/regional-settings/content-type\"; // import \"@pnp/sp/regional-settings/field\"; // import \"@pnp/sp/regional-settings/user-custom-actions\"; const title = await sp.web.titleResource(\"en-us\"); const title2 = await sp.web.titleResource(\"de-de\"); const description = await sp.web.descriptionResource(\"en-us\"); const description2 = await sp.web.descriptionResource(\"de-de\"); You can only read the values through the REST API, not set the value.","title":"Title and Description Resources"},{"location":"sp/related-items/","text":"@pnp/sp/related-items \u00b6 The related items API allows you to add related items to items within a task or workflow list. Related items need to be in the same site collection. Setup \u00b6 Instead of copying this block of code into each sample, understand that each sample is meant to run with this supporting code to work. import { sp, extractWebUrl } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/related-items/web\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import \"@pnp/sp/files/list\"; import { IList } from \"@pnp/sp/lists\"; import { getRandomString } from \"@pnp/core\"; // setup some lists (or just use existing ones this is just to show the complete process) // we need two lists to use for creating related items, they need to use template 107 (task list) const ler1 = await sp.web.lists.ensure(\"RelatedItemsSourceList\", \"\", 107); const ler2 = await sp.web.lists.ensure(\"RelatedItemsTargetList\", \"\", 107); const sourceList = ler1.list; const targetList = ler2.list; const sourceListName = await sourceList.select(\"Id\")().then(r => r.Id); const targetListName = await targetList.select(\"Id\")().then(r => r.Id); // or whatever you need to get the web url, both our example lists are in the same web. const webUrl = sp.web.toUrl(); // ...individual samples start here addSingleLink \u00b6 const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); addSingleLinkToUrl \u00b6 This method adds a link to task item based on a url. The list name and item id are to the task item, the url is to the related item/document. // get a file's server relative url in some manner, here we add one const file = await sp.web.defaultDocumentLibrary.rootFolder.files.add(`file_${getRandomString(4)}.txt`, \"Content\", true).then(r => r.data); // add an item or get an item from the task list const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLinkToUrl(targetListName, targetItem.Id, file.ServerRelativeUrl); addSingleLinkFromUrl \u00b6 This method adds a link to task item based on a url. The list name and item id are to related item, the url is to task item to which the related reference is being added. I haven't found a use case for this method. deleteSingleLink \u00b6 This method allows you to delete a link previously created. const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add the link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); // delete the link await sp.web.relatedItems.deleteSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); getRelatedItems \u00b6 Gets the related items for an item import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getRelatedItems(sourceListName, sourceItem.Id); // items.length === 2 Related items are defined by the IRelatedItem interface export interface IRelatedItem { ListId: string; ItemId: number; Url: string; Title: string; WebId: string; IconUrl: string; } getPageOneRelatedItems \u00b6 Gets an abbreviated set of related items import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getPageOneRelatedItems(sourceListName, sourceItem.Id); // items.length === 2","title":"Related Items"},{"location":"sp/related-items/#pnpsprelated-items","text":"The related items API allows you to add related items to items within a task or workflow list. Related items need to be in the same site collection.","title":"@pnp/sp/related-items"},{"location":"sp/related-items/#setup","text":"Instead of copying this block of code into each sample, understand that each sample is meant to run with this supporting code to work. import { sp, extractWebUrl } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/related-items/web\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import \"@pnp/sp/files/list\"; import { IList } from \"@pnp/sp/lists\"; import { getRandomString } from \"@pnp/core\"; // setup some lists (or just use existing ones this is just to show the complete process) // we need two lists to use for creating related items, they need to use template 107 (task list) const ler1 = await sp.web.lists.ensure(\"RelatedItemsSourceList\", \"\", 107); const ler2 = await sp.web.lists.ensure(\"RelatedItemsTargetList\", \"\", 107); const sourceList = ler1.list; const targetList = ler2.list; const sourceListName = await sourceList.select(\"Id\")().then(r => r.Id); const targetListName = await targetList.select(\"Id\")().then(r => r.Id); // or whatever you need to get the web url, both our example lists are in the same web. const webUrl = sp.web.toUrl(); // ...individual samples start here","title":"Setup"},{"location":"sp/related-items/#addsinglelink","text":"const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl);","title":"addSingleLink"},{"location":"sp/related-items/#addsinglelinktourl","text":"This method adds a link to task item based on a url. The list name and item id are to the task item, the url is to the related item/document. // get a file's server relative url in some manner, here we add one const file = await sp.web.defaultDocumentLibrary.rootFolder.files.add(`file_${getRandomString(4)}.txt`, \"Content\", true).then(r => r.data); // add an item or get an item from the task list const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLinkToUrl(targetListName, targetItem.Id, file.ServerRelativeUrl);","title":"addSingleLinkToUrl"},{"location":"sp/related-items/#addsinglelinkfromurl","text":"This method adds a link to task item based on a url. The list name and item id are to related item, the url is to task item to which the related reference is being added. I haven't found a use case for this method.","title":"addSingleLinkFromUrl"},{"location":"sp/related-items/#deletesinglelink","text":"This method allows you to delete a link previously created. const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add the link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); // delete the link await sp.web.relatedItems.deleteSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl);","title":"deleteSingleLink"},{"location":"sp/related-items/#getrelateditems","text":"Gets the related items for an item import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getRelatedItems(sourceListName, sourceItem.Id); // items.length === 2 Related items are defined by the IRelatedItem interface export interface IRelatedItem { ListId: string; ItemId: number; Url: string; Title: string; WebId: string; IconUrl: string; }","title":"getRelatedItems"},{"location":"sp/related-items/#getpageonerelateditems","text":"Gets an abbreviated set of related items import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getPageOneRelatedItems(sourceListName, sourceItem.Id); // items.length === 2","title":"getPageOneRelatedItems"},{"location":"sp/search/","text":"@pnp/sp/search \u00b6 Using search you can access content throughout your organization in a secure and consistent manner. The library provides support for searching and suggest - as well as some interfaces and helper classes to make building your queries and processing responses easier. Search \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults } from \"@pnp/sp/search\"; Preset: All import { sp, ISearchQuery, SearchResults } from \"@pnp/sp/presets/all\"; Search is accessed directly from the root sp object and can take either a string representing the query text, a plain object matching the ISearchQuery interface, or a SearchQueryBuilder instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // text search using SharePoint default values for other parameters const results: SearchResults = await sp.search(\"test\"); console.log(results.ElapsedTime); console.log(results.RowCount); console.log(results.PrimarySearchResults); // define a search query object matching the ISearchQuery interface const results2: SearchResults = await sp.search(<ISearchQuery>{ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, }); console.log(results2.ElapsedTime); console.log(results2.RowCount); console.log(results2.PrimarySearchResults); // define a query using a builder const builder = SearchQueryBuilder(\"test\").rowLimit(10).enableInterleaving.enableQueryRules.processPersonalFavorites; const results3 = await sp.search(builder); console.log(results3.ElapsedTime); console.log(results3.RowCount); console.log(results3.PrimarySearchResults); Search Result Caching \u00b6 You can use the searchWithCaching method to enable cache support for your search results this option works with any of the options for providing a query, just replace \"search\" with \"searchWithCaching\" in your method chain and gain all the benefits of caching. The second parameter is optional and allows you to specify the cache options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; sp.searchWithCaching({ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, } as ISearchQuery).then((r: SearchResults) => { console.log(r.ElapsedTime); console.log(r.RowCount); console.log(r.PrimarySearchResults); }); // use a query builder const builder = SearchQueryBuilder(\"test\").rowLimit(3); // supply a search query builder and caching options const results2 = await sp.searchWithCaching(builder, { key: \"mykey\", expiration: dateAdd(new Date(), \"month\", 1) }); console.log(results2.TotalRows); Paging with SearchResults.getPage \u00b6 Paging is controlled by a start row and page size parameter. You can specify both arguments in your initial query however you can use the getPage method to jump to any page. The second parameter page size is optional and will use the previous RowLimit or default to 10. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // this will hold our current results let currentResults: SearchResults = null; let page = 1; // triggered on page load or through some other means function onStart() { // construct our query that will be used throughout the paging process, likely from user input const q = SearchQueryBuilder(\"test\").rowLimit(5); const results = await sp.search(q); currentResults = results; // set the current results page = 1; // reset page counter // update UI... } // triggered by an event async function next() { currentResults = await currentResults.getPage(++page); // update UI... } // triggered by an event async function prev() { currentResults = await currentResults.getPage(--page); // update UI... } SearchQueryBuilder \u00b6 The SearchQueryBuilder allows you to build your queries in a fluent manner. It also accepts constructor arguments for query text and a base query plain object, should you have a shared configuration for queries in an application you can define them once. The methods and properties match those on the SearchQuery interface. Boolean properties add the flag to the query while methods require that you supply one or more arguments. Also arguments supplied later in the chain will overwrite previous values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchQueryBuilder, SearchResults, ISearchQuery } from \"@pnp/sp/search\"; // basic usage let q = SearchQueryBuilder().text(\"test\").rowLimit(4).enablePhonetic; sp.search(q).then(h => { /* ... */ }); // provide a default query text at creation let q2 = SearchQueryBuilder(\"text\").rowLimit(4).enablePhonetic; const results: SearchResults = await sp.search(q2); // provide query text and a template for // shared settings across queries that can // be overwritten by individual builders const appSearchSettings: ISearchQuery = { EnablePhonetic: true, HiddenConstraints: \"reports\" }; let q3 = SearchQueryBuilder(\"test\", appSearchSettings).enableQueryRules; let q4 = SearchQueryBuilder(\"financial data\", appSearchSettings).enableSorting.enableStemming; const results2 = await sp.search(q3); const results3 = sp.search(q4); Search Suggest \u00b6 Search suggest works in much the same way as search, except against the suggest end point. It takes a string or a plain object that matches ISuggestQuery. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISuggestQuery, ISuggestResult } from \"@pnp/sp/search\"; const results = await sp.searchSuggest(\"test\"); const results2 = await sp.searchSuggest({ querytext: \"test\", count: 5, } as ISuggestQuery); Search Factory \u00b6 You can also configure a search or suggest query against any valid SP url using the factory methods. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { Search, Suggest } from \"@pnp/sp/search\"; // set the url for search const searcher = Search(\"https://mytenant.sharepoint.com/sites/dev\"); // this can accept any of the query types (text, ISearchQuery, or SearchQueryBuilder) const results = await searcher(\"test\"); // you can reuse the ISearch instance const results2 = await searcher(\"another query\"); // same process works for Suggest const suggester = Suggest(\"https://mytenant.sharepoint.com/sites/dev\"); const suggestions = await suggester({ querytext: \"test\" });","title":"Search"},{"location":"sp/search/#pnpspsearch","text":"Using search you can access content throughout your organization in a secure and consistent manner. The library provides support for searching and suggest - as well as some interfaces and helper classes to make building your queries and processing responses easier.","title":"@pnp/sp/search"},{"location":"sp/search/#search","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults } from \"@pnp/sp/search\"; Preset: All import { sp, ISearchQuery, SearchResults } from \"@pnp/sp/presets/all\"; Search is accessed directly from the root sp object and can take either a string representing the query text, a plain object matching the ISearchQuery interface, or a SearchQueryBuilder instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // text search using SharePoint default values for other parameters const results: SearchResults = await sp.search(\"test\"); console.log(results.ElapsedTime); console.log(results.RowCount); console.log(results.PrimarySearchResults); // define a search query object matching the ISearchQuery interface const results2: SearchResults = await sp.search(<ISearchQuery>{ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, }); console.log(results2.ElapsedTime); console.log(results2.RowCount); console.log(results2.PrimarySearchResults); // define a query using a builder const builder = SearchQueryBuilder(\"test\").rowLimit(10).enableInterleaving.enableQueryRules.processPersonalFavorites; const results3 = await sp.search(builder); console.log(results3.ElapsedTime); console.log(results3.RowCount); console.log(results3.PrimarySearchResults);","title":"Search"},{"location":"sp/search/#search-result-caching","text":"You can use the searchWithCaching method to enable cache support for your search results this option works with any of the options for providing a query, just replace \"search\" with \"searchWithCaching\" in your method chain and gain all the benefits of caching. The second parameter is optional and allows you to specify the cache options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; sp.searchWithCaching({ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, } as ISearchQuery).then((r: SearchResults) => { console.log(r.ElapsedTime); console.log(r.RowCount); console.log(r.PrimarySearchResults); }); // use a query builder const builder = SearchQueryBuilder(\"test\").rowLimit(3); // supply a search query builder and caching options const results2 = await sp.searchWithCaching(builder, { key: \"mykey\", expiration: dateAdd(new Date(), \"month\", 1) }); console.log(results2.TotalRows);","title":"Search Result Caching"},{"location":"sp/search/#paging-with-searchresultsgetpage","text":"Paging is controlled by a start row and page size parameter. You can specify both arguments in your initial query however you can use the getPage method to jump to any page. The second parameter page size is optional and will use the previous RowLimit or default to 10. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // this will hold our current results let currentResults: SearchResults = null; let page = 1; // triggered on page load or through some other means function onStart() { // construct our query that will be used throughout the paging process, likely from user input const q = SearchQueryBuilder(\"test\").rowLimit(5); const results = await sp.search(q); currentResults = results; // set the current results page = 1; // reset page counter // update UI... } // triggered by an event async function next() { currentResults = await currentResults.getPage(++page); // update UI... } // triggered by an event async function prev() { currentResults = await currentResults.getPage(--page); // update UI... }","title":"Paging with SearchResults.getPage"},{"location":"sp/search/#searchquerybuilder","text":"The SearchQueryBuilder allows you to build your queries in a fluent manner. It also accepts constructor arguments for query text and a base query plain object, should you have a shared configuration for queries in an application you can define them once. The methods and properties match those on the SearchQuery interface. Boolean properties add the flag to the query while methods require that you supply one or more arguments. Also arguments supplied later in the chain will overwrite previous values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchQueryBuilder, SearchResults, ISearchQuery } from \"@pnp/sp/search\"; // basic usage let q = SearchQueryBuilder().text(\"test\").rowLimit(4).enablePhonetic; sp.search(q).then(h => { /* ... */ }); // provide a default query text at creation let q2 = SearchQueryBuilder(\"text\").rowLimit(4).enablePhonetic; const results: SearchResults = await sp.search(q2); // provide query text and a template for // shared settings across queries that can // be overwritten by individual builders const appSearchSettings: ISearchQuery = { EnablePhonetic: true, HiddenConstraints: \"reports\" }; let q3 = SearchQueryBuilder(\"test\", appSearchSettings).enableQueryRules; let q4 = SearchQueryBuilder(\"financial data\", appSearchSettings).enableSorting.enableStemming; const results2 = await sp.search(q3); const results3 = sp.search(q4);","title":"SearchQueryBuilder"},{"location":"sp/search/#search-suggest","text":"Search suggest works in much the same way as search, except against the suggest end point. It takes a string or a plain object that matches ISuggestQuery. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISuggestQuery, ISuggestResult } from \"@pnp/sp/search\"; const results = await sp.searchSuggest(\"test\"); const results2 = await sp.searchSuggest({ querytext: \"test\", count: 5, } as ISuggestQuery);","title":"Search Suggest"},{"location":"sp/search/#search-factory","text":"You can also configure a search or suggest query against any valid SP url using the factory methods. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { Search, Suggest } from \"@pnp/sp/search\"; // set the url for search const searcher = Search(\"https://mytenant.sharepoint.com/sites/dev\"); // this can accept any of the query types (text, ISearchQuery, or SearchQueryBuilder) const results = await searcher(\"test\"); // you can reuse the ISearch instance const results2 = await searcher(\"another query\"); // same process works for Suggest const suggester = Suggest(\"https://mytenant.sharepoint.com/sites/dev\"); const suggestions = await suggester({ querytext: \"test\" });","title":"Search Factory"},{"location":"sp/security/","text":"@pnp/sp/security \u00b6 There are four levels where you can break inheritance and assign security: Site, Web, List, Item. All four of these objects share a common set of methods. Because of this we are showing in the examples below usage of these methods for an IList instance, but they apply across all four securable objects. In addition to the shared methods, some types have unique methods which are listed below. Site permissions are managed on the root web of the site collection. A Note on Selective Imports for Security \u00b6 Because the method are shared you can opt to import only the methods for one of the instances. import \"@pnp/sp/security/web\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/security/item\"; Possibly useful if you are trying to hyper-optimize for bundle size but it is just as easy to import the whole module: import \"@pnp/sp/security\"; Securable Methods \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // role assignments (see section below) await list.roleAssignments(); // data will represent one of the possible parents Site, Web, or List const data = await list.firstUniqueAncestorSecurableObject(); // getUserEffectivePermissions const users = await sp.web.siteUsers.top(1).select(\"LoginName\")(); const perms = await list.getUserEffectivePermissions(users[0].LoginName); // getCurrentUserEffectivePermissions const perms2 = list.getCurrentUserEffectivePermissions(); // userHasPermissions const v: boolean = list.userHasPermissions(users[0].LoginName, PermissionKind.AddListItems) // currentUserHasPermissions const v2: boolean = list.currentUserHasPermissions(PermissionKind.AddListItems) // breakRoleInheritance await list.breakRoleInheritance(); // copy existing permissions await list.breakRoleInheritance(true); // copy existing permissions and reset all child securables to the new permissions await list.breakRoleInheritance(true, true); // resetRoleInheritance await list.resetRoleInheritance(); Web Specific methods \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // role definitions (see section below) const defs = await sp.web.roleDefinitions(); Role Assignments \u00b6 Allows you to list and manipulate the set of role assignments for the given securable. Again we show usage using list, but the examples apply to web and item as well. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/web\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // list role assignments const assignments = await list.roleAssignments(); // add a role assignment const defs = await sp.web.roleDefinitions(); const user = await sp.web.currentUser(); const r = await list.roleAssignments.add(user.Id, defs[0].Id); // remove a role assignment const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); const r = await list.roleAssignments.remove(ra.Id); // read role assignment info const info = await list.roleAssignments.getById(ra.Id)(); // get the groups const info2 = await list.roleAssignments.getById(ra.Id).groups(); // get the bindings const info3 = await list.roleAssignments.getById(ra.Id).bindings(); // delete a role assignment (same as remove) const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); // delete it await list.roleAssignments.getById(ra.Id).delete(); Role Definitions \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // read role definitions const defs = await sp.web.roleDefinitions(); // get by id const def = await sp.web.roleDefinitions.getById(5)(); const def = await sp.web.roleDefinitions.getById(5).select(\"Name\", \"Order\")(); // get by name const def = await sp.web.roleDefinitions.getByName(\"Full Control\")(); const def = await sp.web.roleDefinitions.getByName(\"Full Control\").select(\"Name\", \"Order\")(); // get by type const def = await sp.web.roleDefinitions.getByName(5)(); const def = await sp.web.roleDefinitions.getByName(5).select(\"Name\", \"Order\")(); // add // name The new role definition's name // description The new role definition's description // order The order in which the role definition appears // basePermissions The permissions mask for this role definition const rdar = await sp.web.roleDefinitions.add(\"title\", \"description\", 99, { High: 1, Low: 2 }); // the following methods work on a single role def, you can use any of the three getBy methods, here we use getById as an example // delete await sp.web.roleDefinitions.getById(5).delete(); // update const res = sp.web.roleDefinitions.getById(5).update({ Name: \"New Name\" });","title":"Security"},{"location":"sp/security/#pnpspsecurity","text":"There are four levels where you can break inheritance and assign security: Site, Web, List, Item. All four of these objects share a common set of methods. Because of this we are showing in the examples below usage of these methods for an IList instance, but they apply across all four securable objects. In addition to the shared methods, some types have unique methods which are listed below. Site permissions are managed on the root web of the site collection.","title":"@pnp/sp/security"},{"location":"sp/security/#a-note-on-selective-imports-for-security","text":"Because the method are shared you can opt to import only the methods for one of the instances. import \"@pnp/sp/security/web\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/security/item\"; Possibly useful if you are trying to hyper-optimize for bundle size but it is just as easy to import the whole module: import \"@pnp/sp/security\";","title":"A Note on Selective Imports for Security"},{"location":"sp/security/#securable-methods","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // role assignments (see section below) await list.roleAssignments(); // data will represent one of the possible parents Site, Web, or List const data = await list.firstUniqueAncestorSecurableObject(); // getUserEffectivePermissions const users = await sp.web.siteUsers.top(1).select(\"LoginName\")(); const perms = await list.getUserEffectivePermissions(users[0].LoginName); // getCurrentUserEffectivePermissions const perms2 = list.getCurrentUserEffectivePermissions(); // userHasPermissions const v: boolean = list.userHasPermissions(users[0].LoginName, PermissionKind.AddListItems) // currentUserHasPermissions const v2: boolean = list.currentUserHasPermissions(PermissionKind.AddListItems) // breakRoleInheritance await list.breakRoleInheritance(); // copy existing permissions await list.breakRoleInheritance(true); // copy existing permissions and reset all child securables to the new permissions await list.breakRoleInheritance(true, true); // resetRoleInheritance await list.resetRoleInheritance();","title":"Securable Methods"},{"location":"sp/security/#web-specific-methods","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // role definitions (see section below) const defs = await sp.web.roleDefinitions();","title":"Web Specific methods"},{"location":"sp/security/#role-assignments","text":"Allows you to list and manipulate the set of role assignments for the given securable. Again we show usage using list, but the examples apply to web and item as well. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/web\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // list role assignments const assignments = await list.roleAssignments(); // add a role assignment const defs = await sp.web.roleDefinitions(); const user = await sp.web.currentUser(); const r = await list.roleAssignments.add(user.Id, defs[0].Id); // remove a role assignment const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); const r = await list.roleAssignments.remove(ra.Id); // read role assignment info const info = await list.roleAssignments.getById(ra.Id)(); // get the groups const info2 = await list.roleAssignments.getById(ra.Id).groups(); // get the bindings const info3 = await list.roleAssignments.getById(ra.Id).bindings(); // delete a role assignment (same as remove) const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); // delete it await list.roleAssignments.getById(ra.Id).delete();","title":"Role Assignments"},{"location":"sp/security/#role-definitions","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // read role definitions const defs = await sp.web.roleDefinitions(); // get by id const def = await sp.web.roleDefinitions.getById(5)(); const def = await sp.web.roleDefinitions.getById(5).select(\"Name\", \"Order\")(); // get by name const def = await sp.web.roleDefinitions.getByName(\"Full Control\")(); const def = await sp.web.roleDefinitions.getByName(\"Full Control\").select(\"Name\", \"Order\")(); // get by type const def = await sp.web.roleDefinitions.getByName(5)(); const def = await sp.web.roleDefinitions.getByName(5).select(\"Name\", \"Order\")(); // add // name The new role definition's name // description The new role definition's description // order The order in which the role definition appears // basePermissions The permissions mask for this role definition const rdar = await sp.web.roleDefinitions.add(\"title\", \"description\", 99, { High: 1, Low: 2 }); // the following methods work on a single role def, you can use any of the three getBy methods, here we use getById as an example // delete await sp.web.roleDefinitions.getById(5).delete(); // update const res = sp.web.roleDefinitions.getById(5).update({ Name: \"New Name\" });","title":"Role Definitions"},{"location":"sp/sharing/","text":"@pnp/sp/sharing \u00b6 Note: This API is still considered \"beta\" meaning it may change and some behaviors may differ across tenants by version. It is also supported only in SharePoint Online. One of the newer abilities in SharePoint is the ability to share webs, files, or folders with both internal and external folks. It is important to remember that these settings are managed at the tenant level and ? override anything you may supply as an argument to these methods. If you receive an InvalidOperationException when using these methods please check your tenant sharing settings to ensure sharing is not blocked before ?submitting an issue. Imports \u00b6 In previous versions of this library the sharing methods were part of the inheritance stack for SharePointQueryable objects. Starting with v2 this is no longer the case and they are now selectively importable. There are four objects within the SharePoint hierarchy that support sharing: Item, File, Folder, and Web. You can import the sharing methods for all of them, or for individual objects. Import All \u00b6 To import and attach the sharing methods to all four of the sharable types include all of the sharing sub module: import \"@pnp/sp/sharing\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName); Selective Import \u00b6 Import only the web's sharing methods into the library import \"@pnp/sp/sharing/web\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName); getShareLink \u00b6 Applies to: Item, Folder, File Creates a sharing link for the given resource with an optional expiration. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { SharingLinkKind, IShareLinkResponse } from \"@pnp/sp/sharing\"; import { dateAdd } from \"@pnp/core\"; const result = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView); console.log(JSON.stringify(result, null, 2)); const result2 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView, dateAdd(new Date(), \"day\", 5)); console.log(JSON.stringify(result2, null, 2)); shareWith \u00b6 Applies to: Item, Folder, File, Web Shares the given resource with the specified permissions (View or Edit) and optionally sends an email to the users. You can supply a single string for the loginnames parameter or an array of loginnames . The folder method takes an optional parameter \"shareEverything\" which determines if the shared permissions are pushed down to all items in the folder, even those with unique permissions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/files/web\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; const result = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\"); console.log(JSON.stringify(result, null, 2)); // Share and allow editing const result2 = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit); console.log(JSON.stringify(result2, null, 2)); // share folder const result3 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share folder with edit permissions, and provide params for requireSignin and propagateAcl (apply to all children) await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit, true, true); // Share a file await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share a file with edit permissions await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit); shareObject & shareObjectRaw \u00b6 Applies to: Web Allows you to share any shareable object in a web by providing the appropriate parameters. These two methods differ in that shareObject will try and fix up your query based on the supplied parameters where shareObjectRaw will send your supplied json object directly to the server. The later method is provided for the greatest amount of flexibility. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; // Share an object in this web const result = await sp.web.shareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", \"i:0#.f|membership|user@site.com\", SharingRole.View); // Share an object with all settings available await sp.web.shareObjectRaw({ url: \"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", peoplePickerInput: [{ Key: \"i:0#.f|membership|user@site.com\" }], roleValue: \"role: 1973741327\", groupId: 0, propagateAcl: false, sendEmail: true, includeAnonymousLinkInEmail: false, emailSubject: \"subject\", emailBody: \"body\", useSimplifiedRoles: true, }); unshareObject \u00b6 Applies to: Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result = await sp.web.unshareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\"); checkSharingPermissions \u00b6 Applies to: Item, Folder, File Checks Permissions on the list of Users and returns back role the users have on the Item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing/folders\"; import \"@pnp/sp/folders/web\"; import { SharingEntityPermission } from \"@pnp/sp/sharing\"; // check the sharing permissions for a folder const perms = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").checkSharingPermissions([{ alias: \"i:0#.f|membership|user@site.com\" }]); getSharingInformation \u00b6 Applies to: Item, Folder, File Get Sharing Information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingInformation } from \"@pnp/sp/sharing\"; // Get the sharing information for a folder const info = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getSharingInformation(); getObjectSharingSettings \u00b6 Applies to: Item, Folder, File Gets the sharing settings import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { IObjectSharingSettings } from \"@pnp/sp/sharing\"; // Gets the sharing object settings const settings: IObjectSharingSettings = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getObjectSharingSettings(); unshare \u00b6 Applies to: Item, Folder, File Unshares a given resource import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshare(); deleteSharingLinkByKind \u00b6 Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult, SharingLinkKind } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").deleteSharingLinkByKind(SharingLinkKind.AnonymousEdit); unshareLink \u00b6 Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { SharingLinkKind } from \"@pnp/sp/sharing\"; await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit); // specify the sharing link id if available await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit, \"12345\");","title":"Sharing"},{"location":"sp/sharing/#pnpspsharing","text":"Note: This API is still considered \"beta\" meaning it may change and some behaviors may differ across tenants by version. It is also supported only in SharePoint Online. One of the newer abilities in SharePoint is the ability to share webs, files, or folders with both internal and external folks. It is important to remember that these settings are managed at the tenant level and ? override anything you may supply as an argument to these methods. If you receive an InvalidOperationException when using these methods please check your tenant sharing settings to ensure sharing is not blocked before ?submitting an issue.","title":"@pnp/sp/sharing"},{"location":"sp/sharing/#imports","text":"In previous versions of this library the sharing methods were part of the inheritance stack for SharePointQueryable objects. Starting with v2 this is no longer the case and they are now selectively importable. There are four objects within the SharePoint hierarchy that support sharing: Item, File, Folder, and Web. You can import the sharing methods for all of them, or for individual objects.","title":"Imports"},{"location":"sp/sharing/#import-all","text":"To import and attach the sharing methods to all four of the sharable types include all of the sharing sub module: import \"@pnp/sp/sharing\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName);","title":"Import All"},{"location":"sp/sharing/#selective-import","text":"Import only the web's sharing methods into the library import \"@pnp/sp/sharing/web\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName);","title":"Selective Import"},{"location":"sp/sharing/#getsharelink","text":"Applies to: Item, Folder, File Creates a sharing link for the given resource with an optional expiration. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { SharingLinkKind, IShareLinkResponse } from \"@pnp/sp/sharing\"; import { dateAdd } from \"@pnp/core\"; const result = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView); console.log(JSON.stringify(result, null, 2)); const result2 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView, dateAdd(new Date(), \"day\", 5)); console.log(JSON.stringify(result2, null, 2));","title":"getShareLink"},{"location":"sp/sharing/#sharewith","text":"Applies to: Item, Folder, File, Web Shares the given resource with the specified permissions (View or Edit) and optionally sends an email to the users. You can supply a single string for the loginnames parameter or an array of loginnames . The folder method takes an optional parameter \"shareEverything\" which determines if the shared permissions are pushed down to all items in the folder, even those with unique permissions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/files/web\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; const result = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\"); console.log(JSON.stringify(result, null, 2)); // Share and allow editing const result2 = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit); console.log(JSON.stringify(result2, null, 2)); // share folder const result3 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share folder with edit permissions, and provide params for requireSignin and propagateAcl (apply to all children) await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit, true, true); // Share a file await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share a file with edit permissions await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit);","title":"shareWith"},{"location":"sp/sharing/#shareobject-shareobjectraw","text":"Applies to: Web Allows you to share any shareable object in a web by providing the appropriate parameters. These two methods differ in that shareObject will try and fix up your query based on the supplied parameters where shareObjectRaw will send your supplied json object directly to the server. The later method is provided for the greatest amount of flexibility. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; // Share an object in this web const result = await sp.web.shareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", \"i:0#.f|membership|user@site.com\", SharingRole.View); // Share an object with all settings available await sp.web.shareObjectRaw({ url: \"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", peoplePickerInput: [{ Key: \"i:0#.f|membership|user@site.com\" }], roleValue: \"role: 1973741327\", groupId: 0, propagateAcl: false, sendEmail: true, includeAnonymousLinkInEmail: false, emailSubject: \"subject\", emailBody: \"body\", useSimplifiedRoles: true, });","title":"shareObject &amp; shareObjectRaw"},{"location":"sp/sharing/#unshareobject","text":"Applies to: Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result = await sp.web.unshareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\");","title":"unshareObject"},{"location":"sp/sharing/#checksharingpermissions","text":"Applies to: Item, Folder, File Checks Permissions on the list of Users and returns back role the users have on the Item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing/folders\"; import \"@pnp/sp/folders/web\"; import { SharingEntityPermission } from \"@pnp/sp/sharing\"; // check the sharing permissions for a folder const perms = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").checkSharingPermissions([{ alias: \"i:0#.f|membership|user@site.com\" }]);","title":"checkSharingPermissions"},{"location":"sp/sharing/#getsharinginformation","text":"Applies to: Item, Folder, File Get Sharing Information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingInformation } from \"@pnp/sp/sharing\"; // Get the sharing information for a folder const info = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getSharingInformation();","title":"getSharingInformation"},{"location":"sp/sharing/#getobjectsharingsettings","text":"Applies to: Item, Folder, File Gets the sharing settings import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { IObjectSharingSettings } from \"@pnp/sp/sharing\"; // Gets the sharing object settings const settings: IObjectSharingSettings = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getObjectSharingSettings();","title":"getObjectSharingSettings"},{"location":"sp/sharing/#unshare","text":"Applies to: Item, Folder, File Unshares a given resource import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshare();","title":"unshare"},{"location":"sp/sharing/#deletesharinglinkbykind","text":"Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult, SharingLinkKind } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").deleteSharingLinkByKind(SharingLinkKind.AnonymousEdit);","title":"deleteSharingLinkByKind"},{"location":"sp/sharing/#unsharelink","text":"Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { SharingLinkKind } from \"@pnp/sp/sharing\"; await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit); // specify the sharing link id if available await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit, \"12345\");","title":"unshareLink"},{"location":"sp/site-designs/","text":"@pnp/sp/site-designs \u00b6 You can create site designs to provide reusable lists, themes, layouts, pages, or custom actions so that your users can quickly build new SharePoint sites with the features they need. Check out SharePoint site design and site script overview for more information. Site Designs \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Create a new site design \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // WebTemplate: 64 Team site template, 68 Communication site template const siteDesign = await sp.siteDesigns.createSiteDesign({ SiteScriptIds: [\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"], Title: \"SiteDesign001\", WebTemplate: \"64\", }); console.log(siteDesign.Title); Applying a site design to a site \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Limited to 30 actions in a site script, but runs synchronously await sp.siteDesigns.applySiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\",\"https://contoso.sharepoint.com/sites/teamsite-pnpjs001\"); // Better use the following method for 300 actions in a site script const task = await sp.web.addSiteDesignTask(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); Retrieval \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Retrieving all site designs const allSiteDesigns = await sp.siteDesigns.getSiteDesigns(); console.log(`Total site designs: ${allSiteDesigns.length}`); // Retrieving a single site design by Id const siteDesign = await sp.siteDesigns.getSiteDesignMetadata(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(siteDesign.Title); Update and delete \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Update const updatedSiteDesign = await sp.siteDesigns.updateSiteDesign({ Id: \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", Title: \"SiteDesignUpdatedTitle001\" }); // Delete await sp.siteDesigns.deleteSiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); Setting Rights/Permissions \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Get const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(rights.length > 0 ? rights[0].PrincipalName : \"\"); // Grant await sp.siteDesigns.grantSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Revoke await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Reset all view rights const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", rights.map(u => u.PrincipalName)); Get a history of site designs that have run on a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; const runs = await sp.web.getSiteDesignRuns(); const runs2 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\"); // Get runs specific to a site design const runs3 = await sp.web.getSiteDesignRuns(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); const runs4 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\", \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); // For more information about the site script actions const runStatus = await sp.web.getSiteDesignRunStatus(runs[0].ID); const runStatus2 = await sp.siteDesigns.getSiteDesignRunStatus(\"https://TENANT.sharepoint.com/sites/mysite\", runs[0].ID);","title":"Site Designs"},{"location":"sp/site-designs/#pnpspsite-designs","text":"You can create site designs to provide reusable lists, themes, layouts, pages, or custom actions so that your users can quickly build new SharePoint sites with the features they need. Check out SharePoint site design and site script overview for more information.","title":"@pnp/sp/site-designs"},{"location":"sp/site-designs/#site-designs","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"Site Designs"},{"location":"sp/site-designs/#create-a-new-site-design","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // WebTemplate: 64 Team site template, 68 Communication site template const siteDesign = await sp.siteDesigns.createSiteDesign({ SiteScriptIds: [\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"], Title: \"SiteDesign001\", WebTemplate: \"64\", }); console.log(siteDesign.Title);","title":"Create a new site design"},{"location":"sp/site-designs/#applying-a-site-design-to-a-site","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Limited to 30 actions in a site script, but runs synchronously await sp.siteDesigns.applySiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\",\"https://contoso.sharepoint.com/sites/teamsite-pnpjs001\"); // Better use the following method for 300 actions in a site script const task = await sp.web.addSiteDesignTask(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\");","title":"Applying a site design to a site"},{"location":"sp/site-designs/#retrieval","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Retrieving all site designs const allSiteDesigns = await sp.siteDesigns.getSiteDesigns(); console.log(`Total site designs: ${allSiteDesigns.length}`); // Retrieving a single site design by Id const siteDesign = await sp.siteDesigns.getSiteDesignMetadata(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(siteDesign.Title);","title":"Retrieval"},{"location":"sp/site-designs/#update-and-delete","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Update const updatedSiteDesign = await sp.siteDesigns.updateSiteDesign({ Id: \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", Title: \"SiteDesignUpdatedTitle001\" }); // Delete await sp.siteDesigns.deleteSiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\");","title":"Update and delete"},{"location":"sp/site-designs/#setting-rightspermissions","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Get const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(rights.length > 0 ? rights[0].PrincipalName : \"\"); // Grant await sp.siteDesigns.grantSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Revoke await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Reset all view rights const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", rights.map(u => u.PrincipalName));","title":"Setting Rights/Permissions"},{"location":"sp/site-designs/#get-a-history-of-site-designs-that-have-run-on-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; const runs = await sp.web.getSiteDesignRuns(); const runs2 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\"); // Get runs specific to a site design const runs3 = await sp.web.getSiteDesignRuns(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); const runs4 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\", \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); // For more information about the site script actions const runStatus = await sp.web.getSiteDesignRunStatus(runs[0].ID); const runStatus2 = await sp.siteDesigns.getSiteDesignRunStatus(\"https://TENANT.sharepoint.com/sites/mysite\", runs[0].ID);","title":"Get a history of site designs that have run on a web"},{"location":"sp/site-groups/","text":"@pnp/sp/site-groups \u00b6 The site groups module provides methods to manage groups for a sharepoint site. ISiteGroups \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups } from \"@pnp/sp/presets/all\"; Get all site groups \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // gets all site groups of the web const groups = await sp.web.siteGroups(); Get the associated groups of a web \u00b6 You can get the associated Owner, Member and Visitor groups of a web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Gets the associated visitors group of a web const visitorGroup = await sp.web.associatedVisitorGroup(); // Gets the associated members group of a web const memberGroup = await sp.web.associatedMemberGroup(); // Gets the associated owners group of a web const ownerGroup = await sp.web.associatedOwnerGroup(); Create the default associated groups for a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Breaks permission inheritance and creates the default associated groups for the web // Login name of the owner const owner1 = \"owner@example.onmicrosoft.com\"; // Specify true, the permissions should be copied from the current parent scope, else false const copyRoleAssignments = false; // Specify true to make all child securable objects inherit role assignments from the current object const clearSubScopes = true; await sp.web.createDefaultAssociatedGroups(\"PnP Site\", owner1, copyRoleAssignments, clearSubScopes); Create a new site group \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Creates a new site group with the specified title await sp.web.siteGroups.add({\"Title\":\"new group name\"}); ISiteGroup \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups, SiteGroup } from \"@pnp/sp/presets/all\"; Getting and updating the groups of a sharepoint web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get the group using a group id const groupID = 33; let grp = await sp.web.siteGroups.getById(groupID)(); // get the group using the group's name const groupName = \"ClassicTeam Visitors\"; grp = await sp.web.siteGroups.getByName(groupName)(); // update a group await sp.web.siteGroups.getById(groupID).update({\"Title\": \"New Group Title\"}); // delete a group from the site using group id await sp.web.siteGroups.removeById(groupID); // delete a group from the site using group name await sp.web.siteGroups.removeByLoginName(groupName); Getting all users of a group \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get all users of group const groupID = 7; const users = await sp.web.siteGroups.getById(groupID).users(); Updating the owner of a site group \u00b6 Unfortunately for now setting the owner of a group as another or same SharePoint group is currently unsupported in REST. Setting the owner as a user is supported. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // Update the owner with a user id await sp.web.siteGroups.getById(7).setUserAsOwner(4);","title":"Site Groups"},{"location":"sp/site-groups/#pnpspsite-groups","text":"The site groups module provides methods to manage groups for a sharepoint site.","title":"@pnp/sp/site-groups"},{"location":"sp/site-groups/#isitegroups","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups } from \"@pnp/sp/presets/all\";","title":"ISiteGroups"},{"location":"sp/site-groups/#get-all-site-groups","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // gets all site groups of the web const groups = await sp.web.siteGroups();","title":"Get all site groups"},{"location":"sp/site-groups/#get-the-associated-groups-of-a-web","text":"You can get the associated Owner, Member and Visitor groups of a web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Gets the associated visitors group of a web const visitorGroup = await sp.web.associatedVisitorGroup(); // Gets the associated members group of a web const memberGroup = await sp.web.associatedMemberGroup(); // Gets the associated owners group of a web const ownerGroup = await sp.web.associatedOwnerGroup();","title":"Get the associated groups of a web"},{"location":"sp/site-groups/#create-the-default-associated-groups-for-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Breaks permission inheritance and creates the default associated groups for the web // Login name of the owner const owner1 = \"owner@example.onmicrosoft.com\"; // Specify true, the permissions should be copied from the current parent scope, else false const copyRoleAssignments = false; // Specify true to make all child securable objects inherit role assignments from the current object const clearSubScopes = true; await sp.web.createDefaultAssociatedGroups(\"PnP Site\", owner1, copyRoleAssignments, clearSubScopes);","title":"Create the default associated groups for a web"},{"location":"sp/site-groups/#create-a-new-site-group","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Creates a new site group with the specified title await sp.web.siteGroups.add({\"Title\":\"new group name\"});","title":"Create a new site group"},{"location":"sp/site-groups/#isitegroup","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups, SiteGroup } from \"@pnp/sp/presets/all\";","title":"ISiteGroup"},{"location":"sp/site-groups/#getting-and-updating-the-groups-of-a-sharepoint-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get the group using a group id const groupID = 33; let grp = await sp.web.siteGroups.getById(groupID)(); // get the group using the group's name const groupName = \"ClassicTeam Visitors\"; grp = await sp.web.siteGroups.getByName(groupName)(); // update a group await sp.web.siteGroups.getById(groupID).update({\"Title\": \"New Group Title\"}); // delete a group from the site using group id await sp.web.siteGroups.removeById(groupID); // delete a group from the site using group name await sp.web.siteGroups.removeByLoginName(groupName);","title":"Getting and updating the groups of a sharepoint web"},{"location":"sp/site-groups/#getting-all-users-of-a-group","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get all users of group const groupID = 7; const users = await sp.web.siteGroups.getById(groupID).users();","title":"Getting all users of a group"},{"location":"sp/site-groups/#updating-the-owner-of-a-site-group","text":"Unfortunately for now setting the owner of a group as another or same SharePoint group is currently unsupported in REST. Setting the owner as a user is supported. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // Update the owner with a user id await sp.web.siteGroups.getById(7).setUserAsOwner(4);","title":"Updating the owner of a site group"},{"location":"sp/site-scripts/","text":"@pnp/sp/site-scripts \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Create a new site script \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const sitescriptContent = { \"$schema\": \"schema.json\", \"actions\": [ { \"themeName\": \"Theme Name 123\", \"verb\": \"applyTheme\", }, ], \"bindata\": {}, \"version\": 1, }; const siteScript = await sp.siteScripts.createSiteScript(\"Title\", \"description\", sitescriptContent); console.log(siteScript.Title); Retrieval \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Retrieving all site scripts const allSiteScripts = await sp.siteScripts.getSiteScripts(); console.log(allSiteScripts.length > 0 ? allSiteScripts[0].Title : \"\"); // Retrieving a single site script by Id const siteScript = await sp.siteScripts.getSiteScriptMetadata(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"); console.log(siteScript.Title); Update and delete \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Update const updatedSiteScript = await sp.siteScripts.updateSiteScript({ Id: \"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\", Title: \"New Title\" }); console.log(updatedSiteScript.Title); // Delete await sp.siteScripts.deleteSiteScript(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"); Get site script from a list \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Using the absolute URL of the list const ss = await sp.siteScripts.getSiteScriptFromList(\"https://TENANT.sharepoint.com/Lists/mylist\"); // Using the PnPjs web object to fetch the site script from a specific list const ss2 = await sp.web.lists.getByTitle(\"mylist\").getSiteScript(); Get site script from a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const extractInfo = { IncludeBranding: true, IncludeLinksToExportedItems: true, IncludeRegionalSettings: true, IncludeSiteExternalSharingCapability: true, IncludeTheme: true, IncludedLists: [\"Lists/MyList\"] }; const ss = await sp.siteScripts.getSiteScriptFromWeb(\"https://TENANT.sharepoint.com/sites/mysite\", extractInfo); // Using the PnPjs web object to fetch the site script from a specific web const ss2 = await sp.web.getSiteScript(extractInfo); Execute Site Script Action \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const ss = await sp.siteScripts.executeSiteScriptAction(siteScript); Execute site script for a specific web \u00b6 import { sp } from \"@pnp/sp\"; import { SiteScripts } \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const scriptService = SiteScripts(\"https://absolute/url/to/web\"); const ss = await scriptService.executeSiteScriptAction(siteScript);","title":"Site Scripts"},{"location":"sp/site-scripts/#pnpspsite-scripts","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/site-scripts"},{"location":"sp/site-scripts/#create-a-new-site-script","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const sitescriptContent = { \"$schema\": \"schema.json\", \"actions\": [ { \"themeName\": \"Theme Name 123\", \"verb\": \"applyTheme\", }, ], \"bindata\": {}, \"version\": 1, }; const siteScript = await sp.siteScripts.createSiteScript(\"Title\", \"description\", sitescriptContent); console.log(siteScript.Title);","title":"Create a new site script"},{"location":"sp/site-scripts/#retrieval","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Retrieving all site scripts const allSiteScripts = await sp.siteScripts.getSiteScripts(); console.log(allSiteScripts.length > 0 ? allSiteScripts[0].Title : \"\"); // Retrieving a single site script by Id const siteScript = await sp.siteScripts.getSiteScriptMetadata(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"); console.log(siteScript.Title);","title":"Retrieval"},{"location":"sp/site-scripts/#update-and-delete","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Update const updatedSiteScript = await sp.siteScripts.updateSiteScript({ Id: \"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\", Title: \"New Title\" }); console.log(updatedSiteScript.Title); // Delete await sp.siteScripts.deleteSiteScript(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\");","title":"Update and delete"},{"location":"sp/site-scripts/#get-site-script-from-a-list","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Using the absolute URL of the list const ss = await sp.siteScripts.getSiteScriptFromList(\"https://TENANT.sharepoint.com/Lists/mylist\"); // Using the PnPjs web object to fetch the site script from a specific list const ss2 = await sp.web.lists.getByTitle(\"mylist\").getSiteScript();","title":"Get site script from a list"},{"location":"sp/site-scripts/#get-site-script-from-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const extractInfo = { IncludeBranding: true, IncludeLinksToExportedItems: true, IncludeRegionalSettings: true, IncludeSiteExternalSharingCapability: true, IncludeTheme: true, IncludedLists: [\"Lists/MyList\"] }; const ss = await sp.siteScripts.getSiteScriptFromWeb(\"https://TENANT.sharepoint.com/sites/mysite\", extractInfo); // Using the PnPjs web object to fetch the site script from a specific web const ss2 = await sp.web.getSiteScript(extractInfo);","title":"Get site script from a web"},{"location":"sp/site-scripts/#execute-site-script-action","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const ss = await sp.siteScripts.executeSiteScriptAction(siteScript);","title":"Execute Site Script Action"},{"location":"sp/site-scripts/#execute-site-script-for-a-specific-web","text":"import { sp } from \"@pnp/sp\"; import { SiteScripts } \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const scriptService = SiteScripts(\"https://absolute/url/to/web\"); const ss = await scriptService.executeSiteScriptAction(siteScript);","title":"Execute site script for a specific web"},{"location":"sp/site-users/","text":"@pnp/sp/site-users \u00b6 The site users module provides methods to manage users for a sharepoint site. ISiteUsers \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers } from \"@pnp/sp/presets/all\"; Get all site user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const users = await sp.web.siteUsers(); Get Current user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let user = await sp.web.currentUser(); Get user by id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const id = 6; user = await sp.web.getUserById(id); Ensure user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const username = \"usernames@microsoft.com\"; result = await sp.web.ensureUser(username); ISiteUser \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers, SiteUser } from \"@pnp/sp/presets/all\"; Get user Groups \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let groups = await sp.web.currentUser.groups(); Add user to Site collection \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const user = await sp.web.ensureUser(\"userLoginname\") const users = await sp.web.siteUsers; await users.add(user.data.LoginName); Get user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // get user object by id const user = await sp.web.siteUsers.getById(6); //get user object by Email const user = await sp.web.siteUsers.getByEmail(\"user@mail.com\"); //get user object by LoginName const user = await sp.web.siteUsers.getByLoginName(\"userLoginName\"); Update user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let userProps = await sp.web.currentUser(); userProps.Title = \"New title\"; await sp.web.currentUser.update(userProps); Remove user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // remove user by id await sp.web.siteUsers.removeById(6); // remove user by LoginName await sp.web.siteUsers.removeByLoginName(6); ISiteUserProps \u00b6 User properties: Property Name Type Description Email string Contains Site user email Id Number Contains Site user Id IsHiddenInUI Boolean Site user IsHiddenInUI IsShareByEmailGuestUser boolean Site user is external user IsSiteAdmin Boolean Describes if Site user Is Site Admin LoginName string Site user LoginName PrincipalType number Site user Principal type Title string Site user Title interface ISiteUserProps { /** * Contains Site user email * */ Email: string; /** * Contains Site user Id * */ Id: number; /** * Site user IsHiddenInUI * */ IsHiddenInUI: boolean; /** * Site user IsShareByEmailGuestUser * */ IsShareByEmailGuestUser: boolean; /** * Describes if Site user Is Site Admin * */ IsSiteAdmin: boolean; /** * Site user LoginName * */ LoginName: string; /** * Site user Principal type * */ PrincipalType: number | PrincipalType; /** * Site user Title * */ Title: string; }","title":"Site Users"},{"location":"sp/site-users/#pnpspsite-users","text":"The site users module provides methods to manage users for a sharepoint site.","title":"@pnp/sp/site-users"},{"location":"sp/site-users/#isiteusers","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers } from \"@pnp/sp/presets/all\";","title":"ISiteUsers"},{"location":"sp/site-users/#get-all-site-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const users = await sp.web.siteUsers();","title":"Get all site user"},{"location":"sp/site-users/#get-current-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let user = await sp.web.currentUser();","title":"Get Current user"},{"location":"sp/site-users/#get-user-by-id","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const id = 6; user = await sp.web.getUserById(id);","title":"Get user by id"},{"location":"sp/site-users/#ensure-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const username = \"usernames@microsoft.com\"; result = await sp.web.ensureUser(username);","title":"Ensure user"},{"location":"sp/site-users/#isiteuser","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers, SiteUser } from \"@pnp/sp/presets/all\";","title":"ISiteUser"},{"location":"sp/site-users/#get-user-groups","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let groups = await sp.web.currentUser.groups();","title":"Get user Groups"},{"location":"sp/site-users/#add-user-to-site-collection","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const user = await sp.web.ensureUser(\"userLoginname\") const users = await sp.web.siteUsers; await users.add(user.data.LoginName);","title":"Add user to Site collection"},{"location":"sp/site-users/#get-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // get user object by id const user = await sp.web.siteUsers.getById(6); //get user object by Email const user = await sp.web.siteUsers.getByEmail(\"user@mail.com\"); //get user object by LoginName const user = await sp.web.siteUsers.getByLoginName(\"userLoginName\");","title":"Get user"},{"location":"sp/site-users/#update-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let userProps = await sp.web.currentUser(); userProps.Title = \"New title\"; await sp.web.currentUser.update(userProps);","title":"Update user"},{"location":"sp/site-users/#remove-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // remove user by id await sp.web.siteUsers.removeById(6); // remove user by LoginName await sp.web.siteUsers.removeByLoginName(6);","title":"Remove user"},{"location":"sp/site-users/#isiteuserprops","text":"User properties: Property Name Type Description Email string Contains Site user email Id Number Contains Site user Id IsHiddenInUI Boolean Site user IsHiddenInUI IsShareByEmailGuestUser boolean Site user is external user IsSiteAdmin Boolean Describes if Site user Is Site Admin LoginName string Site user LoginName PrincipalType number Site user Principal type Title string Site user Title interface ISiteUserProps { /** * Contains Site user email * */ Email: string; /** * Contains Site user Id * */ Id: number; /** * Site user IsHiddenInUI * */ IsHiddenInUI: boolean; /** * Site user IsShareByEmailGuestUser * */ IsShareByEmailGuestUser: boolean; /** * Describes if Site user Is Site Admin * */ IsSiteAdmin: boolean; /** * Site user LoginName * */ LoginName: string; /** * Site user Principal type * */ PrincipalType: number | PrincipalType; /** * Site user Title * */ Title: string; }","title":"ISiteUserProps"},{"location":"sp/sites/","text":"@pnp/sp/site - Site properties \u00b6 Site collection are one of the fundamental entry points while working with SharePoint. Sites serve as container for webs, lists, features and other entity types. Get context information for the current site collection \u00b6 Using the library, you can get the context information of the current site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IContextInfo } from \"@pnp/sp/sites\"; const oContext: IContextInfo = await sp.site.getContextInfo(); console.log(oContext.FormDigestValue); Get document libraries of a web \u00b6 Using the library, you can get a list of the document libraries present in the a given web. Note: Works only in SharePoint online import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IDocumentLibraryInformation } from \"@pnp/sp/sites\"; const docLibs: IDocumentLibraryInformation[] = await sp.site.getDocumentLibraries(\"https://tenant.sharepoint.com/sites/test/subsite\"); //we got the array of document library information docLibs.forEach((docLib: IDocumentLibraryInformation) => { // do something with each library }); Open Web By Id \u00b6 Because this method is a POST request you can chain off it directly. You will get back the full web properties in the data property of the return object. You can also chain directly off the returned Web instance on the web property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const w = await sp.site.openWebById(\"111ca453-90f5-482e-a381-cee1ff383c9e\"); //we got all the data from the web as well console.log(w.data); // we can chain const w2 = await w.web.select(\"Title\")(); Get site collection url from page \u00b6 Using the library, you can get the site collection url by providing a page url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const d: string = await sp.site.getWebUrlFromPageUrl(\"https://tenant.sharepoint.com/sites/test/Pages/test.aspx\"); console.log(d); //https://tenant.sharepoint.com/sites/test Access the root web \u00b6 There are two methods to access the root web. The first, using the rootWeb property, is best for directly accessing information about that web. If you want to chain multiple operations off of the web, better to use the getRootWeb method that will ensure the web instance is created using its own Url vs. \"_api/sites/rootweb\" which does not work for all operations. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; // use for rootweb information access const rootwebData = await sp.site.rootWeb(); // use for chaining const rootweb = await sp.site.getRootWeb(); const listData = await rootWeb.lists.getByTitle(\"MyList\")(); Create a modern communication site \u00b6 Note: Works only in SharePoint online Creates a modern communication site. Property Type Required Description Title string yes The title of the site to create. lcid number yes The default language to use for the site. shareByEmailEnabled boolean yes If set to true, it will enable sharing files via Email. By default it is set to false url string yes The fully qualified URL (e.g. https://yourtenant.sharepoint.com/sites/mysitecollection ) of the site. description string no The description of the communication site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc hubSiteId string no The Guid of the already existing Hub site Owner string no Required when using app-only context. Owner principal name e.g. user@tenant.onmicrosoft.com import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createCommunicationSite( \"Title\", 1033, true, \"https://tenant.sharepoint.com/sites/commSite\", \"Description\", \"HBI\", \"f6cc5403-0d63-442e-96c0-285923709ffc\", \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"user@TENANT.onmicrosoft.com\"); Create from Props \u00b6 You may need to supply additional parameters such as WebTemplate, to do so please use the createCommunicationSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createCommunicationSiteFromProps({ Owner: \"patrick@three18studios.com\", Title: \"A Test Site\", Url: \"https://{tenant}.sharepoint.com/sites/commsite2\", WebTemplate: \"STS#3\", }); Create a modern team site \u00b6 Note: Works only in SharePoint online. It wont work with App only tokens Creates a modern team site backed by O365 group. Property Type Required Description displayName string yes The title/displayName of the site to be created. alias string yes Alias of the underlying Office 365 Group. isPublic boolean yes Defines whether the Office 365 Group will be public (default), or private. lcid number yes The language to use for the site. If not specified will default to English (1033). description string no The description of the modern team site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information owners string array (string[]) no The Owners of the site to be created hubSiteId string no The Guid of the already existing Hub site siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createModernTeamSite( \"displayName\", \"alias\", true, 1033, \"description\", \"HBI\", [\"user1@tenant.onmicrosoft.com\",\"user2@tenant.onmicrosoft.com\",\"user3@tenant.onmicrosoft.com\"], \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"f6cc5403-0d63-442e-96c0-285923709ffc\" ); console.log(d); Create from Props \u00b6 You may need to supply additional parameters, to do so please use the createModernTeamSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createModernTeamSiteFromProps({ alias: \"JenniferGarner\", displayName: \"A Test Site\", owners: [\"patrick@three18studios.com\"], }); Delete a site collection \u00b6 Using the library, you can delete a specific site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { Site } from \"@pnp/sp/sites\"; // Delete the current site await sp.site.delete(); // Specify which site to delete const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const site2 = Site(siteUrl); await site2.delete(); Check if a Site Collection Exists \u00b6 Using the library, you can check if a specific site collection exist or not on your tenant import { sp } from \"@pnp/sp\"; // Specify which site to verify const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const exists = sp.site.exists(siteUrl); console.log(exists);","title":"Sites"},{"location":"sp/sites/#pnpspsite-site-properties","text":"Site collection are one of the fundamental entry points while working with SharePoint. Sites serve as container for webs, lists, features and other entity types.","title":"@pnp/sp/site - Site properties"},{"location":"sp/sites/#get-context-information-for-the-current-site-collection","text":"Using the library, you can get the context information of the current site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IContextInfo } from \"@pnp/sp/sites\"; const oContext: IContextInfo = await sp.site.getContextInfo(); console.log(oContext.FormDigestValue);","title":"Get context information for the current site collection"},{"location":"sp/sites/#get-document-libraries-of-a-web","text":"Using the library, you can get a list of the document libraries present in the a given web. Note: Works only in SharePoint online import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IDocumentLibraryInformation } from \"@pnp/sp/sites\"; const docLibs: IDocumentLibraryInformation[] = await sp.site.getDocumentLibraries(\"https://tenant.sharepoint.com/sites/test/subsite\"); //we got the array of document library information docLibs.forEach((docLib: IDocumentLibraryInformation) => { // do something with each library });","title":"Get document libraries of a web"},{"location":"sp/sites/#open-web-by-id","text":"Because this method is a POST request you can chain off it directly. You will get back the full web properties in the data property of the return object. You can also chain directly off the returned Web instance on the web property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const w = await sp.site.openWebById(\"111ca453-90f5-482e-a381-cee1ff383c9e\"); //we got all the data from the web as well console.log(w.data); // we can chain const w2 = await w.web.select(\"Title\")();","title":"Open Web By Id"},{"location":"sp/sites/#get-site-collection-url-from-page","text":"Using the library, you can get the site collection url by providing a page url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const d: string = await sp.site.getWebUrlFromPageUrl(\"https://tenant.sharepoint.com/sites/test/Pages/test.aspx\"); console.log(d); //https://tenant.sharepoint.com/sites/test","title":"Get site collection url from page"},{"location":"sp/sites/#access-the-root-web","text":"There are two methods to access the root web. The first, using the rootWeb property, is best for directly accessing information about that web. If you want to chain multiple operations off of the web, better to use the getRootWeb method that will ensure the web instance is created using its own Url vs. \"_api/sites/rootweb\" which does not work for all operations. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; // use for rootweb information access const rootwebData = await sp.site.rootWeb(); // use for chaining const rootweb = await sp.site.getRootWeb(); const listData = await rootWeb.lists.getByTitle(\"MyList\")();","title":"Access the root web"},{"location":"sp/sites/#create-a-modern-communication-site","text":"Note: Works only in SharePoint online Creates a modern communication site. Property Type Required Description Title string yes The title of the site to create. lcid number yes The default language to use for the site. shareByEmailEnabled boolean yes If set to true, it will enable sharing files via Email. By default it is set to false url string yes The fully qualified URL (e.g. https://yourtenant.sharepoint.com/sites/mysitecollection ) of the site. description string no The description of the communication site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc hubSiteId string no The Guid of the already existing Hub site Owner string no Required when using app-only context. Owner principal name e.g. user@tenant.onmicrosoft.com import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createCommunicationSite( \"Title\", 1033, true, \"https://tenant.sharepoint.com/sites/commSite\", \"Description\", \"HBI\", \"f6cc5403-0d63-442e-96c0-285923709ffc\", \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"user@TENANT.onmicrosoft.com\");","title":"Create a modern communication site"},{"location":"sp/sites/#create-from-props","text":"You may need to supply additional parameters such as WebTemplate, to do so please use the createCommunicationSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createCommunicationSiteFromProps({ Owner: \"patrick@three18studios.com\", Title: \"A Test Site\", Url: \"https://{tenant}.sharepoint.com/sites/commsite2\", WebTemplate: \"STS#3\", });","title":"Create from Props"},{"location":"sp/sites/#create-a-modern-team-site","text":"Note: Works only in SharePoint online. It wont work with App only tokens Creates a modern team site backed by O365 group. Property Type Required Description displayName string yes The title/displayName of the site to be created. alias string yes Alias of the underlying Office 365 Group. isPublic boolean yes Defines whether the Office 365 Group will be public (default), or private. lcid number yes The language to use for the site. If not specified will default to English (1033). description string no The description of the modern team site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information owners string array (string[]) no The Owners of the site to be created hubSiteId string no The Guid of the already existing Hub site siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createModernTeamSite( \"displayName\", \"alias\", true, 1033, \"description\", \"HBI\", [\"user1@tenant.onmicrosoft.com\",\"user2@tenant.onmicrosoft.com\",\"user3@tenant.onmicrosoft.com\"], \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"f6cc5403-0d63-442e-96c0-285923709ffc\" ); console.log(d);","title":"Create a modern team site"},{"location":"sp/sites/#create-from-props_1","text":"You may need to supply additional parameters, to do so please use the createModernTeamSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createModernTeamSiteFromProps({ alias: \"JenniferGarner\", displayName: \"A Test Site\", owners: [\"patrick@three18studios.com\"], });","title":"Create from Props"},{"location":"sp/sites/#delete-a-site-collection","text":"Using the library, you can delete a specific site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { Site } from \"@pnp/sp/sites\"; // Delete the current site await sp.site.delete(); // Specify which site to delete const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const site2 = Site(siteUrl); await site2.delete();","title":"Delete a site collection"},{"location":"sp/sites/#check-if-a-site-collection-exists","text":"Using the library, you can check if a specific site collection exist or not on your tenant import { sp } from \"@pnp/sp\"; // Specify which site to verify const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const exists = sp.site.exists(siteUrl); console.log(exists);","title":"Check if a Site Collection Exists"},{"location":"sp/social/","text":"@pnp/sp/ - social \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; The social API allows you to track followed sites, people, and docs. Note, many of these methods only work with the context of a logged in user, and not with app-only permissions. getFollowedSitesUri \u00b6 Gets a URI to a site that lists the current user's followed sites. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedSitesUri(); getFollowedDocumentsUri \u00b6 Gets a URI to a site that lists the current user's followed documents. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedDocumentsUri(); follow \u00b6 Makes the current user start following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // follow a site const r1 = await sp.social.follow({ ActorType: SocialActorType.Site, ContentUri: \"htts://tenant.sharepoint.com/sites/site\", }); // follow a person const r2 = await sp.social.follow({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); // follow a doc const r3 = await sp.social.follow({ ActorType: SocialActorType.Document, ContentUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/Test.aspx\", }); // follow a tag // You need the tag GUID to start following a tag. // You can't get the GUID by using the REST service, but you can use the .NET client object model or the JavaScript object model. // See How to get a tag's GUID based on the tag's name by using the JavaScript object model. // https://docs.microsoft.com/en-us/sharepoint/dev/general-development/follow-content-in-sharepoint#bk_getTagGuid const r4 = await sp.social.follow({ ActorType: SocialActorType.Tag, TagGuid: \"19a4a484-c1dc-4bc5-8c93-bb96245ce928\", }); isFollowed \u00b6 Indicates whether the current user is following a specified user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.isFollowed({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); stopFollowing \u00b6 Makes the current user stop following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.stopFollowing({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); my \u00b6 get \u00b6 Gets this user's social information import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const r = await sp.social.my(); followed \u00b6 Gets users, documents, sites, and tags that the current user is following based on the supplied flags. import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get all the followed documents const r1 = await sp.social.my.followed(SocialActorTypes.Document); // get all the followed documents and sites const r2 = await sp.social.my.followed(SocialActorTypes.Document | SocialActorTypes.Site); // get all the followed sites updated in the last 24 hours const r3 = await sp.social.my.followed(SocialActorTypes.Site | SocialActorTypes.WithinLast24Hours); followedCount \u00b6 Works as followed but returns on the count of actors specified by the query import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followedCount(SocialActorTypes.Document); followers \u00b6 Gets the users who are following the current user. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followers(); suggestions \u00b6 Gets users who the current user might want to follow. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.suggestions();","title":"Social"},{"location":"sp/social/#pnpsp-social","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; The social API allows you to track followed sites, people, and docs. Note, many of these methods only work with the context of a logged in user, and not with app-only permissions.","title":"@pnp/sp/ - social"},{"location":"sp/social/#getfollowedsitesuri","text":"Gets a URI to a site that lists the current user's followed sites. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedSitesUri();","title":"getFollowedSitesUri"},{"location":"sp/social/#getfolloweddocumentsuri","text":"Gets a URI to a site that lists the current user's followed documents. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedDocumentsUri();","title":"getFollowedDocumentsUri"},{"location":"sp/social/#follow","text":"Makes the current user start following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // follow a site const r1 = await sp.social.follow({ ActorType: SocialActorType.Site, ContentUri: \"htts://tenant.sharepoint.com/sites/site\", }); // follow a person const r2 = await sp.social.follow({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); // follow a doc const r3 = await sp.social.follow({ ActorType: SocialActorType.Document, ContentUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/Test.aspx\", }); // follow a tag // You need the tag GUID to start following a tag. // You can't get the GUID by using the REST service, but you can use the .NET client object model or the JavaScript object model. // See How to get a tag's GUID based on the tag's name by using the JavaScript object model. // https://docs.microsoft.com/en-us/sharepoint/dev/general-development/follow-content-in-sharepoint#bk_getTagGuid const r4 = await sp.social.follow({ ActorType: SocialActorType.Tag, TagGuid: \"19a4a484-c1dc-4bc5-8c93-bb96245ce928\", });","title":"follow"},{"location":"sp/social/#isfollowed","text":"Indicates whether the current user is following a specified user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.isFollowed({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, });","title":"isFollowed"},{"location":"sp/social/#stopfollowing","text":"Makes the current user stop following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.stopFollowing({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, });","title":"stopFollowing"},{"location":"sp/social/#my","text":"","title":"my"},{"location":"sp/social/#get","text":"Gets this user's social information import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const r = await sp.social.my();","title":"get"},{"location":"sp/social/#followed","text":"Gets users, documents, sites, and tags that the current user is following based on the supplied flags. import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get all the followed documents const r1 = await sp.social.my.followed(SocialActorTypes.Document); // get all the followed documents and sites const r2 = await sp.social.my.followed(SocialActorTypes.Document | SocialActorTypes.Site); // get all the followed sites updated in the last 24 hours const r3 = await sp.social.my.followed(SocialActorTypes.Site | SocialActorTypes.WithinLast24Hours);","title":"followed"},{"location":"sp/social/#followedcount","text":"Works as followed but returns on the count of actors specified by the query import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followedCount(SocialActorTypes.Document);","title":"followedCount"},{"location":"sp/social/#followers","text":"Gets the users who are following the current user. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followers();","title":"followers"},{"location":"sp/social/#suggestions","text":"Gets users who the current user might want to follow. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.suggestions();","title":"suggestions"},{"location":"sp/sp-utilities-utility/","text":"@pnp/sp/utilities \u00b6 Through the REST api you are able to call a subset of the SP.Utilities.Utility methods. We have explicitly defined some of these methods and provided a method to call any others in a generic manner. These methods are exposed on pnp.sp.utility and support batching and caching. sendEmail \u00b6 This methods allows you to send an email based on the supplied arguments. The method takes a single argument, a plain object defined by the EmailProperties interface (shown below). EmailProperties \u00b6 export interface EmailProperties { To: string[]; CC?: string[]; BCC?: string[]; Subject: string; Body: string; AdditionalHeaders?: TypedHash<string>; From?: string; } Usage \u00b6 You must define the To, Subject, and Body values - the remaining are optional. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { IEmailProperties } from \"@pnp/sp/sputilities\"; const emailProps: IEmailProperties = { To: [\"user@site.com\"], CC: [\"user2@site.com\", \"user3@site.com\"], BCC: [\"user4@site.com\", \"user5@site.com\"], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" } }; await sp.utility.sendEmail(emailProps); console.log(\"Email Sent!\"); getCurrentUserEmailAddresses \u00b6 This method returns the current user's email addresses known to SharePoint. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let addressString: string = await sp.utility.getCurrentUserEmailAddresses(); // and use it with sendEmail await sp.utility.sendEmail({ To: [addressString], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" }, }); resolvePrincipal \u00b6 Gets information about a principal that matches the specified Search criteria import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principal : IPrincipalInfo = await sp.utility.resolvePrincipal(\"user@site.com\", PrincipalType.User, PrincipalSource.All, true, false, true); console.log(principal); searchPrincipals \u00b6 Gets information about the principals that match the specified Search criteria. import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.searchPrincipals(\"john\", PrincipalType.User, PrincipalSource.All,\"\", 10); console.log(principals); createEmailBodyForInvitation \u00b6 Gets the external (outside the firewall) URL to a document or resource in a site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let url : string = await sp.utility.createEmailBodyForInvitation(\"https://contoso.sharepoint.com/sites/dev/SitePages/DevHome.aspx\"); console.log(url); expandGroupsToPrincipals \u00b6 Resolves the principals contained within the supplied groups import { sp, IPrincipalInfo } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"]); console.log(principals); // optionally supply a max results count. Default is 30. let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"], 10); console.log(principals); createWikiPage \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { ICreateWikiPageResult } from \"@pnp/sp/sputilities\"; let newPage : ICreateWikiPageResult = await sp.utility.createWikiPage({ ServerRelativeUrl: \"/sites/dev/SitePages/mynewpage.aspx\", WikiHtmlContent: \"This is my <b>page</b> content. It supports rich html.\", }); // newPage contains the raw data returned by the service console.log(newPage.data); // newPage contains a File instance you can use to further update the new page let file = await newPage.file(); console.log(file);","title":"SP.Utilities.Utility"},{"location":"sp/sp-utilities-utility/#pnpsputilities","text":"Through the REST api you are able to call a subset of the SP.Utilities.Utility methods. We have explicitly defined some of these methods and provided a method to call any others in a generic manner. These methods are exposed on pnp.sp.utility and support batching and caching.","title":"@pnp/sp/utilities"},{"location":"sp/sp-utilities-utility/#sendemail","text":"This methods allows you to send an email based on the supplied arguments. The method takes a single argument, a plain object defined by the EmailProperties interface (shown below).","title":"sendEmail"},{"location":"sp/sp-utilities-utility/#emailproperties","text":"export interface EmailProperties { To: string[]; CC?: string[]; BCC?: string[]; Subject: string; Body: string; AdditionalHeaders?: TypedHash<string>; From?: string; }","title":"EmailProperties"},{"location":"sp/sp-utilities-utility/#usage","text":"You must define the To, Subject, and Body values - the remaining are optional. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { IEmailProperties } from \"@pnp/sp/sputilities\"; const emailProps: IEmailProperties = { To: [\"user@site.com\"], CC: [\"user2@site.com\", \"user3@site.com\"], BCC: [\"user4@site.com\", \"user5@site.com\"], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" } }; await sp.utility.sendEmail(emailProps); console.log(\"Email Sent!\");","title":"Usage"},{"location":"sp/sp-utilities-utility/#getcurrentuseremailaddresses","text":"This method returns the current user's email addresses known to SharePoint. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let addressString: string = await sp.utility.getCurrentUserEmailAddresses(); // and use it with sendEmail await sp.utility.sendEmail({ To: [addressString], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" }, });","title":"getCurrentUserEmailAddresses"},{"location":"sp/sp-utilities-utility/#resolveprincipal","text":"Gets information about a principal that matches the specified Search criteria import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principal : IPrincipalInfo = await sp.utility.resolvePrincipal(\"user@site.com\", PrincipalType.User, PrincipalSource.All, true, false, true); console.log(principal);","title":"resolvePrincipal"},{"location":"sp/sp-utilities-utility/#searchprincipals","text":"Gets information about the principals that match the specified Search criteria. import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.searchPrincipals(\"john\", PrincipalType.User, PrincipalSource.All,\"\", 10); console.log(principals);","title":"searchPrincipals"},{"location":"sp/sp-utilities-utility/#createemailbodyforinvitation","text":"Gets the external (outside the firewall) URL to a document or resource in a site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let url : string = await sp.utility.createEmailBodyForInvitation(\"https://contoso.sharepoint.com/sites/dev/SitePages/DevHome.aspx\"); console.log(url);","title":"createEmailBodyForInvitation"},{"location":"sp/sp-utilities-utility/#expandgroupstoprincipals","text":"Resolves the principals contained within the supplied groups import { sp, IPrincipalInfo } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"]); console.log(principals); // optionally supply a max results count. Default is 30. let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"], 10); console.log(principals);","title":"expandGroupsToPrincipals"},{"location":"sp/sp-utilities-utility/#createwikipage","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { ICreateWikiPageResult } from \"@pnp/sp/sputilities\"; let newPage : ICreateWikiPageResult = await sp.utility.createWikiPage({ ServerRelativeUrl: \"/sites/dev/SitePages/mynewpage.aspx\", WikiHtmlContent: \"This is my <b>page</b> content. It supports rich html.\", }); // newPage contains the raw data returned by the service console.log(newPage.data); // newPage contains a File instance you can use to further update the new page let file = await newPage.file(); console.log(file);","title":"createWikiPage"},{"location":"sp/subscriptions/","text":"@pnp/sp/subscriptions \u00b6 Webhooks on a SharePoint list are used to notify any change in the list, to other applications using a push model. This module provides methods to add, update or delete webhooks on a particular SharePoint list or library. ISubscriptions \u00b6 Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import {sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/presets/all\"; Add a webhook \u00b6 Using this library, you can add a webhook to a specified list within the SharePoint site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\"; // This is the URL which will be called by SharePoint when there is a change in the list const notificationUrl = \"<notification-url>\"; // Set the expiry date to 180 days from now, which is the maximum allowed for the webhook expiry date. const expiryDate = dateAdd(new Date(), \"day\" , 180).toISOString(); // Adds a webhook to the Documents library var res = await sp.web.lists.getByTitle(\"Documents\").subscriptions.add(notificationUrl,expiryDate); Get all webhooks added to a list \u00b6 Read all the webhooks' details which are associated to the list import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; const res = await sp.web.lists.getByTitle(\"Documents\").subscriptions(); ISubscription \u00b6 This interface provides the methods for managing a particular webhook. Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import { sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription } from \"@pnp/sp/presets/all\"; Managing a webhook \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; // Get details of a webhook based on its ID const webhookId = \"1f029e5c-16e4-4941-b46f-67895118763f\"; const webhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId)(); // Update a webhook const newDate = dateAdd(new Date(), \"day\" , 150).toISOString(); const updatedWebhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).update(newDate); // Delete a webhook await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).delete();","title":"Subscriptions"},{"location":"sp/subscriptions/#pnpspsubscriptions","text":"Webhooks on a SharePoint list are used to notify any change in the list, to other applications using a push model. This module provides methods to add, update or delete webhooks on a particular SharePoint list or library.","title":"@pnp/sp/subscriptions"},{"location":"sp/subscriptions/#isubscriptions","text":"Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import {sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/presets/all\";","title":"ISubscriptions"},{"location":"sp/subscriptions/#add-a-webhook","text":"Using this library, you can add a webhook to a specified list within the SharePoint site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\"; // This is the URL which will be called by SharePoint when there is a change in the list const notificationUrl = \"<notification-url>\"; // Set the expiry date to 180 days from now, which is the maximum allowed for the webhook expiry date. const expiryDate = dateAdd(new Date(), \"day\" , 180).toISOString(); // Adds a webhook to the Documents library var res = await sp.web.lists.getByTitle(\"Documents\").subscriptions.add(notificationUrl,expiryDate);","title":"Add a webhook"},{"location":"sp/subscriptions/#get-all-webhooks-added-to-a-list","text":"Read all the webhooks' details which are associated to the list import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; const res = await sp.web.lists.getByTitle(\"Documents\").subscriptions();","title":"Get all webhooks added to a list"},{"location":"sp/subscriptions/#isubscription","text":"This interface provides the methods for managing a particular webhook. Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import { sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription } from \"@pnp/sp/presets/all\";","title":"ISubscription"},{"location":"sp/subscriptions/#managing-a-webhook","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; // Get details of a webhook based on its ID const webhookId = \"1f029e5c-16e4-4941-b46f-67895118763f\"; const webhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId)(); // Update a webhook const newDate = dateAdd(new Date(), \"day\" , 150).toISOString(); const updatedWebhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).update(newDate); // Delete a webhook await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).delete();","title":"Managing a webhook"},{"location":"sp/taxonomy/","text":"@pnp/sp/taxonomy \u00b6 Provides access to the v2.1 api term store Docs updated with v2.0.9 release as the underlying API changed. \u00b6 NOTE: This API may change so please be aware updates to the taxonomy module will not trigger a major version bump in PnPjs even if they are breaking. Once things stabalize this note will be removed. Term Store \u00b6 Access term store data from the root sp object as shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermStoreInfo } from \"@pnp/sp/taxonomy\"; // get term store data const info: ITermStoreInfo = await sp.termStore(); Term Groups \u00b6 Access term group information List \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups const info: ITermGroupInfo[] = await sp.termStore.groups(); Get By Id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups data const info: ITermGroupInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\")(); Term Sets \u00b6 Access term set information List \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get get set info const info: ITermSetInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets(); Get By Id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermSetInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\")(); getAllChildrenAsOrderedTree \u00b6 Added in 2.0.13 This method will get all of a set's child terms in an ordered array. It is a costly method in terms of requests so we suggest you cache the results as taxonomy trees seldom change. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; import { dateAdd, PnPClientStorage } from \"@pnp/core\"; // here we get all the children of a given set const childTree = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); // here we show caching the results using the PnPClientStorage class, there are many caching libraries and options available const store = new PnPClientStorage(); // our tree likely doesn't change much in 30 minutes for most applications // adjust to be longer or shorter as needed const cachedTree = await store.local.getOrPut(\"myKey\", () => { return sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); }, dateAdd(new Date(), \"minute\", 30)); Terms \u00b6 Access term set information List \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").children(); List (terms) \u00b6 Added in 2.0.13 You can use the terms property to get a flat list of all terms in the set. These terms do not contain parent/child relationship information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").terms(); Get By Id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getTermById(\"338666a8-1111-2222-3333-f72471314e72\")(); Get Term Parent \u00b6 Behavior Change in 2.1.0 The server API changed again, resulting in the removal of the \"parent\" property from ITerm as it is not longer supported as a path property. You now must use \"expand\" to load a term's parent information. The side affect of this is that the parent is no longer chainable, meaning you need to load a new term instance to work with the parent term. An approach for this is shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; // get a ref to the set const set = sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\"); // get a term's information and expand parent to get the parent info as well const w = await set.getTermById(\"338666a8-1111-2222-3333-f72471314e72\").expand(\"parent\")(); // get a ref to the parent term const parent = set.getTermById(w.parent.id); // make a request for the parent term's info - this data currently match the results in the expand call above, but this // is to demonstrate how to gain a ref to the parent and select its data const parentInfo = await parent.select(\"Id\", \"Descriptions\")();","title":"Taxonomy"},{"location":"sp/taxonomy/#pnpsptaxonomy","text":"Provides access to the v2.1 api term store","title":"@pnp/sp/taxonomy"},{"location":"sp/taxonomy/#docs-updated-with-v209-release-as-the-underlying-api-changed","text":"NOTE: This API may change so please be aware updates to the taxonomy module will not trigger a major version bump in PnPjs even if they are breaking. Once things stabalize this note will be removed.","title":"Docs updated with v2.0.9 release as the underlying API changed."},{"location":"sp/taxonomy/#term-store","text":"Access term store data from the root sp object as shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermStoreInfo } from \"@pnp/sp/taxonomy\"; // get term store data const info: ITermStoreInfo = await sp.termStore();","title":"Term Store"},{"location":"sp/taxonomy/#term-groups","text":"Access term group information","title":"Term Groups"},{"location":"sp/taxonomy/#list","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups const info: ITermGroupInfo[] = await sp.termStore.groups();","title":"List"},{"location":"sp/taxonomy/#get-by-id","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups data const info: ITermGroupInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\")();","title":"Get By Id"},{"location":"sp/taxonomy/#term-sets","text":"Access term set information","title":"Term Sets"},{"location":"sp/taxonomy/#list_1","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get get set info const info: ITermSetInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets();","title":"List"},{"location":"sp/taxonomy/#get-by-id_1","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermSetInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\")();","title":"Get By Id"},{"location":"sp/taxonomy/#getallchildrenasorderedtree","text":"Added in 2.0.13 This method will get all of a set's child terms in an ordered array. It is a costly method in terms of requests so we suggest you cache the results as taxonomy trees seldom change. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; import { dateAdd, PnPClientStorage } from \"@pnp/core\"; // here we get all the children of a given set const childTree = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); // here we show caching the results using the PnPClientStorage class, there are many caching libraries and options available const store = new PnPClientStorage(); // our tree likely doesn't change much in 30 minutes for most applications // adjust to be longer or shorter as needed const cachedTree = await store.local.getOrPut(\"myKey\", () => { return sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); }, dateAdd(new Date(), \"minute\", 30));","title":"getAllChildrenAsOrderedTree"},{"location":"sp/taxonomy/#terms","text":"Access term set information","title":"Terms"},{"location":"sp/taxonomy/#list_2","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").children();","title":"List"},{"location":"sp/taxonomy/#list-terms","text":"Added in 2.0.13 You can use the terms property to get a flat list of all terms in the set. These terms do not contain parent/child relationship information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").terms();","title":"List (terms)"},{"location":"sp/taxonomy/#get-by-id_2","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getTermById(\"338666a8-1111-2222-3333-f72471314e72\")();","title":"Get By Id"},{"location":"sp/taxonomy/#get-term-parent","text":"Behavior Change in 2.1.0 The server API changed again, resulting in the removal of the \"parent\" property from ITerm as it is not longer supported as a path property. You now must use \"expand\" to load a term's parent information. The side affect of this is that the parent is no longer chainable, meaning you need to load a new term instance to work with the parent term. An approach for this is shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; // get a ref to the set const set = sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\"); // get a term's information and expand parent to get the parent info as well const w = await set.getTermById(\"338666a8-1111-2222-3333-f72471314e72\").expand(\"parent\")(); // get a ref to the parent term const parent = set.getTermById(w.parent.id); // make a request for the parent term's info - this data currently match the results in the expand call above, but this // is to demonstrate how to gain a ref to the parent and select its data const parentInfo = await parent.select(\"Id\", \"Descriptions\")();","title":"Get Term Parent"},{"location":"sp/tenant-properties/","text":"@pnp/sp/web - tenant properties \u00b6 You can set, read, and remove tenant properties using the methods shown below: setStorageEntity \u00b6 This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); // specify required key and value await w.setStorageEntity(\"Test1\", \"Value 1\"); // specify optional description and comments await w.setStorageEntity(\"Test2\", \"Value 2\", \"description\", \"comments\"); getStorageEntity \u00b6 This method can be used from any web to retrieve values previously set. import { sp, IStorageEntity } from \"@pnp/sp/presets/all\"; const prop: IStorageEntity = await sp.web.getStorageEntity(\"Test1\"); console.log(prop.Value); removeStorageEntity \u00b6 This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); await w.removeStorageEntity(\"Test1\");","title":"Tenant Properties"},{"location":"sp/tenant-properties/#pnpspweb-tenant-properties","text":"You can set, read, and remove tenant properties using the methods shown below:","title":"@pnp/sp/web - tenant properties"},{"location":"sp/tenant-properties/#setstorageentity","text":"This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); // specify required key and value await w.setStorageEntity(\"Test1\", \"Value 1\"); // specify optional description and comments await w.setStorageEntity(\"Test2\", \"Value 2\", \"description\", \"comments\");","title":"setStorageEntity"},{"location":"sp/tenant-properties/#getstorageentity","text":"This method can be used from any web to retrieve values previously set. import { sp, IStorageEntity } from \"@pnp/sp/presets/all\"; const prop: IStorageEntity = await sp.web.getStorageEntity(\"Test1\"); console.log(prop.Value);","title":"getStorageEntity"},{"location":"sp/tenant-properties/#removestorageentity","text":"This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); await w.removeStorageEntity(\"Test1\");","title":"removeStorageEntity"},{"location":"sp/user-custom-actions/","text":"@pnp/sp/user-custom-actions \u00b6 Represents a custom action associated with a SharePoint list, web or site collection. IUserCustomActions \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IUserCustomActions, IUserCustomAction } from \"@pnp/sp/user-custom-actions\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/user-custom-actions\"; Preset: All import { sp, IUserCustomActions, IUserCustomAction } from \"@pnp/sp/presents/all\"; Get a collection of User Custom Actions from a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const userCustomActions = sp.web.userCustomActions(); Add a new User Custom Action \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionAddResult } from '@pnp/sp/user-custom-actions'; const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"Location\": \"ScriptLink\", \"ScriptSrc\": \"https://...\" }; const response : IUserCustomActionAddResult = await sp.web.userCustomActions.add(newValues); Get a User Custom Action by ID \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const uca: IUserCustomAction = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const ucaData = await uca(); Clear the User Custom Action collection \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; // Site collection level await sp.site.userCustomActions.clear(); // Site (web) level await sp.web.userCustomActions.clear(); // List level await sp.web.lists.getByTitle(\"Documents\").userCustomActions.clear(); IUserCustomAction \u00b6 Update an existing User Custom Action \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionUpdateResult } from '@pnp/sp/user-custom-actions'; const uca = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"ScriptSrc\": \"https://...\" }; const response: IUserCustomActionUpdateResult = uca.update(newValues);","title":"User custom actions"},{"location":"sp/user-custom-actions/#pnpspuser-custom-actions","text":"Represents a custom action associated with a SharePoint list, web or site collection.","title":"@pnp/sp/user-custom-actions"},{"location":"sp/user-custom-actions/#iusercustomactions","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IUserCustomActions, IUserCustomAction } from \"@pnp/sp/user-custom-actions\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/user-custom-actions\"; Preset: All import { sp, IUserCustomActions, IUserCustomAction } from \"@pnp/sp/presents/all\";","title":"IUserCustomActions"},{"location":"sp/user-custom-actions/#get-a-collection-of-user-custom-actions-from-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const userCustomActions = sp.web.userCustomActions();","title":"Get a collection of User Custom Actions from a web"},{"location":"sp/user-custom-actions/#add-a-new-user-custom-action","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionAddResult } from '@pnp/sp/user-custom-actions'; const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"Location\": \"ScriptLink\", \"ScriptSrc\": \"https://...\" }; const response : IUserCustomActionAddResult = await sp.web.userCustomActions.add(newValues);","title":"Add a new User Custom Action"},{"location":"sp/user-custom-actions/#get-a-user-custom-action-by-id","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const uca: IUserCustomAction = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const ucaData = await uca();","title":"Get a User Custom Action by ID"},{"location":"sp/user-custom-actions/#clear-the-user-custom-action-collection","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; // Site collection level await sp.site.userCustomActions.clear(); // Site (web) level await sp.web.userCustomActions.clear(); // List level await sp.web.lists.getByTitle(\"Documents\").userCustomActions.clear();","title":"Clear the User Custom Action collection"},{"location":"sp/user-custom-actions/#iusercustomaction","text":"","title":"IUserCustomAction"},{"location":"sp/user-custom-actions/#update-an-existing-user-custom-action","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionUpdateResult } from '@pnp/sp/user-custom-actions'; const uca = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"ScriptSrc\": \"https://...\" }; const response: IUserCustomActionUpdateResult = uca.update(newValues);","title":"Update an existing User Custom Action"},{"location":"sp/views/","text":"@pnp/sp/views \u00b6 Views define the columns, ordering, and other details we see when we look at a list. You can have multiple views for a list, including private views - and one default view. IViews \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Views, IViews } from \"@pnp/sp/views\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/views\"; Preset: All import { sp, Views, IViews } from \"@pnp/sp/presets/all\"; Get views in a list \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // get all the views and their properties const views1 = await list.views(); // you can use odata select operations to get just a set a fields const views2 = await list.views.select(\"Id\", \"Title\")(); // get the top three views const views3 = await list.views.top(3)(); Add a View \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // create a new view with default fields and properties const result = await list.views.add(\"My New View\"); // create a new view with specific properties const result2 = await list.views.add(\"My New View 2\", false, { RowLimit: 10, ViewQuery: \"<OrderBy><FieldRef Name='Modified' Ascending='False' /></OrderBy>\", }); // manipulate the view's fields await result2.view.fields.removeAll(); await Promise.all([ result2.view.fields.add(\"Title\"), result2.view.fields.add(\"Modified\"), ]); IView \u00b6 Get a View's Information \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\")(); const result2 = await list.views.getByTitle(\"My View\")(); const result3 = await list.views.getByTitle(\"My View\").select(\"Id\", \"Title\")(); const result4 = await list.defaultView(); const result5 = await list.getView(\"{GUID view id}\")(); fields \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").fields(); update \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").update({ RowLimit: 20, }); renderAsHtml \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const result = await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").renderAsHtml(); setViewXml \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").setViewXml(viewXml); delete \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").delete(); ViewFields \u00b6 getSchemaXml \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const xml = await sp.web.lists.getByTitle(\"My List\").defaultView.fields.getSchemaXml(); add \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.add(\"Created\"); move \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.move(\"Created\", 0); remove \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.remove(\"Created\"); removeAll \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.removeAll();","title":"Views"},{"location":"sp/views/#pnpspviews","text":"Views define the columns, ordering, and other details we see when we look at a list. You can have multiple views for a list, including private views - and one default view.","title":"@pnp/sp/views"},{"location":"sp/views/#iviews","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Views, IViews } from \"@pnp/sp/views\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/views\"; Preset: All import { sp, Views, IViews } from \"@pnp/sp/presets/all\";","title":"IViews"},{"location":"sp/views/#get-views-in-a-list","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // get all the views and their properties const views1 = await list.views(); // you can use odata select operations to get just a set a fields const views2 = await list.views.select(\"Id\", \"Title\")(); // get the top three views const views3 = await list.views.top(3)();","title":"Get views in a list"},{"location":"sp/views/#add-a-view","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // create a new view with default fields and properties const result = await list.views.add(\"My New View\"); // create a new view with specific properties const result2 = await list.views.add(\"My New View 2\", false, { RowLimit: 10, ViewQuery: \"<OrderBy><FieldRef Name='Modified' Ascending='False' /></OrderBy>\", }); // manipulate the view's fields await result2.view.fields.removeAll(); await Promise.all([ result2.view.fields.add(\"Title\"), result2.view.fields.add(\"Modified\"), ]);","title":"Add a View"},{"location":"sp/views/#iview","text":"","title":"IView"},{"location":"sp/views/#get-a-views-information","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\")(); const result2 = await list.views.getByTitle(\"My View\")(); const result3 = await list.views.getByTitle(\"My View\").select(\"Id\", \"Title\")(); const result4 = await list.defaultView(); const result5 = await list.getView(\"{GUID view id}\")();","title":"Get a View's Information"},{"location":"sp/views/#fields","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").fields();","title":"fields"},{"location":"sp/views/#update","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").update({ RowLimit: 20, });","title":"update"},{"location":"sp/views/#renderashtml","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const result = await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").renderAsHtml();","title":"renderAsHtml"},{"location":"sp/views/#setviewxml","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").setViewXml(viewXml);","title":"setViewXml"},{"location":"sp/views/#delete","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").delete();","title":"delete"},{"location":"sp/views/#viewfields","text":"","title":"ViewFields"},{"location":"sp/views/#getschemaxml","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const xml = await sp.web.lists.getByTitle(\"My List\").defaultView.fields.getSchemaXml();","title":"getSchemaXml"},{"location":"sp/views/#add","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.add(\"Created\");","title":"add"},{"location":"sp/views/#move","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.move(\"Created\", 0);","title":"move"},{"location":"sp/views/#remove","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.remove(\"Created\");","title":"remove"},{"location":"sp/views/#removeall","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.removeAll();","title":"removeAll"},{"location":"sp/webs/","text":"@pnp/sp/webs \u00b6 Webs are one of the fundamental entry points when working with SharePoint. Webs serve as a container for lists, features, sub-webs, and all of the entity types. IWebs \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Webs, IWebs } from \"@pnp/sp/presets/core\"; Add Web \u00b6 Using the library you can add a web to another web's collection of subwebs. The simplest usage requires only a title and url. This will result in a team site with all of the default settings. You can also provide other settings such as description, template, language, and inherit permissions. import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; const result = await sp.web.webs.add(\"title\", \"subweb1\"); // show the response from the server when adding the web console.log(result.data); // we can immediately operate on the new web result.web.select(\"Title\")().then((w: IWebAddResult) => { // show our title console.log(w.Title); }); import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; // create a German language wiki site with title, url, description, which does not inherit permissions sp.web.webs.add(\"wiki\", \"subweb2\", \"a wiki web\", \"WIKI#0\", 1031, false).then((w: IWebAddResult) => { // ... }); IWeb \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Web, IWeb } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Web, IWeb } from \"@pnp/sp/presets/core\"; Access a Web \u00b6 There are several ways to access a web instance, each of these methods is equivalent in that you will have an IWeb instance to work with. All of the examples below use a variable named \"web\" which represents an IWeb instance - regardless of how it was initially accessed. Access the web from the imported \"sp\" object using selective import: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'all' preset import { sp } from \"@pnp/sp/presets/all\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'core' preset import { sp } from \"@pnp/sp/presets/core\"; const r = await sp.web(); Create a web instance using the factory function import { Web } from \"@pnp/sp/webs\"; const web = Web(\"https://something.sharepoint.com/sites/dev\"); const r = await web(); webs \u00b6 Access the child webs collection of this web const webs = web.webs(); Get A Web's properties \u00b6 // basic get of the webs properties const props = await web(); // use odata operators to get specific fields const props2 = await web.select(\"Title\")(); // type the result to match what you are requesting const props3 = await web.select(\"Title\")<{ Title: string }>(); getParentWeb \u00b6 Get the data and IWeb instance for the parent web for the given web instance import { IOpenWebByIdResult } from \"@pnp/sp/sites\"; const web: IOpenWebByIdResult = web.getParentWeb(); getSubwebsFilteredForCurrentUser \u00b6 Returns a collection of objects that contain metadata about subsites of the current site in which the current user is a member. const subWebs = await web.getSubwebsFilteredForCurrentUser()(); // apply odata operations to the collection const subWebs2 = await sp.web.getSubwebsFilteredForCurrentUser().select(\"Title\", \"Language\").orderBy(\"Created\", true)(); Note: getSubwebsFilteredForCurrentUser returns IWebInfosData which is a subset of all the available fields on IWebInfo. allProperties \u00b6 Allows access to the web's all properties collection. This is readonly in REST. const props = await web.allProperties(); // select certain props const props2 = await web.allProperties.select(\"prop1\", \"prop2\")(); webinfos \u00b6 Gets a collection of WebInfos for this web's subwebs const infos = await web.webinfos(); // or select certain fields const infos2 = await web.webinfos.select(\"Title\", \"Description\")(); // or filter const infos3 = await web.webinfos.filter(\"Title eq 'MyWebTitle'\")(); // or both const infos4 = await web.webinfos.select(\"Title\", \"Description\").filter(\"Title eq 'MyWebTitle'\")(); // get the top 4 ordered by Title const infos5 = await web.webinfos.top(4).orderBy(\"Title\")(); Note: webinfos returns IWebInfosData which is a subset of all the available fields on IWebInfo. update \u00b6 Updates this web instance with the supplied properties // update the web's title and description const result = await web.update({ Title: \"New Title\", Description: \"My new description\", }); // a project implementation could wrap the update to provide type information for your expected fields: import { IWebUpdateResult } from \"@pnp/sp/webs\"; interface IWebUpdateProps { Title: string; Description: string; } function updateWeb(props: IWebUpdateProps): Promise<IWebUpdateResult> { web.update(props); } Delete a Web \u00b6 await web.delete(); applyTheme \u00b6 Applies the theme specified by the contents of each of the files specified in the arguments to the site import { combine } from \"@pnp/core\"; // we are going to apply the theme to this sub web as an example const web = Web(\"https://{tenant}.sharepoint.com/sites/dev/subweb\"); // the urls to the color and font need to both be from the catalog at the root // these urls can be constants or calculated from existing urls const colorUrl = combine(\"/\", \"sites/dev\", \"_catalogs/theme/15/palette011.spcolor\"); // this gives us the same result const fontUrl = \"/sites/dev/_catalogs/theme/15/fontscheme007.spfont\"; // apply the font and color, no background image, and don't share this theme await web.applyTheme(colorUrl, fontUrl, \"\", false); applyWebTemplate & availableWebTemplates \u00b6 Applies the specified site definition or site template to the Web site that has no template applied to it. This is seldom used outside provisioning scenarios. const templates = (await web.availableWebTemplates().select(\"Name\")<{ Name: string }[]>()).filter(t => /ENTERWIKI#0/i.test(t.Name)); // apply the wiki template const template = templates.length > 0 ? templates[0].Name : \"STS#0\"; await web.applyWebTemplate(template); getChanges \u00b6 Returns the collection of changes from the change log that have occurred within the web, based on the specified query. // get the web changes including add, update, and delete const changes = await web.getChanges({ Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Update: true, Web: true, }); mapToIcon \u00b6 Returns the name of the image file for the icon that is used to represent the specified file import { combine } from \"@pnp/core\"; const iconFileName = await web.mapToIcon(\"test.docx\"); // iconPath === \"icdocx.png\" // which you can need to map to a real url const iconFullPath = `https://{tenant}.sharepoint.com/sites/dev/_layouts/images/${iconFileName}`; // OR dynamically const webData = await sp.web.select(\"Url\")(); const iconFullPath2 = combine(webData.Url, \"_layouts\", \"images\", iconFileName); // OR within SPFx using the context const iconFullPath3 = combine(this.context.pageContext.web.absoluteUrl, \"_layouts\", \"images\", iconFileName); // You can also set size // 16x16 pixels = 0, 32x32 pixels = 1 const icon32FileName = await web.mapToIcon(\"test.docx\", 1); storage entities \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import { IStorageEntity } from \"@pnp/sp/webs\"; // needs to be unique, GUIDs are great const key = \"my-storage-key\"; // read an existing entity const entity: IStorageEntity = await web.getStorageEntity(key); // setStorageEntity and removeStorageEntity must be called in the context of the tenant app catalog site // you can get the tenant app catalog using the getTenantAppCatalogWeb const tenantAppCatalogWeb = await sp.getTenantAppCatalogWeb(); tenantAppCatalogWeb.setStorageEntity(key, \"new value\"); // set other properties tenantAppCatalogWeb.setStorageEntity(key, \"another value\", \"description\", \"comments\"); const entity2: IStorageEntity = await web.getStorageEntity(key); /* entity2 === { Value: \"another value\", Comment: \"comments\"; Description: \"description\", }; */ // you can also remove a storage entity await tenantAppCatalogWeb.removeStorageEntity(key); appcatalog imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/appcatalog\"; Selective 2 import \"@pnp/sp/appcatalog/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; getAppCatalog \u00b6 Returns this web as an IAppCatalog instance or creates a new IAppCatalog instance from the provided url. import { IApp } from \"@pnp/sp/appcatalog\"; const appWeb = web.getAppCatalog(); // appWeb url === web url const app: IApp = appWeb.getAppById(\"{your app id}\"); const appWeb2 = web.getAppCatalog(\"https://tenant.sharepoing.com/sites/someappcatalog\"); // appWeb2 url === \"https://tenant.sharepoing.com/sites/someappcatalog\" client-side-pages imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/client-side-pages\"; Selective 2 import \"@pnp/sp/client-side-pages/web\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; You can create and load clientside page instances directly from a web. More details on working with clientside pages are available in the dedicated article. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // simplest add a page example const page = await sp.web.addClientsidePage(\"mypage1\"); // simplest load a page example const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); content-type imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; contentTypes \u00b6 Allows access to the collection of content types in this web. const cts = await web.contentTypes(); // you can also select fields and use other odata operators const cts2 = await web.contentTypes.select(\"Name\")(); features imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/features\"; Selective 2 import \"@pnp/sp/features/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; features \u00b6 Allows access to the collection of content types in this web. const features = await web.features(); fields imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; fields \u00b6 Allows access to the collection of fields in this web. const fields = await web.fields(); files imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/files\"; Selective 2 import \"@pnp/sp/files/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; getFileByServerRelativeUrl \u00b6 Gets a file by server relative url import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativeUrl(\"/sites/dev/library/myfile.docx\"); getFileByServerRelativePath \u00b6 Gets a file by server relative url if your file name contains # and % characters import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativePath(\"/sites/dev/library/my # file%.docx\"); folders imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; folders \u00b6 Gets the collection of folders in this web const folders = await web.folders(); // you can also filter and select as with any collection const folders2 = await web.folders.select(\"ServerRelativeUrl\", \"TimeLastModified\").filter(\"ItemCount gt 0\")(); // or get the most recently modified folder const folders2 = await web.folders.orderBy(\"TimeLastModified\").top(1)(); rootFolder \u00b6 Gets the root folder of the web const folder = await web.rootFolder(); getFolderByServerRelativeUrl \u00b6 Gets a folder by server relative url import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativeUrl(\"/sites/dev/library\"); getFolderByServerRelativePath \u00b6 Gets a folder by server relative url if your folder name contains # and % characters import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativePath(\"/sites/dev/library/my # folder%/\"); hubsites imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/hubsites\"; Selective 2 import \"@pnp/sp/hubsites/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; hubSiteData \u00b6 Gets hub site data for the current web import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; // get the data and force a refresh const data: IHubSiteWebData = await web.hubSiteData(true); syncHubSiteTheme \u00b6 Applies theme updates from the parent hub site collection await web.syncHubSiteTheme(); lists imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/lists\"; Selective 2 import \"@pnp/sp/lists/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\"; lists \u00b6 Gets the collection of all lists that are contained in the Web site import { ILists } from \"@pnp/sp/lists\"; const lists: ILists = web.lists; // you can always order the lists and select properties const data = await lists.select(\"Title\").orderBy(\"Title\")(); // and use other odata operators as well const data2 = await web.lists.top(3).orderBy(\"LastItemModifiedDate\")(); siteUserInfoList \u00b6 Gets the UserInfo list of the site collection that contains the Web site import { IList } from \"@pnp/sp/lists\"; const list: IList = web.siteUserInfoList; const data = await list(); // or chain off that list to get additional details const items = await list.items.top(2)(); defaultDocumentLibrary \u00b6 Get a reference the default documents library of a web import { IList } from \"@pnp/sp/lists\"; const list: IList = web.defaultDocumentLibrary; customListTemplates \u00b6 Gets the collection of all list definitions and list templates that are available import { IList } from \"@pnp/sp/lists\"; const templates = await web.customListTemplates(); // odata operators chain off the collection as expected const templates2 = await web.customListTemplates.select(\"Title\")(); getList \u00b6 Gets a list by server relative url (list's root folder) import { IList } from \"@pnp/sp/lists\"; const list: IList = web.getList(\"/sites/dev/lists/test\"); const listData = list(); getCatalog \u00b6 Returns the list gallery on the site Name Value WebTemplateCatalog 111 WebPartCatalog 113 ListTemplateCatalog 114 MasterPageCatalog 116 SolutionCatalog 121 ThemeCatalog 123 DesignCatalog 124 AppDataCatalog 125 import { IList } from \"@pnp/sp/lists\"; const templateCatalog: IList = await web.getCatalog(111); const themeCatalog: IList = await web.getCatalog(123); navigation imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/navigation\"; Selective 2 import \"@pnp/sp/navigation/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; navigation \u00b6 Gets a navigation object that represents navigation on the Web site, including the Quick Launch area and the top navigation bar import { INavigation } from \"@pnp/sp/navigation\"; const nav: INavigation = web.navigation; const navData = await nav(); regional-settings imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/regional-settings\"; Selective 2 import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRegionalSettings } from \"@pnp/sp/navigation\"; const settings: IRegionalSettings = web.regionalSettings; const settingsData = await settings(); related-items imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/related-items\"; Selective 2 import \"@pnp/sp/related-items/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRelatedItemManager, IRelatedItem } from \"@pnp/sp/related-items\"; const manager: IRelatedItemManager = web.relatedItems; const data: IRelatedItem[] = await manager.getRelatedItems(\"{list name}\", 4); security imports \u00b6 Please see information around the available security methods in the security article . sharing imports \u00b6 Please see information around the available sharing methods in the sharing article . site-groups imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/site-groups\"; Selective 2 import \"@pnp/sp/site-groups/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; siteGroups \u00b6 The site groups const groups = await web.siteGroups(); const groups2 = await web.siteGroups.top(2)(); associatedOwnerGroup \u00b6 The web's owner group const group = await web.associatedOwnerGroup(); const users = await web.associatedOwnerGroup.users(); associatedMemberGroup \u00b6 The web's member group const group = await web.associatedMemberGroup(); const users = await web.associatedMemberGroup.users(); associatedVisitorGroup \u00b6 The web's visitor group const group = await web.associatedVisitorGroup(); const users = await web.associatedVisitorGroup.users(); createDefaultAssociatedGroups \u00b6 Creates the default associated groups (Members, Owners, Visitors) and gives them the default permissions on the site. The target site must have unique permissions and no associated members / owners / visitors groups await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\"); // copy the role assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", true); // don't clear sub assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, false); // specify secondary owner, don't copy permissions, clear sub scopes await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, true, \"{second owner login}\"); site-users imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/site-users\"; Selective 2 import \"@pnp/sp/site-users/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; siteUsers \u00b6 The site users const users = await web.siteUsers(); const users2 = await web.siteUsers.top(5)(); const users3 = await web.siteUsers.filter(`startswith(LoginName, '${encodeURIComponent(\"i:0#.f|m\")}')`)(); currentUser \u00b6 Information on the current user const user = await web.currentUser(); // check the login name of the current user const user2 = await web.currentUser.select(\"LoginName\")(); ensureUser \u00b6 Checks whether the specified login name belongs to a valid user in the web. If the user doesn't exist, adds the user to the web import { IWebEnsureUserResult } from \"@pnp/sp/site-users/\"; const result: IWebEnsureUserResult = await web.ensureUser(\"i:0#.f|membership|user@domain.onmicrosoft.com\"); getUserById \u00b6 Returns the user corresponding to the specified member identifier for the current web import { ISiteUser } from \"@pnp/sp/site-users/\"; const user: ISiteUser = web.getUserById(23); const userData = await user(); const userData2 = await user.select(\"LoginName\")(); user-custom-actions imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; userCustomActions \u00b6 Gets a newly refreshed collection of the SPWeb's SPUserCustomActionCollection import { IUserCustomActions } from \"@pnp/sp/user-custom-actions\"; const actions: IUserCustomActions = web.userCustomActions; const actionsData = await actions(); IWebInfosData \u00b6 Some web operations return a subset of web information defined by the IWebInfosData interface, shown below. In those cases only these fields are available for select, orderby, and other odata operations. interface IWebInfosData { Configuration: number; Created: string; Description: string; Id: string; Language: number; LastItemModifiedDate: string; LastItemUserModifiedDate: string; ServerRelativeUrl: string; Title: string; WebTemplate: string; WebTemplateId: number; }","title":"Webs"},{"location":"sp/webs/#pnpspwebs","text":"Webs are one of the fundamental entry points when working with SharePoint. Webs serve as a container for lists, features, sub-webs, and all of the entity types.","title":"@pnp/sp/webs"},{"location":"sp/webs/#iwebs","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Webs, IWebs } from \"@pnp/sp/presets/core\";","title":"IWebs"},{"location":"sp/webs/#add-web","text":"Using the library you can add a web to another web's collection of subwebs. The simplest usage requires only a title and url. This will result in a team site with all of the default settings. You can also provide other settings such as description, template, language, and inherit permissions. import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; const result = await sp.web.webs.add(\"title\", \"subweb1\"); // show the response from the server when adding the web console.log(result.data); // we can immediately operate on the new web result.web.select(\"Title\")().then((w: IWebAddResult) => { // show our title console.log(w.Title); }); import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; // create a German language wiki site with title, url, description, which does not inherit permissions sp.web.webs.add(\"wiki\", \"subweb2\", \"a wiki web\", \"WIKI#0\", 1031, false).then((w: IWebAddResult) => { // ... });","title":"Add Web"},{"location":"sp/webs/#iweb","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Web, IWeb } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Web, IWeb } from \"@pnp/sp/presets/core\";","title":"IWeb"},{"location":"sp/webs/#access-a-web","text":"There are several ways to access a web instance, each of these methods is equivalent in that you will have an IWeb instance to work with. All of the examples below use a variable named \"web\" which represents an IWeb instance - regardless of how it was initially accessed. Access the web from the imported \"sp\" object using selective import: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'all' preset import { sp } from \"@pnp/sp/presets/all\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'core' preset import { sp } from \"@pnp/sp/presets/core\"; const r = await sp.web(); Create a web instance using the factory function import { Web } from \"@pnp/sp/webs\"; const web = Web(\"https://something.sharepoint.com/sites/dev\"); const r = await web();","title":"Access a Web"},{"location":"sp/webs/#webs","text":"Access the child webs collection of this web const webs = web.webs();","title":"webs"},{"location":"sp/webs/#get-a-webs-properties","text":"// basic get of the webs properties const props = await web(); // use odata operators to get specific fields const props2 = await web.select(\"Title\")(); // type the result to match what you are requesting const props3 = await web.select(\"Title\")<{ Title: string }>();","title":"Get A Web's properties"},{"location":"sp/webs/#getparentweb","text":"Get the data and IWeb instance for the parent web for the given web instance import { IOpenWebByIdResult } from \"@pnp/sp/sites\"; const web: IOpenWebByIdResult = web.getParentWeb();","title":"getParentWeb"},{"location":"sp/webs/#getsubwebsfilteredforcurrentuser","text":"Returns a collection of objects that contain metadata about subsites of the current site in which the current user is a member. const subWebs = await web.getSubwebsFilteredForCurrentUser()(); // apply odata operations to the collection const subWebs2 = await sp.web.getSubwebsFilteredForCurrentUser().select(\"Title\", \"Language\").orderBy(\"Created\", true)(); Note: getSubwebsFilteredForCurrentUser returns IWebInfosData which is a subset of all the available fields on IWebInfo.","title":"getSubwebsFilteredForCurrentUser"},{"location":"sp/webs/#allproperties","text":"Allows access to the web's all properties collection. This is readonly in REST. const props = await web.allProperties(); // select certain props const props2 = await web.allProperties.select(\"prop1\", \"prop2\")();","title":"allProperties"},{"location":"sp/webs/#webinfos","text":"Gets a collection of WebInfos for this web's subwebs const infos = await web.webinfos(); // or select certain fields const infos2 = await web.webinfos.select(\"Title\", \"Description\")(); // or filter const infos3 = await web.webinfos.filter(\"Title eq 'MyWebTitle'\")(); // or both const infos4 = await web.webinfos.select(\"Title\", \"Description\").filter(\"Title eq 'MyWebTitle'\")(); // get the top 4 ordered by Title const infos5 = await web.webinfos.top(4).orderBy(\"Title\")(); Note: webinfos returns IWebInfosData which is a subset of all the available fields on IWebInfo.","title":"webinfos"},{"location":"sp/webs/#update","text":"Updates this web instance with the supplied properties // update the web's title and description const result = await web.update({ Title: \"New Title\", Description: \"My new description\", }); // a project implementation could wrap the update to provide type information for your expected fields: import { IWebUpdateResult } from \"@pnp/sp/webs\"; interface IWebUpdateProps { Title: string; Description: string; } function updateWeb(props: IWebUpdateProps): Promise<IWebUpdateResult> { web.update(props); }","title":"update"},{"location":"sp/webs/#delete-a-web","text":"await web.delete();","title":"Delete a Web"},{"location":"sp/webs/#applytheme","text":"Applies the theme specified by the contents of each of the files specified in the arguments to the site import { combine } from \"@pnp/core\"; // we are going to apply the theme to this sub web as an example const web = Web(\"https://{tenant}.sharepoint.com/sites/dev/subweb\"); // the urls to the color and font need to both be from the catalog at the root // these urls can be constants or calculated from existing urls const colorUrl = combine(\"/\", \"sites/dev\", \"_catalogs/theme/15/palette011.spcolor\"); // this gives us the same result const fontUrl = \"/sites/dev/_catalogs/theme/15/fontscheme007.spfont\"; // apply the font and color, no background image, and don't share this theme await web.applyTheme(colorUrl, fontUrl, \"\", false);","title":"applyTheme"},{"location":"sp/webs/#applywebtemplate-availablewebtemplates","text":"Applies the specified site definition or site template to the Web site that has no template applied to it. This is seldom used outside provisioning scenarios. const templates = (await web.availableWebTemplates().select(\"Name\")<{ Name: string }[]>()).filter(t => /ENTERWIKI#0/i.test(t.Name)); // apply the wiki template const template = templates.length > 0 ? templates[0].Name : \"STS#0\"; await web.applyWebTemplate(template);","title":"applyWebTemplate &amp; availableWebTemplates"},{"location":"sp/webs/#getchanges","text":"Returns the collection of changes from the change log that have occurred within the web, based on the specified query. // get the web changes including add, update, and delete const changes = await web.getChanges({ Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Update: true, Web: true, });","title":"getChanges"},{"location":"sp/webs/#maptoicon","text":"Returns the name of the image file for the icon that is used to represent the specified file import { combine } from \"@pnp/core\"; const iconFileName = await web.mapToIcon(\"test.docx\"); // iconPath === \"icdocx.png\" // which you can need to map to a real url const iconFullPath = `https://{tenant}.sharepoint.com/sites/dev/_layouts/images/${iconFileName}`; // OR dynamically const webData = await sp.web.select(\"Url\")(); const iconFullPath2 = combine(webData.Url, \"_layouts\", \"images\", iconFileName); // OR within SPFx using the context const iconFullPath3 = combine(this.context.pageContext.web.absoluteUrl, \"_layouts\", \"images\", iconFileName); // You can also set size // 16x16 pixels = 0, 32x32 pixels = 1 const icon32FileName = await web.mapToIcon(\"test.docx\", 1);","title":"mapToIcon"},{"location":"sp/webs/#storage-entities","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import { IStorageEntity } from \"@pnp/sp/webs\"; // needs to be unique, GUIDs are great const key = \"my-storage-key\"; // read an existing entity const entity: IStorageEntity = await web.getStorageEntity(key); // setStorageEntity and removeStorageEntity must be called in the context of the tenant app catalog site // you can get the tenant app catalog using the getTenantAppCatalogWeb const tenantAppCatalogWeb = await sp.getTenantAppCatalogWeb(); tenantAppCatalogWeb.setStorageEntity(key, \"new value\"); // set other properties tenantAppCatalogWeb.setStorageEntity(key, \"another value\", \"description\", \"comments\"); const entity2: IStorageEntity = await web.getStorageEntity(key); /* entity2 === { Value: \"another value\", Comment: \"comments\"; Description: \"description\", }; */ // you can also remove a storage entity await tenantAppCatalogWeb.removeStorageEntity(key);","title":"storage entities"},{"location":"sp/webs/#appcatalog-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/appcatalog\"; Selective 2 import \"@pnp/sp/appcatalog/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"appcatalog imports"},{"location":"sp/webs/#getappcatalog","text":"Returns this web as an IAppCatalog instance or creates a new IAppCatalog instance from the provided url. import { IApp } from \"@pnp/sp/appcatalog\"; const appWeb = web.getAppCatalog(); // appWeb url === web url const app: IApp = appWeb.getAppById(\"{your app id}\"); const appWeb2 = web.getAppCatalog(\"https://tenant.sharepoing.com/sites/someappcatalog\"); // appWeb2 url === \"https://tenant.sharepoing.com/sites/someappcatalog\"","title":"getAppCatalog"},{"location":"sp/webs/#client-side-pages-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/client-side-pages\"; Selective 2 import \"@pnp/sp/client-side-pages/web\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; You can create and load clientside page instances directly from a web. More details on working with clientside pages are available in the dedicated article. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // simplest add a page example const page = await sp.web.addClientsidePage(\"mypage1\"); // simplest load a page example const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\");","title":"client-side-pages imports"},{"location":"sp/webs/#content-type-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"content-type imports"},{"location":"sp/webs/#contenttypes","text":"Allows access to the collection of content types in this web. const cts = await web.contentTypes(); // you can also select fields and use other odata operators const cts2 = await web.contentTypes.select(\"Name\")();","title":"contentTypes"},{"location":"sp/webs/#features-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/features\"; Selective 2 import \"@pnp/sp/features/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"features imports"},{"location":"sp/webs/#features","text":"Allows access to the collection of content types in this web. const features = await web.features();","title":"features"},{"location":"sp/webs/#fields-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"fields imports"},{"location":"sp/webs/#fields","text":"Allows access to the collection of fields in this web. const fields = await web.fields();","title":"fields"},{"location":"sp/webs/#files-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/files\"; Selective 2 import \"@pnp/sp/files/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"files imports"},{"location":"sp/webs/#getfilebyserverrelativeurl","text":"Gets a file by server relative url import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativeUrl(\"/sites/dev/library/myfile.docx\");","title":"getFileByServerRelativeUrl"},{"location":"sp/webs/#getfilebyserverrelativepath","text":"Gets a file by server relative url if your file name contains # and % characters import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativePath(\"/sites/dev/library/my # file%.docx\");","title":"getFileByServerRelativePath"},{"location":"sp/webs/#folders-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"folders imports"},{"location":"sp/webs/#folders","text":"Gets the collection of folders in this web const folders = await web.folders(); // you can also filter and select as with any collection const folders2 = await web.folders.select(\"ServerRelativeUrl\", \"TimeLastModified\").filter(\"ItemCount gt 0\")(); // or get the most recently modified folder const folders2 = await web.folders.orderBy(\"TimeLastModified\").top(1)();","title":"folders"},{"location":"sp/webs/#rootfolder","text":"Gets the root folder of the web const folder = await web.rootFolder();","title":"rootFolder"},{"location":"sp/webs/#getfolderbyserverrelativeurl","text":"Gets a folder by server relative url import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativeUrl(\"/sites/dev/library\");","title":"getFolderByServerRelativeUrl"},{"location":"sp/webs/#getfolderbyserverrelativepath","text":"Gets a folder by server relative url if your folder name contains # and % characters import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativePath(\"/sites/dev/library/my # folder%/\");","title":"getFolderByServerRelativePath"},{"location":"sp/webs/#hubsites-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/hubsites\"; Selective 2 import \"@pnp/sp/hubsites/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"hubsites imports"},{"location":"sp/webs/#hubsitedata","text":"Gets hub site data for the current web import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; // get the data and force a refresh const data: IHubSiteWebData = await web.hubSiteData(true);","title":"hubSiteData"},{"location":"sp/webs/#synchubsitetheme","text":"Applies theme updates from the parent hub site collection await web.syncHubSiteTheme();","title":"syncHubSiteTheme"},{"location":"sp/webs/#lists-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/lists\"; Selective 2 import \"@pnp/sp/lists/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\";","title":"lists imports"},{"location":"sp/webs/#lists","text":"Gets the collection of all lists that are contained in the Web site import { ILists } from \"@pnp/sp/lists\"; const lists: ILists = web.lists; // you can always order the lists and select properties const data = await lists.select(\"Title\").orderBy(\"Title\")(); // and use other odata operators as well const data2 = await web.lists.top(3).orderBy(\"LastItemModifiedDate\")();","title":"lists"},{"location":"sp/webs/#siteuserinfolist","text":"Gets the UserInfo list of the site collection that contains the Web site import { IList } from \"@pnp/sp/lists\"; const list: IList = web.siteUserInfoList; const data = await list(); // or chain off that list to get additional details const items = await list.items.top(2)();","title":"siteUserInfoList"},{"location":"sp/webs/#defaultdocumentlibrary","text":"Get a reference the default documents library of a web import { IList } from \"@pnp/sp/lists\"; const list: IList = web.defaultDocumentLibrary;","title":"defaultDocumentLibrary"},{"location":"sp/webs/#customlisttemplates","text":"Gets the collection of all list definitions and list templates that are available import { IList } from \"@pnp/sp/lists\"; const templates = await web.customListTemplates(); // odata operators chain off the collection as expected const templates2 = await web.customListTemplates.select(\"Title\")();","title":"customListTemplates"},{"location":"sp/webs/#getlist","text":"Gets a list by server relative url (list's root folder) import { IList } from \"@pnp/sp/lists\"; const list: IList = web.getList(\"/sites/dev/lists/test\"); const listData = list();","title":"getList"},{"location":"sp/webs/#getcatalog","text":"Returns the list gallery on the site Name Value WebTemplateCatalog 111 WebPartCatalog 113 ListTemplateCatalog 114 MasterPageCatalog 116 SolutionCatalog 121 ThemeCatalog 123 DesignCatalog 124 AppDataCatalog 125 import { IList } from \"@pnp/sp/lists\"; const templateCatalog: IList = await web.getCatalog(111); const themeCatalog: IList = await web.getCatalog(123);","title":"getCatalog"},{"location":"sp/webs/#navigation-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/navigation\"; Selective 2 import \"@pnp/sp/navigation/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"navigation imports"},{"location":"sp/webs/#navigation","text":"Gets a navigation object that represents navigation on the Web site, including the Quick Launch area and the top navigation bar import { INavigation } from \"@pnp/sp/navigation\"; const nav: INavigation = web.navigation; const navData = await nav();","title":"navigation"},{"location":"sp/webs/#regional-settings-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/regional-settings\"; Selective 2 import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRegionalSettings } from \"@pnp/sp/navigation\"; const settings: IRegionalSettings = web.regionalSettings; const settingsData = await settings();","title":"regional-settings imports"},{"location":"sp/webs/#related-items-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/related-items\"; Selective 2 import \"@pnp/sp/related-items/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRelatedItemManager, IRelatedItem } from \"@pnp/sp/related-items\"; const manager: IRelatedItemManager = web.relatedItems; const data: IRelatedItem[] = await manager.getRelatedItems(\"{list name}\", 4);","title":"related-items imports"},{"location":"sp/webs/#security-imports","text":"Please see information around the available security methods in the security article .","title":"security imports"},{"location":"sp/webs/#sharing-imports","text":"Please see information around the available sharing methods in the sharing article .","title":"sharing imports"},{"location":"sp/webs/#site-groups-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/site-groups\"; Selective 2 import \"@pnp/sp/site-groups/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"site-groups imports"},{"location":"sp/webs/#sitegroups","text":"The site groups const groups = await web.siteGroups(); const groups2 = await web.siteGroups.top(2)();","title":"siteGroups"},{"location":"sp/webs/#associatedownergroup","text":"The web's owner group const group = await web.associatedOwnerGroup(); const users = await web.associatedOwnerGroup.users();","title":"associatedOwnerGroup"},{"location":"sp/webs/#associatedmembergroup","text":"The web's member group const group = await web.associatedMemberGroup(); const users = await web.associatedMemberGroup.users();","title":"associatedMemberGroup"},{"location":"sp/webs/#associatedvisitorgroup","text":"The web's visitor group const group = await web.associatedVisitorGroup(); const users = await web.associatedVisitorGroup.users();","title":"associatedVisitorGroup"},{"location":"sp/webs/#createdefaultassociatedgroups","text":"Creates the default associated groups (Members, Owners, Visitors) and gives them the default permissions on the site. The target site must have unique permissions and no associated members / owners / visitors groups await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\"); // copy the role assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", true); // don't clear sub assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, false); // specify secondary owner, don't copy permissions, clear sub scopes await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, true, \"{second owner login}\");","title":"createDefaultAssociatedGroups"},{"location":"sp/webs/#site-users-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/site-users\"; Selective 2 import \"@pnp/sp/site-users/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"site-users imports"},{"location":"sp/webs/#siteusers","text":"The site users const users = await web.siteUsers(); const users2 = await web.siteUsers.top(5)(); const users3 = await web.siteUsers.filter(`startswith(LoginName, '${encodeURIComponent(\"i:0#.f|m\")}')`)();","title":"siteUsers"},{"location":"sp/webs/#currentuser","text":"Information on the current user const user = await web.currentUser(); // check the login name of the current user const user2 = await web.currentUser.select(\"LoginName\")();","title":"currentUser"},{"location":"sp/webs/#ensureuser","text":"Checks whether the specified login name belongs to a valid user in the web. If the user doesn't exist, adds the user to the web import { IWebEnsureUserResult } from \"@pnp/sp/site-users/\"; const result: IWebEnsureUserResult = await web.ensureUser(\"i:0#.f|membership|user@domain.onmicrosoft.com\");","title":"ensureUser"},{"location":"sp/webs/#getuserbyid","text":"Returns the user corresponding to the specified member identifier for the current web import { ISiteUser } from \"@pnp/sp/site-users/\"; const user: ISiteUser = web.getUserById(23); const userData = await user(); const userData2 = await user.select(\"LoginName\")();","title":"getUserById"},{"location":"sp/webs/#user-custom-actions-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"user-custom-actions imports"},{"location":"sp/webs/#usercustomactions","text":"Gets a newly refreshed collection of the SPWeb's SPUserCustomActionCollection import { IUserCustomActions } from \"@pnp/sp/user-custom-actions\"; const actions: IUserCustomActions = web.userCustomActions; const actionsData = await actions();","title":"userCustomActions"},{"location":"sp/webs/#iwebinfosdata","text":"Some web operations return a subset of web information defined by the IWebInfosData interface, shown below. In those cases only these fields are available for select, orderby, and other odata operations. interface IWebInfosData { Configuration: number; Created: string; Description: string; Id: string; Language: number; LastItemModifiedDate: string; LastItemUserModifiedDate: string; ServerRelativeUrl: string; Title: string; WebTemplate: string; WebTemplateId: number; }","title":"IWebInfosData"},{"location":"sp-addinhelpers/","text":"@pnp/sp-addinhelpers \u00b6 This module contains classes to allow use of the libraries within a SharePoint add-in. Getting Started \u00b6 Install the library and all dependencies, npm install @pnp/sp @pnp/sp-addinhelpers --save Now you can make requests to the host web from your add-in using the crossDomainWeb method. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4)); Library Topics \u00b6 SPRequestExecutorClient SPRestAddIn","title":"sp-addinhelpers"},{"location":"sp-addinhelpers/#pnpsp-addinhelpers","text":"This module contains classes to allow use of the libraries within a SharePoint add-in.","title":"@pnp/sp-addinhelpers"},{"location":"sp-addinhelpers/#getting-started","text":"Install the library and all dependencies, npm install @pnp/sp @pnp/sp-addinhelpers --save Now you can make requests to the host web from your add-in using the crossDomainWeb method. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4));","title":"Getting Started"},{"location":"sp-addinhelpers/#library-topics","text":"SPRequestExecutorClient SPRestAddIn","title":"Library Topics"},{"location":"sp-addinhelpers/sp-request-executor-client/","text":"@pnp/sp-addinhelpers/sprequestexecutorclient \u00b6 The SPRequestExecutorClient is an implementation of the HttpClientImpl interface that facilitates requests to SharePoint from an add-in. It relies on the SharePoint SP product libraries being present to allow use of the SP.RequestExecutor to make the request. Setup \u00b6 To use the client you need to set it using the fetch client factory using the setup method as shown below. This is only required when working within a SharePoint add-in web. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor sp.crossDomainWeb(addInWenUrl, hostWebUrl)().then(w => { console.log(JSON.stringify(w, null, 4)); });","title":"SPRequestExecutorClient"},{"location":"sp-addinhelpers/sp-request-executor-client/#pnpsp-addinhelperssprequestexecutorclient","text":"The SPRequestExecutorClient is an implementation of the HttpClientImpl interface that facilitates requests to SharePoint from an add-in. It relies on the SharePoint SP product libraries being present to allow use of the SP.RequestExecutor to make the request.","title":"@pnp/sp-addinhelpers/sprequestexecutorclient"},{"location":"sp-addinhelpers/sp-request-executor-client/#setup","text":"To use the client you need to set it using the fetch client factory using the setup method as shown below. This is only required when working within a SharePoint add-in web. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor sp.crossDomainWeb(addInWenUrl, hostWebUrl)().then(w => { console.log(JSON.stringify(w, null, 4)); });","title":"Setup"},{"location":"sp-addinhelpers/sp-rest-addin/","text":"@pnp/sp-addinhelpers/sprestaddin \u00b6 This class extends the sp export from @pnp/sp and adds in the methods required to make cross domain calls // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4));","title":"SPRestAddIn"},{"location":"sp-addinhelpers/sp-rest-addin/#pnpsp-addinhelperssprestaddin","text":"This class extends the sp export from @pnp/sp and adds in the methods required to make cross domain calls // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4));","title":"@pnp/sp-addinhelpers/sprestaddin"},{"location":"v2/","text":"PnPjs is a collection of fluent libraries for consuming SharePoint, Graph, and Office 365 REST APIs in a type-safe way. You can use it within SharePoint Framework, Nodejs, or any JavaScript project. This an open source initiative and we encourage contributions and constructive feedback from the community. Animation of the library in use, note intellisense help in building your queries General Guidance \u00b6 These articles provide general guidance for working with the libraries. If you are migrating from v1 please review the transition guide . Getting Started Authentication Get Started Contributing npm scripts Polyfills Packages \u00b6 Patterns and Practices client side libraries (PnPjs) are comprised of the packages listed below. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins Authentication \u00b6 We have a new section dedicated to helping you figure out the best way to handle authentication in your application, check it out! Issues, Questions, Ideas \u00b6 Please log an issue using our template as a guide. This will let us track your request and ensure we respond. We appreciate any constructive feedback, questions, ideas, or bug reports with our thanks for giving back to the project. Changelog \u00b6 Please review the CHANGELOG for release details on all library changes. Code of Conduct \u00b6 This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. \"Sharing is Caring\" \u00b6 Please use http://aka.ms/sppnp for the latest updates around the whole SharePoint Patterns and Practices (PnP) program . Disclaimer \u00b6 THIS CODE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.","title":"Index"},{"location":"v2/#general-guidance","text":"These articles provide general guidance for working with the libraries. If you are migrating from v1 please review the transition guide . Getting Started Authentication Get Started Contributing npm scripts Polyfills","title":"General Guidance"},{"location":"v2/#packages","text":"Patterns and Practices client side libraries (PnPjs) are comprised of the packages listed below. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins","title":"Packages"},{"location":"v2/#authentication","text":"We have a new section dedicated to helping you figure out the best way to handle authentication in your application, check it out!","title":"Authentication"},{"location":"v2/#issues-questions-ideas","text":"Please log an issue using our template as a guide. This will let us track your request and ensure we respond. We appreciate any constructive feedback, questions, ideas, or bug reports with our thanks for giving back to the project.","title":"Issues, Questions, Ideas"},{"location":"v2/#changelog","text":"Please review the CHANGELOG for release details on all library changes.","title":"Changelog"},{"location":"v2/#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Code of Conduct"},{"location":"v2/#sharing-is-caring","text":"Please use http://aka.ms/sppnp for the latest updates around the whole SharePoint Patterns and Practices (PnP) program .","title":"\"Sharing is Caring\""},{"location":"v2/#disclaimer","text":"THIS CODE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.","title":"Disclaimer"},{"location":"v2/SPFx-on-premises/","text":"Workaround for on-premises SPFx TypeScript Version (SharePoint 2016 or 2019) \u00b6 Note this article applies to version 1.4.1 SharePoint Framework projects targeting on-premises only. When using the Yeoman generator to create a SharePoint Framework 1.4.1 project targeting on-premises it installs TypeScript version 2.2.2 (SP2016) or 2.4.2/2.4.1 (SP2019). Unfortunately this library relies on 3.6.4 or later due to extensive use of default values for generic type parameters in the libraries. To work around this limitation you can follow the steps in this article. npm i npm i -g rimraf # used to remove the node_modules folder (much better/faster) Ensure that the @pnp/sp package is already installed npm i @pnp/sp Remove the package-lock.json file & node_modules rimraf node_modules folder and execute npm install Open package-lock.json from the root folder Search for \"typescript\" or similar with version 2.4.1 (SP2019) 2.2.2 (SP2016) Replace \"2.4.1\" or \"2.2.2\" with \"3.6.4\" Search for the next \"typescript\" occurrence and replace the block with: JSON \"typescript\": { \"version\": \"3.6.4\", \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-3.6.4.tgz\", \"integrity\": \"sha512-unoCll1+l+YK4i4F8f22TaNVPRHcD9PA3yCuZ8g5e0qGqlVlJ/8FSateOLLSagn+Yg5+ZwuPkL8LFUc0Jcvksg==\", \"dev\": true } Remove node_modules folder rimraf node_modules Run npm install Alternative using npm-force-resolutions \u00b6 Install resolutions package and TypeScript providing considered version explicitly: bash npm i -D npm-force-resolutions typescript@3.6.4 Add a resolution for TypeScript and preinstall script into package.json to a corresponding code blocks: JSON { \"scripts\": { \"preinstall\": \"npx npm-force-resolutions\" }, \"resolutions\": { \"typescript\": \"3.6.4\" } } Run npm install to trigger preinstall script and bumping TypeScript version into package-lock.json Run npm run build , should produce no errors Installing additional dependencies should be safe then.","title":"Workaround for on-premises SPFx TypeScript Version (SharePoint 2016 or 2019)"},{"location":"v2/SPFx-on-premises/#workaround-for-on-premises-spfx-typescript-version-sharepoint-2016-or-2019","text":"Note this article applies to version 1.4.1 SharePoint Framework projects targeting on-premises only. When using the Yeoman generator to create a SharePoint Framework 1.4.1 project targeting on-premises it installs TypeScript version 2.2.2 (SP2016) or 2.4.2/2.4.1 (SP2019). Unfortunately this library relies on 3.6.4 or later due to extensive use of default values for generic type parameters in the libraries. To work around this limitation you can follow the steps in this article. npm i npm i -g rimraf # used to remove the node_modules folder (much better/faster) Ensure that the @pnp/sp package is already installed npm i @pnp/sp Remove the package-lock.json file & node_modules rimraf node_modules folder and execute npm install Open package-lock.json from the root folder Search for \"typescript\" or similar with version 2.4.1 (SP2019) 2.2.2 (SP2016) Replace \"2.4.1\" or \"2.2.2\" with \"3.6.4\" Search for the next \"typescript\" occurrence and replace the block with: JSON \"typescript\": { \"version\": \"3.6.4\", \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-3.6.4.tgz\", \"integrity\": \"sha512-unoCll1+l+YK4i4F8f22TaNVPRHcD9PA3yCuZ8g5e0qGqlVlJ/8FSateOLLSagn+Yg5+ZwuPkL8LFUc0Jcvksg==\", \"dev\": true } Remove node_modules folder rimraf node_modules Run npm install","title":"Workaround for on-premises SPFx TypeScript Version (SharePoint 2016 or 2019)"},{"location":"v2/SPFx-on-premises/#alternative-using-npm-force-resolutions","text":"Install resolutions package and TypeScript providing considered version explicitly: bash npm i -D npm-force-resolutions typescript@3.6.4 Add a resolution for TypeScript and preinstall script into package.json to a corresponding code blocks: JSON { \"scripts\": { \"preinstall\": \"npx npm-force-resolutions\" }, \"resolutions\": { \"typescript\": \"3.6.4\" } } Run npm install to trigger preinstall script and bumping TypeScript version into package-lock.json Run npm run build , should produce no errors Installing additional dependencies should be safe then.","title":"Alternative using npm-force-resolutions"},{"location":"v2/getting-started/","text":"Getting Started \u00b6 These libraries are geared towards folks working with TypeScript but will work equally well for JavaScript projects. To get started you need to install the libraries you need via npm. Many of the packages have a peer dependency to other packages with the @pnp namespace meaning you may need to install more than one package. All packages are released together eliminating version confusion - all packages will depend on packages with the same version number. If you need to support older browsers please review the article on polyfills for required functionality. Install \u00b6 First you will need to install those libraries you want to use in your application. Here we will install the most frequently used packages. This step applies to any environment or project. npm install @pnp/sp @pnp/graph --save Next we can import and use the functionality within our application. Below is a very simple example, please see the individual package documentation for more details and examples. import { getRandomString } from \"@pnp/core\"; (function() { // get and log a random string console.log(getRandomString(20)); })() Getting Started with SharePoint Framework \u00b6 The @pnp/sp and @pnp/graph libraries are designed to work seamlessly within SharePoint Framework projects with a small amount of upfront configuration. If you are running in 2016 or 2019 on-premises please read this note on a workaround for the included TypeScript version. If you are targeting SharePoint online you do not need to take any additional steps. Establish Context \u00b6 Because SharePoint Framework provides a local context to each component we need to set that context within the library. This allows us to determine request urls as well as use the SPFx HttpGraphClient within @pnp/graph. There are two ways to provide the SPFx context to the library. Either through the setup method imported from @pnp/core or using the setup method on either the @pnp/sp or @pnp/graph main export. All three are shown below and are equivalent, meaning if you are already importing the sp variable from @pnp/sp or the graph variable from @pnp/graph you should use their setup method to reduce imports. The setup is always done in the onInit method to ensure it runs before your other life-cycle code. You can also set any other settings at this time. Using @pnp/core setup \u00b6 import { setup as pnpSetup } from \"@pnp/core\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present pnpSetup({ spfxContext: this.context }); }); } // ... Using @pnp/sp setup \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... Sp setup also supports passing just the SPFx context object directly as this is the most common case import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ... Using @pnp/graph setup \u00b6 import { graph } from \"@pnp/graph/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ... Establish context within an SPFx service \u00b6 Because you do not have full access to the context object within a service you need to setup things a little differently. If you do not need AAD tokens you can leave that part out and specify just the pageContext. import { ServiceKey, ServiceScope } from \"@microsoft/sp-core-library\"; import { PageContext } from \"@microsoft/sp-page-context\"; import { AadTokenProviderFactory } from \"@microsoft/sp-http\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; export interface ISampleService { getLists(): Promise<any[]>; } export class SampleService { public static readonly serviceKey: ServiceKey<ISampleService> = ServiceKey.create<ISampleService>('SPFx:SampleService', SampleService); constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { const pageContext = serviceScope.consume(PageContext.serviceKey); const tokenProviderFactory = serviceScope.consume(AadTokenProviderFactory.serviceKey); // we need to \"spoof\" the context object with the parts we need for PnPjs sp.setup({ spfxContext: { aadTokenProviderFactory: tokenProviderFactory, pageContext: pageContext, } }); // This approach also works if you do not require AAD tokens // you don't need to do both // sp.setup({ // sp : { // baseUrl : pageContext.web.absoluteUrl // } // }); }); } public getLists(): Promise<any[]> { return sp.web.lists(); } } Connect to SharePoint from Node \u00b6 Please see the main article on how we support node versions that require commonjs modules. npm i @pnp/sp-commonjs @pnp/nodejs-commonjs This will install the logging, common, odata, sp, and nodejs packages. You can read more about what each package does starting on the packages page. Once these are installed you need to import them into your project, to communicate with SharePoint from node we'll need the following imports: import { sp } from \"@pnp/sp-commonjs\"; import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; Once you have imported the necessary resources you can update your code to setup the node fetch client as well as make a call to SharePoint. // configure your node options (only once in your application) sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // make a call to SharePoint and log it in the console sp.web.select(\"Title\", \"Description\")().then(w => { console.log(JSON.stringify(w, null, 4)); }); Connect to Microsoft Graph From Node \u00b6 Similar to the above you can also make calls to the Graph api from node using the libraries. Again we start with installing the required resources. You can see ./debug/launch/graph.ts for a live example. npm i @pnp/graph-commonjs @pnp/nodejs-commonjs Now we need to import what we'll need to call graph import { graph } from \"@pnp/graph-commonjs\"; import { AdalFetchClient } from \"@pnp/nodejs-commonjs\"; Now we can make our graph calls after setting up the Adal client. Note you'll need to setup an AzureAD App registration with the necessary permissions. graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{mytenant}.onmicrosoft.com\", \"{application id}\", \"{application secret}\"); }, }, }); // make a call to Graph and get all the groups graph.groups().then(g => { console.log(JSON.stringify(g, null, 4)); }); Getting Started outside SharePoint Framework \u00b6 In some cases you may be working in a way such that we cannot determine the base url for the web. In this scenario you have two options. Set baseUrl through setup \u00b6 Here we are setting the baseUrl via the sp.setup method. We are also setting the headers to use verbose mode, something you may have to do when working against unpatched versions of SharePoint 2013 as discussed here . This is optional for 2016 or SharePoint Online. The library does not support setting the headers to use nometadata as we rely on the metadata in the response to do some of the more complicated functions. Some of the pure data calls will probably work but it is not a supported configuration. import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { headers: { Accept: \"application/json;odata=verbose\", }, baseUrl: \"{Absolute SharePoint Web URL}\" }, }); const w = await sp.web(); Create Web instances directly \u00b6 Using this method you create the web directly with the url you want to use as the base. import { Web } from \"@pnp/sp/presets/all\"; const web = Web(\"{Absolute SharePoint Web URL}\"); const w = await web(); Next Steps \u00b6 Be sure to review the article describing all of the available settings across the libraries.","title":"Getting Started"},{"location":"v2/getting-started/#getting-started","text":"These libraries are geared towards folks working with TypeScript but will work equally well for JavaScript projects. To get started you need to install the libraries you need via npm. Many of the packages have a peer dependency to other packages with the @pnp namespace meaning you may need to install more than one package. All packages are released together eliminating version confusion - all packages will depend on packages with the same version number. If you need to support older browsers please review the article on polyfills for required functionality.","title":"Getting Started"},{"location":"v2/getting-started/#install","text":"First you will need to install those libraries you want to use in your application. Here we will install the most frequently used packages. This step applies to any environment or project. npm install @pnp/sp @pnp/graph --save Next we can import and use the functionality within our application. Below is a very simple example, please see the individual package documentation for more details and examples. import { getRandomString } from \"@pnp/core\"; (function() { // get and log a random string console.log(getRandomString(20)); })()","title":"Install"},{"location":"v2/getting-started/#getting-started-with-sharepoint-framework","text":"The @pnp/sp and @pnp/graph libraries are designed to work seamlessly within SharePoint Framework projects with a small amount of upfront configuration. If you are running in 2016 or 2019 on-premises please read this note on a workaround for the included TypeScript version. If you are targeting SharePoint online you do not need to take any additional steps.","title":"Getting Started with SharePoint Framework"},{"location":"v2/getting-started/#establish-context","text":"Because SharePoint Framework provides a local context to each component we need to set that context within the library. This allows us to determine request urls as well as use the SPFx HttpGraphClient within @pnp/graph. There are two ways to provide the SPFx context to the library. Either through the setup method imported from @pnp/core or using the setup method on either the @pnp/sp or @pnp/graph main export. All three are shown below and are equivalent, meaning if you are already importing the sp variable from @pnp/sp or the graph variable from @pnp/graph you should use their setup method to reduce imports. The setup is always done in the onInit method to ensure it runs before your other life-cycle code. You can also set any other settings at this time.","title":"Establish Context"},{"location":"v2/getting-started/#using-pnpcore-setup","text":"import { setup as pnpSetup } from \"@pnp/core\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present pnpSetup({ spfxContext: this.context }); }); } // ...","title":"Using @pnp/core setup"},{"location":"v2/getting-started/#using-pnpsp-setup","text":"import { sp } from \"@pnp/sp/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... Sp setup also supports passing just the SPFx context object directly as this is the most common case import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ...","title":"Using @pnp/sp setup"},{"location":"v2/getting-started/#using-pnpgraph-setup","text":"import { graph } from \"@pnp/graph/presets/all\"; // ... protected onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ...","title":"Using @pnp/graph setup"},{"location":"v2/getting-started/#establish-context-within-an-spfx-service","text":"Because you do not have full access to the context object within a service you need to setup things a little differently. If you do not need AAD tokens you can leave that part out and specify just the pageContext. import { ServiceKey, ServiceScope } from \"@microsoft/sp-core-library\"; import { PageContext } from \"@microsoft/sp-page-context\"; import { AadTokenProviderFactory } from \"@microsoft/sp-http\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; export interface ISampleService { getLists(): Promise<any[]>; } export class SampleService { public static readonly serviceKey: ServiceKey<ISampleService> = ServiceKey.create<ISampleService>('SPFx:SampleService', SampleService); constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { const pageContext = serviceScope.consume(PageContext.serviceKey); const tokenProviderFactory = serviceScope.consume(AadTokenProviderFactory.serviceKey); // we need to \"spoof\" the context object with the parts we need for PnPjs sp.setup({ spfxContext: { aadTokenProviderFactory: tokenProviderFactory, pageContext: pageContext, } }); // This approach also works if you do not require AAD tokens // you don't need to do both // sp.setup({ // sp : { // baseUrl : pageContext.web.absoluteUrl // } // }); }); } public getLists(): Promise<any[]> { return sp.web.lists(); } }","title":"Establish context within an SPFx service"},{"location":"v2/getting-started/#connect-to-sharepoint-from-node","text":"Please see the main article on how we support node versions that require commonjs modules. npm i @pnp/sp-commonjs @pnp/nodejs-commonjs This will install the logging, common, odata, sp, and nodejs packages. You can read more about what each package does starting on the packages page. Once these are installed you need to import them into your project, to communicate with SharePoint from node we'll need the following imports: import { sp } from \"@pnp/sp-commonjs\"; import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; Once you have imported the necessary resources you can update your code to setup the node fetch client as well as make a call to SharePoint. // configure your node options (only once in your application) sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // make a call to SharePoint and log it in the console sp.web.select(\"Title\", \"Description\")().then(w => { console.log(JSON.stringify(w, null, 4)); });","title":"Connect to SharePoint from Node"},{"location":"v2/getting-started/#connect-to-microsoft-graph-from-node","text":"Similar to the above you can also make calls to the Graph api from node using the libraries. Again we start with installing the required resources. You can see ./debug/launch/graph.ts for a live example. npm i @pnp/graph-commonjs @pnp/nodejs-commonjs Now we need to import what we'll need to call graph import { graph } from \"@pnp/graph-commonjs\"; import { AdalFetchClient } from \"@pnp/nodejs-commonjs\"; Now we can make our graph calls after setting up the Adal client. Note you'll need to setup an AzureAD App registration with the necessary permissions. graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{mytenant}.onmicrosoft.com\", \"{application id}\", \"{application secret}\"); }, }, }); // make a call to Graph and get all the groups graph.groups().then(g => { console.log(JSON.stringify(g, null, 4)); });","title":"Connect to Microsoft Graph From Node"},{"location":"v2/getting-started/#getting-started-outside-sharepoint-framework","text":"In some cases you may be working in a way such that we cannot determine the base url for the web. In this scenario you have two options.","title":"Getting Started outside SharePoint Framework"},{"location":"v2/getting-started/#set-baseurl-through-setup","text":"Here we are setting the baseUrl via the sp.setup method. We are also setting the headers to use verbose mode, something you may have to do when working against unpatched versions of SharePoint 2013 as discussed here . This is optional for 2016 or SharePoint Online. The library does not support setting the headers to use nometadata as we rely on the metadata in the response to do some of the more complicated functions. Some of the pure data calls will probably work but it is not a supported configuration. import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { headers: { Accept: \"application/json;odata=verbose\", }, baseUrl: \"{Absolute SharePoint Web URL}\" }, }); const w = await sp.web();","title":"Set baseUrl through setup"},{"location":"v2/getting-started/#create-web-instances-directly","text":"Using this method you create the web directly with the url you want to use as the base. import { Web } from \"@pnp/sp/presets/all\"; const web = Web(\"{Absolute SharePoint Web URL}\"); const w = await web();","title":"Create Web instances directly"},{"location":"v2/getting-started/#next-steps","text":"Be sure to review the article describing all of the available settings across the libraries.","title":"Next Steps"},{"location":"v2/nodejs-support/","text":"Working in Nodejs \u00b6 As outlined on the getting started page you can easily use the library with Nodejs, but there are some key differences you need to consider. But first a little history, you can skip this part if you just want to see how things work but we felt some folks might be interested. To make selective imports work we need to support es module syntax for client-side environments such as SPFx development. All versions of Nodejs that are currently LTS do not support es modules without flags (as of when this was written). We thought we had a scheme to handle this following the available guidance but ultimately it didn't work across all node versions and we unpublished 2.0.1. CommonJS Libraries \u00b6 Because of the difficulties of working with es modules in node we recommend using our mirror packages providing commonjs modules. These can be installed by using the package name and appending -commonjs, such as: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs These packages are built from the same source and released at the same time so all updates are included with each release. The only difference is that for the sp-commonjs and graph-commonjs packages we target the \"all\" preset as the entry point. This makes things a little easier in node where bundle sizes aren't an issue. You can see this in the nodejs-app sample . Here is that sample explained fully: Install Libraries \u00b6 We want to make a simple request to SharePoint so we need to first install the modules we need: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs --save We will also install TypeScript: npm install typescript --save-dev index.ts \u00b6 We will create an index.ts file and add the following code. You will need to update the site url, client id, and client secret to your values. This should be done using a settings file or something like Azure KeyVault for production, but for this example it is good enough. // our imports come from the -commonjs libs import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; // we call setup to use the node client sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{ site url }\", \"{ client id }\", \"{ client secret }\"); }, }, }); async function makeRequest() { // make a request to get the web's details const w = await sp.web(); console.log(JSON.stringify(w, null, 2)); } // get past no await at root of app makeRequest(); Don't forget you will need to register an app to get the client id and secret. Add a tsconfig.json \u00b6 Not strictly necessary but very useful to include a tsconfig.json to control how tsc transpiles your code to JavaScript { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"esnext\", \"moduleResolution\": \"node\", \"declaration\": true, \"outDir\": \"dist\", \"skipLibCheck\": true, \"sourceMap\": true, \"lib\": [ \"dom\", \"esnext\" ] }, \"files\": [ \"./index.ts\" ] } Add an script to package.json \u00b6 We add the \"start\" script to the default package.json { \"name\": \"nodejs-app\", \"version\": \"1.0.0\", \"description\": \"Sample nodejs app using PnPjs\", \"main\": \"index.js\", \"scripts\": { \"start\": \"tsc -p . && node dist/index.js\", \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"MIT\", \"dependencies\": { \"@pnp/nodejs-commonjs\": \"^2.0.2-5\", \"@pnp/sp-commonjs\": \"^2.0.2-5\" }, \"devDependencies\": { \"typescript\": \"^3.7.5\" } } Run It \u00b6 You can now run your program using: npm start","title":"Working in Nodejs"},{"location":"v2/nodejs-support/#working-in-nodejs","text":"As outlined on the getting started page you can easily use the library with Nodejs, but there are some key differences you need to consider. But first a little history, you can skip this part if you just want to see how things work but we felt some folks might be interested. To make selective imports work we need to support es module syntax for client-side environments such as SPFx development. All versions of Nodejs that are currently LTS do not support es modules without flags (as of when this was written). We thought we had a scheme to handle this following the available guidance but ultimately it didn't work across all node versions and we unpublished 2.0.1.","title":"Working in Nodejs"},{"location":"v2/nodejs-support/#commonjs-libraries","text":"Because of the difficulties of working with es modules in node we recommend using our mirror packages providing commonjs modules. These can be installed by using the package name and appending -commonjs, such as: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs These packages are built from the same source and released at the same time so all updates are included with each release. The only difference is that for the sp-commonjs and graph-commonjs packages we target the \"all\" preset as the entry point. This makes things a little easier in node where bundle sizes aren't an issue. You can see this in the nodejs-app sample . Here is that sample explained fully:","title":"CommonJS Libraries"},{"location":"v2/nodejs-support/#install-libraries","text":"We want to make a simple request to SharePoint so we need to first install the modules we need: npm install @pnp/sp-commonjs @pnp/nodejs-commonjs --save We will also install TypeScript: npm install typescript --save-dev","title":"Install Libraries"},{"location":"v2/nodejs-support/#indexts","text":"We will create an index.ts file and add the following code. You will need to update the site url, client id, and client secret to your values. This should be done using a settings file or something like Azure KeyVault for production, but for this example it is good enough. // our imports come from the -commonjs libs import { SPFetchClient } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; // we call setup to use the node client sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{ site url }\", \"{ client id }\", \"{ client secret }\"); }, }, }); async function makeRequest() { // make a request to get the web's details const w = await sp.web(); console.log(JSON.stringify(w, null, 2)); } // get past no await at root of app makeRequest(); Don't forget you will need to register an app to get the client id and secret.","title":"index.ts"},{"location":"v2/nodejs-support/#add-a-tsconfigjson","text":"Not strictly necessary but very useful to include a tsconfig.json to control how tsc transpiles your code to JavaScript { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"esnext\", \"moduleResolution\": \"node\", \"declaration\": true, \"outDir\": \"dist\", \"skipLibCheck\": true, \"sourceMap\": true, \"lib\": [ \"dom\", \"esnext\" ] }, \"files\": [ \"./index.ts\" ] }","title":"Add a tsconfig.json"},{"location":"v2/nodejs-support/#add-an-script-to-packagejson","text":"We add the \"start\" script to the default package.json { \"name\": \"nodejs-app\", \"version\": \"1.0.0\", \"description\": \"Sample nodejs app using PnPjs\", \"main\": \"index.js\", \"scripts\": { \"start\": \"tsc -p . && node dist/index.js\", \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"MIT\", \"dependencies\": { \"@pnp/nodejs-commonjs\": \"^2.0.2-5\", \"@pnp/sp-commonjs\": \"^2.0.2-5\" }, \"devDependencies\": { \"typescript\": \"^3.7.5\" } }","title":"Add an script to package.json"},{"location":"v2/nodejs-support/#run-it","text":"You can now run your program using: npm start","title":"Run It"},{"location":"v2/npm-scripts/","text":"Supported NPM Scripts \u00b6 As you likely are aware you can embed scripts within package.json. Using this capability coupled with the knowledge that pretty much all of the tools we use now support code files (.js/.ts) as configuration we have removed gulp from our tooling and now execute our various actions via scripts. This is not a knock on gulp, it remains a great tool, rather an opportunity for us to remove some dependencies. This article outlines the current scripts we've implemented and how to use them, with available options and examples. Start \u00b6 Executes the serve command npm start Serve \u00b6 Starts a debugging server serving a bundled script with ./debug/serve/main.ts as the entry point. This allows you to run tests and debug code running within the context of a webpage rather than node. npm run serve Test \u00b6 Runs the tests and coverage for the library. Starting with 2.3.0 ONLY MSAL auth is supported for running the tests. More details on setting up MSAL for node. Options \u00b6 There are several options you can provide to the test command. All of these need to be separated using a \"--\" double hyphen so they are passed to the spawned sub-commands. Test a Single Package \u00b6 --package or -p This option will only run the tests associated with the package you specify. The values are the folder names within the ./packages directory. # run only sp tests npm test -- -p sp # run only logging tests npm test -- -package logging Run a Single Test File \u00b6 --single or --s You can also run a specific file with a package. This option must be used with the single package option as you are essentially specifying the folder and file. This option uses either the flags. # run only sp web tests npm test -- -p sp -s web # run only graph groups tests npm test -- -package graph -single groups Specify a Site \u00b6 --site By default every time you run the tests a new sub-site is created below the site specified in your settings file . You can choose to reuse a site for testing, which saves time when re-running a set of tests frequently. Testing content is not deleted after tests, so if you need to inspect the created content from testing you may wish to forgo this option. This option can be used with any or none of the other testing options. # run only sp web tests with a certain site npm test -- -p sp -s web --site https://some.site.com/sites/dev Cleanup \u00b6 --cleanup If you include this flag the testing web will be deleted once tests are complete. Useful for local testing where you do not need to inspect the web once the tests are complete. Works with any of the other options, be careful when specifying a web using --site as it will be deleted. # clean up our testing site npm test -- --cleanup Logging \u00b6 --logging If you include this flag a console logger will be subscribed and the log level will be set to Info. This will provide console output for all the requests being made during testing. This flag is compatible with all other flags - however unless you are trying to debug a specific test this will produce a lot of chatty output. # enable logging during testing npm test -- --logging spVerbose \u00b6 Added in 2.0.13 --spverbose This flag will enable \"verbose\" OData mode for SharePoint tests. This flag is compatible with other flags. npm test -- --spverbose build \u00b6 Invokes the pnpbuild cli to transpile the TypeScript into JavaScript. All behavior is controlled via the tsconfig.json in the root of the project and sub folders as needed. npm run build package \u00b6 Invokes the pnpbuild cli to create the package directories under the dist folder. This will allow you to see exactly what will end up in the npm packages once they are published. npm run package lint \u00b6 Runs the linter. npm run lint clean \u00b6 Removes any generated folders from the working directory. npm run clean","title":"Supported NPM Scripts"},{"location":"v2/npm-scripts/#supported-npm-scripts","text":"As you likely are aware you can embed scripts within package.json. Using this capability coupled with the knowledge that pretty much all of the tools we use now support code files (.js/.ts) as configuration we have removed gulp from our tooling and now execute our various actions via scripts. This is not a knock on gulp, it remains a great tool, rather an opportunity for us to remove some dependencies. This article outlines the current scripts we've implemented and how to use them, with available options and examples.","title":"Supported NPM Scripts"},{"location":"v2/npm-scripts/#start","text":"Executes the serve command npm start","title":"Start"},{"location":"v2/npm-scripts/#serve","text":"Starts a debugging server serving a bundled script with ./debug/serve/main.ts as the entry point. This allows you to run tests and debug code running within the context of a webpage rather than node. npm run serve","title":"Serve"},{"location":"v2/npm-scripts/#test","text":"Runs the tests and coverage for the library. Starting with 2.3.0 ONLY MSAL auth is supported for running the tests. More details on setting up MSAL for node.","title":"Test"},{"location":"v2/npm-scripts/#options","text":"There are several options you can provide to the test command. All of these need to be separated using a \"--\" double hyphen so they are passed to the spawned sub-commands.","title":"Options"},{"location":"v2/npm-scripts/#test-a-single-package","text":"--package or -p This option will only run the tests associated with the package you specify. The values are the folder names within the ./packages directory. # run only sp tests npm test -- -p sp # run only logging tests npm test -- -package logging","title":"Test a Single Package"},{"location":"v2/npm-scripts/#run-a-single-test-file","text":"--single or --s You can also run a specific file with a package. This option must be used with the single package option as you are essentially specifying the folder and file. This option uses either the flags. # run only sp web tests npm test -- -p sp -s web # run only graph groups tests npm test -- -package graph -single groups","title":"Run a Single Test File"},{"location":"v2/npm-scripts/#specify-a-site","text":"--site By default every time you run the tests a new sub-site is created below the site specified in your settings file . You can choose to reuse a site for testing, which saves time when re-running a set of tests frequently. Testing content is not deleted after tests, so if you need to inspect the created content from testing you may wish to forgo this option. This option can be used with any or none of the other testing options. # run only sp web tests with a certain site npm test -- -p sp -s web --site https://some.site.com/sites/dev","title":"Specify a Site"},{"location":"v2/npm-scripts/#cleanup","text":"--cleanup If you include this flag the testing web will be deleted once tests are complete. Useful for local testing where you do not need to inspect the web once the tests are complete. Works with any of the other options, be careful when specifying a web using --site as it will be deleted. # clean up our testing site npm test -- --cleanup","title":"Cleanup"},{"location":"v2/npm-scripts/#logging","text":"--logging If you include this flag a console logger will be subscribed and the log level will be set to Info. This will provide console output for all the requests being made during testing. This flag is compatible with all other flags - however unless you are trying to debug a specific test this will produce a lot of chatty output. # enable logging during testing npm test -- --logging","title":"Logging"},{"location":"v2/npm-scripts/#spverbose","text":"Added in 2.0.13 --spverbose This flag will enable \"verbose\" OData mode for SharePoint tests. This flag is compatible with other flags. npm test -- --spverbose","title":"spVerbose"},{"location":"v2/npm-scripts/#build","text":"Invokes the pnpbuild cli to transpile the TypeScript into JavaScript. All behavior is controlled via the tsconfig.json in the root of the project and sub folders as needed. npm run build","title":"build"},{"location":"v2/npm-scripts/#package","text":"Invokes the pnpbuild cli to create the package directories under the dist folder. This will allow you to see exactly what will end up in the npm packages once they are published. npm run package","title":"package"},{"location":"v2/npm-scripts/#lint","text":"Runs the linter. npm run lint","title":"lint"},{"location":"v2/npm-scripts/#clean","text":"Removes any generated folders from the working directory. npm run clean","title":"clean"},{"location":"v2/packages/","text":"Packages \u00b6 The following packages comprise the Patterns and Practices client side libraries. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins","title":"Packages"},{"location":"v2/packages/#packages","text":"The following packages comprise the Patterns and Practices client side libraries. All of the packages are published as a set and depend on their peers within the @pnp scope. The latest published version is . @pnp/ adaljsclient Provides an adaljs wrapper suitable for use with PnPjs common Provides shared functionality across all pnp libraries config-store Provides a way to manage configuration within your application graph Provides a fluent api for working with Microsoft Graph logging Light-weight, subscribable logging framework msaljsclient Provides an msal wrapper suitable for use with PnPjs nodejs Provides functionality enabling the @pnp libraries within nodejs odata Provides shared odata functionality and base classes sp Provides a fluent api for working with SharePoint REST sp-addinhelpers Provides functionality for working within SharePoint add-ins","title":"Packages"},{"location":"v2/transition-guide/","text":"Transition Guide \u00b6 We have worked to make moving from @pnp library 1. to 2. as painless as possible, however there are some changes to how things work. The below guide we have provided an overview of what it takes to transition between the libraries. If we missed something, please let us know in the issues list so we can update the guide. Thanks! Installing @pnp libraries \u00b6 In version 1.* the libraries were setup as peer dependencies of each other requiring you to install each of them separately. We continue to believe this correctly describes the relationship, but recognize that basically nothing in the world accounts for peer dependencies. So we have updated the libraries to be dependencies. This makes it easier to install into your projects as you only need to install a single library: npm i --save @pnp/sp Selective Imports \u00b6 Another big change in v2 is the ability to selectively import the pieces you need from the libraries. This allows you to have smaller bundles and works well with tree-shaking. It does require you to have more import statements, which can potentially be a bit confusing at first. The selective imports apply to the sp and graph libraries. To help explain let's take the example of the Web object. In v1 Web includes a reference to pretty much everything else in the entire sp library. Meaning that if you use web (and you pretty much have to) you hold a ref to all the other pieces (like Fields, Lists, ContentTypes) even if you aren't using them. Because of that tree shaking can't do anything to reduce the bundle size because it \"thinks\" you are using them simply because they have been imported. To solve this in v2 the Web object no longer contains references to anything, it is a bare object with a few methods. If you look at the source you will see that, for example, there is no longer a \"lists\" property. These properties and methods are now added through selectively importing the functionality you need: Selectively Import Web lists functionality \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports the functionality for lists associated only with web import \"@pnp/sp/lists/web\"; const r = await sp.web.lists(); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports all the functionality for lists import \"@pnp/sp/lists\"; const r = await sp.web.lists(); Each of the docs pages shows the selective import paths for each sub-module (lists, items, etc.). Presets \u00b6 In addition to the ability to selectively import functionality you can import presets. This allows you to import an entire set of functionality in a single line. At launch the sp library will support two presets \"all\" and \"core\" with the graph library supporting \"all\". Using the \"all\" preset will match the functionality of v1. This can save you time in transitioning your projects so you can update to selective imports later. For new projects we recommend using the selective imports from day 1. To update your V1 projects to V2 you can replace all instances of \"@pnp/sp\" with \"@pnp/sp/presets/all\" and things should work as before (though some class names or other things may have changed, please review the change log and the rest of this guide). // V1 way of doing things: import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes, } from \"@pnp/sp\"; // V2 way with selective imports import { sp } from \"@pnp/sp\"; import { ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/clientside-pages\"; // V2 way with preset \"all\" import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/presets/all\"; Invokable Objects \u00b6 Another new feature is the addition of invokable objects. Previously where you used \"get()\" to invoke a request you can now leave it off. We have left the .get method in place so everyone's code wasn't broken immediately upon transitioning. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // old way (still works) const r1 = sp.web(); // invokable const r2 = sp.web(); The benefit is that objects can now support default actions that are not \"get\" but might be \"post\". And you save typing a few extra characters. This still work the same as with select or any of the other odata methods: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // invokable const r = sp.web.select(\"Title\", \"Url\")(); Factory Functions & Interfaces \u00b6 Another change in the library is in the structure of exports. We are no longer exporting the objects themselves, rather we are only exposing factory functions and interfaces. This allows us to decouple what developers use from our internal implementation. For folks using the fluent chain starting with sp you shouldn't need to update your code. If you are using any of the v1 classes directly you should just need to remove the \"new\" keyword and update the import path. The factory functions signature matches the constructor signature of the v1 objects. // v1 import { Web } from \"@pnp/sp\"; const web: Web = new Web(\"some absolute url\"); const r1 = web(); // v2 import { Web, IWeb } from \"@pnp/sp/webs\"; const web: IWeb = Web(\"some absolute url\"); const r2 = web(); Extension Methods \u00b6 Another new capability in v2 is the ability to extend objects and factories. This allows you to easily add methods or properties on a per-object basis. Please see the full article on extension methods describing this great new capability. CDN publishing \u00b6 Starting with v2 we will no longer create bundles for each of the packages. Historically these are not commonly used, don't work perfectly for everyone (there are a lot of ways to bundle things), and another piece we need to maintain. Instead we encourage folks to create their own bundles , optimized for their particular scenario. This will result in smaller overall bundle size and allow folks to bundle things to match their scenario. Please review the article on creating your custom bundles to see how to tailor bundles to your needs. The PnPjs bundle will remain, though it is designed only for backwards compatibility and we strongly recommend creating your own bundles, or directly importing the libraries into your projects using selective imports. Drop client-svc and sp-taxonomy libraries \u00b6 These libraries were created to allow folks to access and manage SharePoint taxonomy and manage metadata. Given that there is upcoming support for taxonomy via a supported REST API we will drop these two libraries. If working with taxonomy remains a core requirement of your application and we do not yet have support for the new apis, please remain on v1 for the time being. As of 2.0.6 we support reading the modern taxonomy API. Docs here","title":"Transition Guide"},{"location":"v2/transition-guide/#transition-guide","text":"We have worked to make moving from @pnp library 1. to 2. as painless as possible, however there are some changes to how things work. The below guide we have provided an overview of what it takes to transition between the libraries. If we missed something, please let us know in the issues list so we can update the guide. Thanks!","title":"Transition Guide"},{"location":"v2/transition-guide/#installing-pnp-libraries","text":"In version 1.* the libraries were setup as peer dependencies of each other requiring you to install each of them separately. We continue to believe this correctly describes the relationship, but recognize that basically nothing in the world accounts for peer dependencies. So we have updated the libraries to be dependencies. This makes it easier to install into your projects as you only need to install a single library: npm i --save @pnp/sp","title":"Installing @pnp libraries"},{"location":"v2/transition-guide/#selective-imports","text":"Another big change in v2 is the ability to selectively import the pieces you need from the libraries. This allows you to have smaller bundles and works well with tree-shaking. It does require you to have more import statements, which can potentially be a bit confusing at first. The selective imports apply to the sp and graph libraries. To help explain let's take the example of the Web object. In v1 Web includes a reference to pretty much everything else in the entire sp library. Meaning that if you use web (and you pretty much have to) you hold a ref to all the other pieces (like Fields, Lists, ContentTypes) even if you aren't using them. Because of that tree shaking can't do anything to reduce the bundle size because it \"thinks\" you are using them simply because they have been imported. To solve this in v2 the Web object no longer contains references to anything, it is a bare object with a few methods. If you look at the source you will see that, for example, there is no longer a \"lists\" property. These properties and methods are now added through selectively importing the functionality you need:","title":"Selective Imports"},{"location":"v2/transition-guide/#selectively-import-web-lists-functionality","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports the functionality for lists associated only with web import \"@pnp/sp/lists/web\"; const r = await sp.web.lists(); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // this imports all the functionality for lists import \"@pnp/sp/lists\"; const r = await sp.web.lists(); Each of the docs pages shows the selective import paths for each sub-module (lists, items, etc.).","title":"Selectively Import Web lists functionality"},{"location":"v2/transition-guide/#presets","text":"In addition to the ability to selectively import functionality you can import presets. This allows you to import an entire set of functionality in a single line. At launch the sp library will support two presets \"all\" and \"core\" with the graph library supporting \"all\". Using the \"all\" preset will match the functionality of v1. This can save you time in transitioning your projects so you can update to selective imports later. For new projects we recommend using the selective imports from day 1. To update your V1 projects to V2 you can replace all instances of \"@pnp/sp\" with \"@pnp/sp/presets/all\" and things should work as before (though some class names or other things may have changed, please review the change log and the rest of this guide). // V1 way of doing things: import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes, } from \"@pnp/sp\"; // V2 way with selective imports import { sp } from \"@pnp/sp\"; import { ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/clientside-pages\"; // V2 way with preset \"all\" import { sp, ClientSideWebpart, ClientSideWebpartPropertyTypes } from \"@pnp/sp/presets/all\";","title":"Presets"},{"location":"v2/transition-guide/#invokable-objects","text":"Another new feature is the addition of invokable objects. Previously where you used \"get()\" to invoke a request you can now leave it off. We have left the .get method in place so everyone's code wasn't broken immediately upon transitioning. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // old way (still works) const r1 = sp.web(); // invokable const r2 = sp.web(); The benefit is that objects can now support default actions that are not \"get\" but might be \"post\". And you save typing a few extra characters. This still work the same as with select or any of the other odata methods: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // invokable const r = sp.web.select(\"Title\", \"Url\")();","title":"Invokable Objects"},{"location":"v2/transition-guide/#factory-functions-interfaces","text":"Another change in the library is in the structure of exports. We are no longer exporting the objects themselves, rather we are only exposing factory functions and interfaces. This allows us to decouple what developers use from our internal implementation. For folks using the fluent chain starting with sp you shouldn't need to update your code. If you are using any of the v1 classes directly you should just need to remove the \"new\" keyword and update the import path. The factory functions signature matches the constructor signature of the v1 objects. // v1 import { Web } from \"@pnp/sp\"; const web: Web = new Web(\"some absolute url\"); const r1 = web(); // v2 import { Web, IWeb } from \"@pnp/sp/webs\"; const web: IWeb = Web(\"some absolute url\"); const r2 = web();","title":"Factory Functions &amp; Interfaces"},{"location":"v2/transition-guide/#extension-methods","text":"Another new capability in v2 is the ability to extend objects and factories. This allows you to easily add methods or properties on a per-object basis. Please see the full article on extension methods describing this great new capability.","title":"Extension Methods"},{"location":"v2/transition-guide/#cdn-publishing","text":"Starting with v2 we will no longer create bundles for each of the packages. Historically these are not commonly used, don't work perfectly for everyone (there are a lot of ways to bundle things), and another piece we need to maintain. Instead we encourage folks to create their own bundles , optimized for their particular scenario. This will result in smaller overall bundle size and allow folks to bundle things to match their scenario. Please review the article on creating your custom bundles to see how to tailor bundles to your needs. The PnPjs bundle will remain, though it is designed only for backwards compatibility and we strongly recommend creating your own bundles, or directly importing the libraries into your projects using selective imports.","title":"CDN publishing"},{"location":"v2/transition-guide/#drop-client-svc-and-sp-taxonomy-libraries","text":"These libraries were created to allow folks to access and manage SharePoint taxonomy and manage metadata. Given that there is upcoming support for taxonomy via a supported REST API we will drop these two libraries. If working with taxonomy remains a core requirement of your application and we do not yet have support for the new apis, please remain on v1 for the time being. As of 2.0.6 we support reading the modern taxonomy API. Docs here","title":"Drop client-svc and sp-taxonomy libraries"},{"location":"v2/authentication/","text":"Authentication \u00b6 One of the more challenging aspects of web development is ensuring you are properly authenticated to access the resources you need. This section is designed to guide you through connecting to the resources you need using the appropriate methods. There are two places the PnPjs libraries can be used to connect to various services client (browser) or server . Utility Scenarios \u00b6 BearerTokenFetchClient LambdaFetchClient Client Scenarios \u00b6 SharePoint Framework Connect As: Current User User + AAD App via MSAL User + AAD App via ADAL Connect To: SharePoint as: Current User User + AAD App via MSAL Graph as: Current User User + AAD App via MSAL Both as: Current User User + AAD App via MSAL Single Page Application User + AAD App via MSAL Server Scenarios \u00b6 NodeJS SharePoint App Registration (App-Only) ADAL (App-Only) MSAL (App-Only) - coming soon","title":"Authentication"},{"location":"v2/authentication/#authentication","text":"One of the more challenging aspects of web development is ensuring you are properly authenticated to access the resources you need. This section is designed to guide you through connecting to the resources you need using the appropriate methods. There are two places the PnPjs libraries can be used to connect to various services client (browser) or server .","title":"Authentication"},{"location":"v2/authentication/#utility-scenarios","text":"BearerTokenFetchClient LambdaFetchClient","title":"Utility Scenarios"},{"location":"v2/authentication/#client-scenarios","text":"SharePoint Framework Connect As: Current User User + AAD App via MSAL User + AAD App via ADAL Connect To: SharePoint as: Current User User + AAD App via MSAL Graph as: Current User User + AAD App via MSAL Both as: Current User User + AAD App via MSAL Single Page Application User + AAD App via MSAL","title":"Client Scenarios"},{"location":"v2/authentication/#server-scenarios","text":"NodeJS SharePoint App Registration (App-Only) ADAL (App-Only) MSAL (App-Only) - coming soon","title":"Server Scenarios"},{"location":"v2/authentication/adaljsclient/","text":"@pnp/core/adalclient \u00b6 This module contains the AdalClient class which can be used to authenticate to any AzureAD secured resource. It is designed to work seamlessly with SharePoint Framework's permissions. Where possible it is recommended to use the MSAL client . Getting Started \u00b6 Install the library and required dependencies npm install @pnp/adaljsclient --save Setup and Use inside SharePoint Framework \u00b6 Using the SharePoint Framework is the preferred way to make use of the AdalClient as we can use the AADTokenProvider to efficiently get tokens on your behalf. You can also read more about how this process works and the necessary SPFx configurations in the SharePoint Framework 1.6 release notes . This method will only work for SharePoint Framework >= 1.6. For earlier versions of SharePoint Framework you can still use the AdalClient as outlined below using the constructor to specify the values for an AAD Application you have setup. Calling the graph api \u00b6 By providing the context in the onInit we can create the adal client from known information. import { graph } from \"@pnp/graph\"; import { getRandomString } from \"@pnp/core\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup(this.context); }); } public render(): void { // here we are creating a team with a random name, required Group ReadWrite All permissions const teamName = `ATeam.${getRandomString(4)}`; this.domElement.innerHTML = `Hello, I am creating a team named \"${teamName}\" for you...`; graph.teams.create(teamName, \"This is a description\").then(t => { this.domElement.innerHTML += \"done!\"; }).catch(e => { this.domElement.innerHTML = `Oops, I ran into a problem...${JSON.stringify(e, null, 4)}`; }); } Calling the SharePoint API \u00b6 This example shows how to use the ADALClient with the @pnp/sp library to call an API secured with AAD from within SharePoint Framework. import { SPFxAdalClient } from \"@pnp/core\"; import { sp } from \"@pnp/sp/presets/all\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context, sp: { fetchClientFactory: () => new SPFxAdalClient(this.context), }, }); }); } public render(): void { sp.web().then(t => { this.domElement.innerHTML = JSON.stringify(t); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); } Calling the any API \u00b6 You can also use the AdalClient to execute AAD authenticated requests to any API which is properly configured to accept the incoming tokens. This approach will only work within SharePoint Framework >= 1.6. Here we call the SharePoint REST API without the sp library as an example. import { FetchOptions } from \"@pnp/core\"; import { AdalClient } from \"@pnp/adaljsclient\"; import { ODataDefaultParser } from \"@pnp/queryable\"; // ... public render(): void { // create an ADAL Client const client = AdalClient.fromSPFxContext(this.context); // setup the request options const opts: FetchOptions = { method: \"GET\", headers: { \"Accept\": \"application/json\", }, }; // execute the request client.fetch(\"https://{tenant}.sharepoint.com/_api/web\", opts).then(response => { // create a parser to convert the response into JSON. // You can create your own, at this point you have a fetch Response to work with const parser = new ODataDefaultParser(); parser.parse(response).then(json => { this.domElement.innerHTML = JSON.stringify(json); }); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); } Manually Configure \u00b6 This example shows setting up and using the AdalClient to make queries using information you have setup. You can review this article for more information on setting up and securing any application using AzureAD. Setup and Use with Microsoft Graph \u00b6 This sample uses a custom AzureAd app you have created and granted the appropriate permissions. import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph\"; // configure the graph client // parameters are: // client id - the id of the application you created in azure ad // tenant - can be id or URL (shown) // redirect url - absolute url of a page to which your application and Azure AD app allows replies graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"https://myapp/singlesignon.aspx\"); }, }, }); try { // call the graph API const groups = await graph.groups(); console.log(JSON.stringify(groups, null, 4)); } catch (e) { console.error(e); } Nodejs Applications \u00b6 We have a dedicated node client in @pnp/nodejs.","title":"@pnp/core/adalclient"},{"location":"v2/authentication/adaljsclient/#pnpcoreadalclient","text":"This module contains the AdalClient class which can be used to authenticate to any AzureAD secured resource. It is designed to work seamlessly with SharePoint Framework's permissions. Where possible it is recommended to use the MSAL client .","title":"@pnp/core/adalclient"},{"location":"v2/authentication/adaljsclient/#getting-started","text":"Install the library and required dependencies npm install @pnp/adaljsclient --save","title":"Getting Started"},{"location":"v2/authentication/adaljsclient/#setup-and-use-inside-sharepoint-framework","text":"Using the SharePoint Framework is the preferred way to make use of the AdalClient as we can use the AADTokenProvider to efficiently get tokens on your behalf. You can also read more about how this process works and the necessary SPFx configurations in the SharePoint Framework 1.6 release notes . This method will only work for SharePoint Framework >= 1.6. For earlier versions of SharePoint Framework you can still use the AdalClient as outlined below using the constructor to specify the values for an AAD Application you have setup.","title":"Setup and Use inside SharePoint Framework"},{"location":"v2/authentication/adaljsclient/#calling-the-graph-api","text":"By providing the context in the onInit we can create the adal client from known information. import { graph } from \"@pnp/graph\"; import { getRandomString } from \"@pnp/core\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup(this.context); }); } public render(): void { // here we are creating a team with a random name, required Group ReadWrite All permissions const teamName = `ATeam.${getRandomString(4)}`; this.domElement.innerHTML = `Hello, I am creating a team named \"${teamName}\" for you...`; graph.teams.create(teamName, \"This is a description\").then(t => { this.domElement.innerHTML += \"done!\"; }).catch(e => { this.domElement.innerHTML = `Oops, I ran into a problem...${JSON.stringify(e, null, 4)}`; }); }","title":"Calling the graph api"},{"location":"v2/authentication/adaljsclient/#calling-the-sharepoint-api","text":"This example shows how to use the ADALClient with the @pnp/sp library to call an API secured with AAD from within SharePoint Framework. import { SPFxAdalClient } from \"@pnp/core\"; import { sp } from \"@pnp/sp/presets/all\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context, sp: { fetchClientFactory: () => new SPFxAdalClient(this.context), }, }); }); } public render(): void { sp.web().then(t => { this.domElement.innerHTML = JSON.stringify(t); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); }","title":"Calling the SharePoint API"},{"location":"v2/authentication/adaljsclient/#calling-the-any-api","text":"You can also use the AdalClient to execute AAD authenticated requests to any API which is properly configured to accept the incoming tokens. This approach will only work within SharePoint Framework >= 1.6. Here we call the SharePoint REST API without the sp library as an example. import { FetchOptions } from \"@pnp/core\"; import { AdalClient } from \"@pnp/adaljsclient\"; import { ODataDefaultParser } from \"@pnp/queryable\"; // ... public render(): void { // create an ADAL Client const client = AdalClient.fromSPFxContext(this.context); // setup the request options const opts: FetchOptions = { method: \"GET\", headers: { \"Accept\": \"application/json\", }, }; // execute the request client.fetch(\"https://{tenant}.sharepoint.com/_api/web\", opts).then(response => { // create a parser to convert the response into JSON. // You can create your own, at this point you have a fetch Response to work with const parser = new ODataDefaultParser(); parser.parse(response).then(json => { this.domElement.innerHTML = JSON.stringify(json); }); }).catch(e => { this.domElement.innerHTML = JSON.stringify(e); }); }","title":"Calling the any API"},{"location":"v2/authentication/adaljsclient/#manually-configure","text":"This example shows setting up and using the AdalClient to make queries using information you have setup. You can review this article for more information on setting up and securing any application using AzureAD.","title":"Manually Configure"},{"location":"v2/authentication/adaljsclient/#setup-and-use-with-microsoft-graph","text":"This sample uses a custom AzureAd app you have created and granted the appropriate permissions. import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph\"; // configure the graph client // parameters are: // client id - the id of the application you created in azure ad // tenant - can be id or URL (shown) // redirect url - absolute url of a page to which your application and Azure AD app allows replies graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"https://myapp/singlesignon.aspx\"); }, }, }); try { // call the graph API const groups = await graph.groups(); console.log(JSON.stringify(groups, null, 4)); } catch (e) { console.error(e); }","title":"Setup and Use with Microsoft Graph"},{"location":"v2/authentication/adaljsclient/#nodejs-applications","text":"We have a dedicated node client in @pnp/nodejs.","title":"Nodejs Applications"},{"location":"v2/authentication/bearertokenclient/","text":"@pnp/core/BearerTokenFetchClient \u00b6 The BearerTokenFetchClient takes a single parameter representing an access token and uses it to make the requests. The disadvantage to this approach is not knowing to where the request will be sent, which in some cases is fine. An alternative is the LambdaFetchClient Static \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { BearerTokenFetchClient } from \"@pnp/core\"; import { myTokenFactory } from \"./my-auth.js\"; graph.setup({ graph: { fetchClientFactory: () => { // note this method is not async, so your logic here cannot await. // Please see the LambdaFetchClient if you have a need for async support. const token = myTokenFactory(); return new BearerTokenFetchClient(token); }, }, });","title":"@pnp/core/BearerTokenFetchClient"},{"location":"v2/authentication/bearertokenclient/#pnpcorebearertokenfetchclient","text":"The BearerTokenFetchClient takes a single parameter representing an access token and uses it to make the requests. The disadvantage to this approach is not knowing to where the request will be sent, which in some cases is fine. An alternative is the LambdaFetchClient","title":"@pnp/core/BearerTokenFetchClient"},{"location":"v2/authentication/bearertokenclient/#static","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { BearerTokenFetchClient } from \"@pnp/core\"; import { myTokenFactory } from \"./my-auth.js\"; graph.setup({ graph: { fetchClientFactory: () => { // note this method is not async, so your logic here cannot await. // Please see the LambdaFetchClient if you have a need for async support. const token = myTokenFactory(); return new BearerTokenFetchClient(token); }, }, });","title":"Static"},{"location":"v2/authentication/client-spa/","text":"Authentication in Single Page Application \u00b6 If you are writing a single page application deployed outside SharePoint it is recommended to use the MSAL client. You can find further details on the settings in the MSAL docs . You will need to ensure that you grant the permissions required to the application you are trying to use. import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); const data = await graph.me();","title":"Authentication in Single Page Application"},{"location":"v2/authentication/client-spa/#authentication-in-single-page-application","text":"If you are writing a single page application deployed outside SharePoint it is recommended to use the MSAL client. You can find further details on the settings in the MSAL docs . You will need to ensure that you grant the permissions required to the application you are trying to use. import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); const data = await graph.me();","title":"Authentication in Single Page Application"},{"location":"v2/authentication/client-spfx/","text":"Authentication in SharePoint Framework \u00b6 Auth as Current User \u00b6 PnPjs is designed to work as easily as possible within the SharePoint Framework so the authentication setup is very simple for the base case. Supply the current SharePoint Framework context to the library. This works for both SharePoint authentication and Graph authentication using the current user. Graph permissions are controlled by the permissions granted to the SharePoint shared application within your tenant. The below example is taken from a SharePoint Framework webpart. Connect to SharePoint as Current User \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ... Connect to Graph as Current User \u00b6 Permissions for this graph connection are controlled by the Shared SharePoint Application. You can target other applications using the MSAL Client . import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present // this will use the ADAL client behind the scenes with no additional configuration work graph.setup(this.context); } // ... MSAL Client \u00b6 You might want/need to use a client configured to use your own AAD application and not the shared SharePoint application. You can do so using the MSAL client . Here we show this using graph, this works the same with any of the setup strategies . Please see the MSAL library docs for more details on what values to supply in the configuration. Note: you must install the @pnp/msaljsclient client package before using it import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); } // ... ADAL Client \u00b6 You can use the ADAL client from within SPFx, though it is recommended to transition to the MSAL client. Note: you must install the @pnp/adaljsclient client package before using it import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"\"); }, }); } // ...","title":"Authentication in SharePoint Framework"},{"location":"v2/authentication/client-spfx/#authentication-in-sharepoint-framework","text":"","title":"Authentication in SharePoint Framework"},{"location":"v2/authentication/client-spfx/#auth-as-current-user","text":"PnPjs is designed to work as easily as possible within the SharePoint Framework so the authentication setup is very simple for the base case. Supply the current SharePoint Framework context to the library. This works for both SharePoint authentication and Graph authentication using the current user. Graph permissions are controlled by the permissions granted to the SharePoint shared application within your tenant. The below example is taken from a SharePoint Framework webpart.","title":"Auth as Current User"},{"location":"v2/authentication/client-spfx/#connect-to-sharepoint-as-current-user","text":"import { sp } from \"@pnp/sp/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present sp.setup(this.context); } // ...","title":"Connect to SharePoint as Current User"},{"location":"v2/authentication/client-spfx/#connect-to-graph-as-current-user","text":"Permissions for this graph connection are controlled by the Shared SharePoint Application. You can target other applications using the MSAL Client . import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present // this will use the ADAL client behind the scenes with no additional configuration work graph.setup(this.context); } // ...","title":"Connect to Graph as Current User"},{"location":"v2/authentication/client-spfx/#msal-client","text":"You might want/need to use a client configured to use your own AAD application and not the shared SharePoint application. You can do so using the MSAL client . Here we show this using graph, this works the same with any of the setup strategies . Please see the MSAL library docs for more details on what values to supply in the configuration. Note: you must install the @pnp/msaljsclient client package before using it import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/common\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"{your redirect uri}\", }, cache: { cacheLocation: \"sessionStorage\", }, }, [\"email\", \"Files.Read.All\", \"User.Read.All\"]), }, }); } // ...","title":"MSAL Client"},{"location":"v2/authentication/client-spfx/#adal-client","text":"You can use the ADAL client from within SPFx, though it is recommended to transition to the MSAL client. Note: you must install the @pnp/adaljsclient client package before using it import { AdalClient } from \"@pnp/adaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; // ... protected async onInit(): Promise<void> { await super.onInit(); // other init code may be present graph.setup({ graph: { fetchClientFactory: () => { return new AdalClient( \"00000000-0000-0000-0000-000000000000\", \"{tenant}.onmicrosoft.com\", \"\"); }, }); } // ...","title":"ADAL Client"},{"location":"v2/authentication/lambdaclient/","text":"@pnp/core/LambdaFetchClient \u00b6 The LambdaFetchClient class allows you to provide an async function that returns an access token using any logic/supporting libraries you need. This provides total freedom to define how you do authentication, so long as it results in a usable Bearer token to call the target resource. The advantage to the LambdaFetchClient is that you get the url for each request, meaning your logic can account for where the request is headed. The token function should be as efficient as possible as it's logic must complete before each request will be sent. Signature \u00b6 The LambdaFetchClient accepts a single argument of type ILambdaTokenFactoryParams. // signature of method, the return string is the access token (parms: ILambdaTokenFactoryParams) => Promise<string> // ILambdaTokenFactoryParams export interface ILambdaTokenFactoryParams { /** * Url to which the request for which we are requesting a token will be sent */ url: string; /** * Any options supplied for the request */ options: IFetchOptions; } @azure/msal-browser example \u00b6 This example shows how to use @azure/msal-browser along with LambdaFetchClient to achieve signin. msal-browser has many possible configurations which are described within their documentation. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { LambdaFetchClient } from \"@pnp/core\"; import { PublicClientApplication, Configuration } from \"@azure/msal-browser\"; const config: Configuration = { auth: { clientId: \"{client id}\", authority: \"https://login.microsoftonline.com/common/\" } } // create a single application, could also create this within the lambda client, but it would create a new applicaiton per request const msal = new PublicClientApplication(config); // create a new instance of the lambda fetch client const client = new LambdaFetchClient(async () => { const request = { scopes: [\"User.Read.All\"], }; const response = await msal.loginPopup(request); // lamba returns the access token return response.accessToken; }); // setup graph with the client graph.setup({ graph: { fetchClientFactory: () => client, }, }); // execute the request to graph which will use the client defined above const result = await graph.users();","title":"@pnp/core/LambdaFetchClient"},{"location":"v2/authentication/lambdaclient/#pnpcorelambdafetchclient","text":"The LambdaFetchClient class allows you to provide an async function that returns an access token using any logic/supporting libraries you need. This provides total freedom to define how you do authentication, so long as it results in a usable Bearer token to call the target resource. The advantage to the LambdaFetchClient is that you get the url for each request, meaning your logic can account for where the request is headed. The token function should be as efficient as possible as it's logic must complete before each request will be sent.","title":"@pnp/core/LambdaFetchClient"},{"location":"v2/authentication/lambdaclient/#signature","text":"The LambdaFetchClient accepts a single argument of type ILambdaTokenFactoryParams. // signature of method, the return string is the access token (parms: ILambdaTokenFactoryParams) => Promise<string> // ILambdaTokenFactoryParams export interface ILambdaTokenFactoryParams { /** * Url to which the request for which we are requesting a token will be sent */ url: string; /** * Any options supplied for the request */ options: IFetchOptions; }","title":"Signature"},{"location":"v2/authentication/lambdaclient/#azuremsal-browser-example","text":"This example shows how to use @azure/msal-browser along with LambdaFetchClient to achieve signin. msal-browser has many possible configurations which are described within their documentation. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import { LambdaFetchClient } from \"@pnp/core\"; import { PublicClientApplication, Configuration } from \"@azure/msal-browser\"; const config: Configuration = { auth: { clientId: \"{client id}\", authority: \"https://login.microsoftonline.com/common/\" } } // create a single application, could also create this within the lambda client, but it would create a new applicaiton per request const msal = new PublicClientApplication(config); // create a new instance of the lambda fetch client const client = new LambdaFetchClient(async () => { const request = { scopes: [\"User.Read.All\"], }; const response = await msal.loginPopup(request); // lamba returns the access token return response.accessToken; }); // setup graph with the client graph.setup({ graph: { fetchClientFactory: () => client, }, }); // execute the request to graph which will use the client defined above const result = await graph.users();","title":"@azure/msal-browser example"},{"location":"v2/authentication/msaljsclient/","text":"msaljsclient - MSAL Client for PnPjs \u00b6 The MSAL client is a thin wrapper around the MSAL library adapting it for use with PnPjs's request pipeline. Install \u00b6 You need to install the MSAL client before using it. This is in addition to installing the other PnPjs libraries you require. npm install @pnp/msaljsclient --save Configure \u00b6 The PnP client is a very thin wrapper around the MSAL library and you can supply any of the arguments supported. These are described in the MSAL docs . The basic configuration values you need (at least from our testing) are client id, authority, and redirectUri. The other options are settable but not required. This article is not intended to be an exhaustive discussion of all the MSAL configuration possibilities, please see the official docs to understand all of the available options. The second parameter when configuring the PnP client is the list of scope you are seeking to use. These must be configured and properly granted within AAD and you can request one or more scopes as needed for the current scenario. Use in SPFx \u00b6 Calling SharePoint via MSAL \u00b6 When calling the SharePoint REST API we must use only a special scope \"https://{tenant}.sharepoint.com/.default\" import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/mytentant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://mytentant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"https://mytentant.sharepoint.com/.default\"]), }, }); const r = await sp.web(); Calling Graph via MSAL \u00b6 When calling the graph API you must specify the scopes you need and ensure they are configured in AAD import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups(); Use in Single Page Applications \u00b6 You can also use the PnPjs MSAL client within your SPA applications. Please review the various settings to ensure you are configuring MSAL as needed for your application import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://myapp.com/login.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups(); Get a Token \u00b6 You can also use the client to get a token if you need a token for use outside the PnPjs libraries import { MsalClient } from \"@pnp/msaljsclient\"; // note we do not provide scopes here as the second parameter. We certainly could and will get a token // based on those scopes by making a call to getToken() without a param. const client = new MsalClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant}.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://{tenant}.sharepoint.com/sites/dev/SitePages/webpacktest.aspx\", }, }); const token = await client.getToken([\"Group.Read.All\"]); const token2 = await client.getToken([\"Files.Read\"]);","title":"msaljsclient - MSAL Client for PnPjs"},{"location":"v2/authentication/msaljsclient/#msaljsclient-msal-client-for-pnpjs","text":"The MSAL client is a thin wrapper around the MSAL library adapting it for use with PnPjs's request pipeline.","title":"msaljsclient - MSAL Client for PnPjs"},{"location":"v2/authentication/msaljsclient/#install","text":"You need to install the MSAL client before using it. This is in addition to installing the other PnPjs libraries you require. npm install @pnp/msaljsclient --save","title":"Install"},{"location":"v2/authentication/msaljsclient/#configure","text":"The PnP client is a very thin wrapper around the MSAL library and you can supply any of the arguments supported. These are described in the MSAL docs . The basic configuration values you need (at least from our testing) are client id, authority, and redirectUri. The other options are settable but not required. This article is not intended to be an exhaustive discussion of all the MSAL configuration possibilities, please see the official docs to understand all of the available options. The second parameter when configuring the PnP client is the list of scope you are seeking to use. These must be configured and properly granted within AAD and you can request one or more scopes as needed for the current scenario.","title":"Configure"},{"location":"v2/authentication/msaljsclient/#use-in-spfx","text":"","title":"Use in SPFx"},{"location":"v2/authentication/msaljsclient/#calling-sharepoint-via-msal","text":"When calling the SharePoint REST API we must use only a special scope \"https://{tenant}.sharepoint.com/.default\" import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/mytentant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://mytentant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"https://mytentant.sharepoint.com/.default\"]), }, }); const r = await sp.web();","title":"Calling SharePoint via MSAL"},{"location":"v2/authentication/msaljsclient/#calling-graph-via-msal","text":"When calling the graph API you must specify the scopes you need and ensure they are configured in AAD import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups();","title":"Calling Graph via MSAL"},{"location":"v2/authentication/msaljsclient/#use-in-single-page-applications","text":"You can also use the PnPjs MSAL client within your SPA applications. Please review the various settings to ensure you are configuring MSAL as needed for your application import { MsalClientSetup } from \"@pnp/msaljsclient\"; import { graph } from \"@pnp/graph/presets/all\"; graph.setup({ graph: { fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://myapp.com/login.aspx\", }, }, [\"Group.Read.All\"]), }, }); const r = await graph.groups();","title":"Use in Single Page Applications"},{"location":"v2/authentication/msaljsclient/#get-a-token","text":"You can also use the client to get a token if you need a token for use outside the PnPjs libraries import { MsalClient } from \"@pnp/msaljsclient\"; // note we do not provide scopes here as the second parameter. We certainly could and will get a token // based on those scopes by making a call to getToken() without a param. const client = new MsalClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant}.onmicrosoft.com/\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://{tenant}.sharepoint.com/sites/dev/SitePages/webpacktest.aspx\", }, }); const token = await client.getToken([\"Group.Read.All\"]); const token2 = await client.getToken([\"Files.Read\"]);","title":"Get a Token"},{"location":"v2/authentication/server-nodejs/","text":"Authentication in Nodejs \u00b6 SharePoint App Registration \u00b6 Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Auth . Within the PnPjs testing framework we make use of SharePoint App Registration. This uses the SPFetchClient client from the nodejs package. This client works based on the legacy SharePoint App Registration model making use of a client and secret granted permissions through AppInv.aspx. This method works and at the time of writing has no published end date. See: details on how to register a legacy SharePoint application . import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web(); MSAL \u00b6 Added in 2.0.11 You can now use the @azure/msal-node client with PnPjs using MsalFetchClient. You must configure an AAD application with the appropriate permissions for your application. At the time this article was written the msal-node package is not yet GA. Call Graph \u00b6 You can call the Microsoft Graph API with a client id and secret or certificate (see SharePoint example for cert auth) import { graph } from \"@pnp/graph/presets/all\"; // configure your node options graph.setup({ graph: { fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientId: \"{guid}\", clientSecret: \"{client secret}\", } }); }, }, }); const userInfo = await graph.users(); Call SharePoint \u00b6 To call the SharePoint APIs via MSAL you are required to use certificate authentication with your application. Fully covering certificates is outside the scope of these docs, but the following commands were used with openssl to create testing certs for the sample code below. mkdir \\temp cd \\temp openssl req -x509 -newkey rsa:2048 -keyout keytmp.pem -out cert.pem -days 365 -passout pass:HereIsMySuperPass -subj '/C=US/ST=Washington/L=Seattle' openssl rsa -in keytmp.pem -out key.pem -passin pass:HereIsMySuperPass Using the above code you end up with three files, \"cert.pem\", \"key.pem\", and \"keytmp.pem\". The \"cert.pem\" file is uploaded to your AAD application registration. The \"key.pem\" is read as the private key for the configuration. You need to set the baseUrl property when using the MsalFetchClient import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const w = await sp.web(); ADAL \u00b6 The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. See: More details on the node client import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"Authentication in Nodejs"},{"location":"v2/authentication/server-nodejs/#authentication-in-nodejs","text":"","title":"Authentication in Nodejs"},{"location":"v2/authentication/server-nodejs/#sharepoint-app-registration","text":"Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Auth . Within the PnPjs testing framework we make use of SharePoint App Registration. This uses the SPFetchClient client from the nodejs package. This client works based on the legacy SharePoint App Registration model making use of a client and secret granted permissions through AppInv.aspx. This method works and at the time of writing has no published end date. See: details on how to register a legacy SharePoint application . import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web();","title":"SharePoint App Registration"},{"location":"v2/authentication/server-nodejs/#msal","text":"Added in 2.0.11 You can now use the @azure/msal-node client with PnPjs using MsalFetchClient. You must configure an AAD application with the appropriate permissions for your application. At the time this article was written the msal-node package is not yet GA.","title":"MSAL"},{"location":"v2/authentication/server-nodejs/#call-graph","text":"You can call the Microsoft Graph API with a client id and secret or certificate (see SharePoint example for cert auth) import { graph } from \"@pnp/graph/presets/all\"; // configure your node options graph.setup({ graph: { fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientId: \"{guid}\", clientSecret: \"{client secret}\", } }); }, }, }); const userInfo = await graph.users();","title":"Call Graph"},{"location":"v2/authentication/server-nodejs/#call-sharepoint","text":"To call the SharePoint APIs via MSAL you are required to use certificate authentication with your application. Fully covering certificates is outside the scope of these docs, but the following commands were used with openssl to create testing certs for the sample code below. mkdir \\temp cd \\temp openssl req -x509 -newkey rsa:2048 -keyout keytmp.pem -out cert.pem -days 365 -passout pass:HereIsMySuperPass -subj '/C=US/ST=Washington/L=Seattle' openssl rsa -in keytmp.pem -out key.pem -passin pass:HereIsMySuperPass Using the above code you end up with three files, \"cert.pem\", \"key.pem\", and \"keytmp.pem\". The \"cert.pem\" file is uploaded to your AAD application registration. The \"key.pem\" is read as the private key for the configuration. You need to set the baseUrl property when using the MsalFetchClient import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}/\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const w = await sp.web();","title":"Call SharePoint"},{"location":"v2/authentication/server-nodejs/#adal","text":"The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. See: More details on the node client import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"ADAL"},{"location":"v2/authentication/sp-app-registration/","text":"Legacy SharePoint App Registration \u00b6 This section outlines how to register for a client id and secret for use in the above code. Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Authentication . Register An Add-In \u00b6 Before you can begin running tests you need to register a low-trust add-in with SharePoint. This is primarily designed for Office 365, but can work on-premises if you configure your farm accordingly . Navigation to {site url}/_layouts/appregnew.aspx Click \"Generate\" for both the Client Id and Secret values Give you add-in a title, this can be anything but will let you locate it in the list of add-in permissions Provide a fake value for app domain and redirect uri Click \"Create\" Copy the returned block of text containing the client id and secret as well as app name for your records and later in this article. Grant Your Add-In Permissions \u00b6 Now that we have created an add-in registration we need to tell SharePoint what permissions it can use. Due to an update in SharePoint Online you now have to register add-ins with certain permissions in the admin site . Navigate to {admin site url}/_layouts/appinv.aspx Paste your client id from the above section into the App Id box and click \"Lookup\" You should see the information populated into the form from the last section, if not ensure you have the correct id value Paste the below XML into the permissions request xml box and hit \"Create\" You should get a confirmation message. <AppPermissionRequests AllowAppOnlyPolicy=\"true\"> <AppPermissionRequest Scope=\"http://sharepoint/content/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/social/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/search\" Right=\"QueryAsUserIgnoreAppPrincipal\" /> </AppPermissionRequests> Note that the above XML will grant full tenant control. This is OK for testing, but you should grant only those permissions necessary for your application in production.","title":"Legacy SharePoint App Registration"},{"location":"v2/authentication/sp-app-registration/#legacy-sharepoint-app-registration","text":"This section outlines how to register for a client id and secret for use in the above code. Due to a recent change in how SPO is configured NEW tenants will have ACS authentication disabled by default. You can read more details in this article . For testing we recommend using MSAL Certificate Authentication .","title":"Legacy SharePoint App Registration"},{"location":"v2/authentication/sp-app-registration/#register-an-add-in","text":"Before you can begin running tests you need to register a low-trust add-in with SharePoint. This is primarily designed for Office 365, but can work on-premises if you configure your farm accordingly . Navigation to {site url}/_layouts/appregnew.aspx Click \"Generate\" for both the Client Id and Secret values Give you add-in a title, this can be anything but will let you locate it in the list of add-in permissions Provide a fake value for app domain and redirect uri Click \"Create\" Copy the returned block of text containing the client id and secret as well as app name for your records and later in this article.","title":"Register An Add-In"},{"location":"v2/authentication/sp-app-registration/#grant-your-add-in-permissions","text":"Now that we have created an add-in registration we need to tell SharePoint what permissions it can use. Due to an update in SharePoint Online you now have to register add-ins with certain permissions in the admin site . Navigate to {admin site url}/_layouts/appinv.aspx Paste your client id from the above section into the App Id box and click \"Lookup\" You should see the information populated into the form from the last section, if not ensure you have the correct id value Paste the below XML into the permissions request xml box and hit \"Create\" You should get a confirmation message. <AppPermissionRequests AllowAppOnlyPolicy=\"true\"> <AppPermissionRequest Scope=\"http://sharepoint/content/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/social/tenant\" Right=\"FullControl\" /> <AppPermissionRequest Scope=\"http://sharepoint/search\" Right=\"QueryAsUserIgnoreAppPrincipal\" /> </AppPermissionRequests> Note that the above XML will grant full tenant control. This is OK for testing, but you should grant only those permissions necessary for your application in production.","title":"Grant Your Add-In Permissions"},{"location":"v2/common/","text":"@pnp/core \u00b6 The common modules provides a set of utilities classes and reusable building blocks used throughout the @pnp modules. They can be used within your applications as well. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/core --save Import and use functionality, see details on modules below. import { getGUID } from \"@pnp/core\"; console.log(getGUID()); Exports \u00b6 collections libconfig netutil storage util Custom HttpClient","title":"@pnp/core"},{"location":"v2/common/#pnpcore","text":"The common modules provides a set of utilities classes and reusable building blocks used throughout the @pnp modules. They can be used within your applications as well.","title":"@pnp/core"},{"location":"v2/common/#getting-started","text":"Install the library and required dependencies npm install @pnp/core --save Import and use functionality, see details on modules below. import { getGUID } from \"@pnp/core\"; console.log(getGUID());","title":"Getting Started"},{"location":"v2/common/#exports","text":"collections libconfig netutil storage util Custom HttpClient","title":"Exports"},{"location":"v2/common/collections/","text":"@pnp/core/collections \u00b6 The collections module provides typings and classes related to working with dictionaries. TypedHash \u00b6 Interface used to described an object with string keys corresponding to values of type T export interface TypedHash<T> { [key: string]: T; } objectToMap \u00b6 Converts a plain object to a Map instance const map = objectToMap({ a: \"b\", c: \"d\"}); mergeMaps \u00b6 Merges two or more maps, overwriting values with the same key. Last value in wins. const m1 = new Map(); const m2 = new Map(); const m3 = new Map(); const m4 = new Map(); const m = mergeMaps(m1, m2, m3, m4);","title":"@pnp/core/collections"},{"location":"v2/common/collections/#pnpcorecollections","text":"The collections module provides typings and classes related to working with dictionaries.","title":"@pnp/core/collections"},{"location":"v2/common/collections/#typedhash","text":"Interface used to described an object with string keys corresponding to values of type T export interface TypedHash<T> { [key: string]: T; }","title":"TypedHash"},{"location":"v2/common/collections/#objecttomap","text":"Converts a plain object to a Map instance const map = objectToMap({ a: \"b\", c: \"d\"});","title":"objectToMap"},{"location":"v2/common/collections/#mergemaps","text":"Merges two or more maps, overwriting values with the same key. Last value in wins. const m1 = new Map(); const m2 = new Map(); const m3 = new Map(); const m4 = new Map(); const m = mergeMaps(m1, m2, m3, m4);","title":"mergeMaps"},{"location":"v2/common/custom-httpclientimpl/","text":"Custom HttpClientImpl \u00b6 This should be considered an advanced topic and creating a custom HttpClientImpl is not something you will likely need to do. Also, we don't offer support beyond this article for writing your own implementation. It is possible you may need complete control over the sending and receiving of requests. Before you get started read and understand the fetch specification as you are essentially writing a custom fetch implementation. The first step (second if you read the fetch spec as mentioned just above) is to understand the interface you need to implement, HttpClientImpl. export interface HttpClientImpl { fetch(url: string, options: FetchOptions): Promise<Response>; } There is a single method \"fetch\" which takes a url string and a set of options. These options can be just about anything but are constrained within the library to the FetchOptions interface. export interface FetchOptions { method?: string; headers?: HeadersInit | { [index: string]: string }; body?: BodyInit; mode?: string | RequestMode; credentials?: string | RequestCredentials; cache?: string | RequestCache; } So you will need to handle any of those options along with the provided url when sending your request. The library will expect your implementation to return a Promise that resolves to a Response defined by the fetch specification - which you've already read \ud83d\udc4d. Using Your Custom HttpClientImpl \u00b6 Once you have written your implementation using it on your requests is done by setting it in the global library configuration: import { setup } from \"@pnp/core\"; import { sp, Web } from \"@pnp/sp\"; import { MyAwesomeClient } from \"./awesomeclient\"; sp.setup({ sp: { fetchClientFactory: () => { return new MyAwesomeClient(); } } }); let w = new Web(\"{site url}\"); // this request will use your client. const result = await w.select(\"Title\")(); console.log(result); Subclassing is Better \u00b6 You can of course inherit from one of the implementations available within the @pnp scope if you just need to say add a header or need to do something to every request sent. Perhaps some advanced logging. This approach will save you from needing to fully write a fetch implementation. A FINAL NOTE \u00b6 Whatever you do, do not write a client that uses a client id and secret and exposes them on the client side. Client Id and Secret should only ever be used on a server, never exposed to clients as anyone with those values has the full permissions granted to that id and secret.","title":"Custom HttpClientImpl"},{"location":"v2/common/custom-httpclientimpl/#custom-httpclientimpl","text":"This should be considered an advanced topic and creating a custom HttpClientImpl is not something you will likely need to do. Also, we don't offer support beyond this article for writing your own implementation. It is possible you may need complete control over the sending and receiving of requests. Before you get started read and understand the fetch specification as you are essentially writing a custom fetch implementation. The first step (second if you read the fetch spec as mentioned just above) is to understand the interface you need to implement, HttpClientImpl. export interface HttpClientImpl { fetch(url: string, options: FetchOptions): Promise<Response>; } There is a single method \"fetch\" which takes a url string and a set of options. These options can be just about anything but are constrained within the library to the FetchOptions interface. export interface FetchOptions { method?: string; headers?: HeadersInit | { [index: string]: string }; body?: BodyInit; mode?: string | RequestMode; credentials?: string | RequestCredentials; cache?: string | RequestCache; } So you will need to handle any of those options along with the provided url when sending your request. The library will expect your implementation to return a Promise that resolves to a Response defined by the fetch specification - which you've already read \ud83d\udc4d.","title":"Custom HttpClientImpl"},{"location":"v2/common/custom-httpclientimpl/#using-your-custom-httpclientimpl","text":"Once you have written your implementation using it on your requests is done by setting it in the global library configuration: import { setup } from \"@pnp/core\"; import { sp, Web } from \"@pnp/sp\"; import { MyAwesomeClient } from \"./awesomeclient\"; sp.setup({ sp: { fetchClientFactory: () => { return new MyAwesomeClient(); } } }); let w = new Web(\"{site url}\"); // this request will use your client. const result = await w.select(\"Title\")(); console.log(result);","title":"Using Your Custom HttpClientImpl"},{"location":"v2/common/custom-httpclientimpl/#subclassing-is-better","text":"You can of course inherit from one of the implementations available within the @pnp scope if you just need to say add a header or need to do something to every request sent. Perhaps some advanced logging. This approach will save you from needing to fully write a fetch implementation.","title":"Subclassing is Better"},{"location":"v2/common/custom-httpclientimpl/#a-final-note","text":"Whatever you do, do not write a client that uses a client id and secret and exposes them on the client side. Client Id and Secret should only ever be used on a server, never exposed to clients as anyone with those values has the full permissions granted to that id and secret.","title":"A FINAL NOTE"},{"location":"v2/common/libconfig/","text":"@pnp/core/libconfig \u00b6 Contains the shared classes and interfaces used to configure the libraries. These bases classes are expanded on in dependent libraries with the core configuration defined here. This module exposes an instance of the RuntimeConfigImpl class: RuntimeConfig. This configuration object can be referenced and contains the global configuration shared across the libraries. You can also extend the configuration for use within your own applications. ILibraryConfiguration Interface \u00b6 Defines the shared configurable values used across the library as shown below. Each of these has a default value as shown below export interface ILibraryConfiguration { /** * Allows caching to be global disabled, default: false */ globalCacheDisable?: boolean; /** * Defines the default store used by the usingCaching method, default: session */ defaultCachingStore?: \"session\" | \"local\"; /** * Defines the default timeout in seconds used by the usingCaching method, default 30 */ defaultCachingTimeoutSeconds?: number; /** * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval */ enableCacheExpiration?: boolean; /** * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) */ cacheExpirationIntervalMilliseconds?: number; /** * Used to supply the current context from an SPFx webpart to the library */ spfxContext?: any; } RuntimeConfigImpl \u00b6 The class which implements the runtime configuration management as well as sets the default values used within the library. At its heart lies a Dictionary used to track the configuration values. The keys will match the values in the interface or plain object passed to the extend method. assign \u00b6 The assign method is used to add configuration to the global configuration instance. You can pass it any plain object with string keys and those values will be added. Any existing values will be overwritten based on the keys. Last value in wins. For a more detailed scenario of using the RuntimeConfig instance in your own application please see the section below \"Using RuntimeConfig within your application\". Note there are no methods to remove/clear the global config as it should be considered fairly static as frequent updates may have unpredictable side effects as it is a global shared object. Generally it should be set at the start of your application. import { RuntimeConfig } from \"@pnp/core\"; // add your custom keys to the global configuration // note you can use object hashes as values RuntimeConfig.assign({ \"myKey1\": \"value 1\", \"myKey2\": { \"subKey\": \"sub value 1\", \"subKey2\": \"sub value 2\", }, }); // read your custom values const v = RuntimeConfig.get(\"myKey1\"); // \"value 1\" Using RuntimeConfig within your Application \u00b6 If you have a set of properties you will access very frequently it may be desirable to implement your own configuration object and expose those values as properties. To do so you will need to create an interface for your configuration (optional) and a wrapper class for RuntimeConfig to expose your properties import { ILibraryConfiguration, RuntimeConfig, ITypedHash } from \"@pnp/core\"; // first we create our own interface by extending LibraryConfiguration. This allows your class to accept all the values with correct type checking. Note, because // TypeScript allows you to extend from multiple interfaces you can build a complex configuration definition from many sub definitions. // create the interface of your properties // by creating this separately you allows others to compose your parts into their own config interface MyConfigurationPart { // you can create a grouped definition and access your settings as an object // keys can be optional or required as defined by your interface my?: { prop1?: string; prop2?: string; } // and/or define multiple top level properties (beware key collision) // it is good practice to use a unique prefix myProp1: string; myProp2: number; } // now create a combined interface interface MyConfiguration extends ILibraryConfiguration, MyConfigurationPart { } // now create a wrapper object and expose your properties class MyRuntimeConfigImpl { // exposing a nested property public get prop1(): ITypedHash<string> { const myPart = RuntimeConfig.get(\"my\"); if (myPart !== null && typeof myPart !== \"undefined\" && typeof myPart.prop1 !== \"undefined\") { return myPart.prop1; } return {}; } // exposing a root level property public get myProp1(): string | null { let myProp1 = RuntimeConfig.get(\"myProp1\"); if (myProp1 === null) { myProp1 = \"some default value\"; } return myProp1; } setup(config: MyConfiguration): void { RuntimeConfig.assign(config); } } // create a single static instance of your impl class export let MyRuntimeConfig = new MyRuntimeConfigImpl(); Now in other files you can use and set your configuration with a typed interface and properties import { MyRuntimeConfig } from \"{location of module}\"; MyRuntimeConfig.setup({ my: { prop1: \"hello\", }, }); const value = MyRuntimeConfig.myProp1; // \"hello\"","title":"@pnp/core/libconfig"},{"location":"v2/common/libconfig/#pnpcorelibconfig","text":"Contains the shared classes and interfaces used to configure the libraries. These bases classes are expanded on in dependent libraries with the core configuration defined here. This module exposes an instance of the RuntimeConfigImpl class: RuntimeConfig. This configuration object can be referenced and contains the global configuration shared across the libraries. You can also extend the configuration for use within your own applications.","title":"@pnp/core/libconfig"},{"location":"v2/common/libconfig/#ilibraryconfiguration-interface","text":"Defines the shared configurable values used across the library as shown below. Each of these has a default value as shown below export interface ILibraryConfiguration { /** * Allows caching to be global disabled, default: false */ globalCacheDisable?: boolean; /** * Defines the default store used by the usingCaching method, default: session */ defaultCachingStore?: \"session\" | \"local\"; /** * Defines the default timeout in seconds used by the usingCaching method, default 30 */ defaultCachingTimeoutSeconds?: number; /** * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval */ enableCacheExpiration?: boolean; /** * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) */ cacheExpirationIntervalMilliseconds?: number; /** * Used to supply the current context from an SPFx webpart to the library */ spfxContext?: any; }","title":"ILibraryConfiguration Interface"},{"location":"v2/common/libconfig/#runtimeconfigimpl","text":"The class which implements the runtime configuration management as well as sets the default values used within the library. At its heart lies a Dictionary used to track the configuration values. The keys will match the values in the interface or plain object passed to the extend method.","title":"RuntimeConfigImpl"},{"location":"v2/common/libconfig/#assign","text":"The assign method is used to add configuration to the global configuration instance. You can pass it any plain object with string keys and those values will be added. Any existing values will be overwritten based on the keys. Last value in wins. For a more detailed scenario of using the RuntimeConfig instance in your own application please see the section below \"Using RuntimeConfig within your application\". Note there are no methods to remove/clear the global config as it should be considered fairly static as frequent updates may have unpredictable side effects as it is a global shared object. Generally it should be set at the start of your application. import { RuntimeConfig } from \"@pnp/core\"; // add your custom keys to the global configuration // note you can use object hashes as values RuntimeConfig.assign({ \"myKey1\": \"value 1\", \"myKey2\": { \"subKey\": \"sub value 1\", \"subKey2\": \"sub value 2\", }, }); // read your custom values const v = RuntimeConfig.get(\"myKey1\"); // \"value 1\"","title":"assign"},{"location":"v2/common/libconfig/#using-runtimeconfig-within-your-application","text":"If you have a set of properties you will access very frequently it may be desirable to implement your own configuration object and expose those values as properties. To do so you will need to create an interface for your configuration (optional) and a wrapper class for RuntimeConfig to expose your properties import { ILibraryConfiguration, RuntimeConfig, ITypedHash } from \"@pnp/core\"; // first we create our own interface by extending LibraryConfiguration. This allows your class to accept all the values with correct type checking. Note, because // TypeScript allows you to extend from multiple interfaces you can build a complex configuration definition from many sub definitions. // create the interface of your properties // by creating this separately you allows others to compose your parts into their own config interface MyConfigurationPart { // you can create a grouped definition and access your settings as an object // keys can be optional or required as defined by your interface my?: { prop1?: string; prop2?: string; } // and/or define multiple top level properties (beware key collision) // it is good practice to use a unique prefix myProp1: string; myProp2: number; } // now create a combined interface interface MyConfiguration extends ILibraryConfiguration, MyConfigurationPart { } // now create a wrapper object and expose your properties class MyRuntimeConfigImpl { // exposing a nested property public get prop1(): ITypedHash<string> { const myPart = RuntimeConfig.get(\"my\"); if (myPart !== null && typeof myPart !== \"undefined\" && typeof myPart.prop1 !== \"undefined\") { return myPart.prop1; } return {}; } // exposing a root level property public get myProp1(): string | null { let myProp1 = RuntimeConfig.get(\"myProp1\"); if (myProp1 === null) { myProp1 = \"some default value\"; } return myProp1; } setup(config: MyConfiguration): void { RuntimeConfig.assign(config); } } // create a single static instance of your impl class export let MyRuntimeConfig = new MyRuntimeConfigImpl(); Now in other files you can use and set your configuration with a typed interface and properties import { MyRuntimeConfig } from \"{location of module}\"; MyRuntimeConfig.setup({ my: { prop1: \"hello\", }, }); const value = MyRuntimeConfig.myProp1; // \"hello\"","title":"Using RuntimeConfig within your Application"},{"location":"v2/common/netutil/","text":"@pnp/core/net \u00b6 This module contains a set of classes and interfaces used to characterize shared http interactions and configuration of the libraries. Some of the interfaces are described below (many have no use outside the library) as well as several classes. Interfaces \u00b6 HttpClientImpl \u00b6 Defines an implementation of an Http Client within the context of @pnp. This being a class with a a single method \"fetch\" takes a URL and options. It returns a Promise<Response> . Used primarily with the shared request pipeline to define the client used to make the actual request. You can write your own custom implementation if needed. RequestClient \u00b6 An abstraction that contains specific methods related to each of the primary request methods get, post, patch, delete as well as fetch and fetchRaw. The difference between fetch and fetchRaw is that a client may include additional logic or processing in fetch, where fetchRaw should be a direct call to the underlying HttpClientImpl fetch method. Classes \u00b6 This module export two classes of note, FetchClient and BearerTokenFetchClient. Both implement HttpClientImpl. FetchClient \u00b6 Basic implementation that calls the global (window) fetch method with no additional processing. import { FetchClient } from \"@pnp/core\"; const client = new FetchClient(); client.fetch(\"{url}\", {}); BearerTokenFetchClient \u00b6 A simple implementation that takes a provided authentication token and adds the Authentication Bearer header to the request. No other processing is done and the token is treated as a static string. import { BearerTokenFetchClient } from \"@pnp/core\"; const client = new BearerTokenFetchClient(\"{authentication token}\"); client.fetch(\"{url}\", {});","title":"@pnp/core/net"},{"location":"v2/common/netutil/#pnpcorenet","text":"This module contains a set of classes and interfaces used to characterize shared http interactions and configuration of the libraries. Some of the interfaces are described below (many have no use outside the library) as well as several classes.","title":"@pnp/core/net"},{"location":"v2/common/netutil/#interfaces","text":"","title":"Interfaces"},{"location":"v2/common/netutil/#httpclientimpl","text":"Defines an implementation of an Http Client within the context of @pnp. This being a class with a a single method \"fetch\" takes a URL and options. It returns a Promise<Response> . Used primarily with the shared request pipeline to define the client used to make the actual request. You can write your own custom implementation if needed.","title":"HttpClientImpl"},{"location":"v2/common/netutil/#requestclient","text":"An abstraction that contains specific methods related to each of the primary request methods get, post, patch, delete as well as fetch and fetchRaw. The difference between fetch and fetchRaw is that a client may include additional logic or processing in fetch, where fetchRaw should be a direct call to the underlying HttpClientImpl fetch method.","title":"RequestClient"},{"location":"v2/common/netutil/#classes","text":"This module export two classes of note, FetchClient and BearerTokenFetchClient. Both implement HttpClientImpl.","title":"Classes"},{"location":"v2/common/netutil/#fetchclient","text":"Basic implementation that calls the global (window) fetch method with no additional processing. import { FetchClient } from \"@pnp/core\"; const client = new FetchClient(); client.fetch(\"{url}\", {});","title":"FetchClient"},{"location":"v2/common/netutil/#bearertokenfetchclient","text":"A simple implementation that takes a provided authentication token and adds the Authentication Bearer header to the request. No other processing is done and the token is treated as a static string. import { BearerTokenFetchClient } from \"@pnp/core\"; const client = new BearerTokenFetchClient(\"{authentication token}\"); client.fetch(\"{url}\", {});","title":"BearerTokenFetchClient"},{"location":"v2/common/storage/","text":"@pnp/core/storage \u00b6 This module provides a thin wrapper over the browser storage options, local and session. If neither option is available it shims storage with a non-persistent in memory polyfill. Optionally through configuration you can activate expiration. Sample usage is shown below. PnPClientStorage \u00b6 The main export of this module, contains properties representing local and session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); const myvalue = storage.local.get(\"mykey\"); PnPClientStorageWrapper \u00b6 Each of the storage locations (session and local) are wrapped with this helper class. You can use it directly, but generally it would be used from an instance of PnPClientStorage as shown below. These examples all use local storage, the operations are identical for session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // get a value from storage const value = storage.local.get(\"mykey\"); // put a value into storage storage.local.put(\"mykey2\", \"my value\"); // put a value into storage with an expiration storage.local.put(\"mykey2\", \"my value\", new Date()); // put a simple object into storage // because JSON.stringify is used to package the object we do NOT do a deep rehydration of stored objects storage.local.put(\"mykey3\", { key: \"value\", key2: \"value2\", }); // remove a value from storage storage.local.delete(\"mykey3\"); // get an item or add it if it does not exist // returns a promise in case you need time to get the value for storage // optionally takes a third parameter specifying the expiration storage.local.getOrPut(\"mykey4\", () => { return Promise.resolve(\"value\"); }); // delete expired items storage.local.deleteExpired(); Cache Expiration \u00b6 The ability remove of expired items based on a configured timeout can help if the cache is filling up. This can be accomplished in two ways. The first is to explicitly call the new deleteExpired method on the cache you wish to clear. A suggested usage is to add this into your page init code as clearing expired items once per page load is likely sufficient. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // session storage storage.session.deleteExpired(); // local storage storage.local.deleteExpired(); // this returns a promise, so you can perform some activity after the expired items are removed: storage.local.deleteExpired().then(_ => { // init my application }); The second method is to enable automated cache expiration through global config. Setting the enableCacheExpiration property to true will enable the timer. Optionally you can set the interval at which the cache is checked via the cacheExpirationIntervalMilliseconds property, by default 750 milliseconds is used. We enforce a minimum of 300 milliseconds as this functionality is enabled via setTimeout and there is little value in having an excessive number of cache checks. This method is more appropriate for a single page application where the page is infrequently reloaded and many cached operations are performed. There is no advantage to enabling cache expiration unless you are experiencing cache storage space pressure in a long running page - and you may see a performance hit due to the use of setTimeout. import { setup } from \"@pnp/core\"; setup({ enableCacheExpiration: true, cacheExpirationIntervalMilliseconds: 1000, // optional });","title":"@pnp/core/storage"},{"location":"v2/common/storage/#pnpcorestorage","text":"This module provides a thin wrapper over the browser storage options, local and session. If neither option is available it shims storage with a non-persistent in memory polyfill. Optionally through configuration you can activate expiration. Sample usage is shown below.","title":"@pnp/core/storage"},{"location":"v2/common/storage/#pnpclientstorage","text":"The main export of this module, contains properties representing local and session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); const myvalue = storage.local.get(\"mykey\");","title":"PnPClientStorage"},{"location":"v2/common/storage/#pnpclientstoragewrapper","text":"Each of the storage locations (session and local) are wrapped with this helper class. You can use it directly, but generally it would be used from an instance of PnPClientStorage as shown below. These examples all use local storage, the operations are identical for session storage. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // get a value from storage const value = storage.local.get(\"mykey\"); // put a value into storage storage.local.put(\"mykey2\", \"my value\"); // put a value into storage with an expiration storage.local.put(\"mykey2\", \"my value\", new Date()); // put a simple object into storage // because JSON.stringify is used to package the object we do NOT do a deep rehydration of stored objects storage.local.put(\"mykey3\", { key: \"value\", key2: \"value2\", }); // remove a value from storage storage.local.delete(\"mykey3\"); // get an item or add it if it does not exist // returns a promise in case you need time to get the value for storage // optionally takes a third parameter specifying the expiration storage.local.getOrPut(\"mykey4\", () => { return Promise.resolve(\"value\"); }); // delete expired items storage.local.deleteExpired();","title":"PnPClientStorageWrapper"},{"location":"v2/common/storage/#cache-expiration","text":"The ability remove of expired items based on a configured timeout can help if the cache is filling up. This can be accomplished in two ways. The first is to explicitly call the new deleteExpired method on the cache you wish to clear. A suggested usage is to add this into your page init code as clearing expired items once per page load is likely sufficient. import { PnPClientStorage } from \"@pnp/core\"; const storage = new PnPClientStorage(); // session storage storage.session.deleteExpired(); // local storage storage.local.deleteExpired(); // this returns a promise, so you can perform some activity after the expired items are removed: storage.local.deleteExpired().then(_ => { // init my application }); The second method is to enable automated cache expiration through global config. Setting the enableCacheExpiration property to true will enable the timer. Optionally you can set the interval at which the cache is checked via the cacheExpirationIntervalMilliseconds property, by default 750 milliseconds is used. We enforce a minimum of 300 milliseconds as this functionality is enabled via setTimeout and there is little value in having an excessive number of cache checks. This method is more appropriate for a single page application where the page is infrequently reloaded and many cached operations are performed. There is no advantage to enabling cache expiration unless you are experiencing cache storage space pressure in a long running page - and you may see a performance hit due to the use of setTimeout. import { setup } from \"@pnp/core\"; setup({ enableCacheExpiration: true, cacheExpirationIntervalMilliseconds: 1000, // optional });","title":"Cache Expiration"},{"location":"v2/common/util/","text":"@pnp/core/util \u00b6 This module contains utility methods that you can import individually from the common library. import { getRandomString, } from \"@pnp/core\"; // use from individually imported method console.log(getRandomString(10)); assign \u00b6 Merges a source object's own enumerable properties into a single target object. Similar to Object.assign, but allows control of overwriting of existing properties. import { assign } from \"@pnp/core\"; let obj1 = { prop: 1, prop2: 2, }; const obj2 = { prop: 4, prop3: 9, }; const example1 = assign(obj1, obj2); // example1 = { prop: 4, prop2: 2, prop3: 9 } //noOverwrite = true stops overwriting existing properties const example2 = assign(obj1, obj2, true); // example2 = { prop: 1, prop2: 2, prop3: 9 } combine \u00b6 Combines any number of paths, normalizing the slashes as required import { combine } from \"@pnp/core\"; // \"https://microsoft.com/something/more\" const paths = combine(\"https://microsoft.com\", \"something\", \"more\"); // \"also/works/with/relative\" const paths2 = combine(\"/also/\", \"/works\", \"with/\", \"/relative\\\\\"); dateAdd \u00b6 Manipulates a date, please see the Stack Overflow discussion from where this method was taken. import { dateAdd } from \"@pnp/core\"; const testDate = new Date(); dateAdd(testDate,'minute',10); getCtxCallback \u00b6 Gets a callback function which will maintain context across async calls. import { getCtxCallback } from \"@pnp/core\"; const contextThis = { myProp: 6, }; function theFunction() { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp; } const callback = getCtxCallback(contextThis, theFunction); callback(); // returns 6 // You can also supply additional parameters if needed function theFunction2(g: number) { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp + g; } const callback2 = getCtxCallback(contextThis, theFunction2, 4); callback2(); // returns 10 (6 + 4) getGUID \u00b6 Creates a random guid, please see the Stack Overflow discussion from where this method was taken. import { getGUID } from \"@pnp/core\"; const newGUID = getGUID(); getRandomString \u00b6 Gets a random string consisting of the number of characters requested. import { getRandomString } from \"@pnp/core\"; const randomString = getRandomString(10); hOP \u00b6 Shortcut for Object.hasOwnProperty. Determines if an object has a specified property. import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { //Checks to see if the error object has a property called isHttpRequestError. Returns a bool. if (hOP(e, \"isHttpRequestError\")) { // Handle this type or error } else { // not an HttpRequestError so we do something else } } isArray \u00b6 Determines if a supplied variable represents an array. import { isArray } from \"@pnp/core\"; let x:String[] = [1,2,3]]; if (isArray(x)){ console.log(\"I am an array\"); }else{ console.log(\"I am not an array\"); } isFunc \u00b6 Determines if a supplied variable represents a function. import { isFunc } from \"@pnp/core\"; public testFunction() { console.log(\"test function\"); return } if (isFunc(testFunction)){ console.log(\"this is a function\"); testFunction(); } isUrlAbsolute \u00b6 Determines if a supplied url is absolute and returns true; otherwise returns false. import { isUrlAbsolute } from \"@pnp/core\"; const webPath = 'https://{tenant}.sharepoint.com/sites/dev/'; if (isUrlAbsolute(webPath)){ console.log(\"URL is absolute\"); }else{ console.log(\"URL is not absolute\"); } objectDefinedNotNull \u00b6 Determines if an object is defined and not null. import { objectDefinedNotNull } from \"@pnp/core\"; let obj = { prop: 1 }; if (objectDefinedNotNull(obj)){ console.log(\"Not null\"); }else{ console.log(\"Null\"); } stringIsNullOrEmpty \u00b6 Determines if a supplied string is null or empty. import { stringIsNullOrEmpty } from \"@pnp/core\"; let x:String = \"hello\"; if (stringIsNullOrEmpty(x)){ console.log(\"Null or empty\"); }else{ console.log(\"Not null or empty\"); } Removed \u00b6 Some methods that were no longer used internally by the @pnp libraries have been removed. You can find the source for those methods below for use in your projects should you require. /** * Loads a stylesheet into the current page * * @param path The url to the stylesheet * @param avoidCache If true a value will be appended as a query string to avoid browser caching issues */ public static loadStylesheet(path: string, avoidCache: boolean): void { if (avoidCache) { path += \"?\" + encodeURIComponent((new Date()).getTime().toString()); } const head = document.getElementsByTagName(\"head\"); if (head.length > 0) { const e = document.createElement(\"link\"); head[0].appendChild(e); e.setAttribute(\"type\", \"text/css\"); e.setAttribute(\"rel\", \"stylesheet\"); e.setAttribute(\"href\", path); } } /** * Tests if a url param exists * * @param name The name of the url parameter to check */ public static urlParamExists(name: string): boolean { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); return regex.test(location.search); } /** * Gets a url param value by name * * @param name The name of the parameter for which we want the value */ public static getUrlParamByName(name: string): string { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); const results = regex.exec(location.search); return results == null ? \"\" : decodeURIComponent(results[1].replace(/\\+/g, \" \")); } /** * Gets a url param by name and attempts to parse a bool value * * @param name The name of the parameter for which we want the boolean value */ public static getUrlParamBoolByName(name: string): boolean { const p = this.getUrlParamByName(name); const isFalse = (p === \"\" || /false|0/i.test(p)); return !isFalse; } /** * Inserts the string s into the string target as the index specified by index * * @param target The string into which we will insert s * @param index The location in target to insert s (zero based) * @param s The string to insert into target at position index */ public static stringInsert(target: string, index: number, s: string): string { if (index > 0) { return target.substring(0, index) + s + target.substring(index, target.length); } return s + target; }","title":"@pnp/core/util"},{"location":"v2/common/util/#pnpcoreutil","text":"This module contains utility methods that you can import individually from the common library. import { getRandomString, } from \"@pnp/core\"; // use from individually imported method console.log(getRandomString(10));","title":"@pnp/core/util"},{"location":"v2/common/util/#assign","text":"Merges a source object's own enumerable properties into a single target object. Similar to Object.assign, but allows control of overwriting of existing properties. import { assign } from \"@pnp/core\"; let obj1 = { prop: 1, prop2: 2, }; const obj2 = { prop: 4, prop3: 9, }; const example1 = assign(obj1, obj2); // example1 = { prop: 4, prop2: 2, prop3: 9 } //noOverwrite = true stops overwriting existing properties const example2 = assign(obj1, obj2, true); // example2 = { prop: 1, prop2: 2, prop3: 9 }","title":"assign"},{"location":"v2/common/util/#combine","text":"Combines any number of paths, normalizing the slashes as required import { combine } from \"@pnp/core\"; // \"https://microsoft.com/something/more\" const paths = combine(\"https://microsoft.com\", \"something\", \"more\"); // \"also/works/with/relative\" const paths2 = combine(\"/also/\", \"/works\", \"with/\", \"/relative\\\\\");","title":"combine"},{"location":"v2/common/util/#dateadd","text":"Manipulates a date, please see the Stack Overflow discussion from where this method was taken. import { dateAdd } from \"@pnp/core\"; const testDate = new Date(); dateAdd(testDate,'minute',10);","title":"dateAdd"},{"location":"v2/common/util/#getctxcallback","text":"Gets a callback function which will maintain context across async calls. import { getCtxCallback } from \"@pnp/core\"; const contextThis = { myProp: 6, }; function theFunction() { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp; } const callback = getCtxCallback(contextThis, theFunction); callback(); // returns 6 // You can also supply additional parameters if needed function theFunction2(g: number) { // \"this\" within this function will be the context object supplied // in this case the variable contextThis, so myProp will exist return this.myProp + g; } const callback2 = getCtxCallback(contextThis, theFunction2, 4); callback2(); // returns 10 (6 + 4)","title":"getCtxCallback"},{"location":"v2/common/util/#getguid","text":"Creates a random guid, please see the Stack Overflow discussion from where this method was taken. import { getGUID } from \"@pnp/core\"; const newGUID = getGUID();","title":"getGUID"},{"location":"v2/common/util/#getrandomstring","text":"Gets a random string consisting of the number of characters requested. import { getRandomString } from \"@pnp/core\"; const randomString = getRandomString(10);","title":"getRandomString"},{"location":"v2/common/util/#hop","text":"Shortcut for Object.hasOwnProperty. Determines if an object has a specified property. import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { //Checks to see if the error object has a property called isHttpRequestError. Returns a bool. if (hOP(e, \"isHttpRequestError\")) { // Handle this type or error } else { // not an HttpRequestError so we do something else } }","title":"hOP"},{"location":"v2/common/util/#isarray","text":"Determines if a supplied variable represents an array. import { isArray } from \"@pnp/core\"; let x:String[] = [1,2,3]]; if (isArray(x)){ console.log(\"I am an array\"); }else{ console.log(\"I am not an array\"); }","title":"isArray"},{"location":"v2/common/util/#isfunc","text":"Determines if a supplied variable represents a function. import { isFunc } from \"@pnp/core\"; public testFunction() { console.log(\"test function\"); return } if (isFunc(testFunction)){ console.log(\"this is a function\"); testFunction(); }","title":"isFunc"},{"location":"v2/common/util/#isurlabsolute","text":"Determines if a supplied url is absolute and returns true; otherwise returns false. import { isUrlAbsolute } from \"@pnp/core\"; const webPath = 'https://{tenant}.sharepoint.com/sites/dev/'; if (isUrlAbsolute(webPath)){ console.log(\"URL is absolute\"); }else{ console.log(\"URL is not absolute\"); }","title":"isUrlAbsolute"},{"location":"v2/common/util/#objectdefinednotnull","text":"Determines if an object is defined and not null. import { objectDefinedNotNull } from \"@pnp/core\"; let obj = { prop: 1 }; if (objectDefinedNotNull(obj)){ console.log(\"Not null\"); }else{ console.log(\"Null\"); }","title":"objectDefinedNotNull"},{"location":"v2/common/util/#stringisnullorempty","text":"Determines if a supplied string is null or empty. import { stringIsNullOrEmpty } from \"@pnp/core\"; let x:String = \"hello\"; if (stringIsNullOrEmpty(x)){ console.log(\"Null or empty\"); }else{ console.log(\"Not null or empty\"); }","title":"stringIsNullOrEmpty"},{"location":"v2/common/util/#removed","text":"Some methods that were no longer used internally by the @pnp libraries have been removed. You can find the source for those methods below for use in your projects should you require. /** * Loads a stylesheet into the current page * * @param path The url to the stylesheet * @param avoidCache If true a value will be appended as a query string to avoid browser caching issues */ public static loadStylesheet(path: string, avoidCache: boolean): void { if (avoidCache) { path += \"?\" + encodeURIComponent((new Date()).getTime().toString()); } const head = document.getElementsByTagName(\"head\"); if (head.length > 0) { const e = document.createElement(\"link\"); head[0].appendChild(e); e.setAttribute(\"type\", \"text/css\"); e.setAttribute(\"rel\", \"stylesheet\"); e.setAttribute(\"href\", path); } } /** * Tests if a url param exists * * @param name The name of the url parameter to check */ public static urlParamExists(name: string): boolean { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); return regex.test(location.search); } /** * Gets a url param value by name * * @param name The name of the parameter for which we want the value */ public static getUrlParamByName(name: string): string { name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\"); const regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"); const results = regex.exec(location.search); return results == null ? \"\" : decodeURIComponent(results[1].replace(/\\+/g, \" \")); } /** * Gets a url param by name and attempts to parse a bool value * * @param name The name of the parameter for which we want the boolean value */ public static getUrlParamBoolByName(name: string): boolean { const p = this.getUrlParamByName(name); const isFalse = (p === \"\" || /false|0/i.test(p)); return !isFalse; } /** * Inserts the string s into the string target as the index specified by index * * @param target The string into which we will insert s * @param index The location in target to insert s (zero based) * @param s The string to insert into target at position index */ public static stringInsert(target: string, index: number, s: string): string { if (index > 0) { return target.substring(0, index) + s + target.substring(index, target.length); } return s + target; }","title":"Removed"},{"location":"v2/concepts/configuration/","text":"PnPjs Configuration \u00b6 This article describes the configuration architecture used by the library as well as the settings available. Starting with version 2.1.0 we updated our configuration design to support the ability to isolate settings to individual objects. The first part of this article discusses the newer design, you can read about the pre v2.1.0 configuration further down. Post v2.1.0 \u00b6 Architecture \u00b6 Starting from v2.1.0 we have modified our configuration design to allow for configuring individual queryable objects. Backward Compatibility \u00b6 If you have no need to use the isolated runtimes introduced in 2.1.0 then you should see no change in library behavior from prior versions. You can continue to refer to the pre v2.1.0 configuration section - and if you see any issues please let us know. All of the available settings as described below remain, unchanged. If you previously used our internal configuration classes directly RuntimeConfigImpl, SPRuntimeConfigImpl, or GraphRuntimeConfigImpl they no longer exist. We do not consider this a breaking change as they were meant to be internal and their direct use was not documented. This includes the concrete default instances RuntimeConfig, SPRuntimeConfig, and GraphRuntimeConfig. Isolated Runtimes \u00b6 You can create an isolated runtime when using either the sp or graph libraries. What this does is create an isolated set of properties and behaviors specific to a given fluent chain. Have a look at this basic example below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuration applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuration applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the web at https://mytenant.sharepoint.com/ const web1 = await sp.web(); // details for the web at https://mytenant.sharepoint.com/sites/dev const web2 = await isolatedSP.web(); This configuration is supplied to all objects down a given fluent chain: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuraiton applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuraiton applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the lists at https://mytenant.sharepoint.com/ const lists1 = await sp.web.lists(); // details for the lists at https://mytenant.sharepoint.com/sites/dev const lists2 = await isolatedSP.web.lists(); createIsolated \u00b6 The createIsolated method is used to establish the isolated runtime for a given instance of either the sp or graph libraries. Once created it is no longer connected to the default instance and if you have common settings that must be updated you would need to update them across each isolated instance, this is by design. Currently sp and graph createIsolated methods accept the same init, but we have broken them out to make thing clear. All properties of the init object are optional. Any properties provided will overwrite those cloned from the default if cloneGlobal is true. If cloneGlobal is false you start with an empty config containing only the core defaults . sp.createIsolated \u00b6 import { sp, ISPConfiguration } from \"@pnp/sp\"; // accept all the defaults, will clone any settings from sp const isolatedSP = await sp.createIsolated(); // - specify all the config options, using the ISPConfiguration interface to type the config // - setting baseUrl in the root is equivelent to setting it with sp: { baseUrl: }, it is provided as a shortcut as this seemed to be a common use case // - if you set them both the baseUrl in the root will be used. // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedSP = await sp.createIsolated<ISPConfiguration>({ baseUrl: \"https://mytenant.sharepoint.com\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, sp: { baseUrl: \"https://mytenant.sharepoint.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, }); Defaults Name Default baseUrl \"\" cloneGlobal true config {} options {} graph.createIsolated \u00b6 import { graph, IGraphConfiguration } from \"@pnp/graph\"; // - specify all the config options, using the IGraphConfiguration interface to type the config // - setting baseUrl in the root is restricted to \"v1.0\" or \"beta\". If you need to specify a different absolute url should use config.graph.baseUrl // - in practice you should use one or the other. You can always swap Graph api version using IGraphQueryable.setEndpoint // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedGraph = await graph.createIsolated<IGraphConfiguration>({ baseUrl: \"v1.0\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, graph: { baseUrl: \"https://graph.microsoft.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, }); Defaults \u00b6 name Default baseUrl \"v1.0\" cloneGlobal true config {} options {} Additional Examples \u00b6 MSAL with Node multiple site requests \u00b6 MSAL Support Added in 2.0.11 In this example you can see how you can setup the MSAL client once and then set a different baseUrl for an isolated instance. More information specific to setting up the MSAL client is available . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev2/\", }, }, }); Node multiple site requests \u00b6 Isolated configuration was most requested for scenarios in node where you need to access information in multiple sites. This example shows setting up the global configuration and then creating an isolated config with only the baseUrl updated. import { SPFetchClient } from \"@pnp/nodejs\"; import { ISPConfigurationPart, sp } from \"@pnp/sp\"; sp.setup({ cacheExpirationIntervalMilliseconds: 1000, defaultCachingStore: \"local\", sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/\", \"id\", \"secret\"); }, headers: { \"X-MyRequiredHeader\": \"SomeValue\", \"X-MyRequiredHeader2\": \"SomeValue\", }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/site/dev\", \"id\", \"secret\"); }, }, }, }); Batching \u00b6 All batching functionality works as expected, but you must take care to only associate requests from the same isolated instance as you create the batch. Mixing requests across isolation boundaries is not supported. This applies to sp and graph batching. sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"url1\", \"id\", \"secret\"); }, }, }); const isolated = await sp.createIsolated<ISPConfiguration>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"url2\", \"id\", \"secret\"); }, }, }, }); const batch1 = sp.createBatch(); sp.web.lists.select(\"Title\").top(3).inBatch(batch1)().then(r => console.log(`here 1: ${JSON.stringify(r, null, 2)}`)); sp.web.select(\"Title\").inBatch(batch1)().then(r => console.log(`here 2: ${JSON.stringify(r, null, 2)}`)); await batch1.execute(); const batch2 = isolated.createBatch(); isolated.web.lists.select(\"Title\").top(3).inBatch(batch2)().then(r => console.log(`here 3: ${JSON.stringify(r, null, 2)}`)); isolated.web.select(\"Title\").inBatch(batch2)().then(r => console.log(`here 4: ${JSON.stringify(r, null, 2)}`)); await batch2.execute(); IE11 Mode \u00b6 The IE11 mode setting is always global. There is no scenario we care to support where once instance needs to run in ie11 mode and another does not. Your code either does or does not run in ie11. Prior to v2.1.0 \u00b6 Architecture \u00b6 PnPjs uses an additive configuration design with multiple libraries sharing a single global configuration instance. If you need non-global configuration please see this section . There are three ways to access the setup functionality - through either the common, sp, or graph library's setup method. While the configuration is global the various methods have different typing on their input parameter. You can review the libconfig article for more details on storing your own configuration. Common Configuration \u00b6 The common libary's setup method takes parameters defined by ILibraryConfiguration . The properties and their defaults are listed below, followed by a code sample. You can call setup multiple times and any new values will be added to the existing configuration or replace the previous value if one existed. All values are optional. Name Description Default defaultCachingStore Where will PnPjs store cached data by default (session or local) session defaultCachingTimeoutSeconds The global default value used for cached data timeouts in seconds 60 globalCacheDisable Provides a way to globally within PnPjs disable all caching false enableCacheExpiration If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval false cacheExpirationIntervalMilliseconds Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) 750 spfxContext When running in SPFx the current context should always be supplied to PnPjs when available null ie11 If true the library downgrades functionality to work in IE11 false For more information on setting up in SPFx please see the authentication section For more details on ie11 mode please see the topic article import { setup } from \"@pnp/core\"; // called before other code setup({ cacheExpirationIntervalMilliseconds: 15000, defaultCachingStore: \"local\", defaultCachingTimeoutSeconds: 600, enableCacheExpiration: true, globalCacheDisable: false, ie11: false, spfxContext: this.context, // if in SPFx, otherwise leave it out }); SP Configuration \u00b6 The sp library's configuration is defined by the ISPConfiguration interface which extends ILibraryConfiguration. All of the sp values are contained in a top level property named \"sp\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { sp } from \"@pnp/sp\"; import { SPFxAdalClient } from \"@pnp/core\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration sp.setup({ ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", fetchClientFactory: () => { return new SPFxAdalClient(this.context); }, headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, }); SharePoint Framework \u00b6 You can optionally supply only the SPFx context to the sp configure method. import { sp } from \"@pnp/sp\"; // in SPFx only sp.setup(this.context); Graph Configuration \u00b6 The graph configuration works exactly the same as the sp configuration but is defined by the IGraphConfiguration interface which extends ILibraryConfiguration. All of the graph values are contained in a top level property named \"graph\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. ( Added in 2.0.8 ) none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { graph } from \"@pnp/graph\"; import { MsalClientSetup } from \"@pnp/msaljsclient\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration graph.setup({ ie11: false, graph: { // we set the GCC url baseUrl: \"https://graph.microsoft.us\", fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, }); SharePoint Framework \u00b6 You can optionally supply only the SPFx context to the graph configure method. We will attempt to set the baseUrl property from the context - but if that is failing in your environment and you need to call a special cloud (i.e. graph.microsoft.us) please set the baseUrl property. import { graph } from \"@pnp/graph\"; // in SPFx only graph.setup(this.context); Configure Everything At Once \u00b6 In some cases you might want to configure everything in one go. Because the configuration is stored in a single location you can use the common library's setup method and adjust the typings to ensure you are using the correct property names while only having to setup things with a single call. In versions before 2.0.8 ISPConfigurationPart, IGraphConfigurationPart, and ILibraryConfiguration incorrectly were missing the \"I\" prefix. That was fixed in 2.0.8 - but note if you are using an older version of the library you'll need to use the old names. Everything else in the below example works as expected. import { ISPConfigurationPart } from \"@pnp/sp\"; import { IGraphConfigurationPart } from \"@pnp/graph\"; import { ILibraryConfiguration, setup } from \"@pnp/core\"; // you could also include your custom configuration parts export interface AllConfig extends ILibraryConfiguration, ISPConfigurationPart, IGraphConfigurationPart { } // create a single big configuration entry const config: AllConfig = { graph: { baseUrl: \"https://graph.microsoft.us\", }, ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", }, }; setup(config);","title":"PnPjs Configuration"},{"location":"v2/concepts/configuration/#pnpjs-configuration","text":"This article describes the configuration architecture used by the library as well as the settings available. Starting with version 2.1.0 we updated our configuration design to support the ability to isolate settings to individual objects. The first part of this article discusses the newer design, you can read about the pre v2.1.0 configuration further down.","title":"PnPjs Configuration"},{"location":"v2/concepts/configuration/#post-v210","text":"","title":"Post v2.1.0"},{"location":"v2/concepts/configuration/#architecture","text":"Starting from v2.1.0 we have modified our configuration design to allow for configuring individual queryable objects.","title":"Architecture"},{"location":"v2/concepts/configuration/#backward-compatibility","text":"If you have no need to use the isolated runtimes introduced in 2.1.0 then you should see no change in library behavior from prior versions. You can continue to refer to the pre v2.1.0 configuration section - and if you see any issues please let us know. All of the available settings as described below remain, unchanged. If you previously used our internal configuration classes directly RuntimeConfigImpl, SPRuntimeConfigImpl, or GraphRuntimeConfigImpl they no longer exist. We do not consider this a breaking change as they were meant to be internal and their direct use was not documented. This includes the concrete default instances RuntimeConfig, SPRuntimeConfig, and GraphRuntimeConfig.","title":"Backward Compatibility"},{"location":"v2/concepts/configuration/#isolated-runtimes","text":"You can create an isolated runtime when using either the sp or graph libraries. What this does is create an isolated set of properties and behaviors specific to a given fluent chain. Have a look at this basic example below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuration applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuration applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the web at https://mytenant.sharepoint.com/ const web1 = await sp.web(); // details for the web at https://mytenant.sharepoint.com/sites/dev const web2 = await isolatedSP.web(); This configuration is supplied to all objects down a given fluent chain: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // create an isolated sp root instance const isolatedSP = await sp.createIsolated(); // this configuraiton applies to all objects created from \"sp\" sp.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/\", }, }); // this configuraiton applies to all objects created from \"isolatedSP\" isolatedSP.setup({ sp: { baseUrl: \"https://mytenant.sharepoint.com/sites/dev\", }, }); // details for the lists at https://mytenant.sharepoint.com/ const lists1 = await sp.web.lists(); // details for the lists at https://mytenant.sharepoint.com/sites/dev const lists2 = await isolatedSP.web.lists();","title":"Isolated Runtimes"},{"location":"v2/concepts/configuration/#createisolated","text":"The createIsolated method is used to establish the isolated runtime for a given instance of either the sp or graph libraries. Once created it is no longer connected to the default instance and if you have common settings that must be updated you would need to update them across each isolated instance, this is by design. Currently sp and graph createIsolated methods accept the same init, but we have broken them out to make thing clear. All properties of the init object are optional. Any properties provided will overwrite those cloned from the default if cloneGlobal is true. If cloneGlobal is false you start with an empty config containing only the core defaults .","title":"createIsolated"},{"location":"v2/concepts/configuration/#spcreateisolated","text":"import { sp, ISPConfiguration } from \"@pnp/sp\"; // accept all the defaults, will clone any settings from sp const isolatedSP = await sp.createIsolated(); // - specify all the config options, using the ISPConfiguration interface to type the config // - setting baseUrl in the root is equivelent to setting it with sp: { baseUrl: }, it is provided as a shortcut as this seemed to be a common use case // - if you set them both the baseUrl in the root will be used. // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedSP = await sp.createIsolated<ISPConfiguration>({ baseUrl: \"https://mytenant.sharepoint.com\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, sp: { baseUrl: \"https://mytenant.sharepoint.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, }); Defaults Name Default baseUrl \"\" cloneGlobal true config {} options {}","title":"sp.createIsolated"},{"location":"v2/concepts/configuration/#graphcreateisolated","text":"import { graph, IGraphConfiguration } from \"@pnp/graph\"; // - specify all the config options, using the IGraphConfiguration interface to type the config // - setting baseUrl in the root is restricted to \"v1.0\" or \"beta\". If you need to specify a different absolute url should use config.graph.baseUrl // - in practice you should use one or the other. You can always swap Graph api version using IGraphQueryable.setEndpoint // - you can set some or all of the settings in config and if you clone from the global the ones you specify will overwrite the cloned values // - for example your global config can specify everything and your isolated config could specify a different fetchClientFactory, see node example below const isolatedGraph = await graph.createIsolated<IGraphConfiguration>({ baseUrl: \"v1.0\", cloneGlobal: false, config: { cacheExpirationIntervalMilliseconds: 1000, graph: { baseUrl: \"https://graph.microsoft.com\", fetchClientFactory: () => void(0), headers: { \"X-AnotherHeader\": \"54321\", }, }, spfxContext: this.context, // only valid within SPFx }, options: { headers: { \"X-SomeHeader\": \"12345\", }, }, });","title":"graph.createIsolated"},{"location":"v2/concepts/configuration/#defaults","text":"name Default baseUrl \"v1.0\" cloneGlobal true config {} options {}","title":"Defaults"},{"location":"v2/concepts/configuration/#additional-examples","text":"","title":"Additional Examples"},{"location":"v2/concepts/configuration/#msal-with-node-multiple-site-requests","text":"MSAL Support Added in 2.0.11 In this example you can see how you can setup the MSAL client once and then set a different baseUrl for an isolated instance. More information specific to setting up the MSAL client is available . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { readFileSync } from \"fs\"; // read in our private key const buffer = readFileSync(\"c:/temp/key.pem\"); // configure node options sp.setup({ sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev/\", fetchClientFactory: () => { return new MsalFetchClient({ auth: { authority: \"https://login.microsoftonline.com/{tenant id or common}\", clientCertificate: { thumbprint: \"{certificate thumbprint, displayed in AAD}\", privateKey: buffer.toString(), }, clientId: \"{client id}\", } }, [\"https://{my tenant}.sharepoint.com/.default\"]); // you must set the scope for SharePoint access }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { baseUrl: \"https://{my tenant}.sharepoint.com/sites/dev2/\", }, }, });","title":"MSAL with Node multiple site requests"},{"location":"v2/concepts/configuration/#node-multiple-site-requests","text":"Isolated configuration was most requested for scenarios in node where you need to access information in multiple sites. This example shows setting up the global configuration and then creating an isolated config with only the baseUrl updated. import { SPFetchClient } from \"@pnp/nodejs\"; import { ISPConfigurationPart, sp } from \"@pnp/sp\"; sp.setup({ cacheExpirationIntervalMilliseconds: 1000, defaultCachingStore: \"local\", sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/\", \"id\", \"secret\"); }, headers: { \"X-MyRequiredHeader\": \"SomeValue\", \"X-MyRequiredHeader2\": \"SomeValue\", }, }, }); const isolatedSP = await sp.createIsolated<ISPConfigurationPart>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"https://mytenant.sharepoint.com/site/dev\", \"id\", \"secret\"); }, }, }, });","title":"Node multiple site requests"},{"location":"v2/concepts/configuration/#batching","text":"All batching functionality works as expected, but you must take care to only associate requests from the same isolated instance as you create the batch. Mixing requests across isolation boundaries is not supported. This applies to sp and graph batching. sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"url1\", \"id\", \"secret\"); }, }, }); const isolated = await sp.createIsolated<ISPConfiguration>({ config: { sp: { fetchClientFactory: () => { return new SPFetchClient(\"url2\", \"id\", \"secret\"); }, }, }, }); const batch1 = sp.createBatch(); sp.web.lists.select(\"Title\").top(3).inBatch(batch1)().then(r => console.log(`here 1: ${JSON.stringify(r, null, 2)}`)); sp.web.select(\"Title\").inBatch(batch1)().then(r => console.log(`here 2: ${JSON.stringify(r, null, 2)}`)); await batch1.execute(); const batch2 = isolated.createBatch(); isolated.web.lists.select(\"Title\").top(3).inBatch(batch2)().then(r => console.log(`here 3: ${JSON.stringify(r, null, 2)}`)); isolated.web.select(\"Title\").inBatch(batch2)().then(r => console.log(`here 4: ${JSON.stringify(r, null, 2)}`)); await batch2.execute();","title":"Batching"},{"location":"v2/concepts/configuration/#ie11-mode","text":"The IE11 mode setting is always global. There is no scenario we care to support where once instance needs to run in ie11 mode and another does not. Your code either does or does not run in ie11.","title":"IE11 Mode"},{"location":"v2/concepts/configuration/#prior-to-v210","text":"","title":"Prior to v2.1.0"},{"location":"v2/concepts/configuration/#architecture_1","text":"PnPjs uses an additive configuration design with multiple libraries sharing a single global configuration instance. If you need non-global configuration please see this section . There are three ways to access the setup functionality - through either the common, sp, or graph library's setup method. While the configuration is global the various methods have different typing on their input parameter. You can review the libconfig article for more details on storing your own configuration.","title":"Architecture"},{"location":"v2/concepts/configuration/#common-configuration","text":"The common libary's setup method takes parameters defined by ILibraryConfiguration . The properties and their defaults are listed below, followed by a code sample. You can call setup multiple times and any new values will be added to the existing configuration or replace the previous value if one existed. All values are optional. Name Description Default defaultCachingStore Where will PnPjs store cached data by default (session or local) session defaultCachingTimeoutSeconds The global default value used for cached data timeouts in seconds 60 globalCacheDisable Provides a way to globally within PnPjs disable all caching false enableCacheExpiration If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval false cacheExpirationIntervalMilliseconds Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100) 750 spfxContext When running in SPFx the current context should always be supplied to PnPjs when available null ie11 If true the library downgrades functionality to work in IE11 false For more information on setting up in SPFx please see the authentication section For more details on ie11 mode please see the topic article import { setup } from \"@pnp/core\"; // called before other code setup({ cacheExpirationIntervalMilliseconds: 15000, defaultCachingStore: \"local\", defaultCachingTimeoutSeconds: 600, enableCacheExpiration: true, globalCacheDisable: false, ie11: false, spfxContext: this.context, // if in SPFx, otherwise leave it out });","title":"Common Configuration"},{"location":"v2/concepts/configuration/#sp-configuration","text":"The sp library's configuration is defined by the ISPConfiguration interface which extends ILibraryConfiguration. All of the sp values are contained in a top level property named \"sp\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { sp } from \"@pnp/sp\"; import { SPFxAdalClient } from \"@pnp/core\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration sp.setup({ ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", fetchClientFactory: () => { return new SPFxAdalClient(this.context); }, headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, });","title":"SP Configuration"},{"location":"v2/concepts/configuration/#sharepoint-framework","text":"You can optionally supply only the SPFx context to the sp configure method. import { sp } from \"@pnp/sp\"; // in SPFx only sp.setup(this.context);","title":"SharePoint Framework"},{"location":"v2/concepts/configuration/#graph-configuration","text":"The graph configuration works exactly the same as the sp configuration but is defined by the IGraphConfiguration interface which extends ILibraryConfiguration. All of the graph values are contained in a top level property named \"graph\". The following table describes the properties with a code sample following. All values are optional. Name Description Default headers Allows you to apply any headers to all calls made by the sp library none baseUrl Allows you to define a base site url for all requests, takes precedence over all other url logic. Must be absolute. ( Added in 2.0.8 ) none fetchClientFactory Allows you to specify a factory function used to produce IHttpClientImpl instances none There are many examples of using fetchClientFactory available in the authentication section . import { graph } from \"@pnp/graph\"; import { MsalClientSetup } from \"@pnp/msaljsclient\"; // note you can still set the global configuration such as ie11 using the same object as // the interface extends ILibraryConfiguration graph.setup({ ie11: false, graph: { // we set the GCC url baseUrl: \"https://graph.microsoft.us\", fetchClientFactory: MsalClientSetup({ auth: { authority: \"https://login.microsoftonline.com/tenant.onmicrosoft.com\", clientId: \"00000000-0000-0000-0000-000000000000\", redirectUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/test.aspx\", }, }, [\"Group.Read.All\"]), headers: { \"Accept\": \"application/json;odata=verbose\", \"X-Something\": \"header-value\", }, }, spfxContext: this.context, });","title":"Graph Configuration"},{"location":"v2/concepts/configuration/#sharepoint-framework_1","text":"You can optionally supply only the SPFx context to the graph configure method. We will attempt to set the baseUrl property from the context - but if that is failing in your environment and you need to call a special cloud (i.e. graph.microsoft.us) please set the baseUrl property. import { graph } from \"@pnp/graph\"; // in SPFx only graph.setup(this.context);","title":"SharePoint Framework"},{"location":"v2/concepts/configuration/#configure-everything-at-once","text":"In some cases you might want to configure everything in one go. Because the configuration is stored in a single location you can use the common library's setup method and adjust the typings to ensure you are using the correct property names while only having to setup things with a single call. In versions before 2.0.8 ISPConfigurationPart, IGraphConfigurationPart, and ILibraryConfiguration incorrectly were missing the \"I\" prefix. That was fixed in 2.0.8 - but note if you are using an older version of the library you'll need to use the old names. Everything else in the below example works as expected. import { ISPConfigurationPart } from \"@pnp/sp\"; import { IGraphConfigurationPart } from \"@pnp/graph\"; import { ILibraryConfiguration, setup } from \"@pnp/core\"; // you could also include your custom configuration parts export interface AllConfig extends ILibraryConfiguration, ISPConfigurationPart, IGraphConfigurationPart { } // create a single big configuration entry const config: AllConfig = { graph: { baseUrl: \"https://graph.microsoft.us\", }, ie11: false, sp: { baseUrl: \"https://tenant.sharepoint.com/sites/dev\", }, }; setup(config);","title":"Configure Everything At Once"},{"location":"v2/concepts/custom-bundle/","text":"Custom Bundling \u00b6 With the introduction of selective imports it is now possible to create your own bundle to exactly fit your needs. This provides much greater control over how your solutions are deployed and what is included in your bundles. Scenarios could include: Deploying a company-wide PnPjs custom bundle shared by all your components so it only needs to be downloaded once. Creating SPFx libraries either for one project or a single webpart. Create a single library containing the PnPjs code you need bundled along with your custom extensions . Create a custom bundle \u00b6 Webpack \u00b6 You can see/clone a sample project of this example here . Rollup \u00b6 You can see/clone a sample project of this example here .","title":"Custom Bundling"},{"location":"v2/concepts/custom-bundle/#custom-bundling","text":"With the introduction of selective imports it is now possible to create your own bundle to exactly fit your needs. This provides much greater control over how your solutions are deployed and what is included in your bundles. Scenarios could include: Deploying a company-wide PnPjs custom bundle shared by all your components so it only needs to be downloaded once. Creating SPFx libraries either for one project or a single webpart. Create a single library containing the PnPjs code you need bundled along with your custom extensions .","title":"Custom Bundling"},{"location":"v2/concepts/custom-bundle/#create-a-custom-bundle","text":"","title":"Create a custom bundle"},{"location":"v2/concepts/custom-bundle/#webpack","text":"You can see/clone a sample project of this example here .","title":"Webpack"},{"location":"v2/concepts/custom-bundle/#rollup","text":"You can see/clone a sample project of this example here .","title":"Rollup"},{"location":"v2/concepts/error-handling/","text":"Error Handling \u00b6 This article describes the most common types of errors generated by the library. It provides context on the error object, and ways to handle the errors. As always you should tailor your error handling to what your application needs. These are ideas that can be applied to many different patterns. For 429, 503, and 504 errors we include retry logic within the library The HttpRequestError \u00b6 All errors resulting from executed web requests will be returned as an HttpRequestError object which extends the base Error . In addition to the standard Error properties it has some other properties to help you figure out what went wrong. We used a custom error to attempt to normalize what can be a wide assortment of http related errors, while also seeking to provide as much information to library consumers as possible. Property Name Description name Standard Error.name property. Always 'Error' message Normalized string containing the status, status text, and the full response text stack The callstack producing the error isHttpRequestError Always true, allows you to reliably determine if you have an HttpRequestError instance response Unread copy of the Response object resulting in the thrown error status The Response.status value (such as 404) statusText The Response.statusText value (such as 'Not Found') Basic Handling \u00b6 For all operations involving a web request you should account for the possibility they might fail. That failure might be transient or permanent - you won't know until they happen \ud83d\ude09. The most basic type of error handling involves a simple try-catch. import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { console.error(e); } This will produce output like: Error making HttpClient request in queryable [404] Not Found ::> {\"odata.error\":{\"code\":\"-1, System.ArgumentException\",\"message\":{\"lang\":\"en-US\",\"value\":\"List 'no' does not exist at site with URL 'https://tenant.sharepoint.com/sites/dev'.\"}}} Data: {\"response\":{\"size\":0,\"timeout\":0},\"status\":404,\"statusText\":\"Not Found\",\"isHttpRequestError\":true} This is very descriptive and provides full details as to what happened, but you might want to handle things a little more cleanly. Reading the Response \u00b6 In some cases the response body will have additional details such as a localized error messages which can be nicer to display rather than our normalized string. You can read the response directly and process it however you desire: import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { // are we dealing with an HttpRequestError? if (e?.isHttpRequestError) { // we can read the json from the response const json = await (<HttpRequestError>e).response.json(); // if we have a value property we can show it console.log(typeof json[\"odata.error\"] === \"object\" ? json[\"odata.error\"].message.value : e.message); // add of course you have access to the other properties and can make choices on how to act if ((<HttpRequestError>e).status === 404) { console.error((<HttpRequestError>e).statusText); // maybe create the resource, or redirect, or fallback to a secondary data source // just ideas, handle any of the status codes uniquely as needed } } else { // not an HttpRequestError so we just log message console.log(e.message); } } Logging errors \u00b6 Using the PnPjs Logging Framework you can directly pass the error object and the normalized message will be logged. These techniques can be applied to any logging framework. import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { Logger.error(e); } You may want to read the response and customize the message as described above: import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { if (e?.isHttpRequestError) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } } Putting it All Together \u00b6 After reviewing the above section you might have thought it seems like a lot of work to include all that logic for every error. One approach is to establish a single function you use application wide to process errors. This allows all the error handling logic to be easily updated and consistent across the application. errorhandler.ts \u00b6 import { Logger } from \"@pnp/logging\"; import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { if (hOP(e, \"isHttpRequestError\")) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } } web-request.ts \u00b6 import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { await handleError(e); } web-request2.ts \u00b6 import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists(); } catch (e) { await handleError(e); }","title":"Error Handling"},{"location":"v2/concepts/error-handling/#error-handling","text":"This article describes the most common types of errors generated by the library. It provides context on the error object, and ways to handle the errors. As always you should tailor your error handling to what your application needs. These are ideas that can be applied to many different patterns. For 429, 503, and 504 errors we include retry logic within the library","title":"Error Handling"},{"location":"v2/concepts/error-handling/#the-httprequesterror","text":"All errors resulting from executed web requests will be returned as an HttpRequestError object which extends the base Error . In addition to the standard Error properties it has some other properties to help you figure out what went wrong. We used a custom error to attempt to normalize what can be a wide assortment of http related errors, while also seeking to provide as much information to library consumers as possible. Property Name Description name Standard Error.name property. Always 'Error' message Normalized string containing the status, status text, and the full response text stack The callstack producing the error isHttpRequestError Always true, allows you to reliably determine if you have an HttpRequestError instance response Unread copy of the Response object resulting in the thrown error status The Response.status value (such as 404) statusText The Response.statusText value (such as 'Not Found')","title":"The HttpRequestError"},{"location":"v2/concepts/error-handling/#basic-handling","text":"For all operations involving a web request you should account for the possibility they might fail. That failure might be transient or permanent - you won't know until they happen \ud83d\ude09. The most basic type of error handling involves a simple try-catch. import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { console.error(e); } This will produce output like: Error making HttpClient request in queryable [404] Not Found ::> {\"odata.error\":{\"code\":\"-1, System.ArgumentException\",\"message\":{\"lang\":\"en-US\",\"value\":\"List 'no' does not exist at site with URL 'https://tenant.sharepoint.com/sites/dev'.\"}}} Data: {\"response\":{\"size\":0,\"timeout\":0},\"status\":404,\"statusText\":\"Not Found\",\"isHttpRequestError\":true} This is very descriptive and provides full details as to what happened, but you might want to handle things a little more cleanly.","title":"Basic Handling"},{"location":"v2/concepts/error-handling/#reading-the-response","text":"In some cases the response body will have additional details such as a localized error messages which can be nicer to display rather than our normalized string. You can read the response directly and process it however you desire: import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { // are we dealing with an HttpRequestError? if (e?.isHttpRequestError) { // we can read the json from the response const json = await (<HttpRequestError>e).response.json(); // if we have a value property we can show it console.log(typeof json[\"odata.error\"] === \"object\" ? json[\"odata.error\"].message.value : e.message); // add of course you have access to the other properties and can make choices on how to act if ((<HttpRequestError>e).status === 404) { console.error((<HttpRequestError>e).statusText); // maybe create the resource, or redirect, or fallback to a secondary data source // just ideas, handle any of the status codes uniquely as needed } } else { // not an HttpRequestError so we just log message console.log(e.message); } }","title":"Reading the Response"},{"location":"v2/concepts/error-handling/#logging-errors","text":"Using the PnPjs Logging Framework you can directly pass the error object and the normalized message will be logged. These techniques can be applied to any logging framework. import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { Logger.error(e); } You may want to read the response and customize the message as described above: import { Logger } from \"@pnp/logging\"; import { sp } from \"@pnp/sp/presets/all\"; import { HttpRequestError } from \"@pnp/queryable\"; try { // get a list that doesn't exist const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { if (e?.isHttpRequestError) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } }","title":"Logging errors"},{"location":"v2/concepts/error-handling/#putting-it-all-together","text":"After reviewing the above section you might have thought it seems like a lot of work to include all that logic for every error. One approach is to establish a single function you use application wide to process errors. This allows all the error handling logic to be easily updated and consistent across the application.","title":"Putting it All Together"},{"location":"v2/concepts/error-handling/#errorhandlerts","text":"import { Logger } from \"@pnp/logging\"; import { HttpRequestError } from \"@pnp/queryable\"; import { hOP } from \"@pnp/core\"; export async function handleError(e: Error | HttpRequestError): Promise<void> { if (hOP(e, \"isHttpRequestError\")) { // we can read the json from the response const data = await (<HttpRequestError>e).response.json(); // parse this however you want const message = typeof data[\"odata.error\"] === \"object\" ? data[\"odata.error\"].message.value : e.message; // we use the status to determine a custom logging level const level: LogLevel = (<HttpRequestError>e).status === 404 ? LogLevel.Warning : LogLevel.Info; // create a custom log entry Logger.log({ data, level, message, }); } else { // not an HttpRequestError so we just log message Logger.error(e); } }","title":"errorhandler.ts"},{"location":"v2/concepts/error-handling/#web-requestts","text":"import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists.getByTitle(\"no\")(); } catch (e) { await handleError(e); }","title":"web-request.ts"},{"location":"v2/concepts/error-handling/#web-request2ts","text":"import { sp } from \"@pnp/sp/presets/all\"; import { handleError } from \"./errorhandler\"; try { const w = await sp.web.lists(); } catch (e) { await handleError(e); }","title":"web-request2.ts"},{"location":"v2/concepts/ie11-mode/","text":"IE11 Mode \u00b6 Starting with v2 we have made the decision to no longer support IE11. Because we know this affects folks we have introduced IE11 compatibility mode. Configuring the library will allow it to work within IE11, however at a possibly reduced level of functionality depending on your use case. Please see the list below of known limitations. Limitations \u00b6 When required to use IE11 mode there is certain functionality which may not work correctly or at all. Unavailable: Extension Methods Unavailable: OData Debugging Configure IE11 Mode \u00b6 To enable IE11 Mode set the ie11 flag to true in the setup object. Optionally, supply the context object when working in SharePoint Framework . import { sp } from \"@pnp/sp\"; sp.setup({ // set ie 11 mode ie11: true, // only needed when working within SharePoint Framework spfxContext: this.context }); If you are supporting IE 11, please see the article on required polyfills . A note on ie11 mode and support \u00b6 Because IE11 is no longer a primary supported browser our policy moving forward will be doing our best not to break anything in ie11 mode, but not all features will work and new features may never come to ie11 mode. Also, if you find an ie11 bug we expect you to work with us on helping to fix it. If you aren't willing to invest some time to support an old browser it seems we shouldn't either.","title":"IE11 Mode"},{"location":"v2/concepts/ie11-mode/#ie11-mode","text":"Starting with v2 we have made the decision to no longer support IE11. Because we know this affects folks we have introduced IE11 compatibility mode. Configuring the library will allow it to work within IE11, however at a possibly reduced level of functionality depending on your use case. Please see the list below of known limitations.","title":"IE11 Mode"},{"location":"v2/concepts/ie11-mode/#limitations","text":"When required to use IE11 mode there is certain functionality which may not work correctly or at all. Unavailable: Extension Methods Unavailable: OData Debugging","title":"Limitations"},{"location":"v2/concepts/ie11-mode/#configure-ie11-mode","text":"To enable IE11 Mode set the ie11 flag to true in the setup object. Optionally, supply the context object when working in SharePoint Framework . import { sp } from \"@pnp/sp\"; sp.setup({ // set ie 11 mode ie11: true, // only needed when working within SharePoint Framework spfxContext: this.context }); If you are supporting IE 11, please see the article on required polyfills .","title":"Configure IE11 Mode"},{"location":"v2/concepts/ie11-mode/#a-note-on-ie11-mode-and-support","text":"Because IE11 is no longer a primary supported browser our policy moving forward will be doing our best not to break anything in ie11 mode, but not all features will work and new features may never come to ie11 mode. Also, if you find an ie11 bug we expect you to work with us on helping to fix it. If you aren't willing to invest some time to support an old browser it seems we shouldn't either.","title":"A note on ie11 mode and support"},{"location":"v2/concepts/invokable/","text":"Invokables \u00b6 For people who have been using the library since the early days you are familiar with the need to use the () method to invoke a method chain: // an example of get const lists = await sp.web.lists(); Starting with v2 this is no longer required, you can invoke the object directly to execute the default action for that class - typically a get. const lists = await sp.web.lists(); This has two main benefits for people using the library: you can write less code, and we now have a way to model default actions for objects that might do something other than a get. The way we designed the library prior to v2 hid the post, put, delete operations as protected methods attached to the Queryable classes. Without diving into why we did this, having a rethink seemed appropriate for v2. Based on that, the entire queryable chain is now invokable as well for any of the operations. Other Operations (post, put, delete) \u00b6 import { sp, spPost } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // do a post to a web - just an example doesn't do anything fancy spPost(sp.web); Things get a little more interesting in that you can now do posts (or any of the operations) to any of the urls defined by a fluent chain. Meaning you can easily implement methods that are not yet part of the library. For this example I have made up a method called \"MagicFieldCreationMethod\" that doesn't exist. Imagine it was just added to the SharePoint API and we do not yet have support for it. You can now write code like so: import { sp, spPost, SharePointQueryable } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields/web\"; // call our made up example method spPost(SharePointQueryable(sp.web.fields, \"MagicFieldCreationMethod\"), { body: JSON.stringify({ // ... this would be the post body }), });","title":"Invokables"},{"location":"v2/concepts/invokable/#invokables","text":"For people who have been using the library since the early days you are familiar with the need to use the () method to invoke a method chain: // an example of get const lists = await sp.web.lists(); Starting with v2 this is no longer required, you can invoke the object directly to execute the default action for that class - typically a get. const lists = await sp.web.lists(); This has two main benefits for people using the library: you can write less code, and we now have a way to model default actions for objects that might do something other than a get. The way we designed the library prior to v2 hid the post, put, delete operations as protected methods attached to the Queryable classes. Without diving into why we did this, having a rethink seemed appropriate for v2. Based on that, the entire queryable chain is now invokable as well for any of the operations.","title":"Invokables"},{"location":"v2/concepts/invokable/#other-operations-post-put-delete","text":"import { sp, spPost } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // do a post to a web - just an example doesn't do anything fancy spPost(sp.web); Things get a little more interesting in that you can now do posts (or any of the operations) to any of the urls defined by a fluent chain. Meaning you can easily implement methods that are not yet part of the library. For this example I have made up a method called \"MagicFieldCreationMethod\" that doesn't exist. Imagine it was just added to the SharePoint API and we do not yet have support for it. You can now write code like so: import { sp, spPost, SharePointQueryable } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields/web\"; // call our made up example method spPost(SharePointQueryable(sp.web.fields, \"MagicFieldCreationMethod\"), { body: JSON.stringify({ // ... this would be the post body }), });","title":"Other Operations (post, put, delete)"},{"location":"v2/concepts/polyfill/","text":"Polyfills \u00b6 These libraries may make use of some features not found in older browsers. This primarily affects Internet Explorer 11, which requires that we provide this missing functionality. If you are supporting IE11 enable IE11 mode . IE 11 Polyfill package \u00b6 We created a package you try and help provide this missing functionality. This package is independent of the other @pnp/* packages and does not need to be updated monthly unless we introduce additional polyfills and publish a new version. This package is only needed if you are required to support IE 11. Install \u00b6 npm install @pnp/polyfill-ie11 --save Use \u00b6 import \"@pnp/polyfill-ie11\"; import { sp } from \"@pnp/sp/presets/all\"; sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); }); Selective Use \u00b6 Starting with version 2.0.2 you can selectively include the polyfills from the package. Depending on your needs it may make sense in your application to use the underlying libraries directly. We have added an expanded statement on our polyfills . // individually include polyfills as needed to match your requirements import \"@pnp/polyfill-ie11/dist/fetch\"; import \"@pnp/polyfill-ie11/dist/fill\"; import \"@pnp/polyfill-ie11/dist/from\"; import \"@pnp/polyfill-ie11/dist/iterator\"; import \"@pnp/polyfill-ie11/dist/map\"; import \"@pnp/polyfill-ie11/dist/promise\"; import \"@pnp/polyfill-ie11/dist/reflect\"; import \"@pnp/polyfill-ie11/dist/symbol\"; // works in IE11 and other browsers sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); }); SearchQueryBuilder \u00b6 Because the latest version of SearchQueryBuilder uses Proxy internally you can fall back on the older version as shown below. import \"@pnp/polyfill-ie11\"; import { SearchQueryBuilder } from \"@pnp/polyfill-ie11/dist/searchquerybuilder\"; import { sp, ISearchQueryBuilder } from \"@pnp/sp/presets/all\"; // works in IE11 and other browsers const builder: ISearchQueryBuilder = SearchQueryBuilder().text(\"test\"); sp.search(builder).then(r => { this.domElement.innerHTML = JSON.stringify(r); }); General Statement on Polyfills \u00b6 Internet Explorer 11 (IE11) has been an enterprise standard browser for many years. Given the complexity in changing technical platforms in many organizations, it is no surprise standardization on this out-of-date browser continues. Unfortunately, for those organizations, the Internet has moved on and many - if not all - SaaS platforms are embracing modern standards and no longer supporting the legacy IE11 browser. Even Microsoft states in their official documentation that Microsoft 365 is best experienced with a modern browser. They have even gone so far to build the latest version of Microsoft Edge based on Chromium (Edge Chromium), with an \"Internet Explorer mode\" allowing organizations to load legacy sites which require IE automatically. PnPjs is now \"modern\" as well, and by that we mean we have moved to using capabilities of current browsers and JavaScript which are not present in IE11. We understand as a developer your ability to require an organization to switch browsers is unrealistic. We want to do everything we can to support you, but it is up to you to ensure your application is properly supported in IE11. There are many polyfills available, depending on the platform you're running on, the frameworks you are using, and the libraries you consume. Although the majority of PnPjs users build for SharePoint Online, a significant number build for earlier versions of the platform as well as for their own node-based solutions or websites. Unfortunately, there is no way our polyfill library can support all these scenarios. What we intended with the @pnp/polyfill-ie11 package was to provide a comprehensive group of all the polyfills that would be needed based on the complete PnPjs library. We are finding when we aggregate our polyfills with the polyfills provided in the SharePoint page and from other sources, things don't always work well. We cannot solve this for your specific situations except by providing you transparency into the polyfills which we know are necessary for our packages. You may need to adjust what polyfills your application uses based on the other libraries you are using. To that end, we want to provide the list of polyfills we recommend here - along with the associated packages \u2013 with the goal of helping you to work out what combination of polyfills might work with your code. Also, if you haven't reviewed it yet, please check out the information on IE11 Mode for how to configure IE11 mode in the sp.setup as well as what limitations doing so will have on your usage of PnPjs. imports import \"core-js/stable/array/from\"; import \"core-js/stable/array/fill\"; import \"core-js/stable/array/iterator\"; import \"core-js/stable/promise\"; import \"core-js/stable/reflect\"; import \"es6-map/implement\"; import \"core-js/stable/symbol\"; import \"whatwg-fetch\"; The following NPM packages are what we use to do the above indicated imports |package| |---| | core-js | | es6-map | | whatwg-fetch |","title":"Polyfills"},{"location":"v2/concepts/polyfill/#polyfills","text":"These libraries may make use of some features not found in older browsers. This primarily affects Internet Explorer 11, which requires that we provide this missing functionality. If you are supporting IE11 enable IE11 mode .","title":"Polyfills"},{"location":"v2/concepts/polyfill/#ie-11-polyfill-package","text":"We created a package you try and help provide this missing functionality. This package is independent of the other @pnp/* packages and does not need to be updated monthly unless we introduce additional polyfills and publish a new version. This package is only needed if you are required to support IE 11.","title":"IE 11 Polyfill package"},{"location":"v2/concepts/polyfill/#install","text":"npm install @pnp/polyfill-ie11 --save","title":"Install"},{"location":"v2/concepts/polyfill/#use","text":"import \"@pnp/polyfill-ie11\"; import { sp } from \"@pnp/sp/presets/all\"; sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); });","title":"Use"},{"location":"v2/concepts/polyfill/#selective-use","text":"Starting with version 2.0.2 you can selectively include the polyfills from the package. Depending on your needs it may make sense in your application to use the underlying libraries directly. We have added an expanded statement on our polyfills . // individually include polyfills as needed to match your requirements import \"@pnp/polyfill-ie11/dist/fetch\"; import \"@pnp/polyfill-ie11/dist/fill\"; import \"@pnp/polyfill-ie11/dist/from\"; import \"@pnp/polyfill-ie11/dist/iterator\"; import \"@pnp/polyfill-ie11/dist/map\"; import \"@pnp/polyfill-ie11/dist/promise\"; import \"@pnp/polyfill-ie11/dist/reflect\"; import \"@pnp/polyfill-ie11/dist/symbol\"; // works in IE11 and other browsers sp.web.lists.getByTitle(\"BigList\").items.filter(`ID gt 6000`)().then(r => { this.domElement.innerHTML += r.map(l => `${l.Title}<br />`); });","title":"Selective Use"},{"location":"v2/concepts/polyfill/#searchquerybuilder","text":"Because the latest version of SearchQueryBuilder uses Proxy internally you can fall back on the older version as shown below. import \"@pnp/polyfill-ie11\"; import { SearchQueryBuilder } from \"@pnp/polyfill-ie11/dist/searchquerybuilder\"; import { sp, ISearchQueryBuilder } from \"@pnp/sp/presets/all\"; // works in IE11 and other browsers const builder: ISearchQueryBuilder = SearchQueryBuilder().text(\"test\"); sp.search(builder).then(r => { this.domElement.innerHTML = JSON.stringify(r); });","title":"SearchQueryBuilder"},{"location":"v2/concepts/polyfill/#general-statement-on-polyfills","text":"Internet Explorer 11 (IE11) has been an enterprise standard browser for many years. Given the complexity in changing technical platforms in many organizations, it is no surprise standardization on this out-of-date browser continues. Unfortunately, for those organizations, the Internet has moved on and many - if not all - SaaS platforms are embracing modern standards and no longer supporting the legacy IE11 browser. Even Microsoft states in their official documentation that Microsoft 365 is best experienced with a modern browser. They have even gone so far to build the latest version of Microsoft Edge based on Chromium (Edge Chromium), with an \"Internet Explorer mode\" allowing organizations to load legacy sites which require IE automatically. PnPjs is now \"modern\" as well, and by that we mean we have moved to using capabilities of current browsers and JavaScript which are not present in IE11. We understand as a developer your ability to require an organization to switch browsers is unrealistic. We want to do everything we can to support you, but it is up to you to ensure your application is properly supported in IE11. There are many polyfills available, depending on the platform you're running on, the frameworks you are using, and the libraries you consume. Although the majority of PnPjs users build for SharePoint Online, a significant number build for earlier versions of the platform as well as for their own node-based solutions or websites. Unfortunately, there is no way our polyfill library can support all these scenarios. What we intended with the @pnp/polyfill-ie11 package was to provide a comprehensive group of all the polyfills that would be needed based on the complete PnPjs library. We are finding when we aggregate our polyfills with the polyfills provided in the SharePoint page and from other sources, things don't always work well. We cannot solve this for your specific situations except by providing you transparency into the polyfills which we know are necessary for our packages. You may need to adjust what polyfills your application uses based on the other libraries you are using. To that end, we want to provide the list of polyfills we recommend here - along with the associated packages \u2013 with the goal of helping you to work out what combination of polyfills might work with your code. Also, if you haven't reviewed it yet, please check out the information on IE11 Mode for how to configure IE11 mode in the sp.setup as well as what limitations doing so will have on your usage of PnPjs. imports import \"core-js/stable/array/from\"; import \"core-js/stable/array/fill\"; import \"core-js/stable/array/iterator\"; import \"core-js/stable/promise\"; import \"core-js/stable/reflect\"; import \"es6-map/implement\"; import \"core-js/stable/symbol\"; import \"whatwg-fetch\"; The following NPM packages are what we use to do the above indicated imports |package| |---| | core-js | | es6-map | | whatwg-fetch |","title":"General Statement on Polyfills"},{"location":"v2/concepts/selective-imports/","text":"Selective Imports \u00b6 As the libraries have grown to support more of the SharePoint and Graph API they have also grown in size. On one hand this is good as more functionality becomes available but you had to include lots of code you didn't use if you were only doing simple operations. To solve this we introduced selective imports in v2. This allows you to only import the parts of the sp or graph library you need, allowing you to greatly reduce your overall solution bundle size - and enables treeshaking . This concept works well with custom bundling to create a shared package tailored exactly to your needs. If you would prefer to not worry about selective imports please see the section on presets . Old way \u00b6 // the sp var came with all library functionality already attached // meaning treeshaking couldn't reduce the size import { sp } from \"@pnp/sp\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); New Way \u00b6 // the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); Above we are being very specific in what we are importing, but you can also import entire sub-modules and be slightly less specific // the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); The above two examples both work just fine but you may end up with slightly smaller bundle sizes using the first. Consider this example: // this import statement will attach content-type functionality to list, web, and item import \"@pnp/sp/content-types\"; // this import statement will only attach content-type functionality to web import \"@pnp/sp/content-types/web\"; If you only need to access content types on the web object you can reduce size by only importing that piece. // this will fail import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IList } from \"@pnp/sp/lists\"; // do this instead import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { IList } from \"@pnp/sp/lists\"; const lists = await sp.web.lists(); Presets \u00b6 Sometimes you don't care as much about bundle size - testing or node development for example. In these cases we have provided what we are calling presets to allow you to skip importing each module individually. SP \u00b6 For the sp library there are two presets \"all\" and \"core\". The all preset mimics the behavior in v1 and includes everything in the library already attached to the sp var. import { sp } from \"@pnp/sp/presets/all\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists(); The \"core\" preset includes sites, webs, lists, and items. import { sp } from \"@pnp/sp/presets/core\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists(); Graph \u00b6 The graph library contains a single preset, \"all\" mimicking the v1 structure. import { graph } from \"@pnp/graph/presets/all\"; // graph.* exists as it did in v1, tree shaking will not work While we may look to add additional presets in the future you are encouraged to look at making your own custom bundles as a preferred solution.","title":"Selective Imports"},{"location":"v2/concepts/selective-imports/#selective-imports","text":"As the libraries have grown to support more of the SharePoint and Graph API they have also grown in size. On one hand this is good as more functionality becomes available but you had to include lots of code you didn't use if you were only doing simple operations. To solve this we introduced selective imports in v2. This allows you to only import the parts of the sp or graph library you need, allowing you to greatly reduce your overall solution bundle size - and enables treeshaking . This concept works well with custom bundling to create a shared package tailored exactly to your needs. If you would prefer to not worry about selective imports please see the section on presets .","title":"Selective Imports"},{"location":"v2/concepts/selective-imports/#old-way","text":"// the sp var came with all library functionality already attached // meaning treeshaking couldn't reduce the size import { sp } from \"@pnp/sp\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)();","title":"Old way"},{"location":"v2/concepts/selective-imports/#new-way","text":"// the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); Above we are being very specific in what we are importing, but you can also import entire sub-modules and be slightly less specific // the sp var now has almost nothing attached at import time and relies on import { sp } from \"@pnp/sp\"; // we need to import each of the pieces we need to \"attach\" them for chaining // here we are importing the specific sub modules we need and attaching the functionality for lists to web and items to list import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const itemData = await sp.web.lists.getById('00000000-0000-0000-0000-000000000000').items.getById(1)(); The above two examples both work just fine but you may end up with slightly smaller bundle sizes using the first. Consider this example: // this import statement will attach content-type functionality to list, web, and item import \"@pnp/sp/content-types\"; // this import statement will only attach content-type functionality to web import \"@pnp/sp/content-types/web\"; If you only need to access content types on the web object you can reduce size by only importing that piece. // this will fail import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IList } from \"@pnp/sp/lists\"; // do this instead import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { IList } from \"@pnp/sp/lists\"; const lists = await sp.web.lists();","title":"New Way"},{"location":"v2/concepts/selective-imports/#presets","text":"Sometimes you don't care as much about bundle size - testing or node development for example. In these cases we have provided what we are calling presets to allow you to skip importing each module individually.","title":"Presets"},{"location":"v2/concepts/selective-imports/#sp","text":"For the sp library there are two presets \"all\" and \"core\". The all preset mimics the behavior in v1 and includes everything in the library already attached to the sp var. import { sp } from \"@pnp/sp/presets/all\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists(); The \"core\" preset includes sites, webs, lists, and items. import { sp } from \"@pnp/sp/presets/core\"; // sp.* exists as it did in v1, tree shaking will not work const lists = await sp.web.lists();","title":"SP"},{"location":"v2/concepts/selective-imports/#graph","text":"The graph library contains a single preset, \"all\" mimicking the v1 structure. import { graph } from \"@pnp/graph/presets/all\"; // graph.* exists as it did in v1, tree shaking will not work While we may look to add additional presets in the future you are encouraged to look at making your own custom bundles as a preferred solution.","title":"Graph"},{"location":"v2/concepts/settings/","text":"Project Settings \u00b6 This article discusses creating a project settings file for use in local development and debugging of the libraries. The settings file contains authentication and other settings to enable you to run and debug the project locally. The settings file is a JavaScript file that exports a single object representing the settings of your project. You can view the example settings file in the project root . Settings File Format (>= 2.0.13) \u00b6 Starting with version 2.0.13 we have added support within the settings file for MSAL authentication for both SharePoint and Graph. You are NOT required to update your existing settings file unless you want to use MSAL authentication with a Graph application. The existing id/secret settings continue to work however we recommend updating when you have an opportunity. For more information coinfiguring MSAL please review the section in the authentication section for node . MSAL configuration has two parts, these are the initialization which is passed directly to the MsalFetchClient (and on to the underlying msal-node instance) and the scopes. The scopes are always \"https://{tenant}.sharepoint.com/.default\" or \"https://graph.microsoft.com/.default\" depending on what you are calling. If you are calling Microsoft Graph sovereign or gov clouds the scope may need to be updated. const privateKey = `-----BEGIN RSA PRIVATE KEY----- your private key, read from a file or included here -----END RSA PRIVATE KEY----- `; var msalInit = { auth: { authority: \"https://login.microsoftonline.com/{tenant id}\", clientCertificate: { thumbprint: \"{certificate thumbnail}\", privateKey: privateKey, }, clientId: \"{AAD App registration id}\", } } var settings = { testing: { enableWebTests: true, testUser: \"i:0#.f|membership|user@consto.com\", sp: { url: \"{required for MSAL - absolute url of test site}\", notificationUrl: \"{ optional: notification url }\", msal: { init: msalInit, scopes: [\"https://{tenant}.sharepoint.com/.default\"] }, }, graph: { msal: { init: msalInit, scopes: [\"https://graph.microsoft.com/.default\"] }, }, }, } module.exports = settings; The settings object has a single sub-object testing which contains the configuration used for debugging and testing PnPjs. The parts of this object are described in detail below. enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. testUser AAD login account to be used when running tests. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests SP values \u00b6 name description url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions msal Information about MSAL authentication setup Graph value \u00b6 The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description msal Information about MSAL authentication setup Settings File Format (<= 2.0.12) \u00b6 var settings = { testing: { enableWebTests: true, sp: { id: \"{ client id }\", secret: \"{ client secret }\", url: \"{ site collection url }\", notificationUrl: \"{ optional: notification url }\", }, graph: { tenant: \"{tenant.onmicrosoft.com}\", id: \"{your app id}\", secret: \"{your secret}\" }, } } module.exports = settings; enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests SP values \u00b6 The sp values are described in the table below and come from registering a legacy SharePoint add-in . name description id The client id of the registered application secret The client secret of the registered application url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions Graph values \u00b6 The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description tenant Tenant to target for authentication and data (ex: contoso.onmicrosoft.com) id The application id secret The application secret Create Settings.js file \u00b6 Copy the example file and rename it settings.js. Place the file in the root of your project. Update the settings as needed for your environment. If you are only doing SharePoint testing you can leave the graph section off and vice-versa. Also, if you are not testing anything with hooks you can leave off the notificationUrl.","title":"Project Settings"},{"location":"v2/concepts/settings/#project-settings","text":"This article discusses creating a project settings file for use in local development and debugging of the libraries. The settings file contains authentication and other settings to enable you to run and debug the project locally. The settings file is a JavaScript file that exports a single object representing the settings of your project. You can view the example settings file in the project root .","title":"Project Settings"},{"location":"v2/concepts/settings/#settings-file-format-2013","text":"Starting with version 2.0.13 we have added support within the settings file for MSAL authentication for both SharePoint and Graph. You are NOT required to update your existing settings file unless you want to use MSAL authentication with a Graph application. The existing id/secret settings continue to work however we recommend updating when you have an opportunity. For more information coinfiguring MSAL please review the section in the authentication section for node . MSAL configuration has two parts, these are the initialization which is passed directly to the MsalFetchClient (and on to the underlying msal-node instance) and the scopes. The scopes are always \"https://{tenant}.sharepoint.com/.default\" or \"https://graph.microsoft.com/.default\" depending on what you are calling. If you are calling Microsoft Graph sovereign or gov clouds the scope may need to be updated. const privateKey = `-----BEGIN RSA PRIVATE KEY----- your private key, read from a file or included here -----END RSA PRIVATE KEY----- `; var msalInit = { auth: { authority: \"https://login.microsoftonline.com/{tenant id}\", clientCertificate: { thumbprint: \"{certificate thumbnail}\", privateKey: privateKey, }, clientId: \"{AAD App registration id}\", } } var settings = { testing: { enableWebTests: true, testUser: \"i:0#.f|membership|user@consto.com\", sp: { url: \"{required for MSAL - absolute url of test site}\", notificationUrl: \"{ optional: notification url }\", msal: { init: msalInit, scopes: [\"https://{tenant}.sharepoint.com/.default\"] }, }, graph: { msal: { init: msalInit, scopes: [\"https://graph.microsoft.com/.default\"] }, }, }, } module.exports = settings; The settings object has a single sub-object testing which contains the configuration used for debugging and testing PnPjs. The parts of this object are described in detail below. enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. testUser AAD login account to be used when running tests. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests","title":"Settings File Format (&gt;= 2.0.13)"},{"location":"v2/concepts/settings/#sp-values","text":"name description url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions msal Information about MSAL authentication setup","title":"SP values"},{"location":"v2/concepts/settings/#graph-value","text":"The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description msal Information about MSAL authentication setup","title":"Graph value"},{"location":"v2/concepts/settings/#settings-file-format-2012","text":"var settings = { testing: { enableWebTests: true, sp: { id: \"{ client id }\", secret: \"{ client secret }\", url: \"{ site collection url }\", notificationUrl: \"{ optional: notification url }\", }, graph: { tenant: \"{tenant.onmicrosoft.com}\", id: \"{your app id}\", secret: \"{your secret}\" }, } } module.exports = settings; enableWebTests Flag to toggle if tests are run against the live services or not. If this is set to false none of the other sections are required. sp Settings used to configure SharePoint (sp library) debugging and tests graph Settings used to configure Microsoft Graph (graph library) debugging and tests","title":"Settings File Format (&lt;= 2.0.12)"},{"location":"v2/concepts/settings/#sp-values_1","text":"The sp values are described in the table below and come from registering a legacy SharePoint add-in . name description id The client id of the registered application secret The client secret of the registered application url The url of the site to use for all requests. If a site parameter is not specified a child web will be created under the web at this url. See scripts article for more details. notificationUrl Url used when registering test subscriptions","title":"SP values"},{"location":"v2/concepts/settings/#graph-values","text":"The graph values are described in the table below and come from registering an AAD Application . The permissions required by the registered application are dictated by the tests you want to run or resources you wish to test against. name description tenant Tenant to target for authentication and data (ex: contoso.onmicrosoft.com) id The application id secret The application secret","title":"Graph values"},{"location":"v2/concepts/settings/#create-settingsjs-file","text":"Copy the example file and rename it settings.js. Place the file in the root of your project. Update the settings as needed for your environment. If you are only doing SharePoint testing you can leave the graph section off and vice-versa. Also, if you are not testing anything with hooks you can leave off the notificationUrl.","title":"Create Settings.js file"},{"location":"v2/config-store/","text":"@pnp/config-store \u00b6 This module provides a way to load application configuration from one or more providers and share it across an application in a consistent way. A provider can be anything - but we have included one to load information from a SharePoint list. This library is most helpful for larger applications where a formal configuration model is needed. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/sp @pnp/config-store --save See the topics below for usage: configuration providers","title":"@pnp/config-store"},{"location":"v2/config-store/#pnpconfig-store","text":"This module provides a way to load application configuration from one or more providers and share it across an application in a consistent way. A provider can be anything - but we have included one to load information from a SharePoint list. This library is most helpful for larger applications where a formal configuration model is needed.","title":"@pnp/config-store"},{"location":"v2/config-store/#getting-started","text":"Install the library and required dependencies npm install @pnp/sp @pnp/config-store --save See the topics below for usage: configuration providers","title":"Getting Started"},{"location":"v2/config-store/configuration/","text":"@pnp/config-store/configuration \u00b6 The main class exported from the config-store package is Settings. This is the class through which you will load and access your settings via providers . import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create an instance of the settings class, could be static and shared across your application // or built as needed. const settings = new Settings(); // you can add/update a single value using add settings.add(\"mykey\", \"myvalue\"); // you can also add/update a JSON value which will be stringified for you as a shorthand settings.addJSON(\"mykey2\", { field: 1, field2: 2, field3: 3, }); // and you can apply a plain object of keys/values that will be written as single values // this results in each enumerable property of the supplied object being added to the settings collection settings.apply({ field: 1, field2: 2, field3: 3, }); // and finally you can load values from a configuration provider const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // this will load values from the supplied list // by default the key will be from the Title field and the value from a column named Value await settings.load(provider); // once we have loaded values we can then read them const value = settings.get(\"mykey\"); // or read JSON that will be parsed for you from the store const value2 = settings.getJSON(\"mykey2\");","title":"@pnp/config-store/configuration"},{"location":"v2/config-store/configuration/#pnpconfig-storeconfiguration","text":"The main class exported from the config-store package is Settings. This is the class through which you will load and access your settings via providers . import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create an instance of the settings class, could be static and shared across your application // or built as needed. const settings = new Settings(); // you can add/update a single value using add settings.add(\"mykey\", \"myvalue\"); // you can also add/update a JSON value which will be stringified for you as a shorthand settings.addJSON(\"mykey2\", { field: 1, field2: 2, field3: 3, }); // and you can apply a plain object of keys/values that will be written as single values // this results in each enumerable property of the supplied object being added to the settings collection settings.apply({ field: 1, field2: 2, field3: 3, }); // and finally you can load values from a configuration provider const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // this will load values from the supplied list // by default the key will be from the Title field and the value from a column named Value await settings.load(provider); // once we have loaded values we can then read them const value = settings.get(\"mykey\"); // or read JSON that will be parsed for you from the store const value2 = settings.getJSON(\"mykey2\");","title":"@pnp/config-store/configuration"},{"location":"v2/config-store/providers/","text":"@pnp/config-store/providers \u00b6 Currently there is a single provider included in the library, but contributions of additional providers are welcome. SPListConfigurationProvider \u00b6 This provider is based on a SharePoint list it reads all of the rows and makes them available as a TypedHash<string> . By default the column names used are Title for key and \"Value\" for value, but you can update these as needed. Additionally, the settings class supports the idea of last value in wins - so you can easily load multiple configurations. This helps to support a common scenario in the enterprise where you might have one main list for global configuration but some settings can be set at the web level. In this case you would first load the global, then the local settings and any local values will take precedence. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); const settings = new Settings(); // load our values from the list await settings.load(provider); CachingConfigurationProvider \u00b6 Because making requests on each page load is very inefficient you can optionally use the caching configuration provider, which wraps a provider and caches the configuration in local or session storage. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // get an instance of the provider wrapped // you can optionally provide a key that will be used in the cache to the asCaching method const wrappedProvider = provider.asCaching(); // use that wrapped provider to populate the settings await settings.load(wrappedProvider);","title":"@pnp/config-store/providers"},{"location":"v2/config-store/providers/#pnpconfig-storeproviders","text":"Currently there is a single provider included in the library, but contributions of additional providers are welcome.","title":"@pnp/config-store/providers"},{"location":"v2/config-store/providers/#splistconfigurationprovider","text":"This provider is based on a SharePoint list it reads all of the rows and makes them available as a TypedHash<string> . By default the column names used are Title for key and \"Value\" for value, but you can update these as needed. Additionally, the settings class supports the idea of last value in wins - so you can easily load multiple configurations. This helps to support a common scenario in the enterprise where you might have one main list for global configuration but some settings can be set at the web level. In this case you would first load the global, then the local settings and any local values will take precedence. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); const settings = new Settings(); // load our values from the list await settings.load(provider);","title":"SPListConfigurationProvider"},{"location":"v2/config-store/providers/#cachingconfigurationprovider","text":"Because making requests on each page load is very inefficient you can optionally use the caching configuration provider, which wraps a provider and caches the configuration in local or session storage. import { Web } from \"@pnp/sp/presets/all\"; import { Settings, SPListConfigurationProvider } from \"@pnp/config-store\"; // create a new provider instance const w = Web(\"https://mytenant.sharepoint.com/sites/dev\"); const provider = new SPListConfigurationProvider(w, \"myconfiglistname\"); // get an instance of the provider wrapped // you can optionally provide a key that will be used in the cache to the asCaching method const wrappedProvider = provider.asCaching(); // use that wrapped provider to populate the settings await settings.load(wrappedProvider);","title":"CachingConfigurationProvider"},{"location":"v2/contributing/","text":"Contributing to PnPjs \u00b6 Thank you for your interest in contributing to PnPjs. We have updated our contribution section to make things easier to get started, debug the library locally, and learn how to extend the functionality. Section Description Setup Dev Machine Covers setting up your machine to ensure you are ready to debug the solution Local Debug Configuration Discusses the steps required to establish local configuration used for debugging and running tests Debugging Describes how to debug PnPjs locally Extending the library Basic examples on how to extend the library such as adding a method or property Writing Tests How to write and debug tests Update Documentation Describes the steps required to edit and locally view the documentation Submit a Pull Request Outlines guidance for submitting a pull request Need Help? \u00b6 The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website.","title":"Contributing to PnPjs"},{"location":"v2/contributing/#contributing-to-pnpjs","text":"Thank you for your interest in contributing to PnPjs. We have updated our contribution section to make things easier to get started, debug the library locally, and learn how to extend the functionality. Section Description Setup Dev Machine Covers setting up your machine to ensure you are ready to debug the solution Local Debug Configuration Discusses the steps required to establish local configuration used for debugging and running tests Debugging Describes how to debug PnPjs locally Extending the library Basic examples on how to extend the library such as adding a method or property Writing Tests How to write and debug tests Update Documentation Describes the steps required to edit and locally view the documentation Submit a Pull Request Outlines guidance for submitting a pull request","title":"Contributing to PnPjs"},{"location":"v2/contributing/#need-help","text":"The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website.","title":"Need Help?"},{"location":"v2/contributing/debug-tests/","text":"Writing Tests \u00b6 With version 2 we have made a significant effort to improve out test coverage. To keep that up, all changes submitted will require one or more tests be included. For new functionality at least a basic test that the method executes is required. For bug fixes please include a test that would have caught the bug (i.e. fail before your fix) and passes with your fix in place. How to write Tests \u00b6 We use Mocha and Chai for our testing framework. You can see many examples of writing tests within the ./test folder. Here is a sample with extra comments to help explain what's happening, taken from ./test/sp/items.ts : import { getRandomString } from \"@pnp/core\"; import { testSettings } from \"../main\"; import { expect } from \"chai\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import { IList } from \"@pnp/sp/lists\"; describe(\"Items\", () => { // any tests that make a web request should be withing a block checking if web tests are enabled if (testSettings.enableWebTests) { // a block scoped var we will use across our tests let list: IList = null; // we use the before block to setup // executed before all the tests in this block, see the mocha docs for more details // mocha prefers using function vs arrow functions and this is recommended before(async function () { // execute a request to ensure we have a list const ler = await sp.web.lists.ensure(\"ItemTestList\", \"Used to test item operations\"); list = ler.list; // in this case we want to have some items in the list for testing so we add those // only if the list was just created if (ler.created) { // add a few items to get started const batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); await batch.execute(); } }); // this test has a label \"get items\" and is run via an async function it(\"get items\", async function () { // make a request for the list's items const items = await list.items(); // report that we expect that result to be an array with more than 0 items expect(items.length).to.be.gt(0); }); // ... remainder of code removed } } General Guidelines for Writing Tests \u00b6 Tests should operate within the site defined in testSettings Tests should be able to run multiple times on the same site, but do not need to cleanup after themselves Each test should be self contained and not depend on other tests, they can depend on work done in before or beforeAll When writing tests you can use \"only\" and \"skip\" from mochajs to focus on only the tests you are writing Be sure to review the various options when running your tests If you are writing a test and the endpoint doesn't support app only permissions, you can skip writing a test - but please note that in the PR description Next Steps \u00b6 Now that you've written tests to cover your changes you'll need to update the docs .","title":"Writing Tests"},{"location":"v2/contributing/debug-tests/#writing-tests","text":"With version 2 we have made a significant effort to improve out test coverage. To keep that up, all changes submitted will require one or more tests be included. For new functionality at least a basic test that the method executes is required. For bug fixes please include a test that would have caught the bug (i.e. fail before your fix) and passes with your fix in place.","title":"Writing Tests"},{"location":"v2/contributing/debug-tests/#how-to-write-tests","text":"We use Mocha and Chai for our testing framework. You can see many examples of writing tests within the ./test folder. Here is a sample with extra comments to help explain what's happening, taken from ./test/sp/items.ts : import { getRandomString } from \"@pnp/core\"; import { testSettings } from \"../main\"; import { expect } from \"chai\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import { IList } from \"@pnp/sp/lists\"; describe(\"Items\", () => { // any tests that make a web request should be withing a block checking if web tests are enabled if (testSettings.enableWebTests) { // a block scoped var we will use across our tests let list: IList = null; // we use the before block to setup // executed before all the tests in this block, see the mocha docs for more details // mocha prefers using function vs arrow functions and this is recommended before(async function () { // execute a request to ensure we have a list const ler = await sp.web.lists.ensure(\"ItemTestList\", \"Used to test item operations\"); list = ler.list; // in this case we want to have some items in the list for testing so we add those // only if the list was just created if (ler.created) { // add a few items to get started const batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); list.items.inBatch(batch).add({ Title: `Item ${getRandomString(4)}` }); await batch.execute(); } }); // this test has a label \"get items\" and is run via an async function it(\"get items\", async function () { // make a request for the list's items const items = await list.items(); // report that we expect that result to be an array with more than 0 items expect(items.length).to.be.gt(0); }); // ... remainder of code removed } }","title":"How to write Tests"},{"location":"v2/contributing/debug-tests/#general-guidelines-for-writing-tests","text":"Tests should operate within the site defined in testSettings Tests should be able to run multiple times on the same site, but do not need to cleanup after themselves Each test should be self contained and not depend on other tests, they can depend on work done in before or beforeAll When writing tests you can use \"only\" and \"skip\" from mochajs to focus on only the tests you are writing Be sure to review the various options when running your tests If you are writing a test and the endpoint doesn't support app only permissions, you can skip writing a test - but please note that in the PR description","title":"General Guidelines for Writing Tests"},{"location":"v2/contributing/debug-tests/#next-steps","text":"Now that you've written tests to cover your changes you'll need to update the docs .","title":"Next Steps"},{"location":"v2/contributing/debugging/","text":"Debugging \u00b6 Using the steps in this article you will be able to locally debug the library internals as well as new features you are working on. Before proceeding be sure you have reviewed how to setup for local configuration and debugging. Debugging Library Features \u00b6 The easiest way to debug the library when working on new features is using F5 in Visual Studio Code. This uses launch.json to build and run the library using ./debug/launch/main.ts as the entry point. Basic SharePoint Testing \u00b6 You can start the base debugging case by hitting F5. Before you do place a break point in ./debug/launch/sp.ts. You can also place a break point within any of the libraries or modules. Feel free to edit the sp.ts file to try things out, debug suspected issues, or test new features, etc - but please don't commit any changes as this is a shared file. See the section on creating your own debug modules . All of the setup for the node client is handled within sp.ts using the settings from the local configuration . Basic Graph Testing \u00b6 Testing and debugging Graph calls follows the same process as outlined for SharePoint, however you need to update main.ts to import graph instead of sp. You can place break points anywhere within the library code and they should be hit. All of the setup for the node client is handled within graph.ts using the settings from the local configuration . How to: Create a Debug Module \u00b6 If you are working on multiple features or want to save sample code for various tasks you can create your own debugging modules and leave them in the debug/launch folder locally. The gitignore file is setup to ignore any files that aren't already in git. Using ./debug/launch/sp.ts as a reference create a file in the debug/launch folder, let's call it mydebug.ts and add this content: // note we can use the actual package names for our imports (ex: @pnp/logging) import { Logger, LogLevel, ConsoleListener } from \"@pnp/logging\"; // using the all preset for simplicity in the example, selective imports work as expected import { sp, ListEnsureResult } from \"@pnp/sp/presets/all\"; declare var process: { exit(code?: number): void }; export async function MyDebug() { // configure your options // you can have different configs in different modules as needed for your testing/dev work sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret); }, }, }); // run some debugging const list = await sp.web.lists.ensure(\"MyFirstList\"); Logger.log({ data: list.created, level: LogLevel.Info, message: \"Was list created?\", }); if (list.created) { Logger.log({ data: list.data, level: LogLevel.Info, message: \"Raw data from list creation.\", }); } else { Logger.log({ data: null, level: LogLevel.Info, message: \"List already existed!\", }); } process.exit(0); } Update main.ts to launch your module \u00b6 First comment out the import for the default example and then add the import and function call for yours, the updated launch/main.ts should look like this: // ... // comment out the example // import { Example } from \"./example\"; // Example(); import { MyDebug } from \"./mydebug\" MyDebug(); // ... Remember, please don't commit any changes to the shared files within the debug folder. (Unless you've found a bug that needs fixing in the original file) Debug \u00b6 Place a break point within the mydebug.ts file and hit F5. Your module should run and your break point hit. You can then examine the contents of the objects and see the run time state. Remember, you can also set breakpoints within the package src folders to see exactly how things are working during your debugging scenarios. Debug Module Next Steps \u00b6 Using this pattern you can create and preserve multiple debugging scenarios in separate modules locally - they won't be added to git. You just have to update main.ts to point to the one you want to run. In Browser Debugging \u00b6 You can also serve files locally to debug as a user in the browser by serving code using ./debug/serve/main.ts as the entry. The file is served as https://localhost:8080/assets/pnp.js , allowing you to create a single page in your tenant for in browser testing. The remainder of this section describes the process to setup a SharePoint page to debug in this manner. Start the local serve \u00b6 This will serve a package with ./debug/serve/main.ts as the entry. gulp serve Add reference to library \u00b6 Within a SharePoint page add a script editor web part and then paste in the following code. The div is to give you a place to target with visual updates should you desire. <script src=\"https://localhost:8080/assets/pnp.js\"></script> <div id=\"pnp-test\"></div> You should see an alert with the current web's title using the default main.ts. Feel free to update main.ts to do whatever you would like, but remember not to commit changes to the shared files. Debug \u00b6 Refresh the page and open the developer tools in your browser of choice. If the pnp.js file is blocked due to security restrictions you will need to allow it. Next Steps \u00b6 You can make changes to the library and immediately see them reflected in the browser. All files are watched so changes will be available as soon as webpack reloads the package. This allows you to rapidly test the library in the browser. Now you can learn about extending the library .","title":"Debugging"},{"location":"v2/contributing/debugging/#debugging","text":"Using the steps in this article you will be able to locally debug the library internals as well as new features you are working on. Before proceeding be sure you have reviewed how to setup for local configuration and debugging.","title":"Debugging"},{"location":"v2/contributing/debugging/#debugging-library-features","text":"The easiest way to debug the library when working on new features is using F5 in Visual Studio Code. This uses launch.json to build and run the library using ./debug/launch/main.ts as the entry point.","title":"Debugging Library Features"},{"location":"v2/contributing/debugging/#basic-sharepoint-testing","text":"You can start the base debugging case by hitting F5. Before you do place a break point in ./debug/launch/sp.ts. You can also place a break point within any of the libraries or modules. Feel free to edit the sp.ts file to try things out, debug suspected issues, or test new features, etc - but please don't commit any changes as this is a shared file. See the section on creating your own debug modules . All of the setup for the node client is handled within sp.ts using the settings from the local configuration .","title":"Basic SharePoint Testing"},{"location":"v2/contributing/debugging/#basic-graph-testing","text":"Testing and debugging Graph calls follows the same process as outlined for SharePoint, however you need to update main.ts to import graph instead of sp. You can place break points anywhere within the library code and they should be hit. All of the setup for the node client is handled within graph.ts using the settings from the local configuration .","title":"Basic Graph Testing"},{"location":"v2/contributing/debugging/#how-to-create-a-debug-module","text":"If you are working on multiple features or want to save sample code for various tasks you can create your own debugging modules and leave them in the debug/launch folder locally. The gitignore file is setup to ignore any files that aren't already in git. Using ./debug/launch/sp.ts as a reference create a file in the debug/launch folder, let's call it mydebug.ts and add this content: // note we can use the actual package names for our imports (ex: @pnp/logging) import { Logger, LogLevel, ConsoleListener } from \"@pnp/logging\"; // using the all preset for simplicity in the example, selective imports work as expected import { sp, ListEnsureResult } from \"@pnp/sp/presets/all\"; declare var process: { exit(code?: number): void }; export async function MyDebug() { // configure your options // you can have different configs in different modules as needed for your testing/dev work sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret); }, }, }); // run some debugging const list = await sp.web.lists.ensure(\"MyFirstList\"); Logger.log({ data: list.created, level: LogLevel.Info, message: \"Was list created?\", }); if (list.created) { Logger.log({ data: list.data, level: LogLevel.Info, message: \"Raw data from list creation.\", }); } else { Logger.log({ data: null, level: LogLevel.Info, message: \"List already existed!\", }); } process.exit(0); }","title":"How to: Create a Debug Module"},{"location":"v2/contributing/debugging/#update-maints-to-launch-your-module","text":"First comment out the import for the default example and then add the import and function call for yours, the updated launch/main.ts should look like this: // ... // comment out the example // import { Example } from \"./example\"; // Example(); import { MyDebug } from \"./mydebug\" MyDebug(); // ... Remember, please don't commit any changes to the shared files within the debug folder. (Unless you've found a bug that needs fixing in the original file)","title":"Update main.ts to launch your module"},{"location":"v2/contributing/debugging/#debug","text":"Place a break point within the mydebug.ts file and hit F5. Your module should run and your break point hit. You can then examine the contents of the objects and see the run time state. Remember, you can also set breakpoints within the package src folders to see exactly how things are working during your debugging scenarios.","title":"Debug"},{"location":"v2/contributing/debugging/#debug-module-next-steps","text":"Using this pattern you can create and preserve multiple debugging scenarios in separate modules locally - they won't be added to git. You just have to update main.ts to point to the one you want to run.","title":"Debug Module Next Steps"},{"location":"v2/contributing/debugging/#in-browser-debugging","text":"You can also serve files locally to debug as a user in the browser by serving code using ./debug/serve/main.ts as the entry. The file is served as https://localhost:8080/assets/pnp.js , allowing you to create a single page in your tenant for in browser testing. The remainder of this section describes the process to setup a SharePoint page to debug in this manner.","title":"In Browser Debugging"},{"location":"v2/contributing/debugging/#start-the-local-serve","text":"This will serve a package with ./debug/serve/main.ts as the entry. gulp serve","title":"Start the local serve"},{"location":"v2/contributing/debugging/#add-reference-to-library","text":"Within a SharePoint page add a script editor web part and then paste in the following code. The div is to give you a place to target with visual updates should you desire. <script src=\"https://localhost:8080/assets/pnp.js\"></script> <div id=\"pnp-test\"></div> You should see an alert with the current web's title using the default main.ts. Feel free to update main.ts to do whatever you would like, but remember not to commit changes to the shared files.","title":"Add reference to library"},{"location":"v2/contributing/debugging/#debug_1","text":"Refresh the page and open the developer tools in your browser of choice. If the pnp.js file is blocked due to security restrictions you will need to allow it.","title":"Debug"},{"location":"v2/contributing/debugging/#next-steps","text":"You can make changes to the library and immediately see them reflected in the browser. All files are watched so changes will be available as soon as webpack reloads the package. This allows you to rapidly test the library in the browser. Now you can learn about extending the library .","title":"Next Steps"},{"location":"v2/contributing/documentation/","text":"Documentation \u00b6 Just like with tests we have invested much time in updating the documentation and when you make a change to the library you should update the associated documentation as part of the pull request. Writing Docs \u00b6 Our docs are all written in markdown and processed using MkDocs. You can use code blocks, tables, and other markdown formatting. You can review the other articles for examples on writing docs. Generally articles should focus on how to use the library and where appropriate link to official outside documents as needed. Official documentation could be Microsoft, other library project docs such as MkDocs, or other sources. Building Docs Locally \u00b6 Building the documentation locally can help you visualize change you are making to the docs. What you see locally will be what you see online. Documentation is built using MkDocs. You will need to latest version of Python (tested on version 3.7.1) and pip. If you're on the Windows operating system, make sure you have added Python to your Path environment variable . When executing the pip module on Windows you can prefix it with python -m . For example: python -m pip install mkdocs-material Install MkDocs pip install mkdocs Install the Material theme pip install mkdocs-material install the mkdocs-markdownextradata-plugin - this is used for the version variable pip install mkdocs-markdownextradata-plugin (doesn't work on Python v2.7) install redirect plugin - used to redirect from moved pages pip install mkdocs-redirects Serve it up mkdocs serve Open a browser to http://127.0.0.1:8000/ Please see the official mkdocs site for more details on working with mkdocs Next Steps \u00b6 After your changes are made, you've added/updated tests, and updated the docs you're ready to submit a pull request !","title":"Documentation"},{"location":"v2/contributing/documentation/#documentation","text":"Just like with tests we have invested much time in updating the documentation and when you make a change to the library you should update the associated documentation as part of the pull request.","title":"Documentation"},{"location":"v2/contributing/documentation/#writing-docs","text":"Our docs are all written in markdown and processed using MkDocs. You can use code blocks, tables, and other markdown formatting. You can review the other articles for examples on writing docs. Generally articles should focus on how to use the library and where appropriate link to official outside documents as needed. Official documentation could be Microsoft, other library project docs such as MkDocs, or other sources.","title":"Writing Docs"},{"location":"v2/contributing/documentation/#building-docs-locally","text":"Building the documentation locally can help you visualize change you are making to the docs. What you see locally will be what you see online. Documentation is built using MkDocs. You will need to latest version of Python (tested on version 3.7.1) and pip. If you're on the Windows operating system, make sure you have added Python to your Path environment variable . When executing the pip module on Windows you can prefix it with python -m . For example: python -m pip install mkdocs-material Install MkDocs pip install mkdocs Install the Material theme pip install mkdocs-material install the mkdocs-markdownextradata-plugin - this is used for the version variable pip install mkdocs-markdownextradata-plugin (doesn't work on Python v2.7) install redirect plugin - used to redirect from moved pages pip install mkdocs-redirects Serve it up mkdocs serve Open a browser to http://127.0.0.1:8000/ Please see the official mkdocs site for more details on working with mkdocs","title":"Building Docs Locally"},{"location":"v2/contributing/documentation/#next-steps","text":"After your changes are made, you've added/updated tests, and updated the docs you're ready to submit a pull request !","title":"Next Steps"},{"location":"v2/contributing/extending-the-library/","text":"Extending PnPjs \u00b6 This article is targeted at people wishing to extend PnPjs itself, usually by adding a method or property. At the most basic level PnPjs is a set of libraries used to build and execute a web request and handle the response from that request. Conceptually each object in the fluent chain serves as input when creating the next object in the chain. This is how configuration, url, query, and other values are passed along. To get a sense for what this looks like see the code below. This is taken from inside the webs submodule and shows how the \"webs\" property is added to the web class. // TypeScript property, returning an interface public get webs(): IWebs { // using the Webs factory function and providing \"this\" as the first parameter return Webs(this); } Understanding Factory Functions \u00b6 PnPjs v2 is designed to only expose interfaces and factory functions. Let's look at the Webs factory function, used above as an example. All factory functions in sp and graph have a similar form. // create a constant which is a function of type ISPInvokableFactory having the name Webs // this is bound by the generic type param to return an IWebs instance // and it will use the _Webs concrete class to form the internal type of the invocable export const Webs = spInvokableFactory<IWebs>(_Webs); The ISPInvokableFactory type looks like: export type ISPInvokableFactory<R = any> = (baseUrl: string | ISharePointQueryable, path?: string) => R; And the matching graph type: <R>(f: any): (baseUrl: string | IGraphQueryable, path?: string) => R The general idea of a factory function is that it takes two parameters. The first is either a string or Queryable derivative which forms base for the new object. The second is the next part of the url. In some cases (like the webs property example above) you will note there is no second parameter. Some classes are decorated with defaultPath, which automatically fills the second param. Don't worry too much right now about the deep internals of the library, let's instead focus on some concrete examples. import { Web } from \"@pnp/sp/webs\"; // create a web from an absolute url const web = Web(\"https://tenant.sharepoint.com\"); // as an example, create a new web using the first as a base // targets: https://tenant.sharepoint.com/sites/dev const web2 = Web(web, \"sites/dev\"); // or you can add any path components you want, here as an example we access the current user property const cu = Web(web, \"currentuser\"); const currentUserInfo = cu(); Now hey you might say - you can't create a request to current user using the Web factory. Well you can, since everything is just based on urls under the covers the actual factory names don't mean anything other than they have the appropriate properties and method hung off them. This is brought up as you will see in many cases objects being used to create queries within methods and properties that don't match their \"type\". It is an important concept when working with the library to always remember we are just building strings. Class structure \u00b6 Internally to the library we have a bit of complexity to make the whole invocable proxy architecture work and provide the typings folks expect. Here is an example implementation with extra comments explaining what is happening. You don't need to understand the entire stack to add a property or method /* The concrete class implementation. This is never exported or shown directly to consumers of the library. It is wrapped by the Proxy we do expose. It extends the _SharePointQueryableInstance class for which there is a matching _SharePointQueryableCollection. The generic parameter defines the return type of a get operation and the invoked result. Classes can have methods and properties as normal. This one has a single property as a simple example */ export class _HubSite extends _SharePointQueryableInstance<IHubSiteInfo> { /** * Gets the ISite instance associated with this hub site */ // the tag decorator is used to provide some additional telemetry on what methods are // being called. @tag(\"hs.getSite\") public async getSite(): Promise<ISite> { // we execute a request using this instance, selecting the SiteUrl property, and invoking it immediately and awaiting the result const d = await this.select(\"SiteUrl\")(); // we then return a new ISite instance created from the Site factory using the returned SiteUrl property as the baseUrl return Site(d.SiteUrl); } } /* This defines the interface we export and expose to consumers. In most cases this extends the concrete object but may add or remove some methods/properties in special cases */ export interface IHubSite extends _HubSite { } /* This defines the HubSite factory function as discussed above binding the spInvokableFactory to a generic param of IHubSite and a param of _HubSite. This is understood to mean that HubSite is a factory function that returns a types of IHubSite which the spInvokableFactory will create using _HubSite as the concrete underlying type. */ export const HubSite = spInvokableFactory<IHubSite>(_HubSite); Add a Property \u00b6 In most cases you won't need to create the class, interface, or factory - you just want to add a property or method. An example of this is sp.web.lists. web is a property of sp and lists is a property of web. You can have a look at those classes as examples. Let's have a look at the fields on the _View class. export class _View extends _SharePointQueryableInstance<IViewInfo> { // ... other code removed // add the property, and provide a return type // return types should be interfaces public get fields(): IViewFields { // we use the ViewFields factory function supplying \"this\" as the first parameter // this will create a url like \".../fields/viewfields\" due to the defaultPath decorator // on the _ViewFields class. This is equivalent to: ViewFields(this, \"viewfields\") return ViewFields(this); } // ... other code removed } There are many examples throughout the library that follow this pattern. Add a Method \u00b6 Adding a method is just like adding a property with the key difference that a method usually does something like make a web request or act like a property but take parameters. Let's look at the _Items getById method: @defaultPath(\"items\") export class _Items extends _SharePointQueryableCollection { /** * Gets an Item by id * * @param id The integer id of the item to retrieve */ // we declare a method and set the return type to an interface public getById(id: number): IItem { // here we use the tag helper to add some telemetry to our request // we create a new IItem using the factory and appending the id value to the end // this gives us a valid url path to a single item .../items/getById(2) // we can then use the returned IItem to extend our chain or execute a request return tag.configure(Item(this).concat(`(${id})`), \"is.getById\"); } // ... other code removed } Web Request Method \u00b6 A second example is a method that performs a request. Here we use the _Item recycle method as an example: /** * Moves the list item to the Recycle Bin and returns the identifier of the new Recycle Bin item. */ // we use the tag decorator to add telemetry @tag(\"i.recycle\") // we return a promise public recycle(): Promise<string> { // we use the spPost method to post the request created by cloning our current instance IItem using // the Item factory and adding the path \"recycle\" to the end. Url will look like .../items/getById(2)/recycle return spPost<string>(this.clone(Item, \"recycle\")); } Augment Using Selective Imports \u00b6 To understand is how to extend functionality within the selective imports structures look at list.ts file in the items submodule. Here you can see the code below, with extra comments to explain what is happening. Again, you will see this pattern repeated throughout the library so there are many examples available. // import the addProp helper import { addProp } from \"@pnp/queryable\"; // import the _List concrete class from the types module (not the index!) import { _List } from \"../lists/types\"; // import the interface and factory we are going to add to the List import { Items, IItems } from \"./types\"; // This module declaration fixes up the types, allowing .items to appear in intellisense // when you import \"@pnp/sp/items/list\"; declare module \"../lists/types\" { // we need to extend the concrete type interface _List { readonly items: IItems; } // we need to extend the interface // this may not be strictly necessary as the IList interface extends _List so it // should pick up the same additions, but we have seen in some cases this does seem // to be required. So we include it for safety as it will all be removed during // transpilation we don't need to care about the extra code interface IList { readonly items: IItems; } } // finally we add the property to the _List class // this method call says add a property to _List named \"items\" and that property returns a result using the Items factory // The factory will be called with \"this\" when the property is accessed. If needed there is a fourth parameter to append additional path // information to the property url addProp(_List, \"items\", Items); General Rules for Extending PnPjs \u00b6 Only expose interfaces to consumers Use the factory functions except in very special cases Look for other properties and methods as examples Simple is always preferable, but not always possible - use your best judgement If you find yourself writing a ton of code to solve a problem you think should be easy, ask If you find yourself deep within the core classes or odata library trying to make a change, ask - changes to the core classes are rarely needed Next Steps \u00b6 Now that you have extended the library you need to write a test to cover it!","title":"Extending PnPjs"},{"location":"v2/contributing/extending-the-library/#extending-pnpjs","text":"This article is targeted at people wishing to extend PnPjs itself, usually by adding a method or property. At the most basic level PnPjs is a set of libraries used to build and execute a web request and handle the response from that request. Conceptually each object in the fluent chain serves as input when creating the next object in the chain. This is how configuration, url, query, and other values are passed along. To get a sense for what this looks like see the code below. This is taken from inside the webs submodule and shows how the \"webs\" property is added to the web class. // TypeScript property, returning an interface public get webs(): IWebs { // using the Webs factory function and providing \"this\" as the first parameter return Webs(this); }","title":"Extending PnPjs"},{"location":"v2/contributing/extending-the-library/#understanding-factory-functions","text":"PnPjs v2 is designed to only expose interfaces and factory functions. Let's look at the Webs factory function, used above as an example. All factory functions in sp and graph have a similar form. // create a constant which is a function of type ISPInvokableFactory having the name Webs // this is bound by the generic type param to return an IWebs instance // and it will use the _Webs concrete class to form the internal type of the invocable export const Webs = spInvokableFactory<IWebs>(_Webs); The ISPInvokableFactory type looks like: export type ISPInvokableFactory<R = any> = (baseUrl: string | ISharePointQueryable, path?: string) => R; And the matching graph type: <R>(f: any): (baseUrl: string | IGraphQueryable, path?: string) => R The general idea of a factory function is that it takes two parameters. The first is either a string or Queryable derivative which forms base for the new object. The second is the next part of the url. In some cases (like the webs property example above) you will note there is no second parameter. Some classes are decorated with defaultPath, which automatically fills the second param. Don't worry too much right now about the deep internals of the library, let's instead focus on some concrete examples. import { Web } from \"@pnp/sp/webs\"; // create a web from an absolute url const web = Web(\"https://tenant.sharepoint.com\"); // as an example, create a new web using the first as a base // targets: https://tenant.sharepoint.com/sites/dev const web2 = Web(web, \"sites/dev\"); // or you can add any path components you want, here as an example we access the current user property const cu = Web(web, \"currentuser\"); const currentUserInfo = cu(); Now hey you might say - you can't create a request to current user using the Web factory. Well you can, since everything is just based on urls under the covers the actual factory names don't mean anything other than they have the appropriate properties and method hung off them. This is brought up as you will see in many cases objects being used to create queries within methods and properties that don't match their \"type\". It is an important concept when working with the library to always remember we are just building strings.","title":"Understanding Factory Functions"},{"location":"v2/contributing/extending-the-library/#class-structure","text":"Internally to the library we have a bit of complexity to make the whole invocable proxy architecture work and provide the typings folks expect. Here is an example implementation with extra comments explaining what is happening. You don't need to understand the entire stack to add a property or method /* The concrete class implementation. This is never exported or shown directly to consumers of the library. It is wrapped by the Proxy we do expose. It extends the _SharePointQueryableInstance class for which there is a matching _SharePointQueryableCollection. The generic parameter defines the return type of a get operation and the invoked result. Classes can have methods and properties as normal. This one has a single property as a simple example */ export class _HubSite extends _SharePointQueryableInstance<IHubSiteInfo> { /** * Gets the ISite instance associated with this hub site */ // the tag decorator is used to provide some additional telemetry on what methods are // being called. @tag(\"hs.getSite\") public async getSite(): Promise<ISite> { // we execute a request using this instance, selecting the SiteUrl property, and invoking it immediately and awaiting the result const d = await this.select(\"SiteUrl\")(); // we then return a new ISite instance created from the Site factory using the returned SiteUrl property as the baseUrl return Site(d.SiteUrl); } } /* This defines the interface we export and expose to consumers. In most cases this extends the concrete object but may add or remove some methods/properties in special cases */ export interface IHubSite extends _HubSite { } /* This defines the HubSite factory function as discussed above binding the spInvokableFactory to a generic param of IHubSite and a param of _HubSite. This is understood to mean that HubSite is a factory function that returns a types of IHubSite which the spInvokableFactory will create using _HubSite as the concrete underlying type. */ export const HubSite = spInvokableFactory<IHubSite>(_HubSite);","title":"Class structure"},{"location":"v2/contributing/extending-the-library/#add-a-property","text":"In most cases you won't need to create the class, interface, or factory - you just want to add a property or method. An example of this is sp.web.lists. web is a property of sp and lists is a property of web. You can have a look at those classes as examples. Let's have a look at the fields on the _View class. export class _View extends _SharePointQueryableInstance<IViewInfo> { // ... other code removed // add the property, and provide a return type // return types should be interfaces public get fields(): IViewFields { // we use the ViewFields factory function supplying \"this\" as the first parameter // this will create a url like \".../fields/viewfields\" due to the defaultPath decorator // on the _ViewFields class. This is equivalent to: ViewFields(this, \"viewfields\") return ViewFields(this); } // ... other code removed } There are many examples throughout the library that follow this pattern.","title":"Add a Property"},{"location":"v2/contributing/extending-the-library/#add-a-method","text":"Adding a method is just like adding a property with the key difference that a method usually does something like make a web request or act like a property but take parameters. Let's look at the _Items getById method: @defaultPath(\"items\") export class _Items extends _SharePointQueryableCollection { /** * Gets an Item by id * * @param id The integer id of the item to retrieve */ // we declare a method and set the return type to an interface public getById(id: number): IItem { // here we use the tag helper to add some telemetry to our request // we create a new IItem using the factory and appending the id value to the end // this gives us a valid url path to a single item .../items/getById(2) // we can then use the returned IItem to extend our chain or execute a request return tag.configure(Item(this).concat(`(${id})`), \"is.getById\"); } // ... other code removed }","title":"Add a Method"},{"location":"v2/contributing/extending-the-library/#web-request-method","text":"A second example is a method that performs a request. Here we use the _Item recycle method as an example: /** * Moves the list item to the Recycle Bin and returns the identifier of the new Recycle Bin item. */ // we use the tag decorator to add telemetry @tag(\"i.recycle\") // we return a promise public recycle(): Promise<string> { // we use the spPost method to post the request created by cloning our current instance IItem using // the Item factory and adding the path \"recycle\" to the end. Url will look like .../items/getById(2)/recycle return spPost<string>(this.clone(Item, \"recycle\")); }","title":"Web Request Method"},{"location":"v2/contributing/extending-the-library/#augment-using-selective-imports","text":"To understand is how to extend functionality within the selective imports structures look at list.ts file in the items submodule. Here you can see the code below, with extra comments to explain what is happening. Again, you will see this pattern repeated throughout the library so there are many examples available. // import the addProp helper import { addProp } from \"@pnp/queryable\"; // import the _List concrete class from the types module (not the index!) import { _List } from \"../lists/types\"; // import the interface and factory we are going to add to the List import { Items, IItems } from \"./types\"; // This module declaration fixes up the types, allowing .items to appear in intellisense // when you import \"@pnp/sp/items/list\"; declare module \"../lists/types\" { // we need to extend the concrete type interface _List { readonly items: IItems; } // we need to extend the interface // this may not be strictly necessary as the IList interface extends _List so it // should pick up the same additions, but we have seen in some cases this does seem // to be required. So we include it for safety as it will all be removed during // transpilation we don't need to care about the extra code interface IList { readonly items: IItems; } } // finally we add the property to the _List class // this method call says add a property to _List named \"items\" and that property returns a result using the Items factory // The factory will be called with \"this\" when the property is accessed. If needed there is a fourth parameter to append additional path // information to the property url addProp(_List, \"items\", Items);","title":"Augment Using Selective Imports"},{"location":"v2/contributing/extending-the-library/#general-rules-for-extending-pnpjs","text":"Only expose interfaces to consumers Use the factory functions except in very special cases Look for other properties and methods as examples Simple is always preferable, but not always possible - use your best judgement If you find yourself writing a ton of code to solve a problem you think should be easy, ask If you find yourself deep within the core classes or odata library trying to make a change, ask - changes to the core classes are rarely needed","title":"General Rules for Extending PnPjs"},{"location":"v2/contributing/extending-the-library/#next-steps","text":"Now that you have extended the library you need to write a test to cover it!","title":"Next Steps"},{"location":"v2/contributing/local-debug-configuration/","text":"Local Debugging Configuration \u00b6 This article covers the local setup required to debug the library and run tests. This only needs to be done once (unless you update the app registrations, then you just need to update the settings.js file accordingly). Create settings.js \u00b6 Both local debugging and tests make use of a settings.js file located in the root of the project. Ensure you create a settings.js files by copying settings.example.js and renaming it to settings.js. For more information the settings file please see Settings Minimal Configuration \u00b6 You can control which tests are run by including or omitting sp and graph sections. If sp is present and graph is not, only sp tests are run. Include both and all tests are run, respecting the enableWebTests flag. The following configuration file allows you to run all the tests that do not contact services. var sets = { testing: { enableWebTests: false, } } module.exports = sets; Test your setup \u00b6 If you hit F5 in VSCode now you should be able to see the full response from getting the web's title in the internal console window. If not, ensure that you have properly updated the settings file and registered the add-in perms correctly.","title":"Local Debugging Configuration"},{"location":"v2/contributing/local-debug-configuration/#local-debugging-configuration","text":"This article covers the local setup required to debug the library and run tests. This only needs to be done once (unless you update the app registrations, then you just need to update the settings.js file accordingly).","title":"Local Debugging Configuration"},{"location":"v2/contributing/local-debug-configuration/#create-settingsjs","text":"Both local debugging and tests make use of a settings.js file located in the root of the project. Ensure you create a settings.js files by copying settings.example.js and renaming it to settings.js. For more information the settings file please see Settings","title":"Create settings.js"},{"location":"v2/contributing/local-debug-configuration/#minimal-configuration","text":"You can control which tests are run by including or omitting sp and graph sections. If sp is present and graph is not, only sp tests are run. Include both and all tests are run, respecting the enableWebTests flag. The following configuration file allows you to run all the tests that do not contact services. var sets = { testing: { enableWebTests: false, } } module.exports = sets;","title":"Minimal Configuration"},{"location":"v2/contributing/local-debug-configuration/#test-your-setup","text":"If you hit F5 in VSCode now you should be able to see the full response from getting the web's title in the internal console window. If not, ensure that you have properly updated the settings file and registered the add-in perms correctly.","title":"Test your setup"},{"location":"v2/contributing/pull-requests/","text":"Submitting Pull Requests \u00b6 Pull requests may be large or small - adding whole new features or fixing some misspellings. Regardless, they are all appreciated and help improve the library for everyone! By following the below guidelines we'll have an easier time merging your work and getting it into the next release. Target your pull requests to the version-2 branch Add/Update any relevant docs articles in the relevant package's docs folder related to your changes Include a test for any new functionality and ensure all existing tests are passing by running npm test Ensure linting checks pass by typing npm run lint Ensure everything works for a build by running npm run package Keep your PRs as simple as possible and describe the changes to help the reviewer understand your work If you have an idea for a larger change to the library please open an issue and let's discuss before you invest many hours - these are very welcome but want to ensure it is something we can merge before you spend the time :) If you need to target a PR for version 1, please target the \"version-1\" branch Sharing is Caring - Pull Request Guidance \u00b6 The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website. Next Steps \u00b6 Now that you've submitted your PR please keep an eye on it as we might have questions. Once an initial review is complete we'll tag it with the expected version number for which it is targeted. Thank you for helping PnPjs grow and improve!!","title":"Submitting Pull Requests"},{"location":"v2/contributing/pull-requests/#submitting-pull-requests","text":"Pull requests may be large or small - adding whole new features or fixing some misspellings. Regardless, they are all appreciated and help improve the library for everyone! By following the below guidelines we'll have an easier time merging your work and getting it into the next release. Target your pull requests to the version-2 branch Add/Update any relevant docs articles in the relevant package's docs folder related to your changes Include a test for any new functionality and ensure all existing tests are passing by running npm test Ensure linting checks pass by typing npm run lint Ensure everything works for a build by running npm run package Keep your PRs as simple as possible and describe the changes to help the reviewer understand your work If you have an idea for a larger change to the library please open an issue and let's discuss before you invest many hours - these are very welcome but want to ensure it is something we can merge before you spend the time :) If you need to target a PR for version 1, please target the \"version-1\" branch","title":"Submitting Pull Requests"},{"location":"v2/contributing/pull-requests/#sharing-is-caring-pull-request-guidance","text":"The PnP \"Sharing Is Caring\" initiative teaches the basics around making changes in GitHub, submitting pull requests to the PnP & Microsoft 365 open-source repositories such as PnPjs. Every month, we provide multiple live hands-on sessions that walk attendees through the process of using and contributing to PnP initiatives. To learn more and register for an upcoming session, please visit the Sharing is Caring website.","title":"Sharing is Caring - Pull Request Guidance"},{"location":"v2/contributing/pull-requests/#next-steps","text":"Now that you've submitted your PR please keep an eye on it as we might have questions. Once an initial review is complete we'll tag it with the expected version number for which it is targeted. Thank you for helping PnPjs grow and improve!!","title":"Next Steps"},{"location":"v2/contributing/setup-dev-machine/","text":"Setting up your Developer Machine \u00b6 If you are a longtime client side developer you likely have your machine already configured and can skip to forking the repo and debugging . Setup your development environment \u00b6 These steps will help you get your environment setup for contributing to the core library. Install Visual Studio Code - this is the development environment we use so the contribution sections expect you are as well. If you prefer you can use Visual Studio or any editor you like. Install Node JS - this provides two key capabilities; the first is the nodejs server which will act as our development server (think iisexpress), the second is npm a package manager (think nuget). This library requires node >= 10.18.0 On Windows: Install Python [Optional] Install the tslint extension in VS Code: Press Shift + Ctrl + \"p\" to open the command panel Begin typing \"install extension\" and select the command when it appears in view Begin typing \"tslint\" and select the package when it appears in view Restart Code after installation Fork The Repo \u00b6 All of our contributions come via pull requests and you'll need to fork the repository Now we need to fork and clone the git repository. This can be done using your console or using your preferred Git GUI tool. Once you have the code locally, navigate to the root of the project in your console. Type the following command: npm install Follow the guidance to complete the one-time local configuration required to debug and run tests. Then you can follow the guidance in the debugging article.","title":"Setting up your Developer Machine"},{"location":"v2/contributing/setup-dev-machine/#setting-up-your-developer-machine","text":"If you are a longtime client side developer you likely have your machine already configured and can skip to forking the repo and debugging .","title":"Setting up your Developer Machine"},{"location":"v2/contributing/setup-dev-machine/#setup-your-development-environment","text":"These steps will help you get your environment setup for contributing to the core library. Install Visual Studio Code - this is the development environment we use so the contribution sections expect you are as well. If you prefer you can use Visual Studio or any editor you like. Install Node JS - this provides two key capabilities; the first is the nodejs server which will act as our development server (think iisexpress), the second is npm a package manager (think nuget). This library requires node >= 10.18.0 On Windows: Install Python [Optional] Install the tslint extension in VS Code: Press Shift + Ctrl + \"p\" to open the command panel Begin typing \"install extension\" and select the command when it appears in view Begin typing \"tslint\" and select the package when it appears in view Restart Code after installation","title":"Setup your development environment"},{"location":"v2/contributing/setup-dev-machine/#fork-the-repo","text":"All of our contributions come via pull requests and you'll need to fork the repository Now we need to fork and clone the git repository. This can be done using your console or using your preferred Git GUI tool. Once you have the code locally, navigate to the root of the project in your console. Type the following command: npm install Follow the guidance to complete the one-time local configuration required to debug and run tests. Then you can follow the guidance in the debugging article.","title":"Fork The Repo"},{"location":"v2/graph/","text":"@pnp/graph \u00b6 This package contains the fluent api used to call the graph rest services. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application and access the root sp object import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; (function main() { // here we will load the current web's properties graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); }); })() Getting Started with SharePoint Framework \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application, update OnInit, and access the root sp object in render import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; // here we will load the current web's properties graph.groups().then(groups => { this.domElement.innerHTML = `Groups: <ul>${groups.map(g => `<li>${g.displayName}</li>`).join(\"\")}</ul>`; }); } Getting Started on Nodejs \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { graph } from \"@pnp/graph\"; import { AdalFetchClient } from \"@pnp/nodejs\"; import \"@pnp/graph/groups\"; // do this once per page load graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}.onmicrosoft.com\", \"AAD Application Id\", \"AAD Application Secret\"); }, }, }); // here we will load the groups information graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); });","title":"@pnp/graph"},{"location":"v2/graph/#pnpgraph","text":"This package contains the fluent api used to call the graph rest services.","title":"@pnp/graph"},{"location":"v2/graph/#getting-started","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application and access the root sp object import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; (function main() { // here we will load the current web's properties graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); }); })()","title":"Getting Started"},{"location":"v2/graph/#getting-started-with-sharepoint-framework","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph --save Import the library into your application, update OnInit, and access the root sp object in render import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present graph.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; // here we will load the current web's properties graph.groups().then(groups => { this.domElement.innerHTML = `Groups: <ul>${groups.map(g => `<li>${g.displayName}</li>`).join(\"\")}</ul>`; }); }","title":"Getting Started with SharePoint Framework"},{"location":"v2/graph/#getting-started-on-nodejs","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable @pnp/graph @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { graph } from \"@pnp/graph\"; import { AdalFetchClient } from \"@pnp/nodejs\"; import \"@pnp/graph/groups\"; // do this once per page load graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}.onmicrosoft.com\", \"AAD Application Id\", \"AAD Application Secret\"); }, }, }); // here we will load the groups information graph.groups().then(g => { console.log(`Groups: ${JSON.stringify(g, null, 4)}`); });","title":"Getting Started on Nodejs"},{"location":"v2/graph/calendars/","text":"@pnp/graph/calendars \u00b6 Calendars exist in Outlook and can belong to either a user or group. With @pnp/graph@<=2.0.6 , only events for a user and group's default calendar could be fetched/created/updated. In versions 2.0.7 and up, all calendars and their events can be fetched. More information can be found in the official Graph documentation: Calendar Resource Type Event Resource Type ICalendar, ICalendars \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/calendars\"; Preset: All import { graph } from \"@pnp/graph/presets/all\"; Get All Calendars For a User \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendars = await graph.users.getById('user@tenant.onmicrosoft.com').calendars(); const myCalendars = await graph.me.calendars(); Get a Specific Calendar For a User \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CALENDAR_ID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getById(CALENDAR_ID)(); const myCalendar = await graph.me.calendars.getById(CALENDAR_ID)(); Get a User's Default Calendar \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendar(); const myCalendar = await graph.me.calendar(); Get Events For a User's Default Calendar \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // You can get the default calendar events const events = await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events(); // or get all events for the user const events = await graph.users.getById('user@tenant.onmicrosoft.com').events(); // You can get my default calendar events const events = await graph.me.calendar.events(); // or get all events for me const events = await graph.me.events(); Get Events By ID \u00b6 You can use .events.getByID to search through all the events in all calendars or narrow the request to a specific calendar. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CalendarID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA=='; const EventID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; // Get events by ID const event = await graph.users.getById('user@tenant.onmicrosoft.com').events.getByID(EventID); const events = await graph.me.events.getByID(EventID); // Get an event by ID from a specific calendar const event = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getByID(CalendarID).events.getByID(EventID); const events = await graph.me.calendars.getByID(CalendarID).events.getByID(EventID); Create Events \u00b6 This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.add( { \"subject\": \"Let's go for lunch\", \"body\": { \"contentType\": \"HTML\", \"content\": \"Does late morning work for you?\" }, \"start\": { \"dateTime\": \"2017-04-15T12:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"end\": { \"dateTime\": \"2017-04-15T14:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"location\":{ \"displayName\":\"Harry's Bar\" }, \"attendees\": [ { \"emailAddress\": { \"address\":\"samanthab@contoso.onmicrosoft.com\", \"name\": \"Samantha Booth\" }, \"type\": \"required\" } ] }); Update Events \u00b6 This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.getById(EVENT_ID).update({ reminderMinutesBeforeStart: 99, }); Delete Event \u00b6 This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').events.getById(EVENT_ID).delete(); await graph.me.events.getById(EVENT_ID).delete(); Get Calendar for a Group \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; const calendar = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar(); Get Events for a Group \u00b6 import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; // You can do one of const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar.events(); // or const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').events(); Get Calendar View \u00b6 Added in 2.0.7 Gets the events in a calendar during a specified date range. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // basic request, note need to invoke the returned queryable const view = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\")(); // you can use select, top, etc to filter your returned results const view2 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\").select(\"subject\").top(3)(); // you can specify times along with the dates const view3 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01T19:00:00-08:00\", \"2020-03-01T19:00:00-08:00\")(); const view4 = await graph.me.calendarView(\"2020-01-01\", \"2020-03-01\")();","title":"@pnp/graph/calendars"},{"location":"v2/graph/calendars/#pnpgraphcalendars","text":"Calendars exist in Outlook and can belong to either a user or group. With @pnp/graph@<=2.0.6 , only events for a user and group's default calendar could be fetched/created/updated. In versions 2.0.7 and up, all calendars and their events can be fetched. More information can be found in the official Graph documentation: Calendar Resource Type Event Resource Type","title":"@pnp/graph/calendars"},{"location":"v2/graph/calendars/#icalendar-icalendars","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/calendars\"; Preset: All import { graph } from \"@pnp/graph/presets/all\";","title":"ICalendar, ICalendars"},{"location":"v2/graph/calendars/#get-all-calendars-for-a-user","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendars = await graph.users.getById('user@tenant.onmicrosoft.com').calendars(); const myCalendars = await graph.me.calendars();","title":"Get All Calendars For a User"},{"location":"v2/graph/calendars/#get-a-specific-calendar-for-a-user","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CALENDAR_ID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getById(CALENDAR_ID)(); const myCalendar = await graph.me.calendars.getById(CALENDAR_ID)();","title":"Get a Specific Calendar For a User"},{"location":"v2/graph/calendars/#get-a-users-default-calendar","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const calendar = await graph.users.getById('user@tenant.onmicrosoft.com').calendar(); const myCalendar = await graph.me.calendar();","title":"Get a User's Default Calendar"},{"location":"v2/graph/calendars/#get-events-for-a-users-default-calendar","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // You can get the default calendar events const events = await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events(); // or get all events for the user const events = await graph.users.getById('user@tenant.onmicrosoft.com').events(); // You can get my default calendar events const events = await graph.me.calendar.events(); // or get all events for me const events = await graph.me.events();","title":"Get Events For a User's Default Calendar"},{"location":"v2/graph/calendars/#get-events-by-id","text":"You can use .events.getByID to search through all the events in all calendars or narrow the request to a specific calendar. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const CalendarID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA=='; const EventID = 'AQMkAGZjNmY0MDN3LRI3YTYtNDQAFWQtOWNhZC04MmY3MGYxODkeOWUARgAAA-xUBMMopY1NkrWA0qGcXHsHAG4I-wMXjoRMkgRnRetM5oIAAAIBBgAAAG4I-wMXjoRMkgRnRetM5oIAAAIsYgAAAA=='; // Get events by ID const event = await graph.users.getById('user@tenant.onmicrosoft.com').events.getByID(EventID); const events = await graph.me.events.getByID(EventID); // Get an event by ID from a specific calendar const event = await graph.users.getById('user@tenant.onmicrosoft.com').calendars.getByID(CalendarID).events.getByID(EventID); const events = await graph.me.calendars.getByID(CalendarID).events.getByID(EventID);","title":"Get Events By ID"},{"location":"v2/graph/calendars/#create-events","text":"This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.add( { \"subject\": \"Let's go for lunch\", \"body\": { \"contentType\": \"HTML\", \"content\": \"Does late morning work for you?\" }, \"start\": { \"dateTime\": \"2017-04-15T12:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"end\": { \"dateTime\": \"2017-04-15T14:00:00\", \"timeZone\": \"Pacific Standard Time\" }, \"location\":{ \"displayName\":\"Harry's Bar\" }, \"attendees\": [ { \"emailAddress\": { \"address\":\"samanthab@contoso.onmicrosoft.com\", \"name\": \"Samantha Booth\" }, \"type\": \"required\" } ] });","title":"Create Events"},{"location":"v2/graph/calendars/#update-events","text":"This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').calendar.events.getById(EVENT_ID).update({ reminderMinutesBeforeStart: 99, });","title":"Update Events"},{"location":"v2/graph/calendars/#delete-event","text":"This will work on any IEvents objects (e.g. anything accessed using an events key). import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; const EVENT_ID = 'BBMkAGZjNmY6MDM3LWI3YTYtNERhZC05Y2FkLTgyZjcwZjE4OTI5ZQBGAAAAAAD8VQTDKKWNTY61gNKhnFzLBwBuCP8DF46ETJIEZ0XrTOaCAAAAAAENAABuCP8DF46ETJFEZ0EnTOaCAAFvdoJvAAA='; await graph.users.getById('user@tenant.onmicrosoft.com').events.getById(EVENT_ID).delete(); await graph.me.events.getById(EVENT_ID).delete();","title":"Delete Event"},{"location":"v2/graph/calendars/#get-calendar-for-a-group","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; const calendar = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar();","title":"Get Calendar for a Group"},{"location":"v2/graph/calendars/#get-events-for-a-group","text":"import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/groups'; // You can do one of const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').calendar.events(); // or const events = await graph.groups.getById('21aaf779-f6d8-40bd-88c2-4a03f456ee82').events();","title":"Get Events for a Group"},{"location":"v2/graph/calendars/#get-calendar-view","text":"Added in 2.0.7 Gets the events in a calendar during a specified date range. import { graph } from '@pnp/graph'; import '@pnp/graph/calendars'; import '@pnp/graph/users'; // basic request, note need to invoke the returned queryable const view = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\")(); // you can use select, top, etc to filter your returned results const view2 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01\", \"2020-03-01\").select(\"subject\").top(3)(); // you can specify times along with the dates const view3 = await graph.users.getById('user@tenant.onmicrosoft.com').calendarView(\"2020-01-01T19:00:00-08:00\", \"2020-03-01T19:00:00-08:00\")(); const view4 = await graph.me.calendarView(\"2020-01-01\", \"2020-03-01\")();","title":"Get Calendar View"},{"location":"v2/graph/contacts/","text":"@pnp/graph/contacts \u00b6 The ability to manage contacts and folders in Outlook is a capability introduced in version 1.2.2 of @pnp/graph. Through the methods described you can add and edit both contacts and folders in a users Outlook. More information can be found in the official Graph documentation: Contact Resource Type IContact, IContacts, IContactFolder, IContactFolders \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/contacts\"; Preset: All import { graph } from \"@pnp/graph/presets/all\"; Set up notes \u00b6 To make user calls you can use getById where the id is the users email address. Contact ID, Folder ID, and Parent Folder ID use the following format \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\" Get all of the Contacts \u00b6 Gets a list of all the contacts for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contacts = await graph.users.getById('user@tenant.onmicrosoft.com').contacts(); const contacts2 = await graph.me.contacts(); Get Contact by Id \u00b6 Gets a specific contact by ID for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const contact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID)(); const contact2 = await graph.me.contacts.getById(contactID)(); Add a new Contact \u00b6 Adds a new contact for the user. import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); Update a Contact \u00b6 Updates a specific contact by ID for teh designated user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const updContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).update({birthday: \"1986-05-30\" }); const updContact2 = await graph.me.contacts.getById(contactID).update({birthday: \"1986-05-30\" }); Delete a Contact \u00b6 Delete a contact from the list of contacts for a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const delContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).delete(); const delContact2 = await graph.me.contacts.getById(contactID).delete(); Get all of the Contact Folders \u00b6 Get all the folders for the designated user's contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders(); const contactFolders2 = await graph.me.contactFolders(); Get Contact Folder by Id \u00b6 Get a contact folder by ID for the specified user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID)(); const contactFolder2 = await graph.me.contactFolders.getById(folderID)(); Add a new Contact Folder \u00b6 Add a new folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const parentFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAAAAAEOAAA=\"; const addedContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.add(\"New Folder\", parentFolderID); const addedContactFolder2 = await graph.me.contactFolders.add(\"New Folder\", parentFolderID); Update a Contact Folder \u00b6 Update an existing folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const updContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).update({displayName: \"Updated Folder\" }); const updContactFolder2 = await graph.me.contactFolders.getById(folderID).update({displayName: \"Updated Folder\" }); Delete a Contact Folder \u00b6 Delete a folder from the users contacts list. Deleting a folder deletes the contacts in that folder. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const delContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).delete(); const delContactFolder2 = await graph.me.contactFolders.getById(folderID).delete(); Get all of the Contacts from the Contact Folder \u00b6 Get all the contacts in a folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactsInContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).contacts(); const contactsInContactFolder2 = await graph.me.contactFolders.getById(folderID).contacts(); Get Child Folders of the Contact Folder \u00b6 Get child folders from contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const childFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders(); const childFolders2 = await graph.me.contactFolders.getById(folderID).childFolders(); Add a new Child Folder \u00b6 Add a new child folder to a contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const addedChildFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID); const addedChildFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID); Get Child Folder by Id \u00b6 Get child folder by ID from user contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const childFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID)(); const childFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID)(); Add Contact in Child Folder of Contact Folder \u00b6 Add a new contact to a child folder import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"./@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']);","title":"@pnp/graph/contacts"},{"location":"v2/graph/contacts/#pnpgraphcontacts","text":"The ability to manage contacts and folders in Outlook is a capability introduced in version 1.2.2 of @pnp/graph. Through the methods described you can add and edit both contacts and folders in a users Outlook. More information can be found in the official Graph documentation: Contact Resource Type","title":"@pnp/graph/contacts"},{"location":"v2/graph/contacts/#icontact-icontacts-icontactfolder-icontactfolders","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/contacts\"; Preset: All import { graph } from \"@pnp/graph/presets/all\";","title":"IContact, IContacts, IContactFolder, IContactFolders"},{"location":"v2/graph/contacts/#set-up-notes","text":"To make user calls you can use getById where the id is the users email address. Contact ID, Folder ID, and Parent Folder ID use the following format \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"","title":"Set up notes"},{"location":"v2/graph/contacts/#get-all-of-the-contacts","text":"Gets a list of all the contacts for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contacts = await graph.users.getById('user@tenant.onmicrosoft.com').contacts(); const contacts2 = await graph.me.contacts();","title":"Get all of the Contacts"},{"location":"v2/graph/contacts/#get-contact-by-id","text":"Gets a specific contact by ID for the user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const contact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID)(); const contact2 = await graph.me.contacts.getById(contactID)();","title":"Get Contact by Id"},{"location":"v2/graph/contacts/#add-a-new-contact","text":"Adds a new contact for the user. import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']);","title":"Add a new Contact"},{"location":"v2/graph/contacts/#update-a-contact","text":"Updates a specific contact by ID for teh designated user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const updContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).update({birthday: \"1986-05-30\" }); const updContact2 = await graph.me.contacts.getById(contactID).update({birthday: \"1986-05-30\" });","title":"Update a Contact"},{"location":"v2/graph/contacts/#delete-a-contact","text":"Delete a contact from the list of contacts for a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwBGAAAAAAC75QV12PBiRIjb8MNVIrJrBwBgs0NT6NreR57m1u_D8SpPAAAAAAEOAABgs0NT6NreR57m1u_D8SpPAAFCCnApAAA=\"; const delContact = await graph.users.getById('user@tenant.onmicrosoft.com').contacts.getById(contactID).delete(); const delContact2 = await graph.me.contacts.getById(contactID).delete();","title":"Delete a Contact"},{"location":"v2/graph/contacts/#get-all-of-the-contact-folders","text":"Get all the folders for the designated user's contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const contactFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders(); const contactFolders2 = await graph.me.contactFolders();","title":"Get all of the Contact Folders"},{"location":"v2/graph/contacts/#get-contact-folder-by-id","text":"Get a contact folder by ID for the specified user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID)(); const contactFolder2 = await graph.me.contactFolders.getById(folderID)();","title":"Get Contact Folder by Id"},{"location":"v2/graph/contacts/#add-a-new-contact-folder","text":"Add a new folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const parentFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAAAAAEOAAA=\"; const addedContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.add(\"New Folder\", parentFolderID); const addedContactFolder2 = await graph.me.contactFolders.add(\"New Folder\", parentFolderID);","title":"Add a new Contact Folder"},{"location":"v2/graph/contacts/#update-a-contact-folder","text":"Update an existing folder in the users contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const updContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).update({displayName: \"Updated Folder\" }); const updContactFolder2 = await graph.me.contactFolders.getById(folderID).update({displayName: \"Updated Folder\" });","title":"Update a Contact Folder"},{"location":"v2/graph/contacts/#delete-a-contact-folder","text":"Delete a folder from the users contacts list. Deleting a folder deletes the contacts in that folder. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const delContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).delete(); const delContactFolder2 = await graph.me.contactFolders.getById(folderID).delete();","title":"Delete a Contact Folder"},{"location":"v2/graph/contacts/#get-all-of-the-contacts-from-the-contact-folder","text":"Get all the contacts in a folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const contactsInContactFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).contacts(); const contactsInContactFolder2 = await graph.me.contactFolders.getById(folderID).contacts();","title":"Get all of the Contacts from the Contact Folder"},{"location":"v2/graph/contacts/#get-child-folders-of-the-contact-folder","text":"Get child folders from contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const childFolders = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders(); const childFolders2 = await graph.me.contactFolders.getById(folderID).childFolders();","title":"Get Child Folders of the Contact Folder"},{"location":"v2/graph/contacts/#add-a-new-child-folder","text":"Add a new child folder to a contact folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const addedChildFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID); const addedChildFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.add(\"Sub Folder\", folderID);","title":"Add a new Child Folder"},{"location":"v2/graph/contacts/#get-child-folder-by-id","text":"Get child folder by ID from user contacts import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const childFolder = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID)(); const childFolder2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID)();","title":"Get Child Folder by Id"},{"location":"v2/graph/contacts/#add-contact-in-child-folder-of-contact-folder","text":"Add a new contact to a child folder import { graph } from \"@pnp/graph\"; import { EmailAddress } from \"./@microsoft/microsoft-graph-types\"; import \"@pnp/graph/users\" import \"@pnp/graph/contacts\" const folderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqH9AAA=\"; const subFolderID = \"AAMkADY1OTQ5MTM0LTU2OTktNDI0Yy1iODFjLWNiY2RmMzNjODUxYwAuAAAAAAC75QV12PBiRIjb8MNVIrJrAQBgs0NT6NreR57m1u_D8SpPAAFCCqIZAAA=\"; const addedContact = await graph.users.getById('user@tenant.onmicrosoft.com').contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']); const addedContact2 = await graph.me.contactFolders.getById(folderID).childFolders.getById(subFolderID).contacts.add('Pavel', 'Bansky', [<EmailAddress>{address: 'pavelb@fabrikam.onmicrosoft.com', name: 'Pavel Bansky' }], ['+1 732 555 0102']);","title":"Add Contact in Child Folder of Contact Folder"},{"location":"v2/graph/directoryobjects/","text":"@pnp/graph/directoryObjects \u00b6 Represents an Azure Active Directory object. The directoryObject type is the base type for many other directory entity types. More information can be found in the official Graph documentation: DirectoryObject Resource Type IDirectoryObject, IDirectoryObjects \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; Preset: All import { graph } from \"@pnp/sp/presets/all\"; The groups and directory roles for the user \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" const memberOf = await graph.users.getById('user@tenant.onmicrosoft.com').memberOf(); const memberOf2 = await graph.me.memberOf(); Return all the groups the user, group or directoryObject is a member of. Add true parameter to return only security enabled groups \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/groups\" const memberGroups = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberGroups(); const memberGroups2 = await graph.me.getMemberGroups(); // Returns only security enabled groups const memberGroups3 = await graph.me.getMemberGroups(true); const memberGroups4 = await graph.groups.getById('user@tenant.onmicrosoft.com').getMemberGroups(); Returns all the groups, administrative units and directory roles that a user, group, or directory object is a member of. Add true parameter to return only security enabled groups \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const memberObjects = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberObjects(); const memberObjects2 = await graph.me.getMemberObjects(); // Returns only security enabled groups const memberObjects3 = await graph.me.getMemberObjects(true); const memberObjects4 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').getMemberObjects(); Check for membership in a specified list of groups \u00b6 And returns from that list those groups of which the specified user, group, or directory object is a member import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const checkedMembers = await graph.users.getById('user@tenant.onmicrosoft.com').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers2 = await graph.me.checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers3 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); Get directoryObject by Id \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const dirObject = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26'); Delete directoryObject \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const deleted = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').delete()","title":"@pnp/graph/directoryObjects"},{"location":"v2/graph/directoryobjects/#pnpgraphdirectoryobjects","text":"Represents an Azure Active Directory object. The directoryObject type is the base type for many other directory entity types. More information can be found in the official Graph documentation: DirectoryObject Resource Type","title":"@pnp/graph/directoryObjects"},{"location":"v2/graph/directoryobjects/#idirectoryobject-idirectoryobjects","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; Preset: All import { graph } from \"@pnp/sp/presets/all\";","title":"IDirectoryObject, IDirectoryObjects"},{"location":"v2/graph/directoryobjects/#the-groups-and-directory-roles-for-the-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" const memberOf = await graph.users.getById('user@tenant.onmicrosoft.com').memberOf(); const memberOf2 = await graph.me.memberOf();","title":"The groups and directory roles for the user"},{"location":"v2/graph/directoryobjects/#return-all-the-groups-the-user-group-or-directoryobject-is-a-member-of-add-true-parameter-to-return-only-security-enabled-groups","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/groups\" const memberGroups = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberGroups(); const memberGroups2 = await graph.me.getMemberGroups(); // Returns only security enabled groups const memberGroups3 = await graph.me.getMemberGroups(true); const memberGroups4 = await graph.groups.getById('user@tenant.onmicrosoft.com').getMemberGroups();","title":"Return all the groups the user, group or directoryObject is a member of. Add true parameter to return only security enabled groups"},{"location":"v2/graph/directoryobjects/#returns-all-the-groups-administrative-units-and-directory-roles-that-a-user-group-or-directory-object-is-a-member-of-add-true-parameter-to-return-only-security-enabled-groups","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const memberObjects = await graph.users.getById('user@tenant.onmicrosoft.com').getMemberObjects(); const memberObjects2 = await graph.me.getMemberObjects(); // Returns only security enabled groups const memberObjects3 = await graph.me.getMemberObjects(true); const memberObjects4 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').getMemberObjects();","title":"Returns all the groups, administrative units and directory roles that a user, group, or directory object is a member of. Add true parameter to return only security enabled groups"},{"location":"v2/graph/directoryobjects/#check-for-membership-in-a-specified-list-of-groups","text":"And returns from that list those groups of which the specified user, group, or directory object is a member import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/groups\"; const checkedMembers = await graph.users.getById('user@tenant.onmicrosoft.com').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers2 = await graph.me.checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]); const checkedMembers3 = await graph.groups.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').checkMemberGroups([\"c2fb52d1-5c60-42b1-8c7e-26ce8dc1e741\",\"2001bb09-1d46-40a6-8176-7bb867fb75aa\"]);","title":"Check for membership in a specified list of groups"},{"location":"v2/graph/directoryobjects/#get-directoryobject-by-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const dirObject = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26');","title":"Get directoryObject by Id"},{"location":"v2/graph/directoryobjects/#delete-directoryobject","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/directory-objects\"; const deleted = await graph.directoryObjects.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').delete()","title":"Delete directoryObject"},{"location":"v2/graph/groups/","text":"@pnp/graph/groups \u00b6 Groups are collections of users and other principals who share access to resources in Microsoft services or in your app. All group-related operations in Microsoft Graph require administrator consent. Note: Groups can only be created through work or school accounts. Personal Microsoft accounts don't support groups. You can learn more about Microsoft Graph Groups by reading the Official Microsoft Graph Documentation . IGroup, IGroups \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups} from \"@pnp/graph/groups\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; Preset: All import { graph, Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups } from \"@pnp/graph/presets/all\"; Add a Group \u00b6 Add a new group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import { GroupType } from '@pnp/graph/groups'; const groupAddResult = await graph.groups.add(\"GroupName\", \"Mail_NickName\", GroupType.Office365); const group = await groupAddResult.group(); Delete a Group \u00b6 Deletes an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").delete(); Update Group Properties \u00b6 Updates an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").update({ displayName: newName, propertyName: updatedValue}); Add favorite \u00b6 Add the group to the list of the current user's favorite groups. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").addFavorite(); Remove favorite \u00b6 Remove the group from the list of the current user's favorite groups. Supported for Office 365 Groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").removeFavorite(); Reset Unseen Count \u00b6 Reset the unseenCount of all the posts that the current user has not seen since their last visit. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").resetUnseenCount(); Subscribe By Mail \u00b6 Calling this method will enable the current user to receive email notifications for this group, about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").subscribeByMail(); Unsubscribe By Mail \u00b6 Calling this method will prevent the current user from receiving email notifications for this group about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").unsubscribeByMail(); Get Calendar View \u00b6 Get the occurrences, exceptions, and single instances of events in a calendar view defined by a time range, from the default calendar of a group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; const startDate = new Date(\"2020-04-01\"); const endDate = new Date(\"2020-03-01\"); const events = graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").getCalendarView(startDate, endDate); Group Photo Operations \u00b6 See Photos Get the Team Site for a Group \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/sites/group\"; const teamSite = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").sites.root(); const url = teamSite.webUrl","title":"@pnp/graph/groups"},{"location":"v2/graph/groups/#pnpgraphgroups","text":"Groups are collections of users and other principals who share access to resources in Microsoft services or in your app. All group-related operations in Microsoft Graph require administrator consent. Note: Groups can only be created through work or school accounts. Personal Microsoft accounts don't support groups. You can learn more about Microsoft Graph Groups by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/groups"},{"location":"v2/graph/groups/#igroup-igroups","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups} from \"@pnp/graph/groups\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; Preset: All import { graph, Group, GroupType, Groups, IGroup, IGroupAddResult, IGroups } from \"@pnp/graph/presets/all\";","title":"IGroup, IGroups"},{"location":"v2/graph/groups/#add-a-group","text":"Add a new group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import { GroupType } from '@pnp/graph/groups'; const groupAddResult = await graph.groups.add(\"GroupName\", \"Mail_NickName\", GroupType.Office365); const group = await groupAddResult.group();","title":"Add a Group"},{"location":"v2/graph/groups/#delete-a-group","text":"Deletes an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").delete();","title":"Delete a Group"},{"location":"v2/graph/groups/#update-group-properties","text":"Updates an existing group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").update({ displayName: newName, propertyName: updatedValue});","title":"Update Group Properties"},{"location":"v2/graph/groups/#add-favorite","text":"Add the group to the list of the current user's favorite groups. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").addFavorite();","title":"Add favorite"},{"location":"v2/graph/groups/#remove-favorite","text":"Remove the group from the list of the current user's favorite groups. Supported for Office 365 Groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").removeFavorite();","title":"Remove favorite"},{"location":"v2/graph/groups/#reset-unseen-count","text":"Reset the unseenCount of all the posts that the current user has not seen since their last visit. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").resetUnseenCount();","title":"Reset Unseen Count"},{"location":"v2/graph/groups/#subscribe-by-mail","text":"Calling this method will enable the current user to receive email notifications for this group, about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").subscribeByMail();","title":"Subscribe By Mail"},{"location":"v2/graph/groups/#unsubscribe-by-mail","text":"Calling this method will prevent the current user from receiving email notifications for this group about new posts, events, and files in that group. Supported for Office 365 groups only. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").unsubscribeByMail();","title":"Unsubscribe By Mail"},{"location":"v2/graph/groups/#get-calendar-view","text":"Get the occurrences, exceptions, and single instances of events in a calendar view defined by a time range, from the default calendar of a group. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; const startDate = new Date(\"2020-04-01\"); const endDate = new Date(\"2020-03-01\"); const events = graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").getCalendarView(startDate, endDate);","title":"Get Calendar View"},{"location":"v2/graph/groups/#group-photo-operations","text":"See Photos","title":"Group Photo Operations"},{"location":"v2/graph/groups/#get-the-team-site-for-a-group","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/sites/group\"; const teamSite = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").sites.root(); const url = teamSite.webUrl","title":"Get the Team Site for a Group"},{"location":"v2/graph/insights/","text":"@pnp/graph/insights \u00b6 This module helps you get Insights in form of Trending , Used and Shared . The results are based on relationships calculated using advanced analytics and machine learning techniques. IInsights \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; Preset: All import \"@pnp/graph/presets/all\"; Get all Trending documents \u00b6 Returns documents from OneDrive and SharePoint sites trending around a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trending = await graph.me.insights.trending() const trending = await graph.users.getById(\"userId\").insights.trending() Get a Trending document by Id \u00b6 Using the getById method to get a trending document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trendingDoc = await graph.me.insights.trending.getById('Id')() const trendingDoc = await graph.users.getById(\"userId\").insights.trending.getById('Id')() Get the resource from Trending document \u00b6 Using the resources method to get the resource from a trending document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.trending.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.trending.getById('Id').resource() Get all Used documents \u00b6 Returns documents viewed and modified by a user. Includes documents the user used in OneDrive for Business, SharePoint, opened as email attachments, and as link attachments from sources like Box, DropBox and Google Drive. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const used = await graph.me.insights.used() const used = await graph.users.getById(\"userId\").insights.used() Get a Used document by Id \u00b6 Using the getById method to get a used document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const usedDoc = await graph.me.insights.used.getById('Id')() const usedDoc = await graph.users.getById(\"userId\").insights.used.getById('Id')() Get the resource from Used document \u00b6 Using the resources method to get the resource from a used document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.used.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.used.getById('Id').resource() Get all Shared documents \u00b6 Returns documents shared with a user. Documents can be shared as email attachments or as OneDrive for Business links sent in emails. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const shared = await graph.me.insights.shared() const shared = await graph.users.getById(\"userId\").insights.shared() Get a Shared document by Id \u00b6 Using the getById method to get a shared document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const sharedDoc = await graph.me.insights.shared.getById('Id')() const sharedDoc = await graph.users.getById(\"userId\").insights.shared.getById('Id')() Get the resource from a Shared document \u00b6 Using the resources method to get the resource from a shared document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.shared.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.shared.getById('Id').resource()","title":"@pnp/graph/insights"},{"location":"v2/graph/insights/#pnpgraphinsights","text":"This module helps you get Insights in form of Trending , Used and Shared . The results are based on relationships calculated using advanced analytics and machine learning techniques.","title":"@pnp/graph/insights"},{"location":"v2/graph/insights/#iinsights","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInsights"},{"location":"v2/graph/insights/#get-all-trending-documents","text":"Returns documents from OneDrive and SharePoint sites trending around a user. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trending = await graph.me.insights.trending() const trending = await graph.users.getById(\"userId\").insights.trending()","title":"Get all Trending documents"},{"location":"v2/graph/insights/#get-a-trending-document-by-id","text":"Using the getById method to get a trending document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const trendingDoc = await graph.me.insights.trending.getById('Id')() const trendingDoc = await graph.users.getById(\"userId\").insights.trending.getById('Id')()","title":"Get a Trending document by Id"},{"location":"v2/graph/insights/#get-the-resource-from-trending-document","text":"Using the resources method to get the resource from a trending document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.trending.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.trending.getById('Id').resource()","title":"Get the resource from Trending document"},{"location":"v2/graph/insights/#get-all-used-documents","text":"Returns documents viewed and modified by a user. Includes documents the user used in OneDrive for Business, SharePoint, opened as email attachments, and as link attachments from sources like Box, DropBox and Google Drive. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const used = await graph.me.insights.used() const used = await graph.users.getById(\"userId\").insights.used()","title":"Get all Used documents"},{"location":"v2/graph/insights/#get-a-used-document-by-id","text":"Using the getById method to get a used document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const usedDoc = await graph.me.insights.used.getById('Id')() const usedDoc = await graph.users.getById(\"userId\").insights.used.getById('Id')()","title":"Get a Used document by Id"},{"location":"v2/graph/insights/#get-the-resource-from-used-document","text":"Using the resources method to get the resource from a used document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.used.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.used.getById('Id').resource()","title":"Get the resource from Used document"},{"location":"v2/graph/insights/#get-all-shared-documents","text":"Returns documents shared with a user. Documents can be shared as email attachments or as OneDrive for Business links sent in emails. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const shared = await graph.me.insights.shared() const shared = await graph.users.getById(\"userId\").insights.shared()","title":"Get all Shared documents"},{"location":"v2/graph/insights/#get-a-shared-document-by-id","text":"Using the getById method to get a shared document by Id. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const sharedDoc = await graph.me.insights.shared.getById('Id')() const sharedDoc = await graph.users.getById(\"userId\").insights.shared.getById('Id')()","title":"Get a Shared document by Id"},{"location":"v2/graph/insights/#get-the-resource-from-a-shared-document","text":"Using the resources method to get the resource from a shared document. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/insights\"; import \"@pnp/graph/users\"; const resource = await graph.me.insights.shared.getById('Id').resource() const resource = await graph.users.getById(\"userId\").insights.shared.getById('Id').resource()","title":"Get the resource from a Shared document"},{"location":"v2/graph/invitations/","text":"@pnp/graph/invitations \u00b6 The ability invite an external user via the invitation manager IInvitations \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\"; Preset: All import \"@pnp/graph/presets/all\"; Create Invitation \u00b6 Using the invitations.create() you can create an Invitation. We need the email address of the user being invited and the URL user should be redirected to once the invitation is redeemed (redirect URL). import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\" const invitationResult = await graph.invitations.create('external.user@email-address.com', 'https://tenant.sharepoint.com/sites/redirecturi');","title":"@pnp/graph/invitations"},{"location":"v2/graph/invitations/#pnpgraphinvitations","text":"The ability invite an external user via the invitation manager","title":"@pnp/graph/invitations"},{"location":"v2/graph/invitations/#iinvitations","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInvitations"},{"location":"v2/graph/invitations/#create-invitation","text":"Using the invitations.create() you can create an Invitation. We need the email address of the user being invited and the URL user should be redirected to once the invitation is redeemed (redirect URL). import { graph } from \"@pnp/graph\"; import \"@pnp/graph/invitations\" const invitationResult = await graph.invitations.create('external.user@email-address.com', 'https://tenant.sharepoint.com/sites/redirecturi');","title":"Create Invitation"},{"location":"v2/graph/onedrive/","text":"@pnp/graph/onedrive \u00b6 The ability to manage drives and drive items in Onedrive is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can manage drives and drive items in Onedrive. IInvitations \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; Preset: All import \"@pnp/graph/presets/all\"; Get the default drive \u00b6 Using the drive() you can get the default drive from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives(); Get all of the drives \u00b6 Using the drives() you can get the users available drives from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives(); Get drive by Id \u00b6 Using the drives.getById() you can get one of the available drives in Outlook import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drive = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId'); const drive = await graph.me.drives.getById('driveId'); Get the associated list of a drive \u00b6 Using the list() you get the associated list import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const list = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').list(); const list = await graph.me.drives.getById('driveId').list(); Get the recent files \u00b6 Using the recent() you get the recent files import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const files = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').recent(); const files = await graph.me.drives.getById('driveId').recent(); Get the files shared with me \u00b6 Using the sharedWithMe() you get the files shared with the user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const shared = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').sharedWithMe(); const shared = await graph.me.drives.getById('driveId').sharedWithMe(); Get the Root folder \u00b6 Using the root() you get the root folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const root = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root(); const root = await graph.me.drives.getById('driveId').root(); Get the Children \u00b6 Using the children() you get the children import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const rootChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children(); const rootChildren = await graph.me.drives.getById('driveId').root.children(); const itemChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').children(); const itemChildren = await graph.me.drives.getById('driveId').root.items.getById('itemId').children(); Add folder or item \u00b6 Using the add you can add a folder or an item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; import { DriveItem as IDriveItem } from \"@microsoft/microsoft-graph-types\"; const addFolder = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}}); const addFolder = await graph.me.drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}}); Search items \u00b6 Using the search() you can search for items, and optionally select properties import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const search = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId')root.search('queryText')(); const search = await graph.me.drives.getById('driveId')root.search('queryText')(); Get specific item in drive \u00b6 Using the items.getById() you can get a specific item from the current drive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const item = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId'); const item = await graph.me.drives.getById('driveId').items.getById('itemId'); Get thumbnails \u00b6 Using the thumbnails() you get the thumbnails import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').thumbnails(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').thumbnails(); Delete drive item \u00b6 Using the delete() you delete the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').delete(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').delete(); Update drive item \u00b6 Using the update() you update the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const update = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"}); const update = await graph.me.drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"}); Move drive item \u00b6 Using the move() you move the current item, and optionally update it import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; // Requires a parentReference to the new folder location const move = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"}); const move = await graph.me.drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"});","title":"@pnp/graph/onedrive"},{"location":"v2/graph/onedrive/#pnpgraphonedrive","text":"The ability to manage drives and drive items in Onedrive is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can manage drives and drive items in Onedrive.","title":"@pnp/graph/onedrive"},{"location":"v2/graph/onedrive/#iinvitations","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInvitations"},{"location":"v2/graph/onedrive/#get-the-default-drive","text":"Using the drive() you can get the default drive from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives();","title":"Get the default drive"},{"location":"v2/graph/onedrive/#get-all-of-the-drives","text":"Using the drives() you can get the users available drives from Onedrive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drives = await graph.users.getById('user@tenant.onmicrosoft.com').drives(); const drives = await graph.me.drives();","title":"Get all of the drives"},{"location":"v2/graph/onedrive/#get-drive-by-id","text":"Using the drives.getById() you can get one of the available drives in Outlook import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const drive = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId'); const drive = await graph.me.drives.getById('driveId');","title":"Get drive by Id"},{"location":"v2/graph/onedrive/#get-the-associated-list-of-a-drive","text":"Using the list() you get the associated list import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const list = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').list(); const list = await graph.me.drives.getById('driveId').list();","title":"Get the associated list of a drive"},{"location":"v2/graph/onedrive/#get-the-recent-files","text":"Using the recent() you get the recent files import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const files = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').recent(); const files = await graph.me.drives.getById('driveId').recent();","title":"Get the recent files"},{"location":"v2/graph/onedrive/#get-the-files-shared-with-me","text":"Using the sharedWithMe() you get the files shared with the user import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const shared = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').sharedWithMe(); const shared = await graph.me.drives.getById('driveId').sharedWithMe();","title":"Get the files shared with me"},{"location":"v2/graph/onedrive/#get-the-root-folder","text":"Using the root() you get the root folder import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const root = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root(); const root = await graph.me.drives.getById('driveId').root();","title":"Get the Root folder"},{"location":"v2/graph/onedrive/#get-the-children","text":"Using the children() you get the children import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const rootChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children(); const rootChildren = await graph.me.drives.getById('driveId').root.children(); const itemChildren = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').children(); const itemChildren = await graph.me.drives.getById('driveId').root.items.getById('itemId').children();","title":"Get the Children"},{"location":"v2/graph/onedrive/#add-folder-or-item","text":"Using the add you can add a folder or an item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; import { DriveItem as IDriveItem } from \"@microsoft/microsoft-graph-types\"; const addFolder = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}}); const addFolder = await graph.me.drives.getById('driveId').root.children.add('New Folder', <IDriveItem>{folder: {}});","title":"Add folder or item"},{"location":"v2/graph/onedrive/#search-items","text":"Using the search() you can search for items, and optionally select properties import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const search = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId')root.search('queryText')(); const search = await graph.me.drives.getById('driveId')root.search('queryText')();","title":"Search items"},{"location":"v2/graph/onedrive/#get-specific-item-in-drive","text":"Using the items.getById() you can get a specific item from the current drive import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const item = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId'); const item = await graph.me.drives.getById('driveId').items.getById('itemId');","title":"Get specific item in drive"},{"location":"v2/graph/onedrive/#get-thumbnails","text":"Using the thumbnails() you get the thumbnails import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').thumbnails(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').thumbnails();","title":"Get thumbnails"},{"location":"v2/graph/onedrive/#delete-drive-item","text":"Using the delete() you delete the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const thumbs = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').delete(); const thumbs = await graph.me.drives.getById('driveId').items.getById('itemId').delete();","title":"Delete drive item"},{"location":"v2/graph/onedrive/#update-drive-item","text":"Using the update() you update the current item import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; const update = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"}); const update = await graph.me.drives.getById('driveId').items.getById('itemId').update({name: \"New Name\"});","title":"Update drive item"},{"location":"v2/graph/onedrive/#move-drive-item","text":"Using the move() you move the current item, and optionally update it import { graph } from \"@pnp/graph\"; import \"@pnp/graph/onedrive\"; // Requires a parentReference to the new folder location const move = await graph.users.getById('user@tenant.onmicrosoft.com').drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"}); const move = await graph.me.drives.getById('driveId').items.getById('itemId').move({ parentReference: { id: 'itemId'}}, {name: \"New Name\"});","title":"Move drive item"},{"location":"v2/graph/outlook/","text":"@pnp/graph/outlook \u00b6 Represents the Outlook services available to a user. Currently, only interacting with categories is supported. You can learn more by reading the Official Microsoft Graph Documentation . IUsers, IUser, IPeople \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Outlook, IOutlook, MasterCategories, IMasterCategories, OutlookCategory, IOutlookCategory} from \"@pnp/graph/outlook\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/outlook\"; Preset: All import { graph, Outlook, IOutlook, MasterCategories, IMasterCategories } from \"@pnp/graph/presets/all\"; Get All Categories User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories(); Add Category User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions await graph.me.outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' }); // Application permissions await graph.users.getById('{user id}').outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' }); Update Category \u00b6 Testing has shown that displayName cannot be updated. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; import { OutlookCategory } from \"@microsoft/microsoft-graph-types\"; const categoryUpdate: OutlookCategory = { color: \"preset5\" } // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').update(categoryUpdate); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').update(categoryUpdate); Delete Category \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').delete(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').delete();","title":"@pnp/graph/outlook"},{"location":"v2/graph/outlook/#pnpgraphoutlook","text":"Represents the Outlook services available to a user. Currently, only interacting with categories is supported. You can learn more by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/outlook"},{"location":"v2/graph/outlook/#iusers-iuser-ipeople","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {Outlook, IOutlook, MasterCategories, IMasterCategories, OutlookCategory, IOutlookCategory} from \"@pnp/graph/outlook\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/outlook\"; Preset: All import { graph, Outlook, IOutlook, MasterCategories, IMasterCategories } from \"@pnp/graph/presets/all\";","title":"IUsers, IUser, IPeople"},{"location":"v2/graph/outlook/#get-all-categories-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories();","title":"Get All Categories User"},{"location":"v2/graph/outlook/#add-category-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions await graph.me.outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' }); // Application permissions await graph.users.getById('{user id}').outlook.masterCategories.add({ displayName: 'Newsletters', color: 'preset2' });","title":"Add Category User"},{"location":"v2/graph/outlook/#update-category","text":"Testing has shown that displayName cannot be updated. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; import { OutlookCategory } from \"@microsoft/microsoft-graph-types\"; const categoryUpdate: OutlookCategory = { color: \"preset5\" } // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').update(categoryUpdate); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').update(categoryUpdate);","title":"Update Category"},{"location":"v2/graph/outlook/#delete-category","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/outlook\"; // Delegated permissions const categories = await graph.me.outlook.masterCategories.getById('{category id}').delete(); // Application permissions const categories = await graph.users.getById('{user id}').outlook.masterCategories.getById('{category id}').delete();","title":"Delete Category"},{"location":"v2/graph/photos/","text":"@pnp/graph/photos \u00b6 A profile photo of a user, group or an Outlook contact accessed from Exchange Online or Azure Active Directory (AAD). It's binary data not encoded in base-64. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation . IPhoto \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IPhoto, Photo} from \"@pnp/graph/photos\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/photos\"; Preset: All import { graph, IPhoto, Photo } from \"@pnp/sp/presets/all\"; Current User Photo \u00b6 This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const photoValue = await graph.me.photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl); Current Group Photo \u00b6 This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/photos\"; const photoValue = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl); Set User Photo \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file); Set Group Photo \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file);","title":"@pnp/graph/photos"},{"location":"v2/graph/photos/#pnpgraphphotos","text":"A profile photo of a user, group or an Outlook contact accessed from Exchange Online or Azure Active Directory (AAD). It's binary data not encoded in base-64. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/photos"},{"location":"v2/graph/photos/#iphoto","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IPhoto, Photo} from \"@pnp/graph/photos\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/photos\"; Preset: All import { graph, IPhoto, Photo } from \"@pnp/sp/presets/all\";","title":"IPhoto"},{"location":"v2/graph/photos/#current-user-photo","text":"This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const photoValue = await graph.me.photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl);","title":"Current User Photo"},{"location":"v2/graph/photos/#current-group-photo","text":"This example shows the getBlob() endpoint, there is also a getBuffer() endpoint to support node.js import { graph } from \"@pnp/graph\"; import \"@pnp/graph/groups\"; import \"@pnp/graph/photos\"; const photoValue = await graph.groups.getById(\"7d2b9355-0891-47d3-84c8-bf2cd9c62177\").photo.getBlob(); const url = window.URL || window.webkitURL; const blobUrl = url.createObjectURL(photoValue); document.getElementById(\"photoElement\").setAttribute(\"src\", blobUrl);","title":"Current Group Photo"},{"location":"v2/graph/photos/#set-user-photo","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file);","title":"Set User Photo"},{"location":"v2/graph/photos/#set-group-photo","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const input = <HTMLInputElement>document.getElementById(\"thefileinput\"); const file = input.files[0]; await graph.me.photo.setContent(file);","title":"Set Group Photo"},{"location":"v2/graph/planner/","text":"@pnp/graph/planner \u00b6 The ability to manage plans and tasks in Planner is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can add, update and delete items in Planner. IInvitations \u00b6 Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\"; Preset: All import \"@pnp/graph/presets/all\"; Get Plans by Id \u00b6 Using the planner.plans.getById() you can get a specific Plan. Planner.plans is not an available endpoint, you need to get a specific Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const plan = await graph.planner.plans.getById('planId')(); Add new Plan \u00b6 Using the planner.plans.add() you can create a new Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newPlan = await graph.planner.plans.add('groupObjectId', 'title'); Get Tasks in Plan \u00b6 Using the tasks() you can get the Tasks in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planTasks = await graph.planner.plans.getById('planId').tasks(); Get Buckets in Plan \u00b6 Using the buckets() you can get the Buckets in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planBuckets = await graph.planner.plans.getById('planId').buckets(); Get Details in Plan \u00b6 Using the details() you can get the details in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planDetails = await graph.planner.plans.getById('planId').details(); Delete Plan \u00b6 Using the delete() you can get delete a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delPlan = await graph.planner.plans.getById('planId').delete('planEtag'); Update Plan \u00b6 Using the update() you can get update a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updPlan = await graph.planner.plans.getById('planId').update({title: 'New Title', eTag: 'planEtag'}); Get Task by Id \u00b6 Using the planner.tasks.getById() you can get a specific Task. Planner.tasks is not an available endpoint, you need to get a specific Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const task = await graph.planner.tasks.getById('taskId')(); Add new Task \u00b6 Using the planner.tasks.add() you can create a new Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newTask = await graph.planner.tasks.add('planId', 'title'); Get Details in Task \u00b6 Using the details() you can get the details in a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const taskDetails = await graph.planner.tasks.getById('taskId').details(); Delete Task \u00b6 Using the delete() you can get delete a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delTask = await graph.planner.tasks.getById('taskId').delete('taskEtag'); Update Task \u00b6 Using the update() you can get update a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updTask = await graph.planner.tasks.getById('taskId').update({properties, eTag:'taskEtag'}); Get Buckets by Id \u00b6 Using the planner.buckets.getById() you can get a specific Bucket. planner.buckets is not an available endpoint, you need to get a specific Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucket = await graph.planner.buckets.getById('bucketId')(); Add new Bucket \u00b6 Using the planner.buckets.add() you can create a new Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newBucket = await graph.planner.buckets.add('name', 'planId'); Update Bucket \u00b6 Using the update() you can get update a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updBucket = await graph.planner.buckets.getById('bucketId').update({name: \"Name\", eTag:'bucketEtag'}); Delete Bucket \u00b6 Using the delete() you can get delete a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delBucket = await graph.planner.buckets.getById('bucketId').delete(eTag:'bucketEtag'); Get Bucket Tasks \u00b6 Using the tasks() you can get Tasks in a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucketTasks = await graph.planner.buckets.getById('bucketId').tasks();","title":"@pnp/graph/planner"},{"location":"v2/graph/planner/#pnpgraphplanner","text":"The ability to manage plans and tasks in Planner is a capability introduced in version 1.2.4 of @pnp/graph. Through the methods described you can add, update and delete items in Planner.","title":"@pnp/graph/planner"},{"location":"v2/graph/planner/#iinvitations","text":"Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\"; Preset: All import \"@pnp/graph/presets/all\";","title":"IInvitations"},{"location":"v2/graph/planner/#get-plans-by-id","text":"Using the planner.plans.getById() you can get a specific Plan. Planner.plans is not an available endpoint, you need to get a specific Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const plan = await graph.planner.plans.getById('planId')();","title":"Get Plans by Id"},{"location":"v2/graph/planner/#add-new-plan","text":"Using the planner.plans.add() you can create a new Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newPlan = await graph.planner.plans.add('groupObjectId', 'title');","title":"Add new Plan"},{"location":"v2/graph/planner/#get-tasks-in-plan","text":"Using the tasks() you can get the Tasks in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planTasks = await graph.planner.plans.getById('planId').tasks();","title":"Get Tasks in Plan"},{"location":"v2/graph/planner/#get-buckets-in-plan","text":"Using the buckets() you can get the Buckets in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planBuckets = await graph.planner.plans.getById('planId').buckets();","title":"Get Buckets in Plan"},{"location":"v2/graph/planner/#get-details-in-plan","text":"Using the details() you can get the details in a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const planDetails = await graph.planner.plans.getById('planId').details();","title":"Get Details in Plan"},{"location":"v2/graph/planner/#delete-plan","text":"Using the delete() you can get delete a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delPlan = await graph.planner.plans.getById('planId').delete('planEtag');","title":"Delete Plan"},{"location":"v2/graph/planner/#update-plan","text":"Using the update() you can get update a Plan. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updPlan = await graph.planner.plans.getById('planId').update({title: 'New Title', eTag: 'planEtag'});","title":"Update Plan"},{"location":"v2/graph/planner/#get-task-by-id","text":"Using the planner.tasks.getById() you can get a specific Task. Planner.tasks is not an available endpoint, you need to get a specific Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const task = await graph.planner.tasks.getById('taskId')();","title":"Get Task by Id"},{"location":"v2/graph/planner/#add-new-task","text":"Using the planner.tasks.add() you can create a new Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newTask = await graph.planner.tasks.add('planId', 'title');","title":"Add new Task"},{"location":"v2/graph/planner/#get-details-in-task","text":"Using the details() you can get the details in a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const taskDetails = await graph.planner.tasks.getById('taskId').details();","title":"Get Details in Task"},{"location":"v2/graph/planner/#delete-task","text":"Using the delete() you can get delete a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delTask = await graph.planner.tasks.getById('taskId').delete('taskEtag');","title":"Delete Task"},{"location":"v2/graph/planner/#update-task","text":"Using the update() you can get update a Task. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updTask = await graph.planner.tasks.getById('taskId').update({properties, eTag:'taskEtag'});","title":"Update Task"},{"location":"v2/graph/planner/#get-buckets-by-id","text":"Using the planner.buckets.getById() you can get a specific Bucket. planner.buckets is not an available endpoint, you need to get a specific Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucket = await graph.planner.buckets.getById('bucketId')();","title":"Get Buckets by Id"},{"location":"v2/graph/planner/#add-new-bucket","text":"Using the planner.buckets.add() you can create a new Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const newBucket = await graph.planner.buckets.add('name', 'planId');","title":"Add new Bucket"},{"location":"v2/graph/planner/#update-bucket","text":"Using the update() you can get update a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const updBucket = await graph.planner.buckets.getById('bucketId').update({name: \"Name\", eTag:'bucketEtag'});","title":"Update Bucket"},{"location":"v2/graph/planner/#delete-bucket","text":"Using the delete() you can get delete a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const delBucket = await graph.planner.buckets.getById('bucketId').delete(eTag:'bucketEtag');","title":"Delete Bucket"},{"location":"v2/graph/planner/#get-bucket-tasks","text":"Using the tasks() you can get Tasks in a Bucket. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/planner\" const bucketTasks = await graph.planner.buckets.getById('bucketId').tasks();","title":"Get Bucket Tasks"},{"location":"v2/graph/search/","text":"@pnp/graph/search \u00b6 The search module allows you to access the Microsoft Graph Search API. You can read full details of using the API, for library examples please see below. Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; Preset: All import \"@pnp/graph/presets/all\"; Call graph.query \u00b6 This example shows calling the search API via the query method of the root graph object. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; const results = await graph.query({ entityTypes: [\"site\"], query: { queryString: \"test\" }, }); Note: This library allows you to pass multiple search requests to the query method as the value consumed by the server is an array, but it only a single requests works at this time. Eventually this may change and no updates will be required.","title":"@pnp/graph/search"},{"location":"v2/graph/search/#pnpgraphsearch","text":"The search module allows you to access the Microsoft Graph Search API. You can read full details of using the API, for library examples please see below. Scenario Import Statement Selective import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; Preset: All import \"@pnp/graph/presets/all\";","title":"@pnp/graph/search"},{"location":"v2/graph/search/#call-graphquery","text":"This example shows calling the search API via the query method of the root graph object. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/search\"; const results = await graph.query({ entityTypes: [\"site\"], query: { queryString: \"test\" }, }); Note: This library allows you to pass multiple search requests to the query method as the value consumed by the server is an array, but it only a single requests works at this time. Eventually this may change and no updates will be required.","title":"Call graph.query"},{"location":"v2/graph/subscriptions/","text":"@pnp/graph/subscriptions \u00b6 The ability to manage subscriptions is a capability introduced in version 1.2.9 of @pnp/graph. A subscription allows a client app to receive notifications about changes to data in Microsoft Graph. Currently, subscriptions are enabled for the following resources: Mail, events, and contacts from Outlook. Conversations from Office Groups. Drive root items from OneDrive. Users and Groups from Azure Active Directory. Alerts from the Microsoft Graph Security API. Get all of the Subscriptions \u00b6 Using the subscriptions(). If successful this method returns a 200 OK response code and a list of subscription objects in the response body. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscriptions = await graph.subscriptions(); Create a new Subscription \u00b6 Using the subscriptions.add(). Creating a subscription requires read scope to the resource. For example, to get notifications messages, your app needs the Mail.Read permission. To learn more about the scopes visit this url. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const addedSubscription = await graph.subscriptions.add(\"created,updated\", \"https://webhook.azurewebsites.net/api/send/myNotifyClient\", \"me/mailFolders('Inbox')/messages\", \"2019-11-20T18:23:45.9356913Z\"); Get Subscription by Id \u00b6 Using the subscriptions.getById() you can get one of the subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscription = await graph.subscriptions.getById('subscriptionId')(); Delete a Subscription \u00b6 Using the subscriptions.getById().delete() you can remove one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const delSubscription = await graph.subscriptions.getById('subscriptionId').delete(); Update a Subscription \u00b6 Using the subscriptions.getById().update() you can update one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const updSubscription = await graph.subscriptions.getById('subscriptionId').update({changeType: \"created,updated,deleted\" });","title":"@pnp/graph/subscriptions"},{"location":"v2/graph/subscriptions/#pnpgraphsubscriptions","text":"The ability to manage subscriptions is a capability introduced in version 1.2.9 of @pnp/graph. A subscription allows a client app to receive notifications about changes to data in Microsoft Graph. Currently, subscriptions are enabled for the following resources: Mail, events, and contacts from Outlook. Conversations from Office Groups. Drive root items from OneDrive. Users and Groups from Azure Active Directory. Alerts from the Microsoft Graph Security API.","title":"@pnp/graph/subscriptions"},{"location":"v2/graph/subscriptions/#get-all-of-the-subscriptions","text":"Using the subscriptions(). If successful this method returns a 200 OK response code and a list of subscription objects in the response body. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscriptions = await graph.subscriptions();","title":"Get all of the Subscriptions"},{"location":"v2/graph/subscriptions/#create-a-new-subscription","text":"Using the subscriptions.add(). Creating a subscription requires read scope to the resource. For example, to get notifications messages, your app needs the Mail.Read permission. To learn more about the scopes visit this url. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const addedSubscription = await graph.subscriptions.add(\"created,updated\", \"https://webhook.azurewebsites.net/api/send/myNotifyClient\", \"me/mailFolders('Inbox')/messages\", \"2019-11-20T18:23:45.9356913Z\");","title":"Create a new Subscription"},{"location":"v2/graph/subscriptions/#get-subscription-by-id","text":"Using the subscriptions.getById() you can get one of the subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const subscription = await graph.subscriptions.getById('subscriptionId')();","title":"Get Subscription by Id"},{"location":"v2/graph/subscriptions/#delete-a-subscription","text":"Using the subscriptions.getById().delete() you can remove one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const delSubscription = await graph.subscriptions.getById('subscriptionId').delete();","title":"Delete a Subscription"},{"location":"v2/graph/subscriptions/#update-a-subscription","text":"Using the subscriptions.getById().update() you can update one of the Subscriptions import { graph } from \"@pnp/graph\"; import \"@pnp/graph/subscriptions\" const updSubscription = await graph.subscriptions.getById('subscriptionId').update({changeType: \"created,updated,deleted\" });","title":"Update a Subscription"},{"location":"v2/graph/teams/","text":"@pnp/graph/teams \u00b6 The ability to manage Team is a capability introduced in the 1.2.7 of @pnp/graph. Through the methods described you can add, update and delete items in Teams. Teams the user is a member of \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/teams\" const joinedTeams = await graph.users.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').joinedTeams(); const myJoinedTeams = await graph.me.joinedTeams(); Get Teams by Id \u00b6 Using the teams.getById() you can get a specific Team. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528')(); Create new Team/Group - Method #1 \u00b6 The first way to create a new Team and corresponding Group is to first create the group and then create the team. Follow the example in Groups to create the group and get the GroupID. Then make a call to create the team from the group. Create a Team via a specific group \u00b6 Here we get the group via id and use createTeam import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" import \"@pnp/graph/groups\" const createdTeam = await graph.groups.getById('679c8ff4-f07d-40de-b02b-60ec332472dd').createTeam({ \"memberSettings\": { \"allowCreateUpdateChannels\": true }, \"messagingSettings\": { \"allowUserEditMessages\": true, \"allowUserDeleteMessages\": true }, \"funSettings\": { \"allowGiphy\": true, \"giphyContentRating\": \"strict\" }}); Create new Team/Group - Method #2 \u00b6 The second way to create a new Team and corresponding Group is to do so in one call. This can be done by using the createTeam method. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = { \"template@odata.bind\": \"https://graph.microsoft.com/v1.0/teamsTemplates('standard')\", \"displayName\": \"PnPJS Test Team\", \"description\": \"PnPJS Test Team\u2019s Description\", \"members\": [ { \"@odata.type\": \"#microsoft.graph.aadUserConversationMember\", \"roles\": [\"owner\"], \"user@odata.bind\": \"https://graph.microsoft.com/v1.0/users('{owners user id}')\", }, ], }; const createdTeam: ITeamCreateResultAsync = await graph.teams.create(team); //To check the status of the team creation, call getOperationById for the newly created team. const createdTeamStatus = await graph.teams.getById(createdTeam.teamId).getOperationById(createdTeam.operationId); Clone a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public'); Get Teams Async Operation \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public'); const clonedTeamStatus = await graph.teams.getById(clonedTeam.teamId).getOperationById(clonedTeam.operationId); Archive a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').archive(); Unarchive a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').unarchive(); Get all channels of a Team \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channels = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels(); Get channel by Id \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype')(); Create a new Channel \u00b6 import { graph } from \"@pnp/graph\"; const newChannel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.create('New Channel', 'Description'); Get installed Apps \u00b6 import { graph } from \"@pnp/graph\"; const installedApps = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps(); Add an App \u00b6 import { graph } from \"@pnp/graph\"; const addedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.add('https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a'); Remove an App \u00b6 import { graph } from \"@pnp/graph\"; const removedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.remove(); Get Tabs from a Channel \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tabs = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs(); Get Tab by Id \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.getById('Id')(); Add a new Tab \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const newTab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.add('Tab','https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a',<TabsConfiguration>{});","title":"@pnp/graph/teams"},{"location":"v2/graph/teams/#pnpgraphteams","text":"The ability to manage Team is a capability introduced in the 1.2.7 of @pnp/graph. Through the methods described you can add, update and delete items in Teams.","title":"@pnp/graph/teams"},{"location":"v2/graph/teams/#teams-the-user-is-a-member-of","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\" import \"@pnp/graph/teams\" const joinedTeams = await graph.users.getById('99dc1039-eb80-43b1-a09e-250d50a80b26').joinedTeams(); const myJoinedTeams = await graph.me.joinedTeams();","title":"Teams the user is a member of"},{"location":"v2/graph/teams/#get-teams-by-id","text":"Using the teams.getById() you can get a specific Team. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528')();","title":"Get Teams by Id"},{"location":"v2/graph/teams/#create-new-teamgroup-method-1","text":"The first way to create a new Team and corresponding Group is to first create the group and then create the team. Follow the example in Groups to create the group and get the GroupID. Then make a call to create the team from the group.","title":"Create new Team/Group - Method #1"},{"location":"v2/graph/teams/#create-a-team-via-a-specific-group","text":"Here we get the group via id and use createTeam import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" import \"@pnp/graph/groups\" const createdTeam = await graph.groups.getById('679c8ff4-f07d-40de-b02b-60ec332472dd').createTeam({ \"memberSettings\": { \"allowCreateUpdateChannels\": true }, \"messagingSettings\": { \"allowUserEditMessages\": true, \"allowUserDeleteMessages\": true }, \"funSettings\": { \"allowGiphy\": true, \"giphyContentRating\": \"strict\" }});","title":"Create a Team via a specific group"},{"location":"v2/graph/teams/#create-new-teamgroup-method-2","text":"The second way to create a new Team and corresponding Group is to do so in one call. This can be done by using the createTeam method. import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const team = { \"template@odata.bind\": \"https://graph.microsoft.com/v1.0/teamsTemplates('standard')\", \"displayName\": \"PnPJS Test Team\", \"description\": \"PnPJS Test Team\u2019s Description\", \"members\": [ { \"@odata.type\": \"#microsoft.graph.aadUserConversationMember\", \"roles\": [\"owner\"], \"user@odata.bind\": \"https://graph.microsoft.com/v1.0/users('{owners user id}')\", }, ], }; const createdTeam: ITeamCreateResultAsync = await graph.teams.create(team); //To check the status of the team creation, call getOperationById for the newly created team. const createdTeamStatus = await graph.teams.getById(createdTeam.teamId).getOperationById(createdTeam.operationId);","title":"Create new Team/Group - Method #2"},{"location":"v2/graph/teams/#clone-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public');","title":"Clone a Team"},{"location":"v2/graph/teams/#get-teams-async-operation","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const clonedTeam = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').cloneTeam( 'Cloned','description','apps,tabs,settings,channels,members','public'); const clonedTeamStatus = await graph.teams.getById(clonedTeam.teamId).getOperationById(clonedTeam.operationId);","title":"Get Teams Async Operation"},{"location":"v2/graph/teams/#archive-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').archive();","title":"Archive a Team"},{"location":"v2/graph/teams/#unarchive-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const archived = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').unarchive();","title":"Unarchive a Team"},{"location":"v2/graph/teams/#get-all-channels-of-a-team","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channels = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels();","title":"Get all channels of a Team"},{"location":"v2/graph/teams/#get-channel-by-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const channel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype')();","title":"Get channel by Id"},{"location":"v2/graph/teams/#create-a-new-channel","text":"import { graph } from \"@pnp/graph\"; const newChannel = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').channels.create('New Channel', 'Description');","title":"Create a new Channel"},{"location":"v2/graph/teams/#get-installed-apps","text":"import { graph } from \"@pnp/graph\"; const installedApps = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps();","title":"Get installed Apps"},{"location":"v2/graph/teams/#add-an-app","text":"import { graph } from \"@pnp/graph\"; const addedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.add('https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a');","title":"Add an App"},{"location":"v2/graph/teams/#remove-an-app","text":"import { graph } from \"@pnp/graph\"; const removedApp = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528').installedApps.remove();","title":"Remove an App"},{"location":"v2/graph/teams/#get-tabs-from-a-channel","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tabs = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs();","title":"Get Tabs from a Channel"},{"location":"v2/graph/teams/#get-tab-by-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const tab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.getById('Id')();","title":"Get Tab by Id"},{"location":"v2/graph/teams/#add-a-new-tab","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/teams\" const newTab = await graph.teams.getById('3531f3fb-f9ee-4f43-982a-6c90d8226528'). channels.getById('19:65723d632b384ca89c81115c281428a3@thread.skype').tabs.add('Tab','https://graph.microsoft.com/v1.0/appCatalogs/teamsApps/12345678-9abc-def0-123456789a',<TabsConfiguration>{});","title":"Add a new Tab"},{"location":"v2/graph/users/","text":"@pnp/graph/users \u00b6 Users are Azure Active Directory objects representing users in the organizations. They represent the single identity for a person across Microsoft 365 services. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation . IUsers, IUser, IPeople \u00b6 Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IUser, IUsers, User, Users, IPeople, People} from \"@pnp/graph/users\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; Preset: All import { graph,IUser, IUsers, User, Users, IPeople, People } from \"@pnp/graph/presets/all\"; Current User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const currentUser = await graph.me(); Get All Users in the Organization \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const allUsers = await graph.users(); Get a User by email address (or user id) \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const matchingUser = await graph.users.getById('jane@contoso.com')(); Update Current User \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; await graph.me.update({ displayName: 'John Doe' }); People \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)(); People \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)(); Manager \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const manager = await graph.me.manager(); Direct Reports \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const reports = await graph.me.directReports(); Photo \u00b6 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const currentUser = await graph.me.photo(); const specificUser = await graph.users.getById('jane@contoso.com').photo(); User Photo Operations \u00b6 See Photos","title":"@pnp/graph/users"},{"location":"v2/graph/users/#pnpgraphusers","text":"Users are Azure Active Directory objects representing users in the organizations. They represent the single identity for a person across Microsoft 365 services. You can learn more about Microsoft Graph users by reading the Official Microsoft Graph Documentation .","title":"@pnp/graph/users"},{"location":"v2/graph/users/#iusers-iuser-ipeople","text":"Scenario Import Statement Selective 1 import { graph } from \"@pnp/graph\"; import {IUser, IUsers, User, Users, IPeople, People} from \"@pnp/graph/users\"; Selective 2 import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; Preset: All import { graph,IUser, IUsers, User, Users, IPeople, People } from \"@pnp/graph/presets/all\";","title":"IUsers, IUser, IPeople"},{"location":"v2/graph/users/#current-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const currentUser = await graph.me();","title":"Current User"},{"location":"v2/graph/users/#get-all-users-in-the-organization","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const allUsers = await graph.users();","title":"Get All Users in the Organization"},{"location":"v2/graph/users/#get-a-user-by-email-address-or-user-id","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const matchingUser = await graph.users.getById('jane@contoso.com')();","title":"Get a User by email address (or user id)"},{"location":"v2/graph/users/#update-current-user","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; await graph.me.update({ displayName: 'John Doe' });","title":"Update Current User"},{"location":"v2/graph/users/#people","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)();","title":"People"},{"location":"v2/graph/users/#people_1","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const people = await graph.me.people(); // get the top 3 people const people = await graph.me.people.top(3)();","title":"People"},{"location":"v2/graph/users/#manager","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const manager = await graph.me.manager();","title":"Manager"},{"location":"v2/graph/users/#direct-reports","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; const reports = await graph.me.directReports();","title":"Direct Reports"},{"location":"v2/graph/users/#photo","text":"import { graph } from \"@pnp/graph\"; import \"@pnp/graph/users\"; import \"@pnp/graph/photos\"; const currentUser = await graph.me.photo(); const specificUser = await graph.users.getById('jane@contoso.com').photo();","title":"Photo"},{"location":"v2/graph/users/#user-photo-operations","text":"See Photos","title":"User Photo Operations"},{"location":"v2/logging/","text":"@pnp/logging \u00b6 The logging module provides light weight subscribable and extensible logging framework which is used internally and available for use in your projects. This article outlines how to setup logging and use the various loggers. Getting Started \u00b6 Install the logging module, it has no other dependencies npm install @pnp/logging --save Understanding the Logging Framework \u00b6 The logging framework is centered on the Logger class to which any number of listeners can be subscribed. Each of these listeners will receive each of the messages logged. Each listener must implement the ILogListener interface, shown below. There is only one method to implement and it takes an instance of the LogEntry interface as a parameter. /** * Interface that defines a log listener * */ export interface ILogListener { /** * Any associated data that a given logging listener may choose to log or ignore * * @param entry The information to be logged */ log(entry: ILogEntry): void; } /** * Interface that defines a log entry * */ export interface ILogEntry { /** * The main message to be logged */ message: string; /** * The level of information this message represents */ level: LogLevel; /** * Any associated data that a given logging listener may choose to log or ignore */ data?: any; } Log Levels \u00b6 export const enum LogLevel { Verbose = 0, Info = 1, Warning = 2, Error = 3, Off = 99, } Writing to the Logger \u00b6 To write information to a logger you can use either write, writeJSON, or log. import { Logger, LogLevel } from \"@pnp/logging\"; // write logs a simple string as the message value of the LogEntry Logger.write(\"This is logging a simple string\"); // optionally passing a level, default level is Verbose Logger.write(\"This is logging a simple string\", LogLevel.Error); // this will convert the object to a string using JSON.stringify and set the message with the result Logger.writeJSON({ name: \"value\", name2: \"value2\"}); // optionally passing a level, default level is Verbose Logger.writeJSON({ name: \"value\", name2: \"value2\"}, LogLevel.Warning); // specify the entire LogEntry interface using log Logger.log({ data: { name: \"value\", name2: \"value2\"}, level: LogLevel.Warning, message: \"This is my message\" }); Log an error \u00b6 There exists a shortcut method to log an error to the Logger. This will log an entry to the subscribed loggers where the data property will be the Error instance passed in, the level will be 'Error', and the message will be the Error instance's message property. const e = Error(\"An Error\"); Logger.error(e); Subscribing a Listener \u00b6 By default no listeners are subscribed, so if you would like to get logging information you need to subscribe at least one listener. This is done as shown below by importing the Logger and your listener(s) of choice. Here we are using the provided ConsoleListener. We are also setting the active log level, which controls the level of logging that will be output. Be aware that Verbose produces a substantial amount of data about each request. import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; // subscribe a listener Logger.subscribe(new ConsoleListener()); // set the active log level Logger.activeLogLevel = LogLevel.Info; Available Listeners \u00b6 There are two listeners included in the library, ConsoleListener and FunctionListener. ConsoleListener \u00b6 This listener outputs information to the console and works in Node as well as within browsers. It can be used without settings and writes to the appropriate console method based on message level. For example a LogEntry with level Warning will be written to console.warn. Basic usage is shown in the example above. Configuration Options \u00b6 Although ConsoleListener can be used without configuration, there are some additional options available to you. ConsoleListener supports adding a prefix to every output (helpful for filtering console messages) and specifying text color for messages (including by LogLevel). Using a Prefix \u00b6 To add a prefix to all output, supply a string in the constructor: import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE)); Logger.activeLogLevel = LogLevel.Info; With the above configuration, Logger.write(\"My special message\"); will be output to the console as: MyAwesomeWebPart - My special message Customizing Text Color \u00b6 You can also specify text color for your messages by supplying an IConsoleListenerColors object. You can simply specify color to set the default color for all logging levels or you can set one or more logging level specific text colors (if you only want to set color for a specific logging level(s), leave color out and all other log levels will use the default color). Colors can be specified the same way color values are specified in CSS (named colors, hex values, rgb, rgba, hsl, hsla, etc.): import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE, {color:'#0b6a0b',warningColor:'magenta'})); Logger.activeLogLevel = LogLevel.Info; With the above configuration: Logger.write(\"My special message\"); Logger.write(\"A warning!\", LogLevel.Warning); Will result in messages that look like this: Color options: color : Default text color for all logging levels unless they're specified verboseColor : Text color to use for messages with LogLevel.Verbose infoColor : Text color to use for messages with LogLevel.Info warningColor : Text color to use for messages with LogLevel.Warning errorColor : Text color to use for messages with LogLevel.Error To set colors without a prefix, specify either undefined or an empty string for the first parameter: Logger.subscribe(new ConsoleListener(undefined, {color:'purple'})); FunctionListener \u00b6 The FunctionListener allows you to wrap any functionality by creating a function that takes a LogEntry as its single argument. This produces the same result as implementing the LogListener interface, but is useful if you already have a logging method or framework to which you want to pass the messages. import { Logger, FunctionListener, ILogEntry } from \"@pnp/logging\"; let listener = new FunctionListener((entry: ILogEntry) => { // pass all logging data to an existing framework MyExistingCompanyLoggingFramework.log(entry.message); }); Logger.subscribe(listener); Create a Custom Listener \u00b6 If desirable for your project you can create a custom listener to perform any logging action you would like. This is done by implementing the ILogListener interface. import { Logger, ILogListener, ILogEntry } from \"@pnp/logging\"; class MyListener implements ILogListener { log(entry: ILogEntry): void { // here you would do something with the entry } } Logger.subscribe(new MyListener());","title":"@pnp/logging"},{"location":"v2/logging/#pnplogging","text":"The logging module provides light weight subscribable and extensible logging framework which is used internally and available for use in your projects. This article outlines how to setup logging and use the various loggers.","title":"@pnp/logging"},{"location":"v2/logging/#getting-started","text":"Install the logging module, it has no other dependencies npm install @pnp/logging --save","title":"Getting Started"},{"location":"v2/logging/#understanding-the-logging-framework","text":"The logging framework is centered on the Logger class to which any number of listeners can be subscribed. Each of these listeners will receive each of the messages logged. Each listener must implement the ILogListener interface, shown below. There is only one method to implement and it takes an instance of the LogEntry interface as a parameter. /** * Interface that defines a log listener * */ export interface ILogListener { /** * Any associated data that a given logging listener may choose to log or ignore * * @param entry The information to be logged */ log(entry: ILogEntry): void; } /** * Interface that defines a log entry * */ export interface ILogEntry { /** * The main message to be logged */ message: string; /** * The level of information this message represents */ level: LogLevel; /** * Any associated data that a given logging listener may choose to log or ignore */ data?: any; }","title":"Understanding the Logging Framework"},{"location":"v2/logging/#log-levels","text":"export const enum LogLevel { Verbose = 0, Info = 1, Warning = 2, Error = 3, Off = 99, }","title":"Log Levels"},{"location":"v2/logging/#writing-to-the-logger","text":"To write information to a logger you can use either write, writeJSON, or log. import { Logger, LogLevel } from \"@pnp/logging\"; // write logs a simple string as the message value of the LogEntry Logger.write(\"This is logging a simple string\"); // optionally passing a level, default level is Verbose Logger.write(\"This is logging a simple string\", LogLevel.Error); // this will convert the object to a string using JSON.stringify and set the message with the result Logger.writeJSON({ name: \"value\", name2: \"value2\"}); // optionally passing a level, default level is Verbose Logger.writeJSON({ name: \"value\", name2: \"value2\"}, LogLevel.Warning); // specify the entire LogEntry interface using log Logger.log({ data: { name: \"value\", name2: \"value2\"}, level: LogLevel.Warning, message: \"This is my message\" });","title":"Writing to the Logger"},{"location":"v2/logging/#log-an-error","text":"There exists a shortcut method to log an error to the Logger. This will log an entry to the subscribed loggers where the data property will be the Error instance passed in, the level will be 'Error', and the message will be the Error instance's message property. const e = Error(\"An Error\"); Logger.error(e);","title":"Log an error"},{"location":"v2/logging/#subscribing-a-listener","text":"By default no listeners are subscribed, so if you would like to get logging information you need to subscribe at least one listener. This is done as shown below by importing the Logger and your listener(s) of choice. Here we are using the provided ConsoleListener. We are also setting the active log level, which controls the level of logging that will be output. Be aware that Verbose produces a substantial amount of data about each request. import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; // subscribe a listener Logger.subscribe(new ConsoleListener()); // set the active log level Logger.activeLogLevel = LogLevel.Info;","title":"Subscribing a Listener"},{"location":"v2/logging/#available-listeners","text":"There are two listeners included in the library, ConsoleListener and FunctionListener.","title":"Available Listeners"},{"location":"v2/logging/#consolelistener","text":"This listener outputs information to the console and works in Node as well as within browsers. It can be used without settings and writes to the appropriate console method based on message level. For example a LogEntry with level Warning will be written to console.warn. Basic usage is shown in the example above.","title":"ConsoleListener"},{"location":"v2/logging/#configuration-options","text":"Although ConsoleListener can be used without configuration, there are some additional options available to you. ConsoleListener supports adding a prefix to every output (helpful for filtering console messages) and specifying text color for messages (including by LogLevel).","title":"Configuration Options"},{"location":"v2/logging/#using-a-prefix","text":"To add a prefix to all output, supply a string in the constructor: import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE)); Logger.activeLogLevel = LogLevel.Info; With the above configuration, Logger.write(\"My special message\"); will be output to the console as: MyAwesomeWebPart - My special message","title":"Using a Prefix"},{"location":"v2/logging/#customizing-text-color","text":"You can also specify text color for your messages by supplying an IConsoleListenerColors object. You can simply specify color to set the default color for all logging levels or you can set one or more logging level specific text colors (if you only want to set color for a specific logging level(s), leave color out and all other log levels will use the default color). Colors can be specified the same way color values are specified in CSS (named colors, hex values, rgb, rgba, hsl, hsla, etc.): import { Logger, ConsoleListener, LogLevel } from \"@pnp/logging\"; const LOG_SOURCE: string = 'MyAwesomeWebPart'; Logger.subscribe(new ConsoleListener(LOG_SOURCE, {color:'#0b6a0b',warningColor:'magenta'})); Logger.activeLogLevel = LogLevel.Info; With the above configuration: Logger.write(\"My special message\"); Logger.write(\"A warning!\", LogLevel.Warning); Will result in messages that look like this: Color options: color : Default text color for all logging levels unless they're specified verboseColor : Text color to use for messages with LogLevel.Verbose infoColor : Text color to use for messages with LogLevel.Info warningColor : Text color to use for messages with LogLevel.Warning errorColor : Text color to use for messages with LogLevel.Error To set colors without a prefix, specify either undefined or an empty string for the first parameter: Logger.subscribe(new ConsoleListener(undefined, {color:'purple'}));","title":"Customizing Text Color"},{"location":"v2/logging/#functionlistener","text":"The FunctionListener allows you to wrap any functionality by creating a function that takes a LogEntry as its single argument. This produces the same result as implementing the LogListener interface, but is useful if you already have a logging method or framework to which you want to pass the messages. import { Logger, FunctionListener, ILogEntry } from \"@pnp/logging\"; let listener = new FunctionListener((entry: ILogEntry) => { // pass all logging data to an existing framework MyExistingCompanyLoggingFramework.log(entry.message); }); Logger.subscribe(listener);","title":"FunctionListener"},{"location":"v2/logging/#create-a-custom-listener","text":"If desirable for your project you can create a custom listener to perform any logging action you would like. This is done by implementing the ILogListener interface. import { Logger, ILogListener, ILogEntry } from \"@pnp/logging\"; class MyListener implements ILogListener { log(entry: ILogEntry): void { // here you would do something with the entry } } Logger.subscribe(new MyListener());","title":"Create a Custom Listener"},{"location":"v2/news/2020-year-in-review/","text":"2020 Year End Report \u00b6 Welcome to our first year in review report for PnPjs. This year has marked usage milestones, seen more contributors than ever, and expanded the core maintainers team. But none of this would be possible without everyones support and participation - so we start by saying Thank You! We deeply appreciate everyone that has used, helped us grow, and improved the library over the last year. This year we introduced MSAL clients for node and browser, improved our testing/local development plumbing, and updated the libraries to work with the node 15 module resolution rules. We fixed 43 reported bugs, answered 131 questions, and made 55 suggested enhancements to the library - all driven by feedback from users and the community. Planned for release in January 2021 we also undertook the work to enable isolated runtimes, a long requested feature. This allows you to operate on multiple independently configured \"roots\" such as \"sp\" or \"graph\" from the same application. Previously the library was configured globally, so this opens new possibilities for both client and server side scenarios. Finally we made many tooling and project improvements such as moving to GitHub actions, updating the tests to use MSAL, and exploring ways to enhance the developer experience. Usage \u00b6 In 2020 we tracked steady month/month growth in raw usage measured by requests as well as in the number of tenants deploying the library. Starting the year we were used in 14605 tenants and by December that number grew to 21,227. These tenants generated 6.1 billion requests to the service in January growing to 9.2 billion by December, peaking at 10.1 billion requests in November. 1) There was a data glitch in October so the numbers do not fully represent usage. 2) These numbers only include public cloud SPO usage, true usage is higher than we can track due to on-premesis and gov/sovereign clouds Releases \u00b6 We continued our monthly release cadence as it represents a good pace for addressing issues while not expecting folks to update too often and keeping each update to a reasonable size. All changes can be tracked in our change log , updated with each release. You can check our scheduled releases through project milestones , understanding there are occasionally delays. Monthly releases allows us to ensure bugs do not linger and we continually improve and expand the capabilities of the libraries. NPM Package download statistics (@pnp/sp): \u00b6 Month Count * Month Count January 100,686 * July 36,805 February 34,437 * August 38,897 March 34,574 * September 45,968 April 32,436 * October 46,655 May 34,482 * November 45,511 June 34,408 * December 58,977 Grand Total 543,836 With 2020 our total all time downloads of @pnp/sp is now at: 949,638 Stats from https://npm-stat.com/ Future Plans \u00b6 Looking to the future we will continue to actively grow and improve v2 of the library, guided by feedback and reported issues. Additionally, we are beginning to discuss v3 and doing initial planning and prototyping. The v3 work will continue through 2021 with no currently set release date, though we will keep everyone up to date. Additionally in 2021 there will be a general focus on improving not just the code but our tooling, build pipeline, and library contributor experience. We will also look at automatic canary releases with each merge, and other improvements. New Lead Maintainer \u00b6 With the close of 2020 we are very excited to announce a new lead maintainer for PnPjs, Julie Turner ! Julie brings deep expertise with SharePoint Framework, TypeScript, and SharePoint development to the team, coupled with dedication and care in the work. Over the last year she has gotten more involved with handling releases, responding to issues, and helping to keep the code updated and clean. We are very lucky to have her working on the project and look forward to seeing her lead the growth and direction for years to come. Contributors \u00b6 As always we have abundant thanks and appreciation for your contributors. Taking your time to help improve PnPjs for the community is massive and valuable to ensure our sustainability. Thank you for all your help in 2020! If you are interested in becoming a contributor check out our guide on ways to get started. Sponsors \u00b6 We want to thank our sponsors for their support in 2020! This year we put the money towards helping offset the cost and shipping of hoodies to contributors and sponsors. Your continued generosity makes a big difference in our ability to recognize and reward the folks building PnPjs. Thank You Closing \u00b6 In closing we want say Thank You to everyone who uses, contributes to, and participates in PnPjs and the SharePoint Patterns and Practices program. Wishing you the very best for 2021, The PnPjs Team","title":"2020 Year End Report"},{"location":"v2/news/2020-year-in-review/#2020-year-end-report","text":"Welcome to our first year in review report for PnPjs. This year has marked usage milestones, seen more contributors than ever, and expanded the core maintainers team. But none of this would be possible without everyones support and participation - so we start by saying Thank You! We deeply appreciate everyone that has used, helped us grow, and improved the library over the last year. This year we introduced MSAL clients for node and browser, improved our testing/local development plumbing, and updated the libraries to work with the node 15 module resolution rules. We fixed 43 reported bugs, answered 131 questions, and made 55 suggested enhancements to the library - all driven by feedback from users and the community. Planned for release in January 2021 we also undertook the work to enable isolated runtimes, a long requested feature. This allows you to operate on multiple independently configured \"roots\" such as \"sp\" or \"graph\" from the same application. Previously the library was configured globally, so this opens new possibilities for both client and server side scenarios. Finally we made many tooling and project improvements such as moving to GitHub actions, updating the tests to use MSAL, and exploring ways to enhance the developer experience.","title":"2020 Year End Report"},{"location":"v2/news/2020-year-in-review/#usage","text":"In 2020 we tracked steady month/month growth in raw usage measured by requests as well as in the number of tenants deploying the library. Starting the year we were used in 14605 tenants and by December that number grew to 21,227. These tenants generated 6.1 billion requests to the service in January growing to 9.2 billion by December, peaking at 10.1 billion requests in November. 1) There was a data glitch in October so the numbers do not fully represent usage. 2) These numbers only include public cloud SPO usage, true usage is higher than we can track due to on-premesis and gov/sovereign clouds","title":"Usage"},{"location":"v2/news/2020-year-in-review/#releases","text":"We continued our monthly release cadence as it represents a good pace for addressing issues while not expecting folks to update too often and keeping each update to a reasonable size. All changes can be tracked in our change log , updated with each release. You can check our scheduled releases through project milestones , understanding there are occasionally delays. Monthly releases allows us to ensure bugs do not linger and we continually improve and expand the capabilities of the libraries.","title":"Releases"},{"location":"v2/news/2020-year-in-review/#npm-package-download-statistics-pnpsp","text":"Month Count * Month Count January 100,686 * July 36,805 February 34,437 * August 38,897 March 34,574 * September 45,968 April 32,436 * October 46,655 May 34,482 * November 45,511 June 34,408 * December 58,977 Grand Total 543,836 With 2020 our total all time downloads of @pnp/sp is now at: 949,638 Stats from https://npm-stat.com/","title":"NPM Package download statistics (@pnp/sp):"},{"location":"v2/news/2020-year-in-review/#future-plans","text":"Looking to the future we will continue to actively grow and improve v2 of the library, guided by feedback and reported issues. Additionally, we are beginning to discuss v3 and doing initial planning and prototyping. The v3 work will continue through 2021 with no currently set release date, though we will keep everyone up to date. Additionally in 2021 there will be a general focus on improving not just the code but our tooling, build pipeline, and library contributor experience. We will also look at automatic canary releases with each merge, and other improvements.","title":"Future Plans"},{"location":"v2/news/2020-year-in-review/#new-lead-maintainer","text":"With the close of 2020 we are very excited to announce a new lead maintainer for PnPjs, Julie Turner ! Julie brings deep expertise with SharePoint Framework, TypeScript, and SharePoint development to the team, coupled with dedication and care in the work. Over the last year she has gotten more involved with handling releases, responding to issues, and helping to keep the code updated and clean. We are very lucky to have her working on the project and look forward to seeing her lead the growth and direction for years to come.","title":"New Lead Maintainer"},{"location":"v2/news/2020-year-in-review/#contributors","text":"As always we have abundant thanks and appreciation for your contributors. Taking your time to help improve PnPjs for the community is massive and valuable to ensure our sustainability. Thank you for all your help in 2020! If you are interested in becoming a contributor check out our guide on ways to get started.","title":"Contributors"},{"location":"v2/news/2020-year-in-review/#sponsors","text":"We want to thank our sponsors for their support in 2020! This year we put the money towards helping offset the cost and shipping of hoodies to contributors and sponsors. Your continued generosity makes a big difference in our ability to recognize and reward the folks building PnPjs. Thank You","title":"Sponsors"},{"location":"v2/news/2020-year-in-review/#closing","text":"In closing we want say Thank You to everyone who uses, contributes to, and participates in PnPjs and the SharePoint Patterns and Practices program. Wishing you the very best for 2021, The PnPjs Team","title":"Closing"},{"location":"v2/nodejs/","text":"@pnp/nodejs \u00b6 This package supplies helper code when using the @pnp libraries within the context of nodejs. Primarily these consist of clients to enable use of the libraries in nodejs. Getting Started \u00b6 Install the library and required dependencies. You will also need to install other libraries such as @pnp/sp or @pnp/graph to use the exported functionality. npm install @pnp/sp @pnp/nodejs --save AdalFetchClient SPFetchClient BearerTokenFetchClient Proxy SP Extensions \u00b6 Added in 2.0.9 A set of nodejs specific extensions for the @pnp/sp library. SP Extensions","title":"@pnp/nodejs"},{"location":"v2/nodejs/#pnpnodejs","text":"This package supplies helper code when using the @pnp libraries within the context of nodejs. Primarily these consist of clients to enable use of the libraries in nodejs.","title":"@pnp/nodejs"},{"location":"v2/nodejs/#getting-started","text":"Install the library and required dependencies. You will also need to install other libraries such as @pnp/sp or @pnp/graph to use the exported functionality. npm install @pnp/sp @pnp/nodejs --save AdalFetchClient SPFetchClient BearerTokenFetchClient Proxy","title":"Getting Started"},{"location":"v2/nodejs/#sp-extensions","text":"Added in 2.0.9 A set of nodejs specific extensions for the @pnp/sp library. SP Extensions","title":"SP Extensions"},{"location":"v2/nodejs/adal-fetch-client/","text":"@pnp/nodejs/adalfetchclient \u00b6 The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"@pnp/nodejs/adalfetchclient"},{"location":"v2/nodejs/adal-fetch-client/#pnpnodejsadalfetchclient","text":"The AdalFetchClient class depends on the adal-node package to authenticate against Azure AD. The example below outlines usage with the @pnp/graph library, though it would work in any case where an Azure AD Bearer token is expected. import { AdalFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new AdalFetchClient(\"{tenant}\", \"{app id}\", \"{app secret}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"@pnp/nodejs/adalfetchclient"},{"location":"v2/nodejs/bearer-token-fetch-client/","text":"@pnp/nodejs/BearerTokenFetchClient \u00b6 The BearerTokenFetchClient class allows you to easily specify your own Bearer tokens to be used in the requests. How you derive the token is up to you. import { BearerTokenFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new BearerTokenFetchClient(\"{Bearer Token}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"@pnp/nodejs/BearerTokenFetchClient"},{"location":"v2/nodejs/bearer-token-fetch-client/#pnpnodejsbearertokenfetchclient","text":"The BearerTokenFetchClient class allows you to easily specify your own Bearer tokens to be used in the requests. How you derive the token is up to you. import { BearerTokenFetchClient } from \"@pnp/nodejs\"; import { graph } from \"@pnp/graph/presets/all\"; // setup the client using graph setup function graph.setup({ graph: { fetchClientFactory: () => { return new BearerTokenFetchClient(\"{Bearer Token}\"); }, }, }); // execute a library request as normal const g = await graph.groups(); console.log(JSON.stringify(g, null, 4));","title":"@pnp/nodejs/BearerTokenFetchClient"},{"location":"v2/nodejs/provider-hosted-app/","text":"@pnp/nodejs/providerhostedrequestcontext \u00b6 The ProviderHostedRequestContext enables the creation of provider-hosted add-ins built in node.js to use pnpjs to interact with SharePoint. The context is associated to a SharePoint user, allowing requests to be made by the add-in on the behalf of the user. The usage of this class assumes the provider-hosted add-in is called from SharePoint with a valid SPAppToken. This is typically done by means of accessing /_layouts/15/AppRedirect.aspx with the app's client ID and app's redirect URI. Note : To support concurrent requests by different users and/or add-ins on different tenants, do not use the SPFetchClient class. Instead, use the more generic NodeFetchClient class. The downside is that you have to manually configure each request to use the desired user/app context. import { sp, SPRest } from \"@pnp/sp/presets/all\"; import { NodeFetchClient, ProviderHostedRequestContext } from \"@pnp/nodejs\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new NodeFetchClient(); }, }, }); // get request data generated by /_layouts/15/AppRedirect.aspx const spAppToken = request.body.SPAppToken; const spSiteUrl = request.body.SPSiteUrl; // create a context based on the add-in details and SPAppToken const ctx = await ProviderHostedRequestContext.create(spSiteUrl, \"{client id}\", \"{client secret}\", spAppToken); // create an SPRest object configured to use our context // this is used in place of the global sp object const userSP = new SPRest().configure(await ctx.getUserConfig(), spSiteUrl); const addinSP = new SPRest().configure(await ctx.getAddInOnlyConfig(), spSiteUrl); // make a request on behalf of the user const user = await userSP.web.currentUser(); console.log(`Hello ${user.Title}`); // make an add-in only request const app = await addinSP.web.currentUser(); console.log(`Add-in principal: ${app.Title}`);","title":"@pnp/nodejs/providerhostedrequestcontext"},{"location":"v2/nodejs/provider-hosted-app/#pnpnodejsproviderhostedrequestcontext","text":"The ProviderHostedRequestContext enables the creation of provider-hosted add-ins built in node.js to use pnpjs to interact with SharePoint. The context is associated to a SharePoint user, allowing requests to be made by the add-in on the behalf of the user. The usage of this class assumes the provider-hosted add-in is called from SharePoint with a valid SPAppToken. This is typically done by means of accessing /_layouts/15/AppRedirect.aspx with the app's client ID and app's redirect URI. Note : To support concurrent requests by different users and/or add-ins on different tenants, do not use the SPFetchClient class. Instead, use the more generic NodeFetchClient class. The downside is that you have to manually configure each request to use the desired user/app context. import { sp, SPRest } from \"@pnp/sp/presets/all\"; import { NodeFetchClient, ProviderHostedRequestContext } from \"@pnp/nodejs\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new NodeFetchClient(); }, }, }); // get request data generated by /_layouts/15/AppRedirect.aspx const spAppToken = request.body.SPAppToken; const spSiteUrl = request.body.SPSiteUrl; // create a context based on the add-in details and SPAppToken const ctx = await ProviderHostedRequestContext.create(spSiteUrl, \"{client id}\", \"{client secret}\", spAppToken); // create an SPRest object configured to use our context // this is used in place of the global sp object const userSP = new SPRest().configure(await ctx.getUserConfig(), spSiteUrl); const addinSP = new SPRest().configure(await ctx.getAddInOnlyConfig(), spSiteUrl); // make a request on behalf of the user const user = await userSP.web.currentUser(); console.log(`Hello ${user.Title}`); // make an add-in only request const app = await addinSP.web.currentUser(); console.log(`Add-in principal: ${app.Title}`);","title":"@pnp/nodejs/providerhostedrequestcontext"},{"location":"v2/nodejs/proxy/","text":"@pnp/nodejs/proxy \u00b6 In some cases when deploying on node you may need to use a proxy as governed by corporate policy, or perhaps you want to examine the traffic using a tool such as Fiddler. setProxyUrl \u00b6 Basic Usage \u00b6 You need to import the setProxyUrl function from @pnp/nodejs library and call it with your proxy url. Once done an https-proxy-agent will be used with each request. This works across all clients within the @pnp/nodejs library. import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // call the set proxy url function and it will be used for all requests regardless of client setProxyUrl(\"{your proxy url}\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, }); Use with Fiddler \u00b6 To get Fiddler to work you may need to set an environment variable. This should only be done for testing! import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // ignore certificate errors: ONLY FOR TESTING!! process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\"; // this is my fiddler url locally setProxyUrl(\"http://127.0.0.1:8888\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, }); setProxyAgent \u00b6 Added in 2.0.11 You need to import the setProxyAgent function from @pnp/nodejs library and call it with your proxy url. You can supply any valid proxy and it will be used. import { SPFetchClient, SPOAuthEnv, setProxyAgent } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { const myAgent = new MyAgentOfSomeType({}); // call the set proxy agent function and it will be used for all requests regardless of client setProxyAgent(myAgent); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"@pnp/nodejs/proxy"},{"location":"v2/nodejs/proxy/#pnpnodejsproxy","text":"In some cases when deploying on node you may need to use a proxy as governed by corporate policy, or perhaps you want to examine the traffic using a tool such as Fiddler.","title":"@pnp/nodejs/proxy"},{"location":"v2/nodejs/proxy/#setproxyurl","text":"","title":"setProxyUrl"},{"location":"v2/nodejs/proxy/#basic-usage","text":"You need to import the setProxyUrl function from @pnp/nodejs library and call it with your proxy url. Once done an https-proxy-agent will be used with each request. This works across all clients within the @pnp/nodejs library. import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // call the set proxy url function and it will be used for all requests regardless of client setProxyUrl(\"{your proxy url}\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"Basic Usage"},{"location":"v2/nodejs/proxy/#use-with-fiddler","text":"To get Fiddler to work you may need to set an environment variable. This should only be done for testing! import { SPFetchClient, SPOAuthEnv, setProxyUrl } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { // ignore certificate errors: ONLY FOR TESTING!! process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\"; // this is my fiddler url locally setProxyUrl(\"http://127.0.0.1:8888\"); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"Use with Fiddler"},{"location":"v2/nodejs/proxy/#setproxyagent","text":"Added in 2.0.11 You need to import the setProxyAgent function from @pnp/nodejs library and call it with your proxy url. You can supply any valid proxy and it will be used. import { SPFetchClient, SPOAuthEnv, setProxyAgent } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { const myAgent = new MyAgentOfSomeType({}); // call the set proxy agent function and it will be used for all requests regardless of client setProxyAgent(myAgent); return new SPFetchClient(settings.testing.sp.url, settings.testing.sp.id, settings.testing.sp.secret, SPOAuthEnv.SPO); }, }, });","title":"setProxyAgent"},{"location":"v2/nodejs/sp-extensions/","text":"@pnp/nodejs - sp extensions \u00b6 By importing anything from the @pnp/nodejs library you automatically get nodejs specific extension methods added into the sp fluent api. This article describes them. These examples use the *-commonjs version of the libraries as they target node, you can read more about the differences . IFile.getStream \u00b6 Allows you to read a response body as a nodejs PassThrough stream. // by importing the the library the node specific extensions are automatically applied import { SPFetchClient, SPNS } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{url}\", \"{id}\", \"{secret}\"); }, }, }); // get the stream const streamResult: SPNS.IResponseBodyStream = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream(); // see if we have a known length console.log(streamResult.knownLength); // read the stream // this is a very basic example - you can do tons more with streams in node const txt = await new Promise<string>((resolve) => { let data = \"\"; stream.body.on(\"data\", (chunk) => data += chunk); stream.body.on(\"end\", () => resolve(data)); }); IFiles.addChunked \u00b6 Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const files = sp.web.defaultDocumentLibrary.rootFolder.files; await files.addChunked(name, stream, null, true, 10); IFile.setStreamContentChunked \u00b6 Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const file = sp.web.defaultDocumentLibrary.rootFolder.files..getByName(\"file-name.txt\"); await file.setStreamContentChunked(stream); Explicit import \u00b6 If you don't need to import anything from the library, but would like to include the extensions just import the library as shown. // ES Modules: import \"@pnp/nodejs\"; import \"@pnp/nodejs-commonjs\"; // get the stream const streamResult = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream(); Accessing SP Extension Namespace \u00b6 There are classes and interfaces included in extension modules, which you can access through a namespace, \"SPNS\". import { SPNS } from \"@pnp/nodejs-commonjs\"; const parser = new SPNS.StreamParser();","title":"@pnp/nodejs - sp extensions"},{"location":"v2/nodejs/sp-extensions/#pnpnodejs-sp-extensions","text":"By importing anything from the @pnp/nodejs library you automatically get nodejs specific extension methods added into the sp fluent api. This article describes them. These examples use the *-commonjs version of the libraries as they target node, you can read more about the differences .","title":"@pnp/nodejs - sp extensions"},{"location":"v2/nodejs/sp-extensions/#ifilegetstream","text":"Allows you to read a response body as a nodejs PassThrough stream. // by importing the the library the node specific extensions are automatically applied import { SPFetchClient, SPNS } from \"@pnp/nodejs-commonjs\"; import { sp } from \"@pnp/sp-commonjs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{url}\", \"{id}\", \"{secret}\"); }, }, }); // get the stream const streamResult: SPNS.IResponseBodyStream = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream(); // see if we have a known length console.log(streamResult.knownLength); // read the stream // this is a very basic example - you can do tons more with streams in node const txt = await new Promise<string>((resolve) => { let data = \"\"; stream.body.on(\"data\", (chunk) => data += chunk); stream.body.on(\"end\", () => resolve(data)); });","title":"IFile.getStream"},{"location":"v2/nodejs/sp-extensions/#ifilesaddchunked","text":"Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const files = sp.web.defaultDocumentLibrary.rootFolder.files; await files.addChunked(name, stream, null, true, 10);","title":"IFiles.addChunked"},{"location":"v2/nodejs/sp-extensions/#ifilesetstreamcontentchunked","text":"Added in 2.1.0 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/files/folder\"; import * as fs from \"fs\"; const stream = fs.createReadStream(\"{file path}\"); const file = sp.web.defaultDocumentLibrary.rootFolder.files..getByName(\"file-name.txt\"); await file.setStreamContentChunked(stream);","title":"IFile.setStreamContentChunked"},{"location":"v2/nodejs/sp-extensions/#explicit-import","text":"If you don't need to import anything from the library, but would like to include the extensions just import the library as shown. // ES Modules: import \"@pnp/nodejs\"; import \"@pnp/nodejs-commonjs\"; // get the stream const streamResult = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/file.txt\").getStream();","title":"Explicit import"},{"location":"v2/nodejs/sp-extensions/#accessing-sp-extension-namespace","text":"There are classes and interfaces included in extension modules, which you can access through a namespace, \"SPNS\". import { SPNS } from \"@pnp/nodejs-commonjs\"; const parser = new SPNS.StreamParser();","title":"Accessing SP Extension Namespace"},{"location":"v2/nodejs/sp-fetch-client/","text":"@pnp/nodejs/spfetchclient \u00b6 The SPFetchClient is used to authentication to SharePoint as a provider hosted add-in using a client and secret in nodejs. Remember it is not a good practice to expose client ids and secrets on the client and use of this class is intended for nodejs exclusively. See: How to register a legacy SharePoint application import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web(); console.log(JSON.stringify(w, null, 4)); Set Authentication Environment \u00b6 For some areas such as Germany, China, and US Gov clouds you need to specify a different authentication url to the service. This is done by specifying the correct SPOAuthEnv enumeration to the SPFetchClient constructor. The options are listed below. If you are not sure which option to specify the default is likely OK. SPO : (default) for all *.sharepoint.com urls China: for China hosted cloud Germany: for Germany local cloud USDef: USA Defense cloud USGov: USA Government cloud import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.China); }, }, }); Set Realm \u00b6 In some cases automatically resolving the realm may not work. In this case you can set the realm parameter in the SPFetchClient constructor. You can determine the correct value for the realm by navigating to https://{site name}-admin.sharepoint.com/_layouts/15/TA_AllAppPrincipals.aspx and copying the GUID value that appears after the \"@\" - this is the realm id. import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.SPO, \"{realm}\"); }, }, });","title":"@pnp/nodejs/spfetchclient"},{"location":"v2/nodejs/sp-fetch-client/#pnpnodejsspfetchclient","text":"The SPFetchClient is used to authentication to SharePoint as a provider hosted add-in using a client and secret in nodejs. Remember it is not a good practice to expose client ids and secrets on the client and use of this class is intended for nodejs exclusively. See: How to register a legacy SharePoint application import { SPFetchClient } from \"@pnp/nodejs\"; import { sp } from \"@pnp/sp/presets/all\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\"); }, }, }); // execute a library request as normal const w = await sp.web(); console.log(JSON.stringify(w, null, 4));","title":"@pnp/nodejs/spfetchclient"},{"location":"v2/nodejs/sp-fetch-client/#set-authentication-environment","text":"For some areas such as Germany, China, and US Gov clouds you need to specify a different authentication url to the service. This is done by specifying the correct SPOAuthEnv enumeration to the SPFetchClient constructor. The options are listed below. If you are not sure which option to specify the default is likely OK. SPO : (default) for all *.sharepoint.com urls China: for China hosted cloud Germany: for Germany local cloud USDef: USA Defense cloud USGov: USA Government cloud import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.China); }, }, });","title":"Set Authentication Environment"},{"location":"v2/nodejs/sp-fetch-client/#set-realm","text":"In some cases automatically resolving the realm may not work. In this case you can set the realm parameter in the SPFetchClient constructor. You can determine the correct value for the realm by navigating to https://{site name}-admin.sharepoint.com/_layouts/15/TA_AllAppPrincipals.aspx and copying the GUID value that appears after the \"@\" - this is the realm id. import { sp } from \"@pnp/sp/presets/all\"; import { SPFetchClient, SPOAuthEnv } from \"@pnp/nodejs\"; sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{site url}\", \"{client id}\", \"{client secret}\", SPOAuthEnv.SPO, \"{realm}\"); }, }, });","title":"Set Realm"},{"location":"v2/odata/","text":"@pnp/queryable \u00b6 This modules contains the abstract core classes used to process odata requests. They can also be used to build your own odata library should you wish to. By sharing the core functionality across libraries we can provide a consistent API as well as ensure the core code is solid and well tested, with any updates benefitting all inheriting libraries. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable --save Library Topics \u00b6 caching core OData Batching Parsers Pipeline Queryable","title":"@pnp/queryable"},{"location":"v2/odata/#pnpqueryable","text":"This modules contains the abstract core classes used to process odata requests. They can also be used to build your own odata library should you wish to. By sharing the core functionality across libraries we can provide a consistent API as well as ensure the core code is solid and well tested, with any updates benefitting all inheriting libraries.","title":"@pnp/queryable"},{"location":"v2/odata/#getting-started","text":"Install the library and required dependencies npm install @pnp/logging @pnp/core @pnp/queryable --save","title":"Getting Started"},{"location":"v2/odata/#library-topics","text":"caching core OData Batching Parsers Pipeline Queryable","title":"Library Topics"},{"location":"v2/odata/caching/","text":"@pnp/queryable/caching \u00b6 Often times data doesn't change that quickly, especially in the case of rolling up corporate news or upcoming events. These types of things can be cached for minutes if not hours. To help make caching easy you just need to insert the usingCaching method in your chain. This only applies to get requests. The usingCaching method can be used with the inBatch method as well to cache the results of batched requests. The below examples uses the @pnp/sp library as the example - but this works equally well for any library making use of the @pnp/queryable base classes, such as @pnp/graph. Basic example \u00b6 You can use the method without any additional configuration. We have made some default choices for you and will discuss ways to override them later. The code below will get items from a list, first checking the cache for the value. You can also use it with OData operators such as top and orderBy. The usingCaching() method should always be the last method in the chain before the get() (OR if you are using batching these methods can be transposed, more details below). import { sp } from \"@pnp/sp\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.usingCaching()(); console.log(r); const r2 = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r2); Globally Configure Cache Settings \u00b6 If you would not like to use the default values, but don't want to clutter your code by setting the caching values on each request you can configure custom options globally. These will be applied to all calls to usingCaching() throughout your application. import { sp } from \"@pnp/sp\"; sp.setup({ defaultCachingStore: \"session\", // or \"local\" defaultCachingTimeoutSeconds: 30, globalCacheDisable: false // or true to disable caching in case of debugging/testing }); const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r); Per Call Configuration \u00b6 If you prefer more verbose code or have a need to manage the cache settings on a per request basis you can include individual caching settings for each request. These settings are passed to the usingCaching method call and are defined in the following interface. If you want to use the per-request options you must include the key. export interface ICachingOptions { expiration?: Date; storeName?: \"session\" | \"local\"; key: string; } import { sp } from \"@pnp/sp\"; import { dateAdd } from \"@pnp/core\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching({ expiration: dateAdd(new Date(), \"minute\", 20), key: \"My Key\", storeName: \"local\" })(); console.log(r); Using Batching with Caching \u00b6 You can use batching and caching together, but remember caching is only applied to get requests. When you use them together the methods can be transposed, the below example is valid. import { sp } from \"@pnp/sp\"; let batch = sp.createBatch(); sp.web.lists.inBatch(batch).usingCaching()().then(r => { console.log(r) }); sp.web.lists.getByTitle(\"Tasks\").items.usingCaching().inBatch(batch)().then(r => { console.log(r) }); batch.execute().then(() => console.log(\"All done!\")); Implement Custom Caching \u00b6 You may desire to use a different caching strategy than the one we implemented within the library. The easiest way to achieve this is to wrap the request in your custom caching functionality using the unresolved promise as needed. Here we show how to implement the Stale While Revalidate pattern as discussed here . Implement caching helper method \u00b6 We create a map to act as our cache storage and a function to wrap the request caching logic const map = new Map<string, any>(); async function staleWhileRevalidate<T>(key: string, p: Promise<T>): Promise<T> { if (map.has(key)) { // In Cache p.then(u => { // Update Cache once we have a result map.set(key, u); }); // Return from Cache return map.get(key); } // Not In Cache so we need to wait for the value const r = await p; // Set Cache map.set(key, r); // Return from Promise return r; } Usage \u00b6 Don't call usingCaching just apply the helper method // this one will wait for the request to finish const r1 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r2, null, 2)); Wrapper Function \u00b6 You can wrap this call into a single function you can reuse within your application each time you need the web data for example. You can update the select and interface to match your needs as well. interface WebData { Title: string; Description: string; } function getWebData(): Promise<WebData> { return staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); } // this one will wait for the request to finish const r1 = await getWebData(); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await getWebData(); console.log(JSON.stringify(r2, null, 2));","title":"@pnp/queryable/caching"},{"location":"v2/odata/caching/#pnpqueryablecaching","text":"Often times data doesn't change that quickly, especially in the case of rolling up corporate news or upcoming events. These types of things can be cached for minutes if not hours. To help make caching easy you just need to insert the usingCaching method in your chain. This only applies to get requests. The usingCaching method can be used with the inBatch method as well to cache the results of batched requests. The below examples uses the @pnp/sp library as the example - but this works equally well for any library making use of the @pnp/queryable base classes, such as @pnp/graph.","title":"@pnp/queryable/caching"},{"location":"v2/odata/caching/#basic-example","text":"You can use the method without any additional configuration. We have made some default choices for you and will discuss ways to override them later. The code below will get items from a list, first checking the cache for the value. You can also use it with OData operators such as top and orderBy. The usingCaching() method should always be the last method in the chain before the get() (OR if you are using batching these methods can be transposed, more details below). import { sp } from \"@pnp/sp\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.usingCaching()(); console.log(r); const r2 = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r2);","title":"Basic example"},{"location":"v2/odata/caching/#globally-configure-cache-settings","text":"If you would not like to use the default values, but don't want to clutter your code by setting the caching values on each request you can configure custom options globally. These will be applied to all calls to usingCaching() throughout your application. import { sp } from \"@pnp/sp\"; sp.setup({ defaultCachingStore: \"session\", // or \"local\" defaultCachingTimeoutSeconds: 30, globalCacheDisable: false // or true to disable caching in case of debugging/testing }); const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching()(); console.log(r);","title":"Globally Configure Cache Settings"},{"location":"v2/odata/caching/#per-call-configuration","text":"If you prefer more verbose code or have a need to manage the cache settings on a per request basis you can include individual caching settings for each request. These settings are passed to the usingCaching method call and are defined in the following interface. If you want to use the per-request options you must include the key. export interface ICachingOptions { expiration?: Date; storeName?: \"session\" | \"local\"; key: string; } import { sp } from \"@pnp/sp\"; import { dateAdd } from \"@pnp/core\"; const r = await sp.web.lists.getByTitle(\"Tasks\").items.top(5).orderBy(\"Modified\").usingCaching({ expiration: dateAdd(new Date(), \"minute\", 20), key: \"My Key\", storeName: \"local\" })(); console.log(r);","title":"Per Call Configuration"},{"location":"v2/odata/caching/#using-batching-with-caching","text":"You can use batching and caching together, but remember caching is only applied to get requests. When you use them together the methods can be transposed, the below example is valid. import { sp } from \"@pnp/sp\"; let batch = sp.createBatch(); sp.web.lists.inBatch(batch).usingCaching()().then(r => { console.log(r) }); sp.web.lists.getByTitle(\"Tasks\").items.usingCaching().inBatch(batch)().then(r => { console.log(r) }); batch.execute().then(() => console.log(\"All done!\"));","title":"Using Batching with Caching"},{"location":"v2/odata/caching/#implement-custom-caching","text":"You may desire to use a different caching strategy than the one we implemented within the library. The easiest way to achieve this is to wrap the request in your custom caching functionality using the unresolved promise as needed. Here we show how to implement the Stale While Revalidate pattern as discussed here .","title":"Implement Custom Caching"},{"location":"v2/odata/caching/#implement-caching-helper-method","text":"We create a map to act as our cache storage and a function to wrap the request caching logic const map = new Map<string, any>(); async function staleWhileRevalidate<T>(key: string, p: Promise<T>): Promise<T> { if (map.has(key)) { // In Cache p.then(u => { // Update Cache once we have a result map.set(key, u); }); // Return from Cache return map.get(key); } // Not In Cache so we need to wait for the value const r = await p; // Set Cache map.set(key, r); // Return from Promise return r; }","title":"Implement caching helper method"},{"location":"v2/odata/caching/#usage","text":"Don't call usingCaching just apply the helper method // this one will wait for the request to finish const r1 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); console.log(JSON.stringify(r2, null, 2));","title":"Usage"},{"location":"v2/odata/caching/#wrapper-function","text":"You can wrap this call into a single function you can reuse within your application each time you need the web data for example. You can update the select and interface to match your needs as well. interface WebData { Title: string; Description: string; } function getWebData(): Promise<WebData> { return staleWhileRevalidate(\"test1\", sp.web.select(\"Title\", \"Description\")()); } // this one will wait for the request to finish const r1 = await getWebData(); console.log(JSON.stringify(r1, null, 2)); // this one will return the result from cache and then update the cache in the background const r2 = await getWebData(); console.log(JSON.stringify(r2, null, 2));","title":"Wrapper Function"},{"location":"v2/odata/core/","text":"@pnp/queryable/core \u00b6 This module contains shared interfaces and abstract classes used within the @pnp/queryable package and those items that inherit from it. ProcessHttpClientResponseException \u00b6 The exception thrown when a response is returned and cannot be processed. interface ODataParser \u00b6 Base interface used to describe a class that that will parse incoming responses. It takes a single type parameter representing the type of the value to be returned. It has two methods, one is optional: parse(r: Response): Promise - main method use to parse a response and return a Promise resolving to an object of type T hydrate?: (d: any) => T - optional method used when getting an object from the cache if it requires calling a constructor ODataParserBase \u00b6 The base class used by all parsers in the @pnp libraries. It is optional to use when creating your own custom parsers, but does contain several helper methods. Create a custom parser from ODataParserBase \u00b6 You can always create custom parsers for your projects, however it is likely you will not require this step as the default parsers should work for most cases. class MyParser extends ODataParserBase<any> { // we need to override the parse method to do our custom stuff public parse(r: Response): Promise<T> { // we wrap everything in a promise return new Promise((resolve, reject) => { // lets use the default error handling which returns true for no error // and will call reject with an error if one exists if (this.handleError(r, reject)) { // now we add our custom parsing here r.text().then(txt => { // here we call a made up function to parse the result // this is where we would do our parsing as required myCustomerUnencode(txt).then(v => { resolve(v); }); }); } }); } }","title":"@pnp/queryable/core"},{"location":"v2/odata/core/#pnpqueryablecore","text":"This module contains shared interfaces and abstract classes used within the @pnp/queryable package and those items that inherit from it.","title":"@pnp/queryable/core"},{"location":"v2/odata/core/#processhttpclientresponseexception","text":"The exception thrown when a response is returned and cannot be processed.","title":"ProcessHttpClientResponseException"},{"location":"v2/odata/core/#interface-odataparser","text":"Base interface used to describe a class that that will parse incoming responses. It takes a single type parameter representing the type of the value to be returned. It has two methods, one is optional: parse(r: Response): Promise - main method use to parse a response and return a Promise resolving to an object of type T hydrate?: (d: any) => T - optional method used when getting an object from the cache if it requires calling a constructor","title":"interface ODataParser"},{"location":"v2/odata/core/#odataparserbase","text":"The base class used by all parsers in the @pnp libraries. It is optional to use when creating your own custom parsers, but does contain several helper methods.","title":"ODataParserBase"},{"location":"v2/odata/core/#create-a-custom-parser-from-odataparserbase","text":"You can always create custom parsers for your projects, however it is likely you will not require this step as the default parsers should work for most cases. class MyParser extends ODataParserBase<any> { // we need to override the parse method to do our custom stuff public parse(r: Response): Promise<T> { // we wrap everything in a promise return new Promise((resolve, reject) => { // lets use the default error handling which returns true for no error // and will call reject with an error if one exists if (this.handleError(r, reject)) { // now we add our custom parsing here r.text().then(txt => { // here we call a made up function to parse the result // this is where we would do our parsing as required myCustomerUnencode(txt).then(v => { resolve(v); }); }); } }); } }","title":"Create a custom parser from ODataParserBase"},{"location":"v2/odata/debug/","text":"Debugging Proxy Objects \u00b6 Because all queryables are now represented as Proxy objects you can't immediately see the properties/method of the object or the data stored about the request. In certain debugging scenarios it can help to get visibility into the object that is wrapped by the proxy. To enable this we provide a set of extensions to help. The debug extensions are added by including the import \"@pnp/queryable/debug\"; statement in your project. It should be removed for production. This module provides several methods to help with debugging Queryable Proxy objects. Unwrap \u00b6 The __unwrap() method returns the concrete Queryable instance wrapped by the Proxy. You can then examine this object in various ways or dump it to the console for debugging. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // unwrap the underlying concrete queryable instance const unwrapped = sp.web.__unwrap(); console.log(JSON.stringify(unwrapped, null, 2)); Note: It is not supported to unwrap objects and then use them. It may work in some cases, but this behavior may change as what is contained with the Proxy is an implementation detail and should not be relied upon. Without the Proxy wrapper we make no guarantees. Data \u00b6 All of the information related to a queryable's request is contained within the \"data\" property. If you need to grab that information you can use the __data property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's data const data = sp.web.__data; console.log(JSON.stringify(data, null, 2)); JSON \u00b6 You can also get a representation of the wrapped instance in JSON format consisting of all its own properties and values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's as JSON const data = sp.web.__json(); console.log(JSON.stringify(data, null, 2)); Deep Trace \u00b6 Deep tracing is the ability to write every property and method access to the log. This produces VERY verbose output but can be helpful in situations where you need to trace how things are called and when within the Proxy. You enable deep tracing using the __enableDeepTrace method and disable using __disableDeepTrace . import { Logger, ConsoleListener } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; Logger.subscribe(new ConsoleListener()); // grab an instance to enable deep trace const web = sp.web; // enable deep trace on the instance web.__enableDeepTrace(); const y = await web.lists(); // disable deep trace web.__disableDeepTrace(); The example above produces the following output: Message: get ::> lists Message: get ::> lists Message: get ::> toUrl Message: get ::> toUrl Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> query Message: get ::> query Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: get ::> __disableDeepTrace Message: get ::> __disableDeepTrace","title":"Debugging Proxy Objects"},{"location":"v2/odata/debug/#debugging-proxy-objects","text":"Because all queryables are now represented as Proxy objects you can't immediately see the properties/method of the object or the data stored about the request. In certain debugging scenarios it can help to get visibility into the object that is wrapped by the proxy. To enable this we provide a set of extensions to help. The debug extensions are added by including the import \"@pnp/queryable/debug\"; statement in your project. It should be removed for production. This module provides several methods to help with debugging Queryable Proxy objects.","title":"Debugging Proxy Objects"},{"location":"v2/odata/debug/#unwrap","text":"The __unwrap() method returns the concrete Queryable instance wrapped by the Proxy. You can then examine this object in various ways or dump it to the console for debugging. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // unwrap the underlying concrete queryable instance const unwrapped = sp.web.__unwrap(); console.log(JSON.stringify(unwrapped, null, 2)); Note: It is not supported to unwrap objects and then use them. It may work in some cases, but this behavior may change as what is contained with the Proxy is an implementation detail and should not be relied upon. Without the Proxy wrapper we make no guarantees.","title":"Unwrap"},{"location":"v2/odata/debug/#data","text":"All of the information related to a queryable's request is contained within the \"data\" property. If you need to grab that information you can use the __data property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's data const data = sp.web.__data; console.log(JSON.stringify(data, null, 2));","title":"Data"},{"location":"v2/odata/debug/#json","text":"You can also get a representation of the wrapped instance in JSON format consisting of all its own properties and values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; // get the underlying queryable's as JSON const data = sp.web.__json(); console.log(JSON.stringify(data, null, 2));","title":"JSON"},{"location":"v2/odata/debug/#deep-trace","text":"Deep tracing is the ability to write every property and method access to the log. This produces VERY verbose output but can be helpful in situations where you need to trace how things are called and when within the Proxy. You enable deep tracing using the __enableDeepTrace method and disable using __disableDeepTrace . import { Logger, ConsoleListener } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/queryable/debug\"; Logger.subscribe(new ConsoleListener()); // grab an instance to enable deep trace const web = sp.web; // enable deep trace on the instance web.__enableDeepTrace(); const y = await web.lists(); // disable deep trace web.__disableDeepTrace(); The example above produces the following output: Message: get ::> lists Message: get ::> lists Message: get ::> toUrl Message: get ::> toUrl Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> query Message: get ::> query Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: get ::> data Message: get ::> data Message: get ::> _data Message: get ::> _data Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122352) Beginning GET request (_api/web/lists) Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232122354) Sending request. Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124099) Completing GET request. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: [5912fe3e-6c2a-4538-84ee-eec28a29cfef] (1580232124102) Returning result from pipeline. Set logging to verbose to see data. Data: {} Message: get ::> __disableDeepTrace Message: get ::> __disableDeepTrace","title":"Deep Trace"},{"location":"v2/odata/extensions/","text":"Extensions \u00b6 introduced in 2.0.0 Extending is the concept of overriding or adding functionality into an object or environment without altering the underlying class instances. This can be useful for debugging, testing, or injecting custom functionality. Extensions work with any invocable . You can control any behavior of the library with extensions. Extensions do not work in ie11 compatibility mode. This is by design. Types of Extensions \u00b6 There are three types of Extensions available as well as three methods for registration. You can register any type of extension with any of the registration options. Function Extensions \u00b6 The first type is a simple function with a signature: (op: \"apply\" | \"get\" | \"has\" | \"set\", target: T, ...rest: any[]): void This function is passed the current operation as the first argument, currently one of \"apply\", \"get\", \"has\", or \"set\". The second argument is the target instance upon which the operation is being invoked. The remaining parameters vary by the operation being performed, but will match their respective ProxyHandler method signatures. Named Extensions \u00b6 Named extensions are designed to add or replace a single property or method, though you can register multiple using the same object. These extensions are defined by using an object which has the property/methods you want to override described. Registering named extensions globally will override that operation to all invokables. import { extendFactory } from \"@pnp/queryable\"; import { sp, List, Lists, IWeb, ILists, List, IList, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeQueryStrValue\"; // create a plain object with the props and methods we want to add/change const myExtensions = { // override the lists property get lists(this: IWeb): ILists { // we will always order our lists by title and select just the Title for ALL calls (just as an example) return Lists(this).orderBy(\"Title\").select(\"Title\"); }, // override the getByTitle method getByTitle: function (this: ILists, title: string): IList { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, `getByTitle('List2')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; // register all the named Extensions extendFactory(Web, myExtensions); // this will use our extension to ensure the lists are ordered const lists = await sp.web.lists(); console.log(JSON.stringify(lists, null, 2)); // we will get the items from List1 but within the extension it is rewritten as List2 const items = await sp.web.lists.getByTitle(\"List1\").items(); console.log(JSON.stringify(items.length, null, 2)); ProxyHandler Extensions \u00b6 You can also register a partial ProxyHandler implementation as an extension. You can implement one or more of the ProxyHandler methods as needed. Here we implement the same override of getByTitle globally. This is the most complicated method of creating an extension and assumes an understanding of how ProxyHandlers work. import { extendFactory } from \"@pnp/queryable\"; import { sp, Lists, IWeb, ILists, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeSingleQuote\"; const myExtensions = { get: (target, p: string | number | symbol, _receiver: any) => { switch (p) { case \"getByTitle\": return (title: string) => { // in our example our list has moved, so we rewrite the request on the fly if (title === \"LookupList\") { return List(target, `getByTitle('OrderByList')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(target, `getByTitle('${escapeQueryStrValue(title)}')`); } }; } }, }; extendFactory(Web, myExtensions); const lists = sp.web.lists; const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2)); Registering Extensions \u00b6 You can register Extensions either globally, on an invocable factory, or on a per-object basis, and you can register a single extension or an array of Extensions. Global Registration \u00b6 Globally registering an extension allows you to inject functionality into every invocable that is instantiated within your application. It is important to remember that processing extensions happens on ALL property access and method invocation operations - so global extensions should be used sparingly. import { extendGlobal } from \"@pnp/queryable\"; // we can add a logging method to very verbosely track what things are called in our application extendGlobal((op: string, _target: any, ...rest: any[]): void => { switch (op) { case \"apply\": Logger.write(`${op} ::> ()`, LogLevel.Info); break; case \"has\": case \"get\": case \"set\": Logger.write(`${op} ::> ${rest[0]}`, LogLevel.Info); break; default: Logger.write(`unknown ${op}`, LogLevel.Info); } }); Factory Registration \u00b6 The pattern you will likely find most useful is the ability to extend an invocable factory. This will apply your extensions to all instances created with that factory, meaning all IWebs or ILists will have the extension methods. The example below shows how to add a property to IWeb as well as a method to IList. import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import { IWeb, Web } from \"@pnp/sp/webs\"; import { ILists, Lists } from \"@pnp/sp/lists\"; import { extendFactory } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // sets up the types correctly when importing across your application declare module \"@pnp/sp/webs/types\" { // we need to extend the interface interface IWeb { orderedLists: ILists; } } // sets up the types correctly when importing across your application declare module \"@pnp/sp/lists/types\" { // we need to extend the interface interface ILists { getOrderedListsQuery: (this: ILists) => ILists; } } extendFactory(Web, { // add an ordered lists property get orderedLists(this: IWeb): ILists { return this.lists.getOrderedListsQuery(); }, }); extendFactory(Lists, { // add an ordered lists property getOrderedListsQuery(this: ILists): ILists { return this.top(10).orderBy(\"Title\").select(\"Title\"); }, }); // regardless of how we access the web and lists collections our extensions remain with all new instance based on const web = Web(\"https://tenant.sharepoint.com/sites/dev/\"); const lists1 = await web.orderedLists(); console.log(JSON.stringify(lists1, null, 2)); const lists2 = await Web(\"https://tenant.sharepoint.com/sites/dev/\").orderedLists(); console.log(JSON.stringify(lists2, null, 2)); const lists3 = await sp.web.orderedLists(); console.log(JSON.stringify(lists3, null, 2)); Instance Registration \u00b6 You can also register Extensions on a single object instance, which is often the preferred approach as it will have less of a performance impact across your whole application. This is useful for debugging, overriding methods/properties, or controlling the behavior of specific object instances. Extensions are not transferred to child objects in a fluent chain, be sure you are extending the instance you think you are. Here we show the same override operation of getByTitle on the lists collection, but safely only overriding the single instance. import { extendObj } from \"@pnp/queryable\"; import { sp, List, ILists } from \"@pnp/sp/presets/all\"; const myExtensions = { getByTitle: function (this: ILists, title: string) { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, \"getByTitle('List2')\"); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; const lists = extendObj(sp.web.lists, myExtensions); const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2)); Enable & Disable Extensions and Clear Global Extensions \u00b6 Extensions are automatically enabled when you set an extension through any of the above outlined methods. You can disable and enable extensions on demand if needed. import { enableExtensions, disableExtensions, clearGlobalExtensions } from \"@pnp/queryable\"; // disable Extensions disableExtensions(); // enable Extensions enableExtensions(); // clear all the globally registered extensions clearGlobalExtensions(); Order of Operations \u00b6 It is important to understand the order in which extensions are executed and when a value is returned. Instance extensions* are always called first, followed by global Extensions - in both cases they are called in the order they were registered. This allows you to perhaps have some global functionality while maintaining the ability to override it again at the instance level. IF an extension returns a value other than undefined that value is returned and no other extensions are processed. *extensions applied via an extended factory are considered instance extensions","title":"Extensions"},{"location":"v2/odata/extensions/#extensions","text":"introduced in 2.0.0 Extending is the concept of overriding or adding functionality into an object or environment without altering the underlying class instances. This can be useful for debugging, testing, or injecting custom functionality. Extensions work with any invocable . You can control any behavior of the library with extensions. Extensions do not work in ie11 compatibility mode. This is by design.","title":"Extensions"},{"location":"v2/odata/extensions/#types-of-extensions","text":"There are three types of Extensions available as well as three methods for registration. You can register any type of extension with any of the registration options.","title":"Types of Extensions"},{"location":"v2/odata/extensions/#function-extensions","text":"The first type is a simple function with a signature: (op: \"apply\" | \"get\" | \"has\" | \"set\", target: T, ...rest: any[]): void This function is passed the current operation as the first argument, currently one of \"apply\", \"get\", \"has\", or \"set\". The second argument is the target instance upon which the operation is being invoked. The remaining parameters vary by the operation being performed, but will match their respective ProxyHandler method signatures.","title":"Function Extensions"},{"location":"v2/odata/extensions/#named-extensions","text":"Named extensions are designed to add or replace a single property or method, though you can register multiple using the same object. These extensions are defined by using an object which has the property/methods you want to override described. Registering named extensions globally will override that operation to all invokables. import { extendFactory } from \"@pnp/queryable\"; import { sp, List, Lists, IWeb, ILists, List, IList, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeQueryStrValue\"; // create a plain object with the props and methods we want to add/change const myExtensions = { // override the lists property get lists(this: IWeb): ILists { // we will always order our lists by title and select just the Title for ALL calls (just as an example) return Lists(this).orderBy(\"Title\").select(\"Title\"); }, // override the getByTitle method getByTitle: function (this: ILists, title: string): IList { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, `getByTitle('List2')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; // register all the named Extensions extendFactory(Web, myExtensions); // this will use our extension to ensure the lists are ordered const lists = await sp.web.lists(); console.log(JSON.stringify(lists, null, 2)); // we will get the items from List1 but within the extension it is rewritten as List2 const items = await sp.web.lists.getByTitle(\"List1\").items(); console.log(JSON.stringify(items.length, null, 2));","title":"Named Extensions"},{"location":"v2/odata/extensions/#proxyhandler-extensions","text":"You can also register a partial ProxyHandler implementation as an extension. You can implement one or more of the ProxyHandler methods as needed. Here we implement the same override of getByTitle globally. This is the most complicated method of creating an extension and assumes an understanding of how ProxyHandlers work. import { extendFactory } from \"@pnp/queryable\"; import { sp, Lists, IWeb, ILists, Web } from \"@pnp/sp/presets/all\"; import { escapeQueryStrValue } from \"@pnp/sp/utils/escapeSingleQuote\"; const myExtensions = { get: (target, p: string | number | symbol, _receiver: any) => { switch (p) { case \"getByTitle\": return (title: string) => { // in our example our list has moved, so we rewrite the request on the fly if (title === \"LookupList\") { return List(target, `getByTitle('OrderByList')`); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(target, `getByTitle('${escapeQueryStrValue(title)}')`); } }; } }, }; extendFactory(Web, myExtensions); const lists = sp.web.lists; const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2));","title":"ProxyHandler Extensions"},{"location":"v2/odata/extensions/#registering-extensions","text":"You can register Extensions either globally, on an invocable factory, or on a per-object basis, and you can register a single extension or an array of Extensions.","title":"Registering Extensions"},{"location":"v2/odata/extensions/#global-registration","text":"Globally registering an extension allows you to inject functionality into every invocable that is instantiated within your application. It is important to remember that processing extensions happens on ALL property access and method invocation operations - so global extensions should be used sparingly. import { extendGlobal } from \"@pnp/queryable\"; // we can add a logging method to very verbosely track what things are called in our application extendGlobal((op: string, _target: any, ...rest: any[]): void => { switch (op) { case \"apply\": Logger.write(`${op} ::> ()`, LogLevel.Info); break; case \"has\": case \"get\": case \"set\": Logger.write(`${op} ::> ${rest[0]}`, LogLevel.Info); break; default: Logger.write(`unknown ${op}`, LogLevel.Info); } });","title":"Global Registration"},{"location":"v2/odata/extensions/#factory-registration","text":"The pattern you will likely find most useful is the ability to extend an invocable factory. This will apply your extensions to all instances created with that factory, meaning all IWebs or ILists will have the extension methods. The example below shows how to add a property to IWeb as well as a method to IList. import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import { IWeb, Web } from \"@pnp/sp/webs\"; import { ILists, Lists } from \"@pnp/sp/lists\"; import { extendFactory } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // sets up the types correctly when importing across your application declare module \"@pnp/sp/webs/types\" { // we need to extend the interface interface IWeb { orderedLists: ILists; } } // sets up the types correctly when importing across your application declare module \"@pnp/sp/lists/types\" { // we need to extend the interface interface ILists { getOrderedListsQuery: (this: ILists) => ILists; } } extendFactory(Web, { // add an ordered lists property get orderedLists(this: IWeb): ILists { return this.lists.getOrderedListsQuery(); }, }); extendFactory(Lists, { // add an ordered lists property getOrderedListsQuery(this: ILists): ILists { return this.top(10).orderBy(\"Title\").select(\"Title\"); }, }); // regardless of how we access the web and lists collections our extensions remain with all new instance based on const web = Web(\"https://tenant.sharepoint.com/sites/dev/\"); const lists1 = await web.orderedLists(); console.log(JSON.stringify(lists1, null, 2)); const lists2 = await Web(\"https://tenant.sharepoint.com/sites/dev/\").orderedLists(); console.log(JSON.stringify(lists2, null, 2)); const lists3 = await sp.web.orderedLists(); console.log(JSON.stringify(lists3, null, 2));","title":"Factory Registration"},{"location":"v2/odata/extensions/#instance-registration","text":"You can also register Extensions on a single object instance, which is often the preferred approach as it will have less of a performance impact across your whole application. This is useful for debugging, overriding methods/properties, or controlling the behavior of specific object instances. Extensions are not transferred to child objects in a fluent chain, be sure you are extending the instance you think you are. Here we show the same override operation of getByTitle on the lists collection, but safely only overriding the single instance. import { extendObj } from \"@pnp/queryable\"; import { sp, List, ILists } from \"@pnp/sp/presets/all\"; const myExtensions = { getByTitle: function (this: ILists, title: string) { // in our example our list has moved, so we rewrite the request on the fly if (title === \"List1\") { return List(this, \"getByTitle('List2')\"); } else { // you can't at this point call the \"base\" method as you will end up in loop within the proxy // so you need to ensure you patch/include any original functionality you need return List(this, `getByTitle('${escapeQueryStrValue(title)}')`); } }, }; const lists = extendObj(sp.web.lists, myExtensions); const items = await lists.getByTitle(\"LookupList\").items(); console.log(JSON.stringify(items.length, null, 2));","title":"Instance Registration"},{"location":"v2/odata/extensions/#enable-disable-extensions-and-clear-global-extensions","text":"Extensions are automatically enabled when you set an extension through any of the above outlined methods. You can disable and enable extensions on demand if needed. import { enableExtensions, disableExtensions, clearGlobalExtensions } from \"@pnp/queryable\"; // disable Extensions disableExtensions(); // enable Extensions enableExtensions(); // clear all the globally registered extensions clearGlobalExtensions();","title":"Enable &amp; Disable Extensions and Clear Global Extensions"},{"location":"v2/odata/extensions/#order-of-operations","text":"It is important to understand the order in which extensions are executed and when a value is returned. Instance extensions* are always called first, followed by global Extensions - in both cases they are called in the order they were registered. This allows you to perhaps have some global functionality while maintaining the ability to override it again at the instance level. IF an extension returns a value other than undefined that value is returned and no other extensions are processed. *extensions applied via an extended factory are considered instance extensions","title":"Order of Operations"},{"location":"v2/odata/odata-batch/","text":"@pnp/queryable/odatabatch \u00b6 This module contains an abstract class used as a base when inheriting libraries support batching. ODataBatchRequestInfo \u00b6 This interface defines what each batch needs to know about each request. It is generic in that any library can provide the information but will be responsible for processing that info by implementing the abstract executeImpl method. ODataBatch \u00b6 Base class for building batching support for a library inheriting from @pnp/queryable. You can see implementations of this abstract class in the @pnp/sp and @pnp/graph modules.","title":"@pnp/queryable/odatabatch"},{"location":"v2/odata/odata-batch/#pnpqueryableodatabatch","text":"This module contains an abstract class used as a base when inheriting libraries support batching.","title":"@pnp/queryable/odatabatch"},{"location":"v2/odata/odata-batch/#odatabatchrequestinfo","text":"This interface defines what each batch needs to know about each request. It is generic in that any library can provide the information but will be responsible for processing that info by implementing the abstract executeImpl method.","title":"ODataBatchRequestInfo"},{"location":"v2/odata/odata-batch/#odatabatch","text":"Base class for building batching support for a library inheriting from @pnp/queryable. You can see implementations of this abstract class in the @pnp/sp and @pnp/graph modules.","title":"ODataBatch"},{"location":"v2/odata/parsers/","text":"@pnp/queryable/parsers \u00b6 This modules contains a set of generic parsers. These can be used or extended as needed, though it is likely in most cases the default parser will be all you need. ODataDefaultParser \u00b6 The simplest parser used to transform a Response into its JSON representation. The default parser will handle errors in a consistent manner throwing an HttpRequestError instance. This class extends Error and adds the response, status, and statusText properties. The response object is unread. You can use this custom error as shown below to gather more information about what went wrong in the request. import { sp } from \"@pnp/sp\"; import { JSONParser } from \"@pnp/queryable\"; try { const parser = new JSONParser(); // this always throws a 404 error await sp.web.getList(\"doesn't exist\").get(parser); } catch (e) { // we can check for the property \"isHttpRequestError\" to see if this is an instance of our class // this gets by all the many limitations of subclassing Error and type detection in JavaScript if (e.hasOwnProperty(\"isHttpRequestError\")) { console.log(\"e is HttpRequestError\"); // now we can access the various properties and make use of the response object. // at this point the body is unread console.log(`status: ${e.status}`); console.log(`statusText: ${e.statusText}`); const json = await e.response.clone().json(); console.log(JSON.stringify(json)); const text = await e.response.clone().text(); console.log(text); const headers = e.response.headers; } console.error(e); } TextParser \u00b6 Specialized parser used to parse the response using the .text() method with no other processing. Used primarily for files. BlobParser \u00b6 Specialized parser used to parse the response using the .blob() method with no other processing. Used primarily for files. JSONParser \u00b6 Specialized parser used to parse the response using the .json() method with no other processing. Used primarily for files. BufferParser \u00b6 Specialized parser used to parse the response using the .arrayBuffer() [node] for .buffer() [browser] method with no other processing. Used primarily for files. LambdaParser \u00b6 Allows you to pass in any handler function you want, called if the request does not result in an error that transforms the raw, unread request into the result type. import { LambdaParser } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // here a simple parser duplicating the functionality of the JSONParser const parser = new LambdaParser((r: Response) => r.json()); const webDataJson = await sp.web.get(parser); console.log(webDataJson);","title":"@pnp/queryable/parsers"},{"location":"v2/odata/parsers/#pnpqueryableparsers","text":"This modules contains a set of generic parsers. These can be used or extended as needed, though it is likely in most cases the default parser will be all you need.","title":"@pnp/queryable/parsers"},{"location":"v2/odata/parsers/#odatadefaultparser","text":"The simplest parser used to transform a Response into its JSON representation. The default parser will handle errors in a consistent manner throwing an HttpRequestError instance. This class extends Error and adds the response, status, and statusText properties. The response object is unread. You can use this custom error as shown below to gather more information about what went wrong in the request. import { sp } from \"@pnp/sp\"; import { JSONParser } from \"@pnp/queryable\"; try { const parser = new JSONParser(); // this always throws a 404 error await sp.web.getList(\"doesn't exist\").get(parser); } catch (e) { // we can check for the property \"isHttpRequestError\" to see if this is an instance of our class // this gets by all the many limitations of subclassing Error and type detection in JavaScript if (e.hasOwnProperty(\"isHttpRequestError\")) { console.log(\"e is HttpRequestError\"); // now we can access the various properties and make use of the response object. // at this point the body is unread console.log(`status: ${e.status}`); console.log(`statusText: ${e.statusText}`); const json = await e.response.clone().json(); console.log(JSON.stringify(json)); const text = await e.response.clone().text(); console.log(text); const headers = e.response.headers; } console.error(e); }","title":"ODataDefaultParser"},{"location":"v2/odata/parsers/#textparser","text":"Specialized parser used to parse the response using the .text() method with no other processing. Used primarily for files.","title":"TextParser"},{"location":"v2/odata/parsers/#blobparser","text":"Specialized parser used to parse the response using the .blob() method with no other processing. Used primarily for files.","title":"BlobParser"},{"location":"v2/odata/parsers/#jsonparser","text":"Specialized parser used to parse the response using the .json() method with no other processing. Used primarily for files.","title":"JSONParser"},{"location":"v2/odata/parsers/#bufferparser","text":"Specialized parser used to parse the response using the .arrayBuffer() [node] for .buffer() [browser] method with no other processing. Used primarily for files.","title":"BufferParser"},{"location":"v2/odata/parsers/#lambdaparser","text":"Allows you to pass in any handler function you want, called if the request does not result in an error that transforms the raw, unread request into the result type. import { LambdaParser } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; // here a simple parser duplicating the functionality of the JSONParser const parser = new LambdaParser((r: Response) => r.json()); const webDataJson = await sp.web.get(parser); console.log(webDataJson);","title":"LambdaParser"},{"location":"v2/odata/pipeline/","text":"@pnp/queryable/pipeline \u00b6 All of the odata requests processed by @pnp/queryable pass through an extensible request pipeline. Each request is executed in a specific request context defined by the RequestContext<T> interface with the type parameter representing the type ultimately returned at the end a successful processing through the pipeline. Unless you are writing a pipeline method it is unlikely you will ever interact directly with the request pipeline. interface RequestContext<T> \u00b6 The interface that defines the context within which all requests are executed. Note that the pipeline methods to be executed are part of the context. This allows full control over the methods called during a request, and allows for the insertion of any custom methods required. interface RequestContext<T> { batch: ODataBatch; batchDependency: () => void; cachingOptions: ICachingOptions; hasResult?: boolean; isBatched: boolean; isCached: boolean; options: FetchOptions; parser: ODataParser<T>; pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>; requestAbsoluteUrl: string; requestId: string; result?: T; verb: string; clientFactory: () => RequestClient; } requestPipelineMethod decorator \u00b6 The requestPipelineMethod decorator is used to tag a pipeline method and add functionality to bypass processing if a result is already present in the pipeline. If you would like your method to always run regardless of the existence of a result you can pass true to ensure it will always run. Each pipeline method takes a single argument of the current RequestContext and returns a promise resolving to the RequestContext updated as needed. @requestPipelineMethod(true) public static myPipelineMethod<T>(context: RequestContext<T>): Promise<RequestContext<T>> { return new Promise<RequestContext<T>>(resolve => { // do something resolve(context); }); } Default Pipeline \u00b6 logs the start of the request checks the cache for a value based on the context's cache settings sends the request if no value from found in the cache logs the end of the request","title":"@pnp/queryable/pipeline"},{"location":"v2/odata/pipeline/#pnpqueryablepipeline","text":"All of the odata requests processed by @pnp/queryable pass through an extensible request pipeline. Each request is executed in a specific request context defined by the RequestContext<T> interface with the type parameter representing the type ultimately returned at the end a successful processing through the pipeline. Unless you are writing a pipeline method it is unlikely you will ever interact directly with the request pipeline.","title":"@pnp/queryable/pipeline"},{"location":"v2/odata/pipeline/#interface-requestcontextt","text":"The interface that defines the context within which all requests are executed. Note that the pipeline methods to be executed are part of the context. This allows full control over the methods called during a request, and allows for the insertion of any custom methods required. interface RequestContext<T> { batch: ODataBatch; batchDependency: () => void; cachingOptions: ICachingOptions; hasResult?: boolean; isBatched: boolean; isCached: boolean; options: FetchOptions; parser: ODataParser<T>; pipeline: Array<(c: RequestContext<T>) => Promise<RequestContext<T>>>; requestAbsoluteUrl: string; requestId: string; result?: T; verb: string; clientFactory: () => RequestClient; }","title":"interface RequestContext&lt;T&gt;"},{"location":"v2/odata/pipeline/#requestpipelinemethod-decorator","text":"The requestPipelineMethod decorator is used to tag a pipeline method and add functionality to bypass processing if a result is already present in the pipeline. If you would like your method to always run regardless of the existence of a result you can pass true to ensure it will always run. Each pipeline method takes a single argument of the current RequestContext and returns a promise resolving to the RequestContext updated as needed. @requestPipelineMethod(true) public static myPipelineMethod<T>(context: RequestContext<T>): Promise<RequestContext<T>> { return new Promise<RequestContext<T>>(resolve => { // do something resolve(context); }); }","title":"requestPipelineMethod decorator"},{"location":"v2/odata/pipeline/#default-pipeline","text":"logs the start of the request checks the cache for a value based on the context's cache settings sends the request if no value from found in the cache logs the end of the request","title":"Default Pipeline"},{"location":"v2/odata/queryable/","text":"@pnp/queryable/queryable \u00b6 The Queryable class is the base class for all of the libraries building fluent request apis. abstract class ODataQueryable<BatchType extends ODataBatch> \u00b6 This class takes a single type parameter representing the type of the batch implementation object. If your api will not support batching you can create a dummy class here and simply not use the batching calls. Properties \u00b6 query \u00b6 Provides access to the query string builder for this url Public Methods \u00b6 concat \u00b6 Directly concatenates the supplied string to the current url, not normalizing \"/\" chars configure \u00b6 Sets custom options for current object and all derived objects accessible via chaining import { ConfigOptions } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; const headers: ConfigOptions = { Accept: 'application/json;odata=nometadata' }; // here we use configure to set the headers value for all child requests of the list instance const list = sp.web.lists.getByTitle(\"List1\").configure({ headers }); // this will use the values set in configure list.items().then(items => console.log(JSON.stringify(items, null, 2)); For reference the ConfigOptions interface is shown below: export interface ConfigOptions { headers?: string[][] | { [key: string]: string } | Headers; mode?: \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\"; credentials?: \"omit\" | \"same-origin\" | \"include\"; cache?: \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\"; } configureFrom \u00b6 Sets custom options from another queryable instance's options. Identical to configure except the options are derived from the supplied instance. usingCaching \u00b6 Enables caching for this request. See caching for more details. import { sp } from \"@pnp/sp\" sp.web.usingCaching()().then(...); inBatch \u00b6 Adds this query to the supplied batch toUrl \u00b6 Gets the current url abstract toUrlAndQuery() \u00b6 When implemented by an inheriting class will build the full url with appropriate query string used to make the actual request get \u00b6 Execute the current request. Takes an optional type parameter allowing for the typing of the value or the user of parsers that will create specific object instances.","title":"@pnp/queryable/queryable"},{"location":"v2/odata/queryable/#pnpqueryablequeryable","text":"The Queryable class is the base class for all of the libraries building fluent request apis.","title":"@pnp/queryable/queryable"},{"location":"v2/odata/queryable/#abstract-class-odataqueryablebatchtype-extends-odatabatch","text":"This class takes a single type parameter representing the type of the batch implementation object. If your api will not support batching you can create a dummy class here and simply not use the batching calls.","title":"abstract class ODataQueryable&lt;BatchType extends ODataBatch&gt;"},{"location":"v2/odata/queryable/#properties","text":"","title":"Properties"},{"location":"v2/odata/queryable/#query","text":"Provides access to the query string builder for this url","title":"query"},{"location":"v2/odata/queryable/#public-methods","text":"","title":"Public Methods"},{"location":"v2/odata/queryable/#concat","text":"Directly concatenates the supplied string to the current url, not normalizing \"/\" chars","title":"concat"},{"location":"v2/odata/queryable/#configure","text":"Sets custom options for current object and all derived objects accessible via chaining import { ConfigOptions } from \"@pnp/queryable\"; import { sp } from \"@pnp/sp\"; const headers: ConfigOptions = { Accept: 'application/json;odata=nometadata' }; // here we use configure to set the headers value for all child requests of the list instance const list = sp.web.lists.getByTitle(\"List1\").configure({ headers }); // this will use the values set in configure list.items().then(items => console.log(JSON.stringify(items, null, 2)); For reference the ConfigOptions interface is shown below: export interface ConfigOptions { headers?: string[][] | { [key: string]: string } | Headers; mode?: \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\"; credentials?: \"omit\" | \"same-origin\" | \"include\"; cache?: \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\"; }","title":"configure"},{"location":"v2/odata/queryable/#configurefrom","text":"Sets custom options from another queryable instance's options. Identical to configure except the options are derived from the supplied instance.","title":"configureFrom"},{"location":"v2/odata/queryable/#usingcaching","text":"Enables caching for this request. See caching for more details. import { sp } from \"@pnp/sp\" sp.web.usingCaching()().then(...);","title":"usingCaching"},{"location":"v2/odata/queryable/#inbatch","text":"Adds this query to the supplied batch","title":"inBatch"},{"location":"v2/odata/queryable/#tourl","text":"Gets the current url","title":"toUrl"},{"location":"v2/odata/queryable/#abstract-tourlandquery","text":"When implemented by an inheriting class will build the full url with appropriate query string used to make the actual request","title":"abstract toUrlAndQuery()"},{"location":"v2/odata/queryable/#get","text":"Execute the current request. Takes an optional type parameter allowing for the typing of the value or the user of parsers that will create specific object instances.","title":"get"},{"location":"v2/pnpjs/","text":"PnPjs \u00b6 This package is a rollup package of all the other libraries for scenarios where you would prefer to access all of the code from a single file. Examples would be importing a single file into a script editor webpart or using the library in other ways that benefit from a single file. You will not be able to take advantage of selective imports using this bundle. Our recommendation is to import the packages directly into your project, or to create a custom bundle . This package is mostly provided to help folks with backward-compatibility needs. Script Editor Webpart \u00b6 The below is an example of using the pnp.js bundle within a Script Editor webpart. This script editor example is provided for folks on older version of SharePoint - when possible your first choice is SharePoint Framework. You will need to grab the pnp.js bundle file from the dist folder of the pnpjs package and upload it to a location where you can reference it from without your script editor webparts. *This is included as a reference for backward compatibility. The script editor webpart is no longer available in SharePoint online. In addition, see our General Statement on Polyfills and IE11 <script src=\"https://mytenant.sharepoint.com/sites/dev/Shared%20Documents/pnp2bundle/pnp.js\"></script> <!-- Optional to include the IE11 polyfill package --> <script src=\"https://unpkg.com/@pnp/polyfill-ie11\"></script> <script> document.onreadystatechange = async function() { if(document.readyState === \"complete\") { // because this is a UMD bundle there is a global root object named \"pnp\" const a = await pnp.sp.web.lists(); document.getElementById(\"pnpexample\").innerHTML = JSON.stringify(a); } } </script> <div id=\"pnpexample\"></div> Access Library Features \u00b6 Within the bundle all of the classes and methods are exported at the root object, with the exports from sp and graph libraries contained with NS variables to avoid naming conflicts. So if you need to access say the \"Web\" factory you can do so: const web = pnp.SPNS.Web(\"https://something.sharepoint.com\"); const lists = await web.lists(); pnp.GraphNS.* Individual libraries can also be accessed for their exports: pnp.Logger.subscribe(new pnp.ConsoleListener()); pnp.log.write(\"hello\");","title":"PnPjs"},{"location":"v2/pnpjs/#pnpjs","text":"This package is a rollup package of all the other libraries for scenarios where you would prefer to access all of the code from a single file. Examples would be importing a single file into a script editor webpart or using the library in other ways that benefit from a single file. You will not be able to take advantage of selective imports using this bundle. Our recommendation is to import the packages directly into your project, or to create a custom bundle . This package is mostly provided to help folks with backward-compatibility needs.","title":"PnPjs"},{"location":"v2/pnpjs/#script-editor-webpart","text":"The below is an example of using the pnp.js bundle within a Script Editor webpart. This script editor example is provided for folks on older version of SharePoint - when possible your first choice is SharePoint Framework. You will need to grab the pnp.js bundle file from the dist folder of the pnpjs package and upload it to a location where you can reference it from without your script editor webparts. *This is included as a reference for backward compatibility. The script editor webpart is no longer available in SharePoint online. In addition, see our General Statement on Polyfills and IE11 <script src=\"https://mytenant.sharepoint.com/sites/dev/Shared%20Documents/pnp2bundle/pnp.js\"></script> <!-- Optional to include the IE11 polyfill package --> <script src=\"https://unpkg.com/@pnp/polyfill-ie11\"></script> <script> document.onreadystatechange = async function() { if(document.readyState === \"complete\") { // because this is a UMD bundle there is a global root object named \"pnp\" const a = await pnp.sp.web.lists(); document.getElementById(\"pnpexample\").innerHTML = JSON.stringify(a); } } </script> <div id=\"pnpexample\"></div>","title":"Script Editor Webpart"},{"location":"v2/pnpjs/#access-library-features","text":"Within the bundle all of the classes and methods are exported at the root object, with the exports from sp and graph libraries contained with NS variables to avoid naming conflicts. So if you need to access say the \"Web\" factory you can do so: const web = pnp.SPNS.Web(\"https://something.sharepoint.com\"); const lists = await web.lists(); pnp.GraphNS.* Individual libraries can also be accessed for their exports: pnp.Logger.subscribe(new pnp.ConsoleListener()); pnp.log.write(\"hello\");","title":"Access Library Features"},{"location":"v2/sp/","text":"@pnp/sp \u00b6 This package contains the fluent api used to call the SharePoint rest services. Getting Started \u00b6 Install the library and required dependencies npm install @pnp/sp --save Import the library into your application and access the root sp object import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; (function main() { // here we will load the current web's title const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`); )() Getting Started: SharePoint Framework \u00b6 Install the library and required dependencies npm install @pnp/sp --save Import the library into your application, update OnInit, and access the root sp object in render import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; const w = await sp.web.select(\"Title\")(); this.domElement.innerHTML = `Web Title: ${w.Title}`; } Getting Started: Nodejs \u00b6 Install the library and required dependencies npm install @pnp/sp @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { SPFetchClient } from \"@pnp/nodejs\"; // do this once per page load sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{your site url}\", \"{your client id}\", \"{your client secret}\"); }, }, }); // now make any calls you need using the configured client const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`);","title":"@pnp/sp"},{"location":"v2/sp/#pnpsp","text":"This package contains the fluent api used to call the SharePoint rest services.","title":"@pnp/sp"},{"location":"v2/sp/#getting-started","text":"Install the library and required dependencies npm install @pnp/sp --save Import the library into your application and access the root sp object import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; (function main() { // here we will load the current web's title const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`); )()","title":"Getting Started"},{"location":"v2/sp/#getting-started-sharepoint-framework","text":"Install the library and required dependencies npm install @pnp/sp --save Import the library into your application, update OnInit, and access the root sp object in render import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // ... public onInit(): Promise<void> { return super.onInit().then(_ => { // other init code may be present sp.setup({ spfxContext: this.context }); }); } // ... public render(): void { // A simple loading message this.domElement.innerHTML = `Loading...`; const w = await sp.web.select(\"Title\")(); this.domElement.innerHTML = `Web Title: ${w.Title}`; }","title":"Getting Started: SharePoint Framework"},{"location":"v2/sp/#getting-started-nodejs","text":"Install the library and required dependencies npm install @pnp/sp @pnp/nodejs --save Import the library into your application, setup the node client, make a request import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { SPFetchClient } from \"@pnp/nodejs\"; // do this once per page load sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{your site url}\", \"{your client id}\", \"{your client secret}\"); }, }, }); // now make any calls you need using the configured client const w = await sp.web.select(\"Title\")(); console.log(`Web Title: ${w.Title}`);","title":"Getting Started: Nodejs"},{"location":"v2/sp/alias-parameters/","text":"@pnp/sp - Aliased Parameters \u00b6 Within the @pnp/sp api you can alias any of the parameters so they will be written into the querystring. This is most helpful if you are hitting up against the url length limits when working with files and folders. To alias a parameter you include the label name, a separator (\"::\") and the value in the string. You also need to prepend a \"!\" to the string to trigger the replacement. You can see this below, as well as the string that will be generated. Labels must start with a \"@\" followed by a letter. It is also your responsibility to ensure that the aliases you supply do not conflict, for example if you use \"@p1\" you should use \"@p2\" for a second parameter alias in the same query. Construct a parameter alias \u00b6 Pattern: !@{label name}::{value} Example: \"!@p1::\\sites\\dev\" or \"!@p2::\\text.txt\" Example without aliasing \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // still works as expected, no aliasing const query = sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files?$select=Title&$top=3 const r = await query(); console.log(r);; Example with aliasing \u00b6 import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 const r = await query(); console.log(r); Example with aliasing and batching \u00b6 Aliasing is supported with batching as well: import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing and batching const batch = sp.web.createBatch(); const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 query.inBatch(batch)().then(r => { console.log(r); }); batch.execute();","title":"@pnp/sp - Aliased Parameters"},{"location":"v2/sp/alias-parameters/#pnpsp-aliased-parameters","text":"Within the @pnp/sp api you can alias any of the parameters so they will be written into the querystring. This is most helpful if you are hitting up against the url length limits when working with files and folders. To alias a parameter you include the label name, a separator (\"::\") and the value in the string. You also need to prepend a \"!\" to the string to trigger the replacement. You can see this below, as well as the string that will be generated. Labels must start with a \"@\" followed by a letter. It is also your responsibility to ensure that the aliases you supply do not conflict, for example if you use \"@p1\" you should use \"@p2\" for a second parameter alias in the same query.","title":"@pnp/sp - Aliased Parameters"},{"location":"v2/sp/alias-parameters/#construct-a-parameter-alias","text":"Pattern: !@{label name}::{value} Example: \"!@p1::\\sites\\dev\" or \"!@p2::\\text.txt\"","title":"Construct a parameter alias"},{"location":"v2/sp/alias-parameters/#example-without-aliasing","text":"import { sp } from \"@pnp/sp/presets/all\"; // still works as expected, no aliasing const query = sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl('/sites/dev/Shared Documents/')/files?$select=Title&$top=3 const r = await query(); console.log(r);;","title":"Example without aliasing"},{"location":"v2/sp/alias-parameters/#example-with-aliasing","text":"import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 const r = await query(); console.log(r);","title":"Example with aliasing"},{"location":"v2/sp/alias-parameters/#example-with-aliasing-and-batching","text":"Aliasing is supported with batching as well: import { sp } from \"@pnp/sp/presets/all\"; // same query with aliasing and batching const batch = sp.web.createBatch(); const query = sp.web.getFolderByServerRelativeUrl(\"!@p1::/sites/dev/Shared Documents/\").files.select(\"Title\").top(3); console.log(query.toUrl()); // _api/web/getFolderByServerRelativeUrl('!@p1::/sites/dev/Shared Documents/')/files console.log(query.toUrlAndQuery()); // _api/web/getFolderByServerRelativeUrl(@p1)/files?@p1='/sites/dev/Shared Documents/'&$select=Title&$top=3 query.inBatch(batch)().then(r => { console.log(r); }); batch.execute();","title":"Example with aliasing and batching"},{"location":"v2/sp/alm/","text":"@pnp/sp/appcatalog \u00b6 The ALM api allows you to manage app installations both in the tenant app catalog and individual site app catalogs. Some of the methods are still in beta and as such may change in the future. This article outlines how to call this api using @pnp/sp. Remember all these actions are bound by permissions so it is likely most users will not have the rights to perform these ALM actions. Understanding the App Catalog Hierarchy \u00b6 Before you begin provisioning applications it is important to understand the relationship between a local web catalog and the tenant app catalog. Some of the methods described below only work within the context of the tenant app catalog web, such as adding an app to the catalog and the app actions retract, remove, and deploy. You can install, uninstall, and upgrade an app in any web. Read more in the official documentation . Referencing an App Catalog \u00b6 There are several ways using @pnp/sp to get a reference to an app catalog. These methods are to provide you the greatest amount of flexibility in gaining access to the app catalog. Ultimately each method produces an AppCatalog instance differentiated only by the web to which it points. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // get the current context web's app catalog const catalog = await sp.web.getAppCatalog()(); // you can also chain off the app catalog const apps = await sp.web.getAppCatalog()(); console.log(apps); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // you can get the tenant app catalog (or any app catalog) by using the getTenantAppCatalogWeb method const appCatWeb = await sp.getTenantAppCatalogWeb()(); const appCatalog = await appCatWeb.getAppCatalog()(); // you can get the tenant app catalog (or any app catalog) by passing in a url // get the tenant app catalog const tenantCatalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/appcatalog\")(); // get a different app catalog const catalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/anothersite\")(); // alternatively you can create a new app catalog instance directly by importing the AppCatalog class import { IAppCatalog, AppCatalog } from '@pnp/sp/appcatalog'; const catalog: IAppCatalog = await AppCatalog(\"https://mytenant.sharepoint.com/sites/apps\")(); // and finally you can combine use of the Web and AppCatalog classes to create an AppCatalog instance from an existing Web import { Web } from '@pnp/sp/webs'; import { AppCatalog } from '@pnp/sp/appcatalog'; const web = Web(\"https://mytenant.sharepoint.com/sites/apps\"); const catalog = await AppCatalog(web)(); The following examples make use of a variable \"catalog\" which is assumed to represent an AppCatalog instance obtained using one of the above methods, supporting code is omitted for brevity. List Available Apps \u00b6 The AppCatalog is itself a queryable collection so you can query this object directly to get a list of available apps. Also, the odata operators work on the catalog to sort, filter, and select. // get available apps await catalog(); // get available apps selecting two fields await catalog.select(\"Title\", \"Deployed\")(); Add an App \u00b6 This action must be performed in the context of the tenant app catalog // this represents the file bytes of the app package file const blob = new Blob(); // there is an optional third argument to control overwriting existing files const r = await catalog.add(\"myapp.app\", blob); // this is at its core a file add operation so you have access to the response data as well // as a File instance representing the created file console.log(JSON.stringify(r.data, null, 4)); // all file operations are available const nameData = await r.file.select(\"Name\")(); Get an App \u00b6 You can get the details of a single app by GUID id. This is also the branch point to perform specific app actions const app = await catalog.getAppById(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\")(); Perform app actions \u00b6 Remember: retract, deploy, and remove only work in the context of the tenant app catalog web. All of these methods return void and you can monitor success by wrapping the call in a try/catch block. const myAppId = \"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"; // deploy await catalog.getAppById(myAppId).deploy(); // retract await catalog.getAppById(myAppId).retract(); // install await catalog.getAppById(myAppId).install(); // uninstall await catalog.getAppById(myAppId).uninstall(); // upgrade await catalog.getAppById(myAppId).upgrade(); // remove await catalog.getAppById(myAppId).remove(); Synchronize a solution/app to the Microsoft Teams App Catalog \u00b6 By default this REST call requires the SharePoint item id of the app, not the app id. PnPjs will try to fetch the SharePoint item id by default. You can still use this the second parameter useSharePointItemId to pass your own item id in the first parameter id . // Using the app id await catalog.syncSolutionToTeams(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"); // Using the SharePoint apps item id await catalog.syncSolutionToTeams(\"123\", true); Notes \u00b6 The app catalog is just a document library under the hood, so you can also perform non-ALM actions on the library if needed. But you should be aware of possible side-effects to the ALM life-cycle when doing so.","title":"@pnp/sp/appcatalog"},{"location":"v2/sp/alm/#pnpspappcatalog","text":"The ALM api allows you to manage app installations both in the tenant app catalog and individual site app catalogs. Some of the methods are still in beta and as such may change in the future. This article outlines how to call this api using @pnp/sp. Remember all these actions are bound by permissions so it is likely most users will not have the rights to perform these ALM actions.","title":"@pnp/sp/appcatalog"},{"location":"v2/sp/alm/#understanding-the-app-catalog-hierarchy","text":"Before you begin provisioning applications it is important to understand the relationship between a local web catalog and the tenant app catalog. Some of the methods described below only work within the context of the tenant app catalog web, such as adding an app to the catalog and the app actions retract, remove, and deploy. You can install, uninstall, and upgrade an app in any web. Read more in the official documentation .","title":"Understanding the App Catalog Hierarchy"},{"location":"v2/sp/alm/#referencing-an-app-catalog","text":"There are several ways using @pnp/sp to get a reference to an app catalog. These methods are to provide you the greatest amount of flexibility in gaining access to the app catalog. Ultimately each method produces an AppCatalog instance differentiated only by the web to which it points. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // get the current context web's app catalog const catalog = await sp.web.getAppCatalog()(); // you can also chain off the app catalog const apps = await sp.web.getAppCatalog()(); console.log(apps); import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import \"@pnp/sp/webs\"; // you can get the tenant app catalog (or any app catalog) by using the getTenantAppCatalogWeb method const appCatWeb = await sp.getTenantAppCatalogWeb()(); const appCatalog = await appCatWeb.getAppCatalog()(); // you can get the tenant app catalog (or any app catalog) by passing in a url // get the tenant app catalog const tenantCatalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/appcatalog\")(); // get a different app catalog const catalog = await sp.web.getAppCatalog(\"https://mytenant.sharepoint.com/sites/anothersite\")(); // alternatively you can create a new app catalog instance directly by importing the AppCatalog class import { IAppCatalog, AppCatalog } from '@pnp/sp/appcatalog'; const catalog: IAppCatalog = await AppCatalog(\"https://mytenant.sharepoint.com/sites/apps\")(); // and finally you can combine use of the Web and AppCatalog classes to create an AppCatalog instance from an existing Web import { Web } from '@pnp/sp/webs'; import { AppCatalog } from '@pnp/sp/appcatalog'; const web = Web(\"https://mytenant.sharepoint.com/sites/apps\"); const catalog = await AppCatalog(web)(); The following examples make use of a variable \"catalog\" which is assumed to represent an AppCatalog instance obtained using one of the above methods, supporting code is omitted for brevity.","title":"Referencing an App Catalog"},{"location":"v2/sp/alm/#list-available-apps","text":"The AppCatalog is itself a queryable collection so you can query this object directly to get a list of available apps. Also, the odata operators work on the catalog to sort, filter, and select. // get available apps await catalog(); // get available apps selecting two fields await catalog.select(\"Title\", \"Deployed\")();","title":"List Available Apps"},{"location":"v2/sp/alm/#add-an-app","text":"This action must be performed in the context of the tenant app catalog // this represents the file bytes of the app package file const blob = new Blob(); // there is an optional third argument to control overwriting existing files const r = await catalog.add(\"myapp.app\", blob); // this is at its core a file add operation so you have access to the response data as well // as a File instance representing the created file console.log(JSON.stringify(r.data, null, 4)); // all file operations are available const nameData = await r.file.select(\"Name\")();","title":"Add an App"},{"location":"v2/sp/alm/#get-an-app","text":"You can get the details of a single app by GUID id. This is also the branch point to perform specific app actions const app = await catalog.getAppById(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\")();","title":"Get an App"},{"location":"v2/sp/alm/#perform-app-actions","text":"Remember: retract, deploy, and remove only work in the context of the tenant app catalog web. All of these methods return void and you can monitor success by wrapping the call in a try/catch block. const myAppId = \"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"; // deploy await catalog.getAppById(myAppId).deploy(); // retract await catalog.getAppById(myAppId).retract(); // install await catalog.getAppById(myAppId).install(); // uninstall await catalog.getAppById(myAppId).uninstall(); // upgrade await catalog.getAppById(myAppId).upgrade(); // remove await catalog.getAppById(myAppId).remove();","title":"Perform app actions"},{"location":"v2/sp/alm/#synchronize-a-solutionapp-to-the-microsoft-teams-app-catalog","text":"By default this REST call requires the SharePoint item id of the app, not the app id. PnPjs will try to fetch the SharePoint item id by default. You can still use this the second parameter useSharePointItemId to pass your own item id in the first parameter id . // Using the app id await catalog.syncSolutionToTeams(\"5137dff1-0b79-4ebc-8af4-ca01f7bd393c\"); // Using the SharePoint apps item id await catalog.syncSolutionToTeams(\"123\", true);","title":"Synchronize a solution/app to the Microsoft Teams App Catalog"},{"location":"v2/sp/alm/#notes","text":"The app catalog is just a document library under the hood, so you can also perform non-ALM actions on the library if needed. But you should be aware of possible side-effects to the ALM life-cycle when doing so.","title":"Notes"},{"location":"v2/sp/attachments/","text":"@pnp/sp/attachments \u00b6 The ability to attach file to list items allows users to track documents outside of a document library. You can use the PnP JS Core library to work with attachments as outlined below. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/attachments\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\"; Get attachments \u00b6 import { sp } from \"@pnp/sp\"; import { IAttachmentInfo } from \"@pnp/sp/attachments\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); // get all the attachments const info: IAttachmentInfo[] = await item.attachmentFiles(); // get a single file by file name const info2: IAttachmentInfo = await item.attachmentFiles.getByName(\"file.txt\")(); // select specific properties using odata operators and use Pick to type the result const info3: Pick<IAttachmentInfo, \"ServerRelativeUrl\">[] = await item.attachmentFiles.select(\"ServerRelativeUrl\")(); Add an Attachment \u00b6 You can add an attachment to a list item using the add method. This method takes either a string, Blob, or ArrayBuffer. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.add(\"file2.txt\", \"Here is my content\"); Add Multiple \u00b6 This method allows you to pass an array of AttachmentFileInfo plain objects that will be added one at a time as attachments. Essentially automating the promise chaining. import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists\"; import { IAttachmentFileInfo } from \"@pnp/sp/attachments\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); let fileInfos: IAttachmentFileInfo[] = []; fileInfos.push({ name: \"My file name 1\", content: \"string, blob, or array\" }); fileInfos.push({ name: \"My file name 2\", content: \"string, blob, or array\" }); await list.items.getById(2).attachmentFiles.addMultiple(fileInfos); Delete Multiple \u00b6 import { sp } from \"@pnp/sp\"; import { IList } from \"./@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.deleteMultiple(\"1.txt\", \"2.txt\"); Read Attachment Content \u00b6 You can read the content of an attachment as a string, Blob, ArrayBuffer, or json using the methods supplied. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); const text = await item.attachmentFiles.getByName(\"file.txt\").getText(); // use this in the browser, does not work in nodejs const blob = await item.attachmentFiles.getByName(\"file.mp4\").getBlob(); // use this in nodejs const buffer = await item.attachmentFiles.getByName(\"file.mp4\").getBuffer(); // file must be valid json const json = await item.attachmentFiles.getByName(\"file.json\").getJSON(); Update Attachment Content \u00b6 You can also update the content of an attachment. This API is limited compared to the full file API - so if you need to upload large files consider using a document library. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").setContent(\"My new content!!!\"); Delete Attachment \u00b6 import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").delete(); Recycle Attachment \u00b6 Delete the attachment and send it to recycle bin import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").recycle(); Recycle Multiple Attachments \u00b6 Delete multiple attachments and send them to recycle bin import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.recycleMultiple(\"1.txt\",\"2.txt\");","title":"@pnp/sp/attachments"},{"location":"v2/sp/attachments/#pnpspattachments","text":"The ability to attach file to list items allows users to track documents outside of a document library. You can use the PnP JS Core library to work with attachments as outlined below. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/attachments\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/attachments"},{"location":"v2/sp/attachments/#get-attachments","text":"import { sp } from \"@pnp/sp\"; import { IAttachmentInfo } from \"@pnp/sp/attachments\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); // get all the attachments const info: IAttachmentInfo[] = await item.attachmentFiles(); // get a single file by file name const info2: IAttachmentInfo = await item.attachmentFiles.getByName(\"file.txt\")(); // select specific properties using odata operators and use Pick to type the result const info3: Pick<IAttachmentInfo, \"ServerRelativeUrl\">[] = await item.attachmentFiles.select(\"ServerRelativeUrl\")();","title":"Get attachments"},{"location":"v2/sp/attachments/#add-an-attachment","text":"You can add an attachment to a list item using the add method. This method takes either a string, Blob, or ArrayBuffer. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.add(\"file2.txt\", \"Here is my content\");","title":"Add an Attachment"},{"location":"v2/sp/attachments/#add-multiple","text":"This method allows you to pass an array of AttachmentFileInfo plain objects that will be added one at a time as attachments. Essentially automating the promise chaining. import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists\"; import { IAttachmentFileInfo } from \"@pnp/sp/attachments\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); let fileInfos: IAttachmentFileInfo[] = []; fileInfos.push({ name: \"My file name 1\", content: \"string, blob, or array\" }); fileInfos.push({ name: \"My file name 2\", content: \"string, blob, or array\" }); await list.items.getById(2).attachmentFiles.addMultiple(fileInfos);","title":"Add Multiple"},{"location":"v2/sp/attachments/#delete-multiple","text":"import { sp } from \"@pnp/sp\"; import { IList } from \"./@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.deleteMultiple(\"1.txt\", \"2.txt\");","title":"Delete Multiple"},{"location":"v2/sp/attachments/#read-attachment-content","text":"You can read the content of an attachment as a string, Blob, ArrayBuffer, or json using the methods supplied. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); const text = await item.attachmentFiles.getByName(\"file.txt\").getText(); // use this in the browser, does not work in nodejs const blob = await item.attachmentFiles.getByName(\"file.mp4\").getBlob(); // use this in nodejs const buffer = await item.attachmentFiles.getByName(\"file.mp4\").getBuffer(); // file must be valid json const json = await item.attachmentFiles.getByName(\"file.json\").getJSON();","title":"Read Attachment Content"},{"location":"v2/sp/attachments/#update-attachment-content","text":"You can also update the content of an attachment. This API is limited compared to the full file API - so if you need to upload large files consider using a document library. import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").setContent(\"My new content!!!\");","title":"Update Attachment Content"},{"location":"v2/sp/attachments/#delete-attachment","text":"import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").delete();","title":"Delete Attachment"},{"location":"v2/sp/attachments/#recycle-attachment","text":"Delete the attachment and send it to recycle bin import { sp } from \"@pnp/sp\"; import { IItem } from \"@pnp/sp/items/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const item: IItem = sp.web.lists.getByTitle(\"MyList\").items.getById(1); await item.attachmentFiles.getByName(\"file2.txt\").recycle();","title":"Recycle Attachment"},{"location":"v2/sp/attachments/#recycle-multiple-attachments","text":"Delete multiple attachments and send them to recycle bin import { sp } from \"@pnp/sp\"; import { IList } from \"@pnp/sp/lists/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/attachments\"; const list: IList = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(2).attachmentFiles.recycleMultiple(\"1.txt\",\"2.txt\");","title":"Recycle Multiple Attachments"},{"location":"v2/sp/clientside-pages/","text":"@pnp/sp/clientside-pages \u00b6 The 'clientside-pages' module allows you to create, edit, and delete modern SharePoint pages. There are methods to update the page settings and add/remove client-side web parts. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/clientside-pages\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/clientside-pages\"; Preset: All import { sp, ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/presets/all\"; Create a new Page \u00b6 You can create a new client-side page in several ways, all are equivalent. Create using IWeb.addClientsidePage \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { PromotedState } from \"@pnp/sp/clientside-pages\"; // Create a page providing a file name const page = await sp.web.addClientsidePage(\"mypage1\"); // ... other operations on the page as outlined below // the page is initially not published, you must publish it so it appears for others users await page.save(); // include title and page layout const page2 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // include title, page layout, and specifying the publishing status (Added in 2.0.4) const page3 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page3.save(); Create using CreateClientsidePage method \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import { CreateClientsidePage, PromotedState } from \"@pnp/sp/clientside-pages\"; const page1 = await CreateClientsidePage(sp.web, \"mypage2\", \"My Page Title\"); // you must publish the new page await page1.save(true); // specify the page layout type parameter const page2 = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // specify the page layout type parameter while also specifying the publishing status (Added in 2.0.4) const page2half = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page2half.save(); // use the web factory to create a page in a specific web const page3 = await CreateClientsidePage(Web(\"https://{absolute web url}\"), \"mypage4\", \"My Page Title\"); // you must publish the new page await page3.save(); Load Pages \u00b6 There are a few ways to load pages, each of which results in an IClientsidePage instance being returned. Load using IWeb.loadClientsidePage \u00b6 This method takes a server relative path to the page to load. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // use from the sp.web fluent chain const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); // use the web factory to target a specific web const page2 = await Web(\"https://{absolute web url}\").loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); Load using ClientsidePageFromFile \u00b6 This method takes an IFile instance and loads an IClientsidePage instance. import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const page = await ClientsidePageFromFile(sp.web.getFileByServerRelativePath(\"/sites/dev/sitepages/mypage3.aspx\")); Edit Sections and Columns \u00b6 Client-side pages are made up of sections, columns, and controls. Sections contain columns which contain controls. There are methods to operate on these within the page, in addition to the standard array methods available in JavaScript. These samples use a variable page that is understood to be an IClientsidePage instance which is either created or loaded as outlined in previous sections. // our page instance const page: IClientsidePage; // add two columns with factor 6 - this is a two column layout as the total factor in a section should add up to 12 const section1 = page.addSection(); section1.addColumn(6); section1.addColumn(6); // create a three column layout in a new section const section2 = page.addSection(); section2.addColumn(4); section2.addColumn(4); section2.addColumn(4); // publish our changes await page.save(); Manipulate Sections and Columns \u00b6 // our page instance const page: IClientsidePage; // drop all the columns in this section // this will also DELETE all controls contained in the columns page.sections[1].columns.length = 0; // create a new column layout page.sections[1].addColumn(4); page.sections[1].addColumn(8); // publish our changes await page.save(); Vertical Section \u00b6 The vertical section, if on the page, is stored within the sections array. However, you access it slightly differently to make things easier. // our page instance const page: IClientsidePage; // add or get a vertical section (handles case where section already exists) const vertSection = page.addVerticalSection(); // **************************************************************** // if you know or want to test if a vertical section is present: if (page.hasVerticalSection) { // access the vertical section (this method will NOT create the section if it does not exist) page.verticalSection.addControl(new ClientsideText(\"hello\")); } else { const vertSection = page.addVerticalSection(); vertSection.addControl(new ClientsideText(\"hello\")); } Reorder Sections \u00b6 // our page instance const page: IClientsidePage; // swap the order of two sections // this will preserve the controls within the columns page.sections = [page.sections[1], page.sections[0]]; // publish our changes await page.save(); Reorder Columns \u00b6 The sections and columns are arrays, so normal array operations work as expected // our page instance const page: IClientsidePage; // swap the order of two columns // this will preserve the controls within the columns page.sections[1].columns = [page.sections[1].columns[1], page.sections[1].columns[0]]; // publish our changes await page.save(); Clientside Controls \u00b6 Once you have your sections and columns defined you will want to add/edit controls within those columns. Add Text Content \u00b6 import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; page.addSection().addControl(new ClientsideText(\"@pnp/sp is a great library!\")); await page.save(); Add Controls \u00b6 Adding controls involves loading the available client-side part definitions from the server or creating a text part. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // this will be a ClientsidePageComponent array // this can be cached on the client in production scenarios const partDefs = await sp.web.getClientsideWebParts(); // find the definition we want, here by id const partDef = partDefs.filter(c => c.Id === \"490d7c76-1824-45b2-9de3-676421c997fa\"); // optionally ensure you found the def if (partDef.length < 1) { // we didn't find it so we throw an error throw new Error(\"Could not find the web part\"); } // create a ClientWebPart instance from the definition const part = ClientsideWebpart.fromComponentDef(partDef[0]); // set the properties on the web part. Here for the embed web part we only have to supply an embedCode - in this case a YouTube video. // the structure of the properties varies for each web part and each version of a web part, so you will need to ensure you are setting // the properties correctly part.setProperties<{ embedCode: string }>({ embedCode: \"https://www.youtube.com/watch?v=IWQFZ7Lx-rg\", }); // we add that part to a new section page.addSection().addControl(part); await page.save(); Handle Different Webpart's Settings \u00b6 There are many ways that client side web parts are implemented and we can't provide handling within the library for all possibilities. This example shows how to handle a property set within the serverProcessedContent, in this case a List part's display title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // we create a class to wrap our functionality in a reusable way class ListWebpart extends ClientsideWebpart { constructor(control: ClientsideWebpart) { super((<any>control).json); } // add property getter/setter for what we need, in this case \"listTitle\" within searchablePlainTexts public get DisplayTitle(): string { return this.json.webPartData?.serverProcessedContent?.searchablePlainTexts?.listTitle || \"\"; } public set DisplayTitle(value: string) { this.json.webPartData.serverProcessedContent.searchablePlainTexts.listTitle = value; } } // now we load our page const page = await sp.web.loadClientsidePage(\"/sites/dev/SitePages/List-Web-Part.aspx\"); // get our part and pass it to the constructor of our wrapper class const part = new ListWebpart(page.sections[0].columns[0].getControl(0)); part.DisplayTitle = \"My New Title!\"; await page.save(); Unfortunately each webpart can be authored differently, so there isn't a way to know how the setting for a given webpart are stored without loading it and examining the properties. Page Operations \u00b6 There are other operation you can perform on a page in addition to manipulating the content. pageLayout \u00b6 You can get and set the page layout. Changing the layout after creating the page may have side effects and should be done cautiously. // our page instance const page: IClientsidePage; // get the current value const value = page.pageLayout; // set the value page.pageLayout = \"Article\"; await page.save(); bannerImageUrl \u00b6 // our page instance const page: IClientsidePage; // get the current value const value = page.bannerImageUrl; // set the value page.bannerImageUrl = \"/server/relative/path/to/image.png\"; await page.save(); Banner images need to exist within the same site collection as the page where you want to use them. thumbnailUrl \u00b6 Allows you to set the thumbnail used for the page independently of the banner. If you set the bannerImageUrl property and not thumbnailUrl the thumbnail will be reset to match the banner, mimicking the UI functionality. // our page instance const page: IClientsidePage; // get the current value const value = page.thumbnailUrl; // set the value page.thumbnailUrl = \"/server/relative/path/to/image.png\"; await page.save(); topicHeader \u00b6 // our page instance const page: IClientsidePage; // get the current value const value = page.topicHeader; // set the value page.topicHeader = \"My cool header!\"; await page.save(); // clear the topic header and hide it page.topicHeader = \"\"; await page.save(); title \u00b6 // our page instance const page: IClientsidePage; // get the current value const value = page.title; // set the value page.title = \"My page title\"; await page.save(); description \u00b6 Descriptions are limited to 255 chars // our page instance const page: IClientsidePage; // get the current value const value = page.description; // set the value page.description = \"A description\"; await page.save(); layoutType \u00b6 Sets the layout type of the page. The valid values are: \"FullWidthImage\", \"NoImage\", \"ColorBlock\", \"CutInShape\" // our page instance const page: IClientsidePage; // get the current value const value = page.layoutType; // set the value page.layoutType = \"ColorBlock\"; await page.save(); headerTextAlignment \u00b6 Sets the header text alignment to one of \"Left\" or \"Center\" // our page instance const page: IClientsidePage; // get the current value const value = page.headerTextAlignment; // set the value page.headerTextAlignment = \"Center\"; await page.save(); showTopicHeader \u00b6 Sets if the topic header is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showTopicHeader; // show the header page.showTopicHeader = true; await page.save(); // hide the header page.showTopicHeader = false; await page.save(); showPublishDate \u00b6 Sets if the publish date is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showPublishDate; // show the date page.showPublishDate = true; await page.save(); // hide the date page.showPublishDate = false; await page.save(); Get / Set author details \u00b6 Added in 2.0.4 // our page instance const page: IClientsidePage; // get the author details (string | null) const value = page.authorByLine; // set the author by user id const user = await web.currentUser.select(\"Id\", \"LoginName\")(); const userId = user.Id; const userLogin = user.LoginName; await page.setAuthorById(userId); await page.save(); await page.setAuthorByLoginName(userLogin); await page.save(); you must still save the page after setting the author to persist your changes as shown in the example. load \u00b6 Loads the page from the server. This will overwrite any local unsaved changes. // our page instance const page: IClientsidePage; await page.load(); save \u00b6 Saves any changes to the page, optionally keeping them in draft state. // our page instance const page: IClientsidePage; // changes are published await page.save(); // changes remain in draft await page.save(false); discardPageCheckout \u00b6 Discards any current checkout of the page by the current user. // our page instance const page: IClientsidePage; await page.discardPageCheckout(); promoteToNews \u00b6 Promotes the page as a news article. // our page instance const page: IClientsidePage; await page.promoteToNews(); enableComments & disableComments \u00b6 Used to control the availability of comments on a page. // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments(); findControlById \u00b6 Finds a control within the page by id. import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; const control = page.findControlById(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\"); // you can also type the control const control = page.findControlById<ClientsideText>(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\"); findControl \u00b6 Finds a control within the page using the supplied delegate. Can also be used to iterate through all controls in the page. // our page instance const page: IClientsidePage; // find the first control whose order is 9 const control = page.findControl((c) => c.order === 9); // iterate all the controls and output the id to the console page.findControl((c) => { console.log(c.id); return false; }); like & unlike \u00b6 Updates the page's like value for the current user. // our page instance const page: IClientsidePage; // like this page await page.like(); // unlike this page await page.unlike(); getLikedByInformation \u00b6 Gets the likes information for this page. // our page instance const page: IClientsidePage; const info = await page.getLikedByInformation(); copy \u00b6 Creates a copy of the page, including all controls. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instance const page: IClientsidePage; // creates a published copy of the page const pageCopy = await page.copy(sp.web, \"newpagename\", \"New Page Title\"); // creates a draft (unpublished) copy of the page const pageCopy2 = await page.copy(sp.web, \"newpagename\", \"New Page Title\", false); // edits to pageCopy2 ... // publish the page pageCopy2.save(); copyTo \u00b6 Copies the contents of a page to another existing page instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instances, loaded in any of the ways shown above const source: IClientsidePage; const target: IClientsidePage; const target2: IClientsidePage; // creates a published copy of the page await source.copyTo(target); // creates a draft (unpublished) copy of the page await source.copyTo(target2, false); // edits to target2... // publish the page target2.save(); setBannerImage \u00b6 Sets the banner image url and optionally additional properties. Allows you to set additional properties if needed, if you do not need to set the additional properties they are equivalent. Banner images need to exist within the same site collection as the page where you want to use them. // our page instance const page: IClientsidePage; page.setBannerImage(\"/server/relative/path/to/image.png\"); // save the changes await page.save(); // set additional props page.setBannerImage(\"/server/relative/path/to/image.png\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save(); This sample shows the full process of adding a page, image file, and setting the banner image in nodejs. The same code would work in a browser with an update on how you get the file - likely from a file input or similar. import { SPFetchClient } from \"@pnp/nodejs\"; import { join } from \"path\"; import { readFileSync } from \"fs\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/clientside-pages\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{Site Url}\", \"{Client Id}\", \"{Client Secret}\"); }, }, }); // add the banner image const dirname = join(\"C:/path/to/file\", \"img-file.jpg\"); const file: Uint8Array = new Uint8Array(readFileSync(dirname)); const far = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents\").files.add(\"banner.jpg\", file, true); // add the page const page = await sp.web.addClientsidePage(\"MyPage\", \"Page Title\"); // set the banner image page.setBannerImage(far.data.ServerRelativeUrl); // publish the page await page.save(); setBannerImageFromExternalUrl \u00b6 Added in 2.0.12 Allows you to set the banner image from a source outside the current site collection. The image file will be copied to the SiteAssets library and referenced from there. // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\"); // save the changes await page.save(); You can optionally supply additional props for the banner image, these match the properties when calling setBannerImage // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save();","title":"@pnp/sp/clientside-pages"},{"location":"v2/sp/clientside-pages/#pnpspclientside-pages","text":"The 'clientside-pages' module allows you to create, edit, and delete modern SharePoint pages. There are methods to update the page settings and add/remove client-side web parts. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/clientside-pages\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/clientside-pages\"; Preset: All import { sp, ClientsidePageFromFile, ClientsideText, ClientsideWebpartPropertyTypes, CreateClientsidePage, ClientsideWebpart, IClientsidePage } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/clientside-pages"},{"location":"v2/sp/clientside-pages/#create-a-new-page","text":"You can create a new client-side page in several ways, all are equivalent.","title":"Create a new Page"},{"location":"v2/sp/clientside-pages/#create-using-iwebaddclientsidepage","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { PromotedState } from \"@pnp/sp/clientside-pages\"; // Create a page providing a file name const page = await sp.web.addClientsidePage(\"mypage1\"); // ... other operations on the page as outlined below // the page is initially not published, you must publish it so it appears for others users await page.save(); // include title and page layout const page2 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // include title, page layout, and specifying the publishing status (Added in 2.0.4) const page3 = await sp.web.addClientsidePage(\"mypage\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page3.save();","title":"Create using IWeb.addClientsidePage"},{"location":"v2/sp/clientside-pages/#create-using-createclientsidepage-method","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import { CreateClientsidePage, PromotedState } from \"@pnp/sp/clientside-pages\"; const page1 = await CreateClientsidePage(sp.web, \"mypage2\", \"My Page Title\"); // you must publish the new page await page1.save(true); // specify the page layout type parameter const page2 = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\"); // you must publish the new page await page2.save(); // specify the page layout type parameter while also specifying the publishing status (Added in 2.0.4) const page2half = await CreateClientsidePage(sp.web, \"mypage3\", \"My Page Title\", \"Article\", PromotedState.PromoteOnPublish); // you must publish the new page, after which the page will immediately be promoted to a news article await page2half.save(); // use the web factory to create a page in a specific web const page3 = await CreateClientsidePage(Web(\"https://{absolute web url}\"), \"mypage4\", \"My Page Title\"); // you must publish the new page await page3.save();","title":"Create using CreateClientsidePage method"},{"location":"v2/sp/clientside-pages/#load-pages","text":"There are a few ways to load pages, each of which results in an IClientsidePage instance being returned.","title":"Load Pages"},{"location":"v2/sp/clientside-pages/#load-using-iwebloadclientsidepage","text":"This method takes a server relative path to the page to load. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // use from the sp.web fluent chain const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); // use the web factory to target a specific web const page2 = await Web(\"https://{absolute web url}\").loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\");","title":"Load using IWeb.loadClientsidePage"},{"location":"v2/sp/clientside-pages/#load-using-clientsidepagefromfile","text":"This method takes an IFile instance and loads an IClientsidePage instance. import { sp } from \"@pnp/sp\"; import { ClientsidePageFromFile } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const page = await ClientsidePageFromFile(sp.web.getFileByServerRelativePath(\"/sites/dev/sitepages/mypage3.aspx\"));","title":"Load using ClientsidePageFromFile"},{"location":"v2/sp/clientside-pages/#edit-sections-and-columns","text":"Client-side pages are made up of sections, columns, and controls. Sections contain columns which contain controls. There are methods to operate on these within the page, in addition to the standard array methods available in JavaScript. These samples use a variable page that is understood to be an IClientsidePage instance which is either created or loaded as outlined in previous sections. // our page instance const page: IClientsidePage; // add two columns with factor 6 - this is a two column layout as the total factor in a section should add up to 12 const section1 = page.addSection(); section1.addColumn(6); section1.addColumn(6); // create a three column layout in a new section const section2 = page.addSection(); section2.addColumn(4); section2.addColumn(4); section2.addColumn(4); // publish our changes await page.save();","title":"Edit Sections and Columns"},{"location":"v2/sp/clientside-pages/#manipulate-sections-and-columns","text":"// our page instance const page: IClientsidePage; // drop all the columns in this section // this will also DELETE all controls contained in the columns page.sections[1].columns.length = 0; // create a new column layout page.sections[1].addColumn(4); page.sections[1].addColumn(8); // publish our changes await page.save();","title":"Manipulate Sections and Columns"},{"location":"v2/sp/clientside-pages/#vertical-section","text":"The vertical section, if on the page, is stored within the sections array. However, you access it slightly differently to make things easier. // our page instance const page: IClientsidePage; // add or get a vertical section (handles case where section already exists) const vertSection = page.addVerticalSection(); // **************************************************************** // if you know or want to test if a vertical section is present: if (page.hasVerticalSection) { // access the vertical section (this method will NOT create the section if it does not exist) page.verticalSection.addControl(new ClientsideText(\"hello\")); } else { const vertSection = page.addVerticalSection(); vertSection.addControl(new ClientsideText(\"hello\")); }","title":"Vertical Section"},{"location":"v2/sp/clientside-pages/#reorder-sections","text":"// our page instance const page: IClientsidePage; // swap the order of two sections // this will preserve the controls within the columns page.sections = [page.sections[1], page.sections[0]]; // publish our changes await page.save();","title":"Reorder Sections"},{"location":"v2/sp/clientside-pages/#reorder-columns","text":"The sections and columns are arrays, so normal array operations work as expected // our page instance const page: IClientsidePage; // swap the order of two columns // this will preserve the controls within the columns page.sections[1].columns = [page.sections[1].columns[1], page.sections[1].columns[0]]; // publish our changes await page.save();","title":"Reorder Columns"},{"location":"v2/sp/clientside-pages/#clientside-controls","text":"Once you have your sections and columns defined you will want to add/edit controls within those columns.","title":"Clientside Controls"},{"location":"v2/sp/clientside-pages/#add-text-content","text":"import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; page.addSection().addControl(new ClientsideText(\"@pnp/sp is a great library!\")); await page.save();","title":"Add Text Content"},{"location":"v2/sp/clientside-pages/#add-controls","text":"Adding controls involves loading the available client-side part definitions from the server or creating a text part. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // this will be a ClientsidePageComponent array // this can be cached on the client in production scenarios const partDefs = await sp.web.getClientsideWebParts(); // find the definition we want, here by id const partDef = partDefs.filter(c => c.Id === \"490d7c76-1824-45b2-9de3-676421c997fa\"); // optionally ensure you found the def if (partDef.length < 1) { // we didn't find it so we throw an error throw new Error(\"Could not find the web part\"); } // create a ClientWebPart instance from the definition const part = ClientsideWebpart.fromComponentDef(partDef[0]); // set the properties on the web part. Here for the embed web part we only have to supply an embedCode - in this case a YouTube video. // the structure of the properties varies for each web part and each version of a web part, so you will need to ensure you are setting // the properties correctly part.setProperties<{ embedCode: string }>({ embedCode: \"https://www.youtube.com/watch?v=IWQFZ7Lx-rg\", }); // we add that part to a new section page.addSection().addControl(part); await page.save();","title":"Add Controls"},{"location":"v2/sp/clientside-pages/#handle-different-webparts-settings","text":"There are many ways that client side web parts are implemented and we can't provide handling within the library for all possibilities. This example shows how to handle a property set within the serverProcessedContent, in this case a List part's display title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { ClientsideWebpart } from \"@pnp/sp/clientside-pages\"; // we create a class to wrap our functionality in a reusable way class ListWebpart extends ClientsideWebpart { constructor(control: ClientsideWebpart) { super((<any>control).json); } // add property getter/setter for what we need, in this case \"listTitle\" within searchablePlainTexts public get DisplayTitle(): string { return this.json.webPartData?.serverProcessedContent?.searchablePlainTexts?.listTitle || \"\"; } public set DisplayTitle(value: string) { this.json.webPartData.serverProcessedContent.searchablePlainTexts.listTitle = value; } } // now we load our page const page = await sp.web.loadClientsidePage(\"/sites/dev/SitePages/List-Web-Part.aspx\"); // get our part and pass it to the constructor of our wrapper class const part = new ListWebpart(page.sections[0].columns[0].getControl(0)); part.DisplayTitle = \"My New Title!\"; await page.save(); Unfortunately each webpart can be authored differently, so there isn't a way to know how the setting for a given webpart are stored without loading it and examining the properties.","title":"Handle Different Webpart's Settings"},{"location":"v2/sp/clientside-pages/#page-operations","text":"There are other operation you can perform on a page in addition to manipulating the content.","title":"Page Operations"},{"location":"v2/sp/clientside-pages/#pagelayout","text":"You can get and set the page layout. Changing the layout after creating the page may have side effects and should be done cautiously. // our page instance const page: IClientsidePage; // get the current value const value = page.pageLayout; // set the value page.pageLayout = \"Article\"; await page.save();","title":"pageLayout"},{"location":"v2/sp/clientside-pages/#bannerimageurl","text":"// our page instance const page: IClientsidePage; // get the current value const value = page.bannerImageUrl; // set the value page.bannerImageUrl = \"/server/relative/path/to/image.png\"; await page.save(); Banner images need to exist within the same site collection as the page where you want to use them.","title":"bannerImageUrl"},{"location":"v2/sp/clientside-pages/#thumbnailurl","text":"Allows you to set the thumbnail used for the page independently of the banner. If you set the bannerImageUrl property and not thumbnailUrl the thumbnail will be reset to match the banner, mimicking the UI functionality. // our page instance const page: IClientsidePage; // get the current value const value = page.thumbnailUrl; // set the value page.thumbnailUrl = \"/server/relative/path/to/image.png\"; await page.save();","title":"thumbnailUrl"},{"location":"v2/sp/clientside-pages/#topicheader","text":"// our page instance const page: IClientsidePage; // get the current value const value = page.topicHeader; // set the value page.topicHeader = \"My cool header!\"; await page.save(); // clear the topic header and hide it page.topicHeader = \"\"; await page.save();","title":"topicHeader"},{"location":"v2/sp/clientside-pages/#title","text":"// our page instance const page: IClientsidePage; // get the current value const value = page.title; // set the value page.title = \"My page title\"; await page.save();","title":"title"},{"location":"v2/sp/clientside-pages/#description","text":"Descriptions are limited to 255 chars // our page instance const page: IClientsidePage; // get the current value const value = page.description; // set the value page.description = \"A description\"; await page.save();","title":"description"},{"location":"v2/sp/clientside-pages/#layouttype","text":"Sets the layout type of the page. The valid values are: \"FullWidthImage\", \"NoImage\", \"ColorBlock\", \"CutInShape\" // our page instance const page: IClientsidePage; // get the current value const value = page.layoutType; // set the value page.layoutType = \"ColorBlock\"; await page.save();","title":"layoutType"},{"location":"v2/sp/clientside-pages/#headertextalignment","text":"Sets the header text alignment to one of \"Left\" or \"Center\" // our page instance const page: IClientsidePage; // get the current value const value = page.headerTextAlignment; // set the value page.headerTextAlignment = \"Center\"; await page.save();","title":"headerTextAlignment"},{"location":"v2/sp/clientside-pages/#showtopicheader","text":"Sets if the topic header is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showTopicHeader; // show the header page.showTopicHeader = true; await page.save(); // hide the header page.showTopicHeader = false; await page.save();","title":"showTopicHeader"},{"location":"v2/sp/clientside-pages/#showpublishdate","text":"Sets if the publish date is displayed on a page. // our page instance const page: IClientsidePage; // get the current value const value = page.showPublishDate; // show the date page.showPublishDate = true; await page.save(); // hide the date page.showPublishDate = false; await page.save();","title":"showPublishDate"},{"location":"v2/sp/clientside-pages/#get-set-author-details","text":"Added in 2.0.4 // our page instance const page: IClientsidePage; // get the author details (string | null) const value = page.authorByLine; // set the author by user id const user = await web.currentUser.select(\"Id\", \"LoginName\")(); const userId = user.Id; const userLogin = user.LoginName; await page.setAuthorById(userId); await page.save(); await page.setAuthorByLoginName(userLogin); await page.save(); you must still save the page after setting the author to persist your changes as shown in the example.","title":"Get / Set author details"},{"location":"v2/sp/clientside-pages/#load","text":"Loads the page from the server. This will overwrite any local unsaved changes. // our page instance const page: IClientsidePage; await page.load();","title":"load"},{"location":"v2/sp/clientside-pages/#save","text":"Saves any changes to the page, optionally keeping them in draft state. // our page instance const page: IClientsidePage; // changes are published await page.save(); // changes remain in draft await page.save(false);","title":"save"},{"location":"v2/sp/clientside-pages/#discardpagecheckout","text":"Discards any current checkout of the page by the current user. // our page instance const page: IClientsidePage; await page.discardPageCheckout();","title":"discardPageCheckout"},{"location":"v2/sp/clientside-pages/#promotetonews","text":"Promotes the page as a news article. // our page instance const page: IClientsidePage; await page.promoteToNews();","title":"promoteToNews"},{"location":"v2/sp/clientside-pages/#enablecomments-disablecomments","text":"Used to control the availability of comments on a page. // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments();","title":"enableComments &amp; disableComments"},{"location":"v2/sp/clientside-pages/#findcontrolbyid","text":"Finds a control within the page by id. import { ClientsideText } from \"@pnp/sp/clientside-pages\"; // our page instance const page: IClientsidePage; const control = page.findControlById(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\"); // you can also type the control const control = page.findControlById<ClientsideText>(\"06d4cdf6-bce6-4200-8b93-667a1b0a6c9d\");","title":"findControlById"},{"location":"v2/sp/clientside-pages/#findcontrol","text":"Finds a control within the page using the supplied delegate. Can also be used to iterate through all controls in the page. // our page instance const page: IClientsidePage; // find the first control whose order is 9 const control = page.findControl((c) => c.order === 9); // iterate all the controls and output the id to the console page.findControl((c) => { console.log(c.id); return false; });","title":"findControl"},{"location":"v2/sp/clientside-pages/#like-unlike","text":"Updates the page's like value for the current user. // our page instance const page: IClientsidePage; // like this page await page.like(); // unlike this page await page.unlike();","title":"like &amp; unlike"},{"location":"v2/sp/clientside-pages/#getlikedbyinformation","text":"Gets the likes information for this page. // our page instance const page: IClientsidePage; const info = await page.getLikedByInformation();","title":"getLikedByInformation"},{"location":"v2/sp/clientside-pages/#copy","text":"Creates a copy of the page, including all controls. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instance const page: IClientsidePage; // creates a published copy of the page const pageCopy = await page.copy(sp.web, \"newpagename\", \"New Page Title\"); // creates a draft (unpublished) copy of the page const pageCopy2 = await page.copy(sp.web, \"newpagename\", \"New Page Title\", false); // edits to pageCopy2 ... // publish the page pageCopy2.save();","title":"copy"},{"location":"v2/sp/clientside-pages/#copyto","text":"Copies the contents of a page to another existing page instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; // our page instances, loaded in any of the ways shown above const source: IClientsidePage; const target: IClientsidePage; const target2: IClientsidePage; // creates a published copy of the page await source.copyTo(target); // creates a draft (unpublished) copy of the page await source.copyTo(target2, false); // edits to target2... // publish the page target2.save();","title":"copyTo"},{"location":"v2/sp/clientside-pages/#setbannerimage","text":"Sets the banner image url and optionally additional properties. Allows you to set additional properties if needed, if you do not need to set the additional properties they are equivalent. Banner images need to exist within the same site collection as the page where you want to use them. // our page instance const page: IClientsidePage; page.setBannerImage(\"/server/relative/path/to/image.png\"); // save the changes await page.save(); // set additional props page.setBannerImage(\"/server/relative/path/to/image.png\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save(); This sample shows the full process of adding a page, image file, and setting the banner image in nodejs. The same code would work in a browser with an update on how you get the file - likely from a file input or similar. import { SPFetchClient } from \"@pnp/nodejs\"; import { join } from \"path\"; import { readFileSync } from \"fs\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/clientside-pages\"; // configure your node options sp.setup({ sp: { fetchClientFactory: () => { return new SPFetchClient(\"{Site Url}\", \"{Client Id}\", \"{Client Secret}\"); }, }, }); // add the banner image const dirname = join(\"C:/path/to/file\", \"img-file.jpg\"); const file: Uint8Array = new Uint8Array(readFileSync(dirname)); const far = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents\").files.add(\"banner.jpg\", file, true); // add the page const page = await sp.web.addClientsidePage(\"MyPage\", \"Page Title\"); // set the banner image page.setBannerImage(far.data.ServerRelativeUrl); // publish the page await page.save();","title":"setBannerImage"},{"location":"v2/sp/clientside-pages/#setbannerimagefromexternalurl","text":"Added in 2.0.12 Allows you to set the banner image from a source outside the current site collection. The image file will be copied to the SiteAssets library and referenced from there. // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\"); // save the changes await page.save(); You can optionally supply additional props for the banner image, these match the properties when calling setBannerImage // our page instance const page: IClientsidePage; // you must await this method await page.setBannerImageFromExternalUrl(\"https://absolute.url/to/my/image.jpg\", { altText: \"Image description\", imageSourceType: 2, translateX: 30, translateY: 1234, }); // save the changes await page.save();","title":"setBannerImageFromExternalUrl"},{"location":"v2/sp/column-defaults/","text":"@pnp/sp/column-defaults \u00b6 The column defaults sub-module allows you to manage the default column values on a library or library folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/column-defaults\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/column-defaults\"; Preset: All import { sp, IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/presents/all\"; Get Folder Defaults \u00b6 You can get the default values for a specific folder as shown below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" } ] */ Set Folder Defaults \u00b6 When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").setDefaultColumnValues([{ name: \"TextField\", value: \"Something\", }, { name: \"NumberField\", value: 14, }]); Get Library Defaults \u00b6 You can also get all of the defaults for the entire library. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.lists.getByTitle(\"DefaultColumnValues\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{a different default value}\" } ] */ Set Library Defaults \u00b6 You can also set the defaults for an entire library at once (root and all sub-folders). This may be helpful in provisioning a library or other scenarios. When setting the defaults for the entire library you must also include the path value with is the server relative path to the folder. When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([{ name: \"TextField\", path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }]); Clear Folder Defaults \u00b6 If you want to clear all of the folder defaults you can use the clear method: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").clearDefaultColumnValues(); Clear Library Defaults \u00b6 If you need to clear all of the default column values in a library you can pass an empty array to the list's setDefaultColumnValues method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([]); Pattern for setting defaults on various column types \u00b6 The following is an example of the structure for setting the default column value when using the setDefaultColumnValues that covers the various field types. [{ // Text/Boolean/CurrencyDateTime/Choice/User name: \"TextField\": path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }, { //Number name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: 42, }, { //Date name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"1900-01-01T00:00:00Z\", }, { //Date - Today name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"[today]\", }, { //MultiChoice name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues\", value: [\"Item 1\", \"Item 2\"], }, { //MultiChoice - single value name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues/folder2\", value: [\"Item 1\"], }, { //Taxonomy - single value name: \"TaxonomyField\", path: \"/sites/dev/DefaultColumnValues\", value: { wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" } }, { //Taxonomy - multiple value name: \"TaxonomyMultiField\", path: \"/sites/dev/DefaultColumnValues\", value: [{ wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" },{ wssId:\"-1\", termName: \"TaxValueName2\", termId: \"95d4c307-dde5-49d8-b861-392e145d94d3\" },] }]); Taxonomy Full Example \u00b6 This example shows fully how to get the taxonomy values and set them as a default column value using PnPjs. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/column-defaults\"; import \"@pnp/sp/taxonomy\"; // get the term's info we want to use as the default const term = await sp.termStore.sets.getById(\"ea6fc521-d293-4f3d-9e84-f3a5bc0936ce\").getTermById(\"775c9cf6-c3cd-4db9-8cfa-fc0aeefad93a\")(); // get the default term label const defLabel = term.labels.find(v => v.isDefault); // set the default value using -1, the term id, and the term's default label name await sp.web.lists.getByTitle(\"MetaDataDocLib\").rootFolder.setDefaultColumnValues([{ name: \"MetaDataColumnInternalName\", value: { wssId: \"-1\", termId: term.id, termName: defLabel.name, } }]) // check that the defaults have updated const newDefaults = await sp.web.lists.getByTitle(\"MetaDataDocLib\").getDefaultColumnValues();","title":"@pnp/sp/column-defaults"},{"location":"v2/sp/column-defaults/#pnpspcolumn-defaults","text":"The column defaults sub-module allows you to manage the default column values on a library or library folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/column-defaults\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/column-defaults\"; Preset: All import { sp, IFieldDefault, IFieldDefaultProps, AllowedDefaultColumnValues } from \"@pnp/sp/presents/all\";","title":"@pnp/sp/column-defaults"},{"location":"v2/sp/column-defaults/#get-folder-defaults","text":"You can get the default values for a specific folder as shown below: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{the default value}\" } ] */","title":"Get Folder Defaults"},{"location":"v2/sp/column-defaults/#set-folder-defaults","text":"When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").setDefaultColumnValues([{ name: \"TextField\", value: \"Something\", }, { name: \"NumberField\", value: 14, }]);","title":"Set Folder Defaults"},{"location":"v2/sp/column-defaults/#get-library-defaults","text":"You can also get all of the defaults for the entire library. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; const defaults = await sp.web.lists.getByTitle(\"DefaultColumnValues\").getDefaultColumnValues(); /* The resulting structure will have the form: [ { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues\", \"value\": \"{the default value}\" }, { \"name\": \"{field internal name}\", \"path\": \"/sites/dev/DefaultColumnValues/fld_GHk5\", \"value\": \"{a different default value}\" } ] */","title":"Get Library Defaults"},{"location":"v2/sp/column-defaults/#set-library-defaults","text":"You can also set the defaults for an entire library at once (root and all sub-folders). This may be helpful in provisioning a library or other scenarios. When setting the defaults for the entire library you must also include the path value with is the server relative path to the folder. When setting the defaults for a folder you need to include the field's internal name and the value. For more examples of other field types see the section Pattern for setting defaults on various column types Note: Be very careful when setting the path as the site collection url is case sensitive import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([{ name: \"TextField\", path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }]);","title":"Set Library Defaults"},{"location":"v2/sp/column-defaults/#clear-folder-defaults","text":"If you want to clear all of the folder defaults you can use the clear method: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.getFolderByServerRelativePath(\"/sites/dev/DefaultColumnValues/fld_GHk5\").clearDefaultColumnValues();","title":"Clear Folder Defaults"},{"location":"v2/sp/column-defaults/#clear-library-defaults","text":"If you need to clear all of the default column values in a library you can pass an empty array to the list's setDefaultColumnValues method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/column-defaults\"; await sp.web.lists.getByTitle(\"DefaultColumnValues\").setDefaultColumnValues([]);","title":"Clear Library Defaults"},{"location":"v2/sp/column-defaults/#pattern-for-setting-defaults-on-various-column-types","text":"The following is an example of the structure for setting the default column value when using the setDefaultColumnValues that covers the various field types. [{ // Text/Boolean/CurrencyDateTime/Choice/User name: \"TextField\": path: \"/sites/dev/DefaultColumnValues\", value: \"#PnPjs Rocks!\", }, { //Number name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: 42, }, { //Date name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"1900-01-01T00:00:00Z\", }, { //Date - Today name: \"NumberField\", path: \"/sites/dev/DefaultColumnValues\", value: \"[today]\", }, { //MultiChoice name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues\", value: [\"Item 1\", \"Item 2\"], }, { //MultiChoice - single value name: \"MultiChoiceField\", path: \"/sites/dev/DefaultColumnValues/folder2\", value: [\"Item 1\"], }, { //Taxonomy - single value name: \"TaxonomyField\", path: \"/sites/dev/DefaultColumnValues\", value: { wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" } }, { //Taxonomy - multiple value name: \"TaxonomyMultiField\", path: \"/sites/dev/DefaultColumnValues\", value: [{ wssId:\"-1\", termName: \"TaxValueName\", termId: \"924d2077-d5e3-4507-9f36-4a3655e74274\" },{ wssId:\"-1\", termName: \"TaxValueName2\", termId: \"95d4c307-dde5-49d8-b861-392e145d94d3\" },] }]);","title":"Pattern for setting defaults on various column types"},{"location":"v2/sp/column-defaults/#taxonomy-full-example","text":"This example shows fully how to get the taxonomy values and set them as a default column value using PnPjs. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/column-defaults\"; import \"@pnp/sp/taxonomy\"; // get the term's info we want to use as the default const term = await sp.termStore.sets.getById(\"ea6fc521-d293-4f3d-9e84-f3a5bc0936ce\").getTermById(\"775c9cf6-c3cd-4db9-8cfa-fc0aeefad93a\")(); // get the default term label const defLabel = term.labels.find(v => v.isDefault); // set the default value using -1, the term id, and the term's default label name await sp.web.lists.getByTitle(\"MetaDataDocLib\").rootFolder.setDefaultColumnValues([{ name: \"MetaDataColumnInternalName\", value: { wssId: \"-1\", termId: term.id, termName: defLabel.name, } }]) // check that the defaults have updated const newDefaults = await sp.web.lists.getByTitle(\"MetaDataDocLib\").getDefaultColumnValues();","title":"Taxonomy Full Example"},{"location":"v2/sp/comments-likes/","text":"@pnp/sp/comments and likes \u00b6 Comments can be accessed through either IItem or IClientsidePage instances, though in slightly different ways. For information on loading clientside pages or items please refer to those articles. These APIs are currently in BETA and are subject to change or may not work on all tenants. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; ClientsidePage Comments \u00b6 The IClientsidePage interface has three methods to provide easier access to the comments for a page, without requiring that you load the item separately. Add Comments \u00b6 You can add a comment using the addComment method as shown import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\"); Get Page Comments \u00b6 import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); const comments = await page.getComments(); enableComments & disableComments \u00b6 Used to control the availability of comments on a page // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments(); GetById \u00b6 import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\"); const commentData = await page.getCommentById(parseInt(comment.id, 10)); Clear Comments \u00b6 Item Comments \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/comments/item\"; const item = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/SitePages/Test_8q5L.aspx\").getItem(); // as an example, or any of the below options await item.like(); The below examples use a variable named \"item\" which is taken to represent an IItem instance. Comments \u00b6 Get Item Comments \u00b6 const comments = await item.comments(); You can also get the comments merged with instances of the Comment class to immediately start accessing the properties and methods: import { spODataEntityArray } from \"@pnp/sp/odata\"; import { Comment, ICommentData } from \"@pnp/sp/comments\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" }); //load the top 20 replies and comments for an item including likedBy information const comments = await item.comments.expand(\"replies\", \"likedBy\", \"replies/likedBy\").top(20)(); Add Comment \u00b6 // you can add a comment as a string item.comments.add(\"string comment\"); // or you can add it as an object to include mentions item.comments.add({ text: \"comment from object property\" }); Delete a Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].delete() Like Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].like() Unlike Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); comments[0].unlike() Reply to a Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const comment: Comment & CommentData = await comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" }); Load Replies to a Comment \u00b6 import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const replies = await comments[0].replies(); Like \u00b6 You can like/unlike client-side pages, items, and comments on items. See above for how to like or unlike a comment. Below you can see how to like and unlike an items, as well as get the liked by data. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/item\"; import { ILikeData, ILikedByInformation } from \"@pnp/sp/comments\"; // like an item await item.like(); // unlike an item await item.unlike(); // get the liked by data const likedByData: ILikeData[] = await item.getLikedBy(); // get the liked by information const likedByInfo: ILikedByInformation = await item.getLikedByInformation(); To like/unlike a client-side page and get liked by information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/clientside-page\"; import { ILikedByInformation } from \"@pnp/sp/comments\"; // like a page await page.like(); // unlike a page await page.unlike(); // get the liked by information const likedByInfo: ILikedByInformation = await page.getLikedByInformation();","title":"@pnp/sp/comments and likes"},{"location":"v2/sp/comments-likes/#pnpspcomments-and-likes","text":"Comments can be accessed through either IItem or IClientsidePage instances, though in slightly different ways. For information on loading clientside pages or items please refer to those articles. These APIs are currently in BETA and are subject to change or may not work on all tenants. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/comments and likes"},{"location":"v2/sp/comments-likes/#clientsidepage-comments","text":"The IClientsidePage interface has three methods to provide easier access to the comments for a page, without requiring that you load the item separately.","title":"ClientsidePage Comments"},{"location":"v2/sp/comments-likes/#add-comments","text":"You can add a comment using the addComment method as shown import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\");","title":"Add Comments"},{"location":"v2/sp/comments-likes/#get-page-comments","text":"import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); await page.addComment(\"A test comment\"); const comments = await page.getComments();","title":"Get Page Comments"},{"location":"v2/sp/comments-likes/#enablecomments-disablecomments","text":"Used to control the availability of comments on a page // you need to import the comments sub-module or use the all preset import \"@pnp/sp/comments/clientside-page\"; // our page instance const page: IClientsidePage; // turn on comments await page.enableComments(); // turn off comments await page.disableComments();","title":"enableComments &amp; disableComments"},{"location":"v2/sp/comments-likes/#getbyid","text":"import { CreateClientsidePage } from \"@pnp/sp/clientside-pages\"; import \"@pnp/sp/comments/clientside-page\"; const page = await CreateClientsidePage(sp.web, \"mypage\", \"My Page Title\", \"Article\"); // optionally publish the page first await page.save(); const comment = await page.addComment(\"A test comment\"); const commentData = await page.getCommentById(parseInt(comment.id, 10));","title":"GetById"},{"location":"v2/sp/comments-likes/#clear-comments","text":"","title":"Clear Comments"},{"location":"v2/sp/comments-likes/#item-comments","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; import \"@pnp/sp/items\"; import \"@pnp/sp/comments/item\"; const item = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/SitePages/Test_8q5L.aspx\").getItem(); // as an example, or any of the below options await item.like(); The below examples use a variable named \"item\" which is taken to represent an IItem instance.","title":"Item Comments"},{"location":"v2/sp/comments-likes/#comments","text":"","title":"Comments"},{"location":"v2/sp/comments-likes/#get-item-comments","text":"const comments = await item.comments(); You can also get the comments merged with instances of the Comment class to immediately start accessing the properties and methods: import { spODataEntityArray } from \"@pnp/sp/odata\"; import { Comment, ICommentData } from \"@pnp/sp/comments\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" }); //load the top 20 replies and comments for an item including likedBy information const comments = await item.comments.expand(\"replies\", \"likedBy\", \"replies/likedBy\").top(20)();","title":"Get Item Comments"},{"location":"v2/sp/comments-likes/#add-comment","text":"// you can add a comment as a string item.comments.add(\"string comment\"); // or you can add it as an object to include mentions item.comments.add({ text: \"comment from object property\" });","title":"Add Comment"},{"location":"v2/sp/comments-likes/#delete-a-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].delete()","title":"Delete a Comment"},{"location":"v2/sp/comments-likes/#like-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); // these will be Comment instances in the array comments[0].like()","title":"Like Comment"},{"location":"v2/sp/comments-likes/#unlike-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); comments[0].unlike()","title":"Unlike Comment"},{"location":"v2/sp/comments-likes/#reply-to-a-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const comment: Comment & CommentData = await comments[0].replies.add({ text: \"#PnPjs is pretty ok!\" });","title":"Reply to a Comment"},{"location":"v2/sp/comments-likes/#load-replies-to-a-comment","text":"import { spODataEntityArray, Comment, CommentData } from \"@pnp/sp\"; const comments = await item.comments(spODataEntityArray<Comment, CommentData>(Comment)); const replies = await comments[0].replies();","title":"Load Replies to a Comment"},{"location":"v2/sp/comments-likes/#like","text":"You can like/unlike client-side pages, items, and comments on items. See above for how to like or unlike a comment. Below you can see how to like and unlike an items, as well as get the liked by data. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/item\"; import { ILikeData, ILikedByInformation } from \"@pnp/sp/comments\"; // like an item await item.like(); // unlike an item await item.unlike(); // get the liked by data const likedByData: ILikeData[] = await item.getLikedBy(); // get the liked by information const likedByInfo: ILikedByInformation = await item.getLikedByInformation(); To like/unlike a client-side page and get liked by information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/comments/clientside-page\"; import { ILikedByInformation } from \"@pnp/sp/comments\"; // like a page await page.like(); // unlike a page await page.unlike(); // get the liked by information const likedByInfo: ILikedByInformation = await page.getLikedByInformation();","title":"Like"},{"location":"v2/sp/content-types/","text":"@pnp/sp/content-types \u00b6 Content Types are used to define sets of columns in SharePoint. IContentTypes \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { ContentTypes, IContentTypes } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentTypes, IContentTypes } from \"@pnp/sp/presets/all\"; Add an existing Content Type to a collection \u00b6 The following example shows how to add the built in Picture Content Type to the Documents library. sp.web.lists.getByTitle(\"Documents\").contentTypes.addAvailableContentType(\"0x010102\"); Get a Content Type by Id \u00b6 const d: IContentType = await sp.web.contentTypes.getById(\"0x01\")(); // log content type name to console console.log(d.name); Add a new Content Type \u00b6 To add a new Content Type to a collection, parameters id and name are required. For more information on creating content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\"); It is also possible to provide a description and group parameter. For other settings, we can use the parameter named 'additionalSettings' which is a TypedHash, meaning you can send whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). //Adding a content type with id, name, description, group and setting it to read only mode (using additionalsettings) sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\", \"This is my content type.\", \"_PnP Content Types\", { ReadOnly: true }); IContentType \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ContentType, IContentType } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentType, IContentType } from \"@pnp/sp/presets/all\"; Get the field links \u00b6 Use this method to get a collection containing all the field links (SP.FieldLink) for a Content Type. // get field links from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fieldLinks(); // log collection of fieldlinks to console console.log(d); Get Content Type fields \u00b6 To get a collection with all fields on the Content Type, simply use this method. // get fields from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fields(); // log collection of fields to console console.log(d); Get parent Content Type \u00b6 // get parent Content Type from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").parent(); // log name of parent Content Type to console console.log(d.Name) Get Content Type Workflow associations \u00b6 // get workflow associations from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").workflowAssociations(); // log collection of workflow associations to console console.log(d);","title":"@pnp/sp/content-types"},{"location":"v2/sp/content-types/#pnpspcontent-types","text":"Content Types are used to define sets of columns in SharePoint.","title":"@pnp/sp/content-types"},{"location":"v2/sp/content-types/#icontenttypes","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { ContentTypes, IContentTypes } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentTypes, IContentTypes } from \"@pnp/sp/presets/all\";","title":"IContentTypes"},{"location":"v2/sp/content-types/#add-an-existing-content-type-to-a-collection","text":"The following example shows how to add the built in Picture Content Type to the Documents library. sp.web.lists.getByTitle(\"Documents\").contentTypes.addAvailableContentType(\"0x010102\");","title":"Add an existing Content Type to a collection"},{"location":"v2/sp/content-types/#get-a-content-type-by-id","text":"const d: IContentType = await sp.web.contentTypes.getById(\"0x01\")(); // log content type name to console console.log(d.name);","title":"Get a Content Type by Id"},{"location":"v2/sp/content-types/#add-a-new-content-type","text":"To add a new Content Type to a collection, parameters id and name are required. For more information on creating content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\"); It is also possible to provide a description and group parameter. For other settings, we can use the parameter named 'additionalSettings' which is a TypedHash, meaning you can send whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). //Adding a content type with id, name, description, group and setting it to read only mode (using additionalsettings) sp.web.contentTypes.add(\"0x01008D19F38845B0884EBEBE239FDF359184\", \"My Content Type\", \"This is my content type.\", \"_PnP Content Types\", { ReadOnly: true });","title":"Add a new Content Type"},{"location":"v2/sp/content-types/#icontenttype","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { ContentType, IContentType } from \"@pnp/sp/content-types\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/content-types\"; Preset: All import { sp, ContentType, IContentType } from \"@pnp/sp/presets/all\";","title":"IContentType"},{"location":"v2/sp/content-types/#get-the-field-links","text":"Use this method to get a collection containing all the field links (SP.FieldLink) for a Content Type. // get field links from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fieldLinks(); // log collection of fieldlinks to console console.log(d);","title":"Get the field links"},{"location":"v2/sp/content-types/#get-content-type-fields","text":"To get a collection with all fields on the Content Type, simply use this method. // get fields from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").fields(); // log collection of fields to console console.log(d);","title":"Get Content Type fields"},{"location":"v2/sp/content-types/#get-parent-content-type","text":"// get parent Content Type from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").parent(); // log name of parent Content Type to console console.log(d.Name)","title":"Get parent Content Type"},{"location":"v2/sp/content-types/#get-content-type-workflow-associations","text":"// get workflow associations from built in Content Type Document (Id: \"0x0101\") const d = await sp.web.contentTypes.getById(\"0x0101\").workflowAssociations(); // log collection of workflow associations to console console.log(d);","title":"Get Content Type Workflow associations"},{"location":"v2/sp/custom-irequestclient/","text":"Custom IRequestClient \u00b6 Scenario: You have some special requirements involving auth scenarios or other needs that the library can't directly support. You may need to create a custom IRequestClient implementation to meet those needs as we can't customize the library to handle every case. This article walks you through how to create a custom IRequestClient and register it for use by the library. It is very unlikely this is a step you ever need to take and we encourage you to ask a question in the issues list before going down this path. Create the Client \u00b6 The easiest way to create a new IRequestClient is to subclass the existing SPHttpClient. You can always write a full client from scratch so long as it supports the IRequestClient interface but you need to handle all of the logic for retry, headers, and the request digest. Here we show implementing a client to solve the need discussed in pull request 1264 as an example. // we subclass SPHttpClient class CustomSPHttpClient extends SPHttpClient { // optionally add a constructor, done here as an example constructor(impl?: IHttpClientImpl) { super(impl); } // override the fetchRaw method to ensure we always include the credentials = \"include\" option // you could also override fetch, but fetchRaw ensures no matter what all requests get your custom logic is applied public fetchRaw(url: string, options?: IFetchOptions): Promise<Response> { options.credentials = \"include\"; return super.fetchRaw(url, options); } } The final step is to register the custom client with the library so it is used instead of the default. For that we import the registerCustomRequestClientFactory function and call it before our request generating code. You can reset to the default client factory by passing null to this same function. import { sp, registerCustomRequestClientFactory } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; registerCustomRequestClientFactory(() => new CustomSPHttpClient()); // configure your other options sp.setup({ // ... }); // this request will be executed through your custom client const w = await sp.web(); Unregister Custom Client \u00b6 // unregister custom client factory registerCustomRequestClientFactory(null); IRequestClient Interface \u00b6 If you want to 100% roll your own client you need to implement the below interface, found in common. import { IRequestClient } from \"@pnp/core\"; export interface IRequestClient { fetch(url: string, options?: IFetchOptions): Promise<Response>; fetchRaw(url: string, options?: IFetchOptions): Promise<Response>; get(url: string, options?: IFetchOptions): Promise<Response>; post(url: string, options?: IFetchOptions): Promise<Response>; patch(url: string, options?: IFetchOptions): Promise<Response>; delete(url: string, options?: IFetchOptions): Promise<Response>; } Supportability Note \u00b6 We cannot provide support for your custom client implementation, and creating your own client assumes an intimate knowledge of how SharePoint requests work. Again, this is very likely something you will never need to do - and we recommend exhausting all other options before taking this route.","title":"Custom IRequestClient"},{"location":"v2/sp/custom-irequestclient/#custom-irequestclient","text":"Scenario: You have some special requirements involving auth scenarios or other needs that the library can't directly support. You may need to create a custom IRequestClient implementation to meet those needs as we can't customize the library to handle every case. This article walks you through how to create a custom IRequestClient and register it for use by the library. It is very unlikely this is a step you ever need to take and we encourage you to ask a question in the issues list before going down this path.","title":"Custom IRequestClient"},{"location":"v2/sp/custom-irequestclient/#create-the-client","text":"The easiest way to create a new IRequestClient is to subclass the existing SPHttpClient. You can always write a full client from scratch so long as it supports the IRequestClient interface but you need to handle all of the logic for retry, headers, and the request digest. Here we show implementing a client to solve the need discussed in pull request 1264 as an example. // we subclass SPHttpClient class CustomSPHttpClient extends SPHttpClient { // optionally add a constructor, done here as an example constructor(impl?: IHttpClientImpl) { super(impl); } // override the fetchRaw method to ensure we always include the credentials = \"include\" option // you could also override fetch, but fetchRaw ensures no matter what all requests get your custom logic is applied public fetchRaw(url: string, options?: IFetchOptions): Promise<Response> { options.credentials = \"include\"; return super.fetchRaw(url, options); } } The final step is to register the custom client with the library so it is used instead of the default. For that we import the registerCustomRequestClientFactory function and call it before our request generating code. You can reset to the default client factory by passing null to this same function. import { sp, registerCustomRequestClientFactory } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; registerCustomRequestClientFactory(() => new CustomSPHttpClient()); // configure your other options sp.setup({ // ... }); // this request will be executed through your custom client const w = await sp.web();","title":"Create the Client"},{"location":"v2/sp/custom-irequestclient/#unregister-custom-client","text":"// unregister custom client factory registerCustomRequestClientFactory(null);","title":"Unregister Custom Client"},{"location":"v2/sp/custom-irequestclient/#irequestclient-interface","text":"If you want to 100% roll your own client you need to implement the below interface, found in common. import { IRequestClient } from \"@pnp/core\"; export interface IRequestClient { fetch(url: string, options?: IFetchOptions): Promise<Response>; fetchRaw(url: string, options?: IFetchOptions): Promise<Response>; get(url: string, options?: IFetchOptions): Promise<Response>; post(url: string, options?: IFetchOptions): Promise<Response>; patch(url: string, options?: IFetchOptions): Promise<Response>; delete(url: string, options?: IFetchOptions): Promise<Response>; }","title":"IRequestClient Interface"},{"location":"v2/sp/custom-irequestclient/#supportability-note","text":"We cannot provide support for your custom client implementation, and creating your own client assumes an intimate knowledge of how SharePoint requests work. Again, this is very likely something you will never need to do - and we recommend exhausting all other options before taking this route.","title":"Supportability Note"},{"location":"v2/sp/entity-merging/","text":"@pnp/sp - entity merging \u00b6 Sometimes when we make a query entity's data we would like then to immediately run other commands on the returned entity. To have data returned as its representing type we make use of the spODataEntity and spODataEntityArray parsers. The below approach works for all instance types such as List, Web, Item, or Field as examples. Importing spODataEntity and spODataEntityArray \u00b6 You can import spODataEntity and spODataEntityArray in two ways, depending on your use case. The simplest way is to use the presets/all import as shown in the examples. The downside of this approach is that you can't take advantage of selective imports. If you want to take advantage of selective imports while using either of the entity parsers you can use: import { spODataEntity, spODataEntityArray } from \"@pnp/sp/odata\"; The full selective import for the first sample would be: import { sp } from \"@pnp/sp\"; import { spODataEntity } from \"@pnp/sp/odata\"; import { Item, IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; Request a single entity \u00b6 If we are loading a single entity we use the spODataEntity method. Here we show loading a list item using the Item class and a simple get query. import { sp, spODataEntity, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; } try { // get a list item loaded with data and merged into an instance of Item const item = await sp.web.lists.getByTitle(\"ListTitle\").items.getById(1).usingParser(spODataEntity<IItem, MyProps>(Item))(); // log the item id, all properties specified in MyProps will be type checked Logger.write(`Item id: ${item.Id}`); // now we can call update because we have an instance of the Item type to work with as well await item.update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); } Request a collection \u00b6 The same pattern works when requesting a collection of objects with the exception of using the spODataEntityArray method. import { sp, spODataEntityArray, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; Title: string; } try { // get a list item loaded with data and merged into an instance of Item const items = await sp.web.lists.getByTitle(\"OrderByList\").items.select(\"Id\", \"Title\").usingParser(spODataEntityArray<IItem, MyProps>(Item))(); Logger.write(`Item id: ${items.length}`); Logger.write(`Item id: ${items[0].Title}`); // now we can call update because we have an instance of the Item type to work with as well await items[0].update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); }","title":"@pnp/sp - entity merging"},{"location":"v2/sp/entity-merging/#pnpsp-entity-merging","text":"Sometimes when we make a query entity's data we would like then to immediately run other commands on the returned entity. To have data returned as its representing type we make use of the spODataEntity and spODataEntityArray parsers. The below approach works for all instance types such as List, Web, Item, or Field as examples.","title":"@pnp/sp - entity merging"},{"location":"v2/sp/entity-merging/#importing-spodataentity-and-spodataentityarray","text":"You can import spODataEntity and spODataEntityArray in two ways, depending on your use case. The simplest way is to use the presets/all import as shown in the examples. The downside of this approach is that you can't take advantage of selective imports. If you want to take advantage of selective imports while using either of the entity parsers you can use: import { spODataEntity, spODataEntityArray } from \"@pnp/sp/odata\"; The full selective import for the first sample would be: import { sp } from \"@pnp/sp\"; import { spODataEntity } from \"@pnp/sp/odata\"; import { Item, IItem } from \"@pnp/sp/items\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\";","title":"Importing spODataEntity and spODataEntityArray"},{"location":"v2/sp/entity-merging/#request-a-single-entity","text":"If we are loading a single entity we use the spODataEntity method. Here we show loading a list item using the Item class and a simple get query. import { sp, spODataEntity, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; } try { // get a list item loaded with data and merged into an instance of Item const item = await sp.web.lists.getByTitle(\"ListTitle\").items.getById(1).usingParser(spODataEntity<IItem, MyProps>(Item))(); // log the item id, all properties specified in MyProps will be type checked Logger.write(`Item id: ${item.Id}`); // now we can call update because we have an instance of the Item type to work with as well await item.update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); }","title":"Request a single entity"},{"location":"v2/sp/entity-merging/#request-a-collection","text":"The same pattern works when requesting a collection of objects with the exception of using the spODataEntityArray method. import { sp, spODataEntityArray, Item, IItem } from \"@pnp/sp/presets/all\"; // interface defining the returned properties interface MyProps { Id: number; Title: string; } try { // get a list item loaded with data and merged into an instance of Item const items = await sp.web.lists.getByTitle(\"OrderByList\").items.select(\"Id\", \"Title\").usingParser(spODataEntityArray<IItem, MyProps>(Item))(); Logger.write(`Item id: ${items.length}`); Logger.write(`Item id: ${items[0].Title}`); // now we can call update because we have an instance of the Item type to work with as well await items[0].update({ Title: \"New title.\", }); } catch (e) { Logger.error(e); }","title":"Request a collection"},{"location":"v2/sp/features/","text":"@pnp/sp/features \u00b6 Features module provides method to get the details of activated features. And to activate/deactivate features scoped at Site Collection and Web. IFeatures \u00b6 Represents a collection of features. SharePoint Sites and Webs will have a collection of features Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\"; getById \u00b6 Gets the information about a feature for the given GUID import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; const webFeature = await sp.web.features.getById(webFeatureId)(); const siteFeatureId = \"guid-of-site-scope-feature\"; const siteFeature = await sp.site.features.getById(siteFeatureId)(); add \u00b6 Adds (activates) a feature at the Site or Web level import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.add(webFeatureId); // Activate with force res = await sp.web.features.add(webFeatureId, true); remove \u00b6 Removes and deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.remove(webFeatureId); // Deactivate with force res = await sp.web.features.remove(webFeatureId, true); IFeature \u00b6 Represents an instance of a SharePoint feature. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features, IFeature, Feature } from \"@pnp/sp/presets/all\"; deactivate \u00b6 Deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; sp.web.features.getById(webFeatureId).deactivate() // Deactivate with force sp.web.features.getById(webFeatureId).deactivate(true)","title":"@pnp/sp/features"},{"location":"v2/sp/features/#pnpspfeatures","text":"Features module provides method to get the details of activated features. And to activate/deactivate features scoped at Site Collection and Web.","title":"@pnp/sp/features"},{"location":"v2/sp/features/#ifeatures","text":"Represents a collection of features. SharePoint Sites and Webs will have a collection of features Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features } from \"@pnp/sp/presets/all\";","title":"IFeatures"},{"location":"v2/sp/features/#getbyid","text":"Gets the information about a feature for the given GUID import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; const webFeature = await sp.web.features.getById(webFeatureId)(); const siteFeatureId = \"guid-of-site-scope-feature\"; const siteFeature = await sp.site.features.getById(siteFeatureId)();","title":"getById"},{"location":"v2/sp/features/#add","text":"Adds (activates) a feature at the Site or Web level import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.add(webFeatureId); // Activate with force res = await sp.web.features.add(webFeatureId, true);","title":"add"},{"location":"v2/sp/features/#remove","text":"Removes and deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; let res = await sp.web.features.remove(webFeatureId); // Deactivate with force res = await sp.web.features.remove(webFeatureId, true);","title":"remove"},{"location":"v2/sp/features/#ifeature","text":"Represents an instance of a SharePoint feature. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features/site\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features/web\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/features\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; Preset: All import { sp, IFeatures, Features, IFeature, Feature } from \"@pnp/sp/presets/all\";","title":"IFeature"},{"location":"v2/sp/features/#deactivate","text":"Deactivates the specified feature from the SharePoint Site or Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/features\"; //Example of GUID format a7a2793e-67cd-4dc1-9fd0-43f61581207a const webFeatureId = \"guid-of-web-feature\"; sp.web.features.getById(webFeatureId).deactivate() // Deactivate with force sp.web.features.getById(webFeatureId).deactivate(true)","title":"deactivate"},{"location":"v2/sp/fields/","text":"@pnp/sp/lists \u00b6 Fields in SharePoint can be applied to both webs and lists. When referencing a webs' fields you are effectively looking at site columns which are common fields that can be utilized in any list/library in the site. When referencing a lists' fields you are looking at the fields only associated to that particular list. IFields \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Fields, IFields } from \"@pnp/sp/fields\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; Preset: All import { sp, Fields, IFields } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Fields, IFields } from \"@pnp/sp/presets/core\"; Get Field by Id \u00b6 Gets a field from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/fields\"; // get the field by Id for web const field: IField = sp.web.fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // get the field by Id for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\")(); // we can use this 'field' variable to execute more queries on the field: const r = await field.select(\"Title\")(); // show the response from the server console.log(r.Title); Get Field by Title \u00b6 You can also get a field from the collection by title. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the title 'Author' for web const field: IField = sp.web.fields.getByTitle(\"Author\"); // get the field with the title 'Author' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"Author\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Get Field by Internal Name or Title \u00b6 You can also get a field from the collection regardless of if the string is the fields internal name or title which can be different. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the internal name 'ModifiedBy' for web const field: IField = sp.web.fields.getByInternalNameOrTitle(\"ModifiedBy\"); // get the field with the internal name 'ModifiedBy' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByInternalNameOrTitle(\"ModifiedBy\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Create a Field using an XML schema \u00b6 Create a new field by defining an XML schema that assigns all the properties for the field. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // define the schema for your new field, in this case a date field with a default date of today. const fieldSchema = `<Field ID=\"{03b09ff4-d99d-45ed-841d-3855f77a2483}\" StaticName=\"MyField\" Name=\"MyField\" DisplayName=\"My New Field\" FriendlyDisplayFormat=\"Disabled\" Format=\"DateOnly\" Type=\"DateTime\" Group=\"My Group\"><Default>[today]</Default></Field>`; // create the new field in the web const field: IFieldAddResult = await sp.web.fields.createFieldAsXml(fieldSchema); // create the new field in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(fieldSchema); // we can use this 'field' variable to run more queries on the list: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a New Field \u00b6 Use the add method to create a new field where you define the field type import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // create a new field called 'My Field' in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Site Field to a List \u00b6 Use the createFieldAsXml method to add a site field to a list. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // add the site field 'My Field' to the list 'My List' const r = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(field.data.SchemaXml); // log the field Id to console console.log(r.data.Id); Add a Text Field \u00b6 Use the addText method to create a new text field. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new text field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // create a new text field called 'My Field' in the list 'My List'. const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Calculated Field \u00b6 Use the addCalculated method to create a new calculated field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, FieldTypes } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new calculated field called 'My Field' in web const field = await sp.web.fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // create a new calculated field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Date/Time Field \u00b6 Use the addDateTime method to create a new date/time field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, CalendarType, DateTimeFieldFriendlyFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new date/time field called 'My Field' in web const field = await sp.web.fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // create a new date/time field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Currency Field \u00b6 Use the addCurrency method to create a new currency field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new currency field called 'My Field' in web const field = await sp.web.fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // create a new currency field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Multi-line Text Field \u00b6 Use the addMultilineText method to create a new multi-line text field. For Enhanced Rich Text mode, see the next section. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new multi-line text field called 'My Field' in web const field = await sp.web.fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // create a new multi-line text field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Multi-line Text Field with Enhanced Rich Text \u00b6 The REST endpoint doesn't support setting the RichTextMode field therefore you will need to revert to Xml to create the field. The following is an example that will create a multi-line text field in Enhanced Rich Text mode. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; //Create a new multi-line text field called 'My Field' in web const field = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml( `<Field Type=\"Note\" Name=\"MyField\" DisplayName=\"My Field\" Required=\"FALSE\" RichText=\"TRUE\" RichTextMode=\"FullHtml\" />` ); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Number Field \u00b6 Use the addNumber method to create a new number field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new number field called 'My Field' in web const field = await sp.web.fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // create a new number field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a URL Field \u00b6 Use the addUrl method to create a new url field. import { sp } from \"@pnp/sp\"; import { UrlFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new url field called 'My Field' in web const field = await sp.web.fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // create a new url field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a User Field \u00b6 Use the addUser method to create a new user field. import { sp } from \"@pnp/sp\"; import { FieldUserSelectionMode } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new user field called 'My Field' in web const field = await sp.web.fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // create a new user field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Lookup Field \u00b6 Use the addLookup method to create a new lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const list = await sp.web.lists.getByTitle(\"My Lookup List\")(); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in web. const field = await sp.web.fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); // ** // Adding a lookup that supports multiple values takes two calls: const fieldAddResult = await sp.web.fields.addLookup(\"Test Lookup 124\", \"GUID\", \"Title\"); await fieldAddResult.field.update({ Description: 'New Description' }, \"SP.FieldLookup\"); Add a Choice Field \u00b6 Use the addChoice method to create a new choice field. import { sp } from \"@pnp/sp\"; import { ChoiceFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new choice field called 'My Field' in web const field = await sp.web.fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // create a new choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Multi-Choice Field \u00b6 Use the addMultiChoice method to create a new multi-choice field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new multi-choice field called 'My Field' in web const field = await sp.web.fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // create a new multi-choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Boolean Field \u00b6 Use the addBoolean method to create a new boolean field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new boolean field called 'My Field' in web const field = await sp.web.fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // create a new boolean field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Dependent Lookup Field \u00b6 Use the addDependentLookupField method to create a new dependent lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in web. const field = await sp.web.fields.getByTitle(\"My Field\")(); const fieldDep = await sp.web.fields.addDependentLookupField(\"My Dep Field\", field.Id, \"Description\"); // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\")(); const fieldDep2 = await sp.web.lists.getByTitle(\"My List\").fields.addDependentLookupField(\"My Dep Field\", field2.Id, \"Description\"); // we can use this 'fieldDep' variable to run more queries on the field: const r = await fieldDep.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Add a Location Field \u00b6 Use the addLocation method to create a new location field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new location field called 'My Field' in web const field = await sp.web.fields.addLocation(\"My Field\", { Group: \"My Group\" }); // create a new location field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLocation(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); Delete a Field \u00b6 Use the delete method to delete a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; // delete one or more fields from web, returns boolean const result = await sp.web.fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.fields.getByTitle(\"My Field 2\").delete(); // delete one or more fields from list 'My List', returns boolean const result = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field 2\").delete(); Update a Field \u00b6 Use the update method to update a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // update the field called 'My Field' with a description in web, returns FieldUpdateResult const fieldUpdate = await sp.web.fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // update the field called 'My Field' with a description in list 'My List', returns FieldUpdateResult const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // if you need to update a field with properties for a specific field type you can optionally include the field type as a second param // if you do not include it we will look up the type, but that adds a call to the server const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Look up Field\").update({ RelationshipDeleteBehavior: 1 }, \"SP.FieldLookup\"); Show a Field in the Display Form \u00b6 Use the setShowInDisplayForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in display form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInDisplayForm(true); // show field called 'My Field' in display form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInDisplayForm(true); Show a Field in the Edit Form \u00b6 Use the setShowInEditForm method to add a field to the edit form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in edit form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInEditForm(true); // show field called 'My Field' in edit form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInEditForm(true); Show a Field in the New Form \u00b6 Use the setShowInNewForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in new form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInNewForm(true); // show field called 'My Field' in new form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInNewForm(true);","title":"@pnp/sp/lists"},{"location":"v2/sp/fields/#pnpsplists","text":"Fields in SharePoint can be applied to both webs and lists. When referencing a webs' fields you are effectively looking at site columns which are common fields that can be utilized in any list/library in the site. When referencing a lists' fields you are looking at the fields only associated to that particular list.","title":"@pnp/sp/lists"},{"location":"v2/sp/fields/#ifields","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Fields, IFields } from \"@pnp/sp/fields\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; Preset: All import { sp, Fields, IFields } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Fields, IFields } from \"@pnp/sp/presets/core\";","title":"IFields"},{"location":"v2/sp/fields/#get-field-by-id","text":"Gets a field from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/fields\"; // get the field by Id for web const field: IField = sp.web.fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // get the field by Id for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\")(); // we can use this 'field' variable to execute more queries on the field: const r = await field.select(\"Title\")(); // show the response from the server console.log(r.Title);","title":"Get Field by Id"},{"location":"v2/sp/fields/#get-field-by-title","text":"You can also get a field from the collection by title. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the title 'Author' for web const field: IField = sp.web.fields.getByTitle(\"Author\"); // get the field with the title 'Author' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"Author\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Get Field by Title"},{"location":"v2/sp/fields/#get-field-by-internal-name-or-title","text":"You can also get a field from the collection regardless of if the string is the fields internal name or title which can be different. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\" import \"@pnp/sp/fields\"; // get the field with the internal name 'ModifiedBy' for web const field: IField = sp.web.fields.getByInternalNameOrTitle(\"ModifiedBy\"); // get the field with the internal name 'ModifiedBy' for list 'My List' const field2: IFieldInfo = await sp.web.lists.getByTitle(\"My List\").fields.getByInternalNameOrTitle(\"ModifiedBy\")(); // we can use this 'field' variable to run more queries on the field: const r = await field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Get Field by Internal Name or Title"},{"location":"v2/sp/fields/#create-a-field-using-an-xml-schema","text":"Create a new field by defining an XML schema that assigns all the properties for the field. import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // define the schema for your new field, in this case a date field with a default date of today. const fieldSchema = `<Field ID=\"{03b09ff4-d99d-45ed-841d-3855f77a2483}\" StaticName=\"MyField\" Name=\"MyField\" DisplayName=\"My New Field\" FriendlyDisplayFormat=\"Disabled\" Format=\"DateOnly\" Type=\"DateTime\" Group=\"My Group\"><Default>[today]</Default></Field>`; // create the new field in the web const field: IFieldAddResult = await sp.web.fields.createFieldAsXml(fieldSchema); // create the new field in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(fieldSchema); // we can use this 'field' variable to run more queries on the list: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Create a Field using an XML schema"},{"location":"v2/sp/fields/#add-a-new-field","text":"Use the add method to create a new field where you define the field type import { sp } from \"@pnp/sp\"; import { IField } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // create a new field called 'My Field' in the list 'My List' const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a New Field"},{"location":"v2/sp/fields/#add-a-site-field-to-a-list","text":"Use the createFieldAsXml method to add a site field to a list. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.add(\"My Field\", \"SP.FieldText\", { FieldTypeKind: 3, Group: \"My Group\" }); // add the site field 'My Field' to the list 'My List' const r = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml(field.data.SchemaXml); // log the field Id to console console.log(r.data.Id);","title":"Add a Site Field to a List"},{"location":"v2/sp/fields/#add-a-text-field","text":"Use the addText method to create a new text field. import { sp } from \"@pnp/sp\"; import { IFieldAddResult } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new text field called 'My Field' in web. const field: IFieldAddResult = await sp.web.fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // create a new text field called 'My Field' in the list 'My List'. const field2: IFieldAddResult = await sp.web.lists.getByTitle(\"My List\").fields.addText(\"My Field\", 255, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Text Field"},{"location":"v2/sp/fields/#add-a-calculated-field","text":"Use the addCalculated method to create a new calculated field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, FieldTypes } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new calculated field called 'My Field' in web const field = await sp.web.fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // create a new calculated field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCalculated(\"My Field\", \"=Modified+1\", DateTimeFieldFormatType.DateOnly, FieldTypes.DateTime, { Group: \"MyGroup\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Calculated Field"},{"location":"v2/sp/fields/#add-a-datetime-field","text":"Use the addDateTime method to create a new date/time field. import { sp } from \"@pnp/sp\"; import { DateTimeFieldFormatType, CalendarType, DateTimeFieldFriendlyFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new date/time field called 'My Field' in web const field = await sp.web.fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // create a new date/time field called 'My Field' in the list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addDateTime(\"My Field\", DateTimeFieldFormatType.DateOnly, CalendarType.Gregorian, DateTimeFieldFriendlyFormatType.Disabled, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Date/Time Field"},{"location":"v2/sp/fields/#add-a-currency-field","text":"Use the addCurrency method to create a new currency field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new currency field called 'My Field' in web const field = await sp.web.fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // create a new currency field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addCurrency(\"My Field\", 0, 100, 1033, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Currency Field"},{"location":"v2/sp/fields/#add-a-multi-line-text-field","text":"Use the addMultilineText method to create a new multi-line text field. For Enhanced Rich Text mode, see the next section. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new multi-line text field called 'My Field' in web const field = await sp.web.fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // create a new multi-line text field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultilineText(\"My Field\", 6, true, false, false, true, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Multi-line Text Field"},{"location":"v2/sp/fields/#add-a-multi-line-text-field-with-enhanced-rich-text","text":"The REST endpoint doesn't support setting the RichTextMode field therefore you will need to revert to Xml to create the field. The following is an example that will create a multi-line text field in Enhanced Rich Text mode. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; //Create a new multi-line text field called 'My Field' in web const field = await sp.web.lists.getByTitle(\"My List\").fields.createFieldAsXml( `<Field Type=\"Note\" Name=\"MyField\" DisplayName=\"My Field\" Required=\"FALSE\" RichText=\"TRUE\" RichTextMode=\"FullHtml\" />` ); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Multi-line Text Field with Enhanced Rich Text"},{"location":"v2/sp/fields/#add-a-number-field","text":"Use the addNumber method to create a new number field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new number field called 'My Field' in web const field = await sp.web.fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // create a new number field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addNumber(\"My Field\", 1, 100, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Number Field"},{"location":"v2/sp/fields/#add-a-url-field","text":"Use the addUrl method to create a new url field. import { sp } from \"@pnp/sp\"; import { UrlFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new url field called 'My Field' in web const field = await sp.web.fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // create a new url field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUrl(\"My Field\", UrlFieldFormatType.Hyperlink, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a URL Field"},{"location":"v2/sp/fields/#add-a-user-field","text":"Use the addUser method to create a new user field. import { sp } from \"@pnp/sp\"; import { FieldUserSelectionMode } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new user field called 'My Field' in web const field = await sp.web.fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // create a new user field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addUser(\"My Field\", FieldUserSelectionMode.PeopleOnly, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a User Field"},{"location":"v2/sp/fields/#add-a-lookup-field","text":"Use the addLookup method to create a new lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const list = await sp.web.lists.getByTitle(\"My Lookup List\")(); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in web. const field = await sp.web.fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // create a new lookup field called 'My Field' based on an existing list 'My Lookup List' showing 'Title' field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLookup(\"My Field\", list.Id, \"Title\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id); // ** // Adding a lookup that supports multiple values takes two calls: const fieldAddResult = await sp.web.fields.addLookup(\"Test Lookup 124\", \"GUID\", \"Title\"); await fieldAddResult.field.update({ Description: 'New Description' }, \"SP.FieldLookup\");","title":"Add a Lookup Field"},{"location":"v2/sp/fields/#add-a-choice-field","text":"Use the addChoice method to create a new choice field. import { sp } from \"@pnp/sp\"; import { ChoiceFieldFormatType } from \"@pnp/sp/fields/types\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new choice field called 'My Field' in web const field = await sp.web.fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // create a new choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addChoice(\"My Field\", choices, ChoiceFieldFormatType.Dropdown, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Choice Field"},{"location":"v2/sp/fields/#add-a-multi-choice-field","text":"Use the addMultiChoice method to create a new multi-choice field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; const choices = [`ChoiceA`, `ChoiceB`, `ChoiceC`]; // create a new multi-choice field called 'My Field' in web const field = await sp.web.fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // create a new multi-choice field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addMultiChoice(\"My Field\", choices, false, { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Multi-Choice Field"},{"location":"v2/sp/fields/#add-a-boolean-field","text":"Use the addBoolean method to create a new boolean field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new boolean field called 'My Field' in web const field = await sp.web.fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // create a new boolean field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addBoolean(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Boolean Field"},{"location":"v2/sp/fields/#add-a-dependent-lookup-field","text":"Use the addDependentLookupField method to create a new dependent lookup field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in web. const field = await sp.web.fields.getByTitle(\"My Field\")(); const fieldDep = await sp.web.fields.addDependentLookupField(\"My Dep Field\", field.Id, \"Description\"); // create a new dependent lookup field called 'My Dep Field' showing 'Description' based on an existing 'My Field' lookup field in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\")(); const fieldDep2 = await sp.web.lists.getByTitle(\"My List\").fields.addDependentLookupField(\"My Dep Field\", field2.Id, \"Description\"); // we can use this 'fieldDep' variable to run more queries on the field: const r = await fieldDep.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Dependent Lookup Field"},{"location":"v2/sp/fields/#add-a-location-field","text":"Use the addLocation method to create a new location field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // create a new location field called 'My Field' in web const field = await sp.web.fields.addLocation(\"My Field\", { Group: \"My Group\" }); // create a new location field called 'My Field' in list 'My List' const field2 = await sp.web.lists.getByTitle(\"My List\").fields.addLocation(\"My Field\", { Group: \"My Group\" }); // we can use this 'field' variable to run more queries on the field: const r = await field.field.select(\"Id\")(); // log the field Id to console console.log(r.Id);","title":"Add a Location Field"},{"location":"v2/sp/fields/#delete-a-field","text":"Use the delete method to delete a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/fields\"; // delete one or more fields from web, returns boolean const result = await sp.web.fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.fields.getByTitle(\"My Field 2\").delete(); // delete one or more fields from list 'My List', returns boolean const result = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").delete(); const result2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field 2\").delete();","title":"Delete a Field"},{"location":"v2/sp/fields/#update-a-field","text":"Use the update method to update a field. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // update the field called 'My Field' with a description in web, returns FieldUpdateResult const fieldUpdate = await sp.web.fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // update the field called 'My Field' with a description in list 'My List', returns FieldUpdateResult const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").update({ Description: \"My Description\" }); // if you need to update a field with properties for a specific field type you can optionally include the field type as a second param // if you do not include it we will look up the type, but that adds a call to the server const fieldUpdate2 = await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Look up Field\").update({ RelationshipDeleteBehavior: 1 }, \"SP.FieldLookup\");","title":"Update a Field"},{"location":"v2/sp/fields/#show-a-field-in-the-display-form","text":"Use the setShowInDisplayForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in display form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInDisplayForm(true); // show field called 'My Field' in display form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInDisplayForm(true);","title":"Show a Field in the Display Form"},{"location":"v2/sp/fields/#show-a-field-in-the-edit-form","text":"Use the setShowInEditForm method to add a field to the edit form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in edit form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInEditForm(true); // show field called 'My Field' in edit form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInEditForm(true);","title":"Show a Field in the Edit Form"},{"location":"v2/sp/fields/#show-a-field-in-the-new-form","text":"Use the setShowInNewForm method to add a field to the display form. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/fields\"; // show field called 'My Field' in new form throughout web await sp.web.fields.getByTitle(\"My Field\").setShowInNewForm(true); // show field called 'My Field' in new form for list 'My List' await sp.web.lists.getByTitle(\"My List\").fields.getByTitle(\"My Field\").setShowInNewForm(true);","title":"Show a Field in the New Form"},{"location":"v2/sp/files/","text":"@pnp/sp/files \u00b6 One of the more challenging tasks on the client side is working with SharePoint files, especially if they are large files. We have added some methods to the library to help and their use is outlined below. Reading Files \u00b6 Reading files from the client using REST is covered in the below examples. The important thing to remember is choosing which format you want the file in so you can appropriately process it. You can retrieve a file as Blob, Buffer, JSON, or Text. If you have a special requirement you could also write your own parser . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const blob: Blob = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBlob(); const buffer: ArrayBuffer = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBuffer(); const json: any = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.json\").getJSON(); const text: string = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.txt\").getText(); // all of these also work from a file object no matter how you access it const text2: string = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/documents\").files.getByName(\"file.txt\").getText(); getFileByUrl \u00b6 Added in 2.0.4 This method supports opening files from sharing links or absolute urls. The file must reside in the site from which you are trying to open the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const url = \"{absolute file url OR sharing url}\"; // file is an IFile and supports all the file operations const file = sp.web.getFileByUrl(url); // for example const fileContent = await file.getText(); Adding Files \u00b6 Likewise you can add files using one of two methods, add or addChunked. AddChunked is appropriate for larger files, generally larger than 10 MB but this may differ based on your bandwidth/latency so you can adjust the code to use the chunked method. The below example shows getting the file object from an input and uploading it to SharePoint, choosing the upload method based on file size. declare var require: (s: string) => any; import { ConsoleListener, Logger, LogLevel } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import { auth } from \"./auth\"; let $ = require(\"jquery\"); // <-- used here for illustration let siteUrl = \"https://mytenant.sharepoint.com/sites/dev\"; // comment this out for non-node execution // auth(siteUrl); Logger.subscribe(new ConsoleListener()); Logger.activeLogLevel = LogLevel.Verbose; let web = Web(siteUrl); $(() => { $(\"#testingdiv\").append(\"<button id='thebuttontodoit'>Do It</button>\"); $(\"#thebuttontodoit\").on('click', async (e) => { e.preventDefault(); let input = <HTMLInputElement>document.getElementById(\"thefileinput\"); let file = input.files[0]; // you can adjust this number to control what size files are uploaded in chunks if (file.size <= 10485760) { // small upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(file.name, file, true); Logger.write(\"done\"); } else { // large upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addChunked(file.name, file, data => { Logger.log({ data: data, level: LogLevel.Verbose, message: \"progress\" }); }, true); Logger.write(\"done!\") } }); }); Adding a file using Nodejs Streams \u00b6 If you are working in nodejs you can also add a file using a stream. This example makes a copy of a file using streams. // triggers auto-application of extensions, in this case to add getStream import \"@pnp/nodejs\"; // get a stream of an existing file const sr = await sp.web.getFileByServerRelativePath(\"/sites/dev/shared documents/old.md\").getStream(); // now add the stream as a new file, remember to set the content-length header const fr = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.configure({ headers: { \"content-length\": `${sr.knownLength}`, }, }).add(\"new.md\", sr.body); Setting Associated Item Values \u00b6 You can also update the file properties of a newly uploaded file using code similar to the below snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(\"file.name\", \"file\", true); const item = await file.file.getItem(); await item.update({ Title: \"A Title\", OtherField: \"My Other Value\" }); AddUsingPath \u00b6 If you need to support the percent or pound characters you can use the addUsingPath method of IFiles import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addUsingPath(\"file%#%.name\", \"content\"); Update File Content \u00b6 You can of course use similar methods to update existing files as shown below. This overwrites the existing content in the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.txt\").setContent(\"New string content for the file.\"); await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.mp4\").setContentChunked(file); Check in, Check out, and Approve & Deny \u00b6 The library provides helper methods for checking in, checking out, and approving files. Examples of these methods are shown below. Check In \u00b6 Check in takes two optional arguments, comment and check in type. import { sp } from \"@pnp/sp\"; import { CheckinType } from \"@pnp/sp/files\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // default options with empty comment and CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(); console.log(\"File checked in!\"); // supply a comment (< 1024 chars) and using default check in type CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\"); console.log(\"File checked in!\"); // Supply both comment and check in type await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\", CheckinType.Overwrite); console.log(\"File checked in!\"); Check Out \u00b6 Check out takes no arguments. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkout(); console.log(\"File checked out!\"); Approve and Deny \u00b6 You can also approve or deny files in libraries that use approval. Approve takes a single required argument of comment, the comment is optional for deny. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").approve(\"Approval Comment\"); console.log(\"File approved!\"); // deny with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(); console.log(\"File denied!\"); // deny with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(\"Deny comment\"); console.log(\"File denied!\"); Publish and Unpublish \u00b6 You can both publish and unpublish a file using the library. Both methods take an optional comment argument. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // publish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(); console.log(\"File published!\"); // publish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(\"Publish comment\"); console.log(\"File published!\"); // unpublish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(); console.log(\"File unpublished!\"); // unpublish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(\"Unpublish comment\"); console.log(\"File unpublished!\"); Advanced Upload Options \u00b6 Both the addChunked and setContentChunked methods support options beyond just supplying the file content. progress function \u00b6 A method that is called each time a chunk is uploaded and provides enough information to report progress or update a progress bar easily. The method has the signature: (data: ChunkedFileUploadProgressData) => void The data interface is: export interface ChunkedFileUploadProgressData { stage: \"starting\" | \"continue\" | \"finishing\"; blockNumber: number; totalBlocks: number; chunkSize: number; currentPointer: number; fileSize: number; } chunkSize \u00b6 This property controls the size of the individual chunks and is defaulted to 10485760 bytes (10 MB). You can adjust this based on your bandwidth needs - especially if writing code for mobile uploads or you are seeing frequent timeouts. getItem \u00b6 This method allows you to get the item associated with this file. You can optionally specify one or more select fields. The result will be merged with a new Item instance so you will have both the returned property values and chaining ability in a single object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/security\"; const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(); console.log(item); const item2 = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(\"Title\", \"Modified\"); console.log(item2); // you can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms); You can also supply a generic typing parameter and the resulting type will be a union type of Item and the generic type parameter. This allows you to have proper intellisense and type checking. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/items\"; import \"@pnp/sp/security\"; // also supports typing the objects so your type will be a union type const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem<{ Id: number, Title: string }>(\"Id\", \"Title\"); // You get intellisense and proper typing of the returned object console.log(`Id: ${item.Id} -- ${item.Title}`); // You can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms); move \u00b6 It's possible to move a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveTo(destinationUrl); copy \u00b6 It's possible to copy a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyTo(destinationUrl, false); move by path \u00b6 It's possible to move a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveByPath(destinationUrl, false, true); copy by path \u00b6 It's possible to copy a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyByPath(destinationUrl, false, true); getFileById \u00b6 You can get a file by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import { IFile } from \"@pnp/sp/files\"; const file: IFile = sp.web.getFileById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); delete \u00b6 Deletes a file import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").delete(); delete with params \u00b6 Added in 2.0.9 Deletes a file with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").deleteWithParams({ BypassSharedLock: true, }); exists \u00b6 Added in 2.0.9 Checks to see if a file exists import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; const exists = await sp.web.rootFolder.files.getByName(\"name.txt\").exists();","title":"@pnp/sp/files"},{"location":"v2/sp/files/#pnpspfiles","text":"One of the more challenging tasks on the client side is working with SharePoint files, especially if they are large files. We have added some methods to the library to help and their use is outlined below.","title":"@pnp/sp/files"},{"location":"v2/sp/files/#reading-files","text":"Reading files from the client using REST is covered in the below examples. The important thing to remember is choosing which format you want the file in so you can appropriately process it. You can retrieve a file as Blob, Buffer, JSON, or Text. If you have a special requirement you could also write your own parser . import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const blob: Blob = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBlob(); const buffer: ArrayBuffer = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.avi\").getBuffer(); const json: any = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.json\").getJSON(); const text: string = await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/file.txt\").getText(); // all of these also work from a file object no matter how you access it const text2: string = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/documents\").files.getByName(\"file.txt\").getText();","title":"Reading Files"},{"location":"v2/sp/files/#getfilebyurl","text":"Added in 2.0.4 This method supports opening files from sharing links or absolute urls. The file must reside in the site from which you are trying to open the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files/web\"; const url = \"{absolute file url OR sharing url}\"; // file is an IFile and supports all the file operations const file = sp.web.getFileByUrl(url); // for example const fileContent = await file.getText();","title":"getFileByUrl"},{"location":"v2/sp/files/#adding-files","text":"Likewise you can add files using one of two methods, add or addChunked. AddChunked is appropriate for larger files, generally larger than 10 MB but this may differ based on your bandwidth/latency so you can adjust the code to use the chunked method. The below example shows getting the file object from an input and uploading it to SharePoint, choosing the upload method based on file size. declare var require: (s: string) => any; import { ConsoleListener, Logger, LogLevel } from \"@pnp/logging\"; import { sp } from \"@pnp/sp\"; import { Web } from \"@pnp/sp/webs\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import { auth } from \"./auth\"; let $ = require(\"jquery\"); // <-- used here for illustration let siteUrl = \"https://mytenant.sharepoint.com/sites/dev\"; // comment this out for non-node execution // auth(siteUrl); Logger.subscribe(new ConsoleListener()); Logger.activeLogLevel = LogLevel.Verbose; let web = Web(siteUrl); $(() => { $(\"#testingdiv\").append(\"<button id='thebuttontodoit'>Do It</button>\"); $(\"#thebuttontodoit\").on('click', async (e) => { e.preventDefault(); let input = <HTMLInputElement>document.getElementById(\"thefileinput\"); let file = input.files[0]; // you can adjust this number to control what size files are uploaded in chunks if (file.size <= 10485760) { // small upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(file.name, file, true); Logger.write(\"done\"); } else { // large upload await web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addChunked(file.name, file, data => { Logger.log({ data: data, level: LogLevel.Verbose, message: \"progress\" }); }, true); Logger.write(\"done!\") } }); });","title":"Adding Files"},{"location":"v2/sp/files/#adding-a-file-using-nodejs-streams","text":"If you are working in nodejs you can also add a file using a stream. This example makes a copy of a file using streams. // triggers auto-application of extensions, in this case to add getStream import \"@pnp/nodejs\"; // get a stream of an existing file const sr = await sp.web.getFileByServerRelativePath(\"/sites/dev/shared documents/old.md\").getStream(); // now add the stream as a new file, remember to set the content-length header const fr = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.configure({ headers: { \"content-length\": `${sr.knownLength}`, }, }).add(\"new.md\", sr.body);","title":"Adding a file using Nodejs Streams"},{"location":"v2/sp/files/#setting-associated-item-values","text":"You can also update the file properties of a newly uploaded file using code similar to the below snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.add(\"file.name\", \"file\", true); const item = await file.file.getItem(); await item.update({ Title: \"A Title\", OtherField: \"My Other Value\" });","title":"Setting Associated Item Values"},{"location":"v2/sp/files/#addusingpath","text":"If you need to support the percent or pound characters you can use the addUsingPath method of IFiles import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; const file = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared%20Documents/test/\").files.addUsingPath(\"file%#%.name\", \"content\");","title":"AddUsingPath"},{"location":"v2/sp/files/#update-file-content","text":"You can of course use similar methods to update existing files as shown below. This overwrites the existing content in the file. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.txt\").setContent(\"New string content for the file.\"); await sp.web.getFileByServerRelativeUrl(\"/sites/dev/documents/test.mp4\").setContentChunked(file);","title":"Update File Content"},{"location":"v2/sp/files/#check-in-check-out-and-approve-deny","text":"The library provides helper methods for checking in, checking out, and approving files. Examples of these methods are shown below.","title":"Check in, Check out, and Approve &amp; Deny"},{"location":"v2/sp/files/#check-in","text":"Check in takes two optional arguments, comment and check in type. import { sp } from \"@pnp/sp\"; import { CheckinType } from \"@pnp/sp/files\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // default options with empty comment and CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(); console.log(\"File checked in!\"); // supply a comment (< 1024 chars) and using default check in type CheckinType.Major await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\"); console.log(\"File checked in!\"); // Supply both comment and check in type await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkin(\"A comment\", CheckinType.Overwrite); console.log(\"File checked in!\");","title":"Check In"},{"location":"v2/sp/files/#check-out","text":"Check out takes no arguments. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").checkout(); console.log(\"File checked out!\");","title":"Check Out"},{"location":"v2/sp/files/#approve-and-deny","text":"You can also approve or deny files in libraries that use approval. Approve takes a single required argument of comment, the comment is optional for deny. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").approve(\"Approval Comment\"); console.log(\"File approved!\"); // deny with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(); console.log(\"File denied!\"); // deny with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").deny(\"Deny comment\"); console.log(\"File denied!\");","title":"Approve and Deny"},{"location":"v2/sp/files/#publish-and-unpublish","text":"You can both publish and unpublish a file using the library. Both methods take an optional comment argument. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // publish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(); console.log(\"File published!\"); // publish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").publish(\"Publish comment\"); console.log(\"File published!\"); // unpublish with no comment await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(); console.log(\"File unpublished!\"); // unpublish with a supplied comment. await sp.web.getFileByServerRelativeUrl(\"/sites/dev/shared documents/file.txt\").unpublish(\"Unpublish comment\"); console.log(\"File unpublished!\");","title":"Publish and Unpublish"},{"location":"v2/sp/files/#advanced-upload-options","text":"Both the addChunked and setContentChunked methods support options beyond just supplying the file content.","title":"Advanced Upload Options"},{"location":"v2/sp/files/#progress-function","text":"A method that is called each time a chunk is uploaded and provides enough information to report progress or update a progress bar easily. The method has the signature: (data: ChunkedFileUploadProgressData) => void The data interface is: export interface ChunkedFileUploadProgressData { stage: \"starting\" | \"continue\" | \"finishing\"; blockNumber: number; totalBlocks: number; chunkSize: number; currentPointer: number; fileSize: number; }","title":"progress function"},{"location":"v2/sp/files/#chunksize","text":"This property controls the size of the individual chunks and is defaulted to 10485760 bytes (10 MB). You can adjust this based on your bandwidth needs - especially if writing code for mobile uploads or you are seeing frequent timeouts.","title":"chunkSize"},{"location":"v2/sp/files/#getitem","text":"This method allows you to get the item associated with this file. You can optionally specify one or more select fields. The result will be merged with a new Item instance so you will have both the returned property values and chaining ability in a single object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/security\"; const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(); console.log(item); const item2 = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem(\"Title\", \"Modified\"); console.log(item2); // you can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms); You can also supply a generic typing parameter and the resulting type will be a union type of Item and the generic type parameter. This allows you to have proper intellisense and type checking. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/items\"; import \"@pnp/sp/security\"; // also supports typing the objects so your type will be a union type const item = await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.txt\").getItem<{ Id: number, Title: string }>(\"Id\", \"Title\"); // You get intellisense and proper typing of the returned object console.log(`Id: ${item.Id} -- ${item.Title}`); // You can also chain directly off this item instance const perms = await item.getCurrentUserEffectivePermissions(); console.log(perms);","title":"getItem"},{"location":"v2/sp/files/#move","text":"It's possible to move a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveTo(destinationUrl);","title":"move"},{"location":"v2/sp/files/#copy","text":"It's possible to copy a file to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyTo(destinationUrl, false);","title":"copy"},{"location":"v2/sp/files/#move-by-path","text":"It's possible to move a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").moveByPath(destinationUrl, false, true);","title":"move by path"},{"location":"v2/sp/files/#copy-by-path","text":"It's possible to copy a file to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; // destination is a server-relative url of a new file const destinationUrl = `/sites/dev2/SiteAssets/new-file.docx`; await sp.web.getFileByServerRelativePath(\"/sites/dev/Shared Documents/test.docx\").copyByPath(destinationUrl, false, true);","title":"copy by path"},{"location":"v2/sp/files/#getfilebyid","text":"You can get a file by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; import { IFile } from \"@pnp/sp/files\"; const file: IFile = sp.web.getFileById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\");","title":"getFileById"},{"location":"v2/sp/files/#delete","text":"Deletes a file import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").delete();","title":"delete"},{"location":"v2/sp/files/#delete-with-params","text":"Added in 2.0.9 Deletes a file with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; await sp.web.rootFolder.files.getByName(\"name.txt\").deleteWithParams({ BypassSharedLock: true, });","title":"delete with params"},{"location":"v2/sp/files/#exists","text":"Added in 2.0.9 Checks to see if a file exists import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/files\"; const exists = await sp.web.rootFolder.files.getByName(\"name.txt\").exists();","title":"exists"},{"location":"v2/sp/folders/","text":"@pnp/sp/folders \u00b6 Folders serve as a container for your files and list items. IFolders \u00b6 Represents a collection of folders. SharePoint webs, lists, and list items have a collection of folders under their properties. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\"; Get folders collection for various SharePoint objects \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; // gets web's folders const webFolders = await sp.web.folders(); // gets list's folders const listFolders = await sp.web.lists.getByTitle(\"My List\").rootFolder.folders(); // gets item's folders const itemFolders = await sp.web.lists.getByTitle(\"My List\").items.getById(1).folder.folders(); add \u00b6 Adds a new folder to collection of folders import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // creates a new folder for web with specified url const folderAddResult = await sp.web.folders.add(\"folder url\"); getByName \u00b6 Gets a folder instance from a collection by folder's name import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = await sp.web.folders.getByName(\"folder name\")(); IFolder \u00b6 Represents an instance of a SharePoint folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\"; Get a folder object associated with different SharePoint artifacts (web, list, list item) \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // web's folder const rootFolder = await sp.web.rootFolder(); // list's folder const listRootFolder = await sp.web.lists.getByTitle(\"234\").rootFolder(); // item's folder const itemFolder = await sp.web.lists.getByTitle(\"234\").items.getById(1).folder(); getItem \u00b6 Gets list item associated with a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folderItem = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").getItem(); move \u00b6 It's possible to move a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveTo(destinationUrl); copy \u00b6 It's possible to copy a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyTo(destinationUrl); move by path \u00b6 It's possible to move a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveByPath(destinationUrl, true); copy by path \u00b6 It's possible to copy a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyByPath(destinationUrl, true); delete \u00b6 Deletes a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").delete(); delete with params \u00b6 Added in 2.0.9 Deletes a folder with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").deleteWithParams({ BypassSharedLock: true, DeleteIfEmpty: true, }); recycle \u00b6 Recycles a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").recycle(); serverRelativeUrl \u00b6 Gets folder's server relative url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const relUrl = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").serverRelativeUrl(); update \u00b6 Updates folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").update({ \"Name\": \"New name\", }); contentTypeOrder \u00b6 Gets content type order of a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const order = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").contentTypeOrder(); folders \u00b6 Gets all child folders associated with the current folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folders = await sp.web.rootFolder.folders(); files \u00b6 Gets all files inside a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files/folder\"; const files = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").files(); listItemAllFields \u00b6 Gets this folder's list item field values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const itemFields = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").listItemAllFields(); parentFolder \u00b6 Gets the parent folder, if available import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const parentFolder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").parentFolder(); properties \u00b6 Gets this folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const properties = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").properties(); uniqueContentTypeOrder \u00b6 Gets a value that specifies the content type order. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const contentTypeOrder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").uniqueContentTypeOrder(); Rename a folder \u00b6 You can rename a folder by updating FileLeafRef property: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\"); const item = await folder.getItem(); const result = await item.update({ FileLeafRef: \"Folder2\" }); Create a folder with custom content type \u00b6 Below code creates a new folder under Document library and assigns custom folder content type to a newly created folder. Additionally it sets a field of a custom folder content type. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; const newFolderResult = await sp.web.rootFolder.folders.getByName(\"Shared Documents\").folders.add(\"My New Folder\"); const item = await newFolderResult.folder.listItemAllFields(); await sp.web.lists.getByTitle(\"Documents\").items.getById(item.ID).update({ ContentTypeId: \"0x0120001E76ED75A3E3F3408811F0BF56C4CDDD\", MyFolderField: \"field value\", Title: \"My New Folder\", }); addSubFolderUsingPath \u00b6 Added in 2.0.9 You can use the addSubFolderUsingPath method to add a folder with some special chars supported import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; // add a folder to site assets const folder: IFolder = await web.rootFolder.folders.getByName(\"SiteAssets\").addSubFolderUsingPath(\"folder name\"); getFolderById \u00b6 You can get a folder by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); getParentInfos \u00b6 Added in 2.0.12 Gets information about folder, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); await folder.getParentInfos();","title":"@pnp/sp/folders"},{"location":"v2/sp/folders/#pnpspfolders","text":"Folders serve as a container for your files and list items.","title":"@pnp/sp/folders"},{"location":"v2/sp/folders/#ifolders","text":"Represents a collection of folders. SharePoint webs, lists, and list items have a collection of folders under their properties. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\";","title":"IFolders"},{"location":"v2/sp/folders/#get-folders-collection-for-various-sharepoint-objects","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; // gets web's folders const webFolders = await sp.web.folders(); // gets list's folders const listFolders = await sp.web.lists.getByTitle(\"My List\").rootFolder.folders(); // gets item's folders const itemFolders = await sp.web.lists.getByTitle(\"My List\").items.getById(1).folder.folders();","title":"Get folders collection for various SharePoint objects"},{"location":"v2/sp/folders/#add","text":"Adds a new folder to collection of folders import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // creates a new folder for web with specified url const folderAddResult = await sp.web.folders.add(\"folder url\");","title":"add"},{"location":"v2/sp/folders/#getbyname","text":"Gets a folder instance from a collection by folder's name import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = await sp.web.folders.getByName(\"folder name\")();","title":"getByName"},{"location":"v2/sp/folders/#ifolder","text":"Represents an instance of a SharePoint folder. Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IFolders, Folders } from \"@pnp/sp/folders\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/web\"; Selective 4 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; Selective 5 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders/list\"; import \"@pnp/sp/folders/item\"; Preset: All import { sp, IFolders, Folders } from \"@pnp/sp/presets/all\";","title":"IFolder"},{"location":"v2/sp/folders/#get-a-folder-object-associated-with-different-sharepoint-artifacts-web-list-list-item","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // web's folder const rootFolder = await sp.web.rootFolder(); // list's folder const listRootFolder = await sp.web.lists.getByTitle(\"234\").rootFolder(); // item's folder const itemFolder = await sp.web.lists.getByTitle(\"234\").items.getById(1).folder();","title":"Get a folder object associated with different SharePoint artifacts (web, list, list item)"},{"location":"v2/sp/folders/#getitem","text":"Gets list item associated with a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folderItem = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").getItem();","title":"getItem"},{"location":"v2/sp/folders/#move","text":"It's possible to move a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveTo(destinationUrl);","title":"move"},{"location":"v2/sp/folders/#copy","text":"It's possible to copy a folder to a new destination within a site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyTo(destinationUrl);","title":"copy"},{"location":"v2/sp/folders/#move-by-path","text":"It's possible to move a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").moveByPath(destinationUrl, true);","title":"move by path"},{"location":"v2/sp/folders/#copy-by-path","text":"It's possible to copy a folder to a new destination within the same or a different site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; // destination is a server-relative url of a new folder const destinationUrl = `/sites/my-site/SiteAssets/new-folder`; await sp.web.rootFolder.folders.getByName(\"SiteAssets\").folders.getByName(\"My Folder\").copyByPath(destinationUrl, true);","title":"copy by path"},{"location":"v2/sp/folders/#delete","text":"Deletes a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").delete();","title":"delete"},{"location":"v2/sp/folders/#delete-with-params","text":"Added in 2.0.9 Deletes a folder with options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").deleteWithParams({ BypassSharedLock: true, DeleteIfEmpty: true, });","title":"delete with params"},{"location":"v2/sp/folders/#recycle","text":"Recycles a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.rootFolder.folders.getByName(\"My Folder\").recycle();","title":"recycle"},{"location":"v2/sp/folders/#serverrelativeurl","text":"Gets folder's server relative url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const relUrl = await sp.web.rootFolder.folders.getByName(\"SiteAssets\").serverRelativeUrl();","title":"serverRelativeUrl"},{"location":"v2/sp/folders/#update","text":"Updates folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").update({ \"Name\": \"New name\", });","title":"update"},{"location":"v2/sp/folders/#contenttypeorder","text":"Gets content type order of a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const order = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").contentTypeOrder();","title":"contentTypeOrder"},{"location":"v2/sp/folders/#folders","text":"Gets all child folders associated with the current folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folders = await sp.web.rootFolder.folders();","title":"folders"},{"location":"v2/sp/folders/#files","text":"Gets all files inside a folder import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files/folder\"; const files = await sp.web.getFolderByServerRelativePath(\"Shared Documents\").files();","title":"files"},{"location":"v2/sp/folders/#listitemallfields","text":"Gets this folder's list item field values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const itemFields = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").listItemAllFields();","title":"listItemAllFields"},{"location":"v2/sp/folders/#parentfolder","text":"Gets the parent folder, if available import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const parentFolder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\").parentFolder();","title":"parentFolder"},{"location":"v2/sp/folders/#properties","text":"Gets this folder's properties import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const properties = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").properties();","title":"properties"},{"location":"v2/sp/folders/#uniquecontenttypeorder","text":"Gets a value that specifies the content type order. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const contentTypeOrder = await sp.web.getFolderByServerRelativePath(\"Shared Documents/Folder2\").uniqueContentTypeOrder();","title":"uniqueContentTypeOrder"},{"location":"v2/sp/folders/#rename-a-folder","text":"You can rename a folder by updating FileLeafRef property: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder = sp.web.getFolderByServerRelativePath(\"Shared Documents/My Folder\"); const item = await folder.getItem(); const result = await item.update({ FileLeafRef: \"Folder2\" });","title":"Rename a folder"},{"location":"v2/sp/folders/#create-a-folder-with-custom-content-type","text":"Below code creates a new folder under Document library and assigns custom folder content type to a newly created folder. Additionally it sets a field of a custom folder content type. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/lists\"; const newFolderResult = await sp.web.rootFolder.folders.getByName(\"Shared Documents\").folders.add(\"My New Folder\"); const item = await newFolderResult.folder.listItemAllFields(); await sp.web.lists.getByTitle(\"Documents\").items.getById(item.ID).update({ ContentTypeId: \"0x0120001E76ED75A3E3F3408811F0BF56C4CDDD\", MyFolderField: \"field value\", Title: \"My New Folder\", });","title":"Create a folder with custom content type"},{"location":"v2/sp/folders/#addsubfolderusingpath","text":"Added in 2.0.9 You can use the addSubFolderUsingPath method to add a folder with some special chars supported import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; // add a folder to site assets const folder: IFolder = await web.rootFolder.folders.getByName(\"SiteAssets\").addSubFolderUsingPath(\"folder name\");","title":"addSubFolderUsingPath"},{"location":"v2/sp/folders/#getfolderbyid","text":"You can get a folder by Id from a web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\");","title":"getFolderById"},{"location":"v2/sp/folders/#getparentinfos","text":"Added in 2.0.12 Gets information about folder, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/folders\"; const folder: IFolder = sp.web.getFolderById(\"2b281c7b-ece9-4b76-82f9-f5cf5e152ba0\"); await folder.getParentInfos();","title":"getParentInfos"},{"location":"v2/sp/forms/","text":"@pnp/sp/forms \u00b6 Forms in SharePoint are the Display, New, and Edit forms associated with a list. IFields \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\"; Get Form by Id \u00b6 Gets a form from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\"; // get the field by Id for web const form = sp.web.lists.getByTitle(\"Documents\").forms.getById(\"{c4486774-f1e2-4804-96f3-91edf3e22a19}\")();","title":"@pnp/sp/forms"},{"location":"v2/sp/forms/#pnpspforms","text":"Forms in SharePoint are the Display, New, and Edit forms associated with a list.","title":"@pnp/sp/forms"},{"location":"v2/sp/forms/#ifields","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\";","title":"IFields"},{"location":"v2/sp/forms/#get-form-by-id","text":"Gets a form from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/forms\"; import \"@pnp/sp/lists\"; // get the field by Id for web const form = sp.web.lists.getByTitle(\"Documents\").forms.getById(\"{c4486774-f1e2-4804-96f3-91edf3e22a19}\")();","title":"Get Form by Id"},{"location":"v2/sp/hubsites/","text":"@pnp/sp/hubsites \u00b6 This module helps you with working with hub sites in your tenant. IHubSites \u00b6 Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/hubsites\"; Preset: All import { sp, HubSites, IHubSites } from \"@pnp/sp/presets/all\"; Get a Listing of All Hub sites \u00b6 import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; // invoke the hub sites object const hubsites: IHubSiteInfo[] = await sp.hubSites(); // you can also use select to only return certain fields: const hubsites2: IHubSiteInfo[] = await sp.hubSites.select(\"ID\", \"Title\", \"RelatedHubSiteIds\")(); Get Hub site by Id \u00b6 Using the getById method on the hubsites module to get a hub site by site Id (guid). import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; const hubsite: IHubSiteInfo = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\")(); // log hub site title to console console.log(hubsite.Title); Get ISite instance \u00b6 We provide a helper method to load the ISite instance from the HubSite import { sp } from \"@pnp/sp\"; import { ISite } from \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites\"; const site: ISite = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\").getSite(); const siteData = await site(); console.log(siteData.Title); Get Hub site data for a web \u00b6 import { sp } from \"@pnp/sp\"; import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; const webData: Partial<IHubSiteWebData> = await sp.web.hubSiteData(); // you can also force a refresh of the hub site data const webData2: Partial<IHubSiteWebData> = await sp.web.hubSiteData(true); syncHubSiteTheme \u00b6 Allows you to apply theme updates from the parent hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; await sp.web.syncHubSiteTheme(); Hub site Site Methods \u00b6 You manage hub sites at the Site level. joinHubSite \u00b6 Id of the hub site collection you want to join. If you want to disassociate the site collection from hub site, then pass the siteId as 00000000-0000-0000-0000-000000000000 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // join a site to a hub site await sp.site.joinHubSite(\"{parent hub site id}\"); // remove a site from a hub site await sp.site.joinHubSite(\"00000000-0000-0000-0000-000000000000\"); registerHubSite \u00b6 Registers the current site collection as hub site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // register current site as a hub site await sp.site.registerHubSite(); unRegisterHubSite \u00b6 Un-registers the current site collection as hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // make a site no longer a hub await sp.site.unRegisterHubSite();","title":"@pnp/sp/hubsites"},{"location":"v2/sp/hubsites/#pnpsphubsites","text":"This module helps you with working with hub sites in your tenant.","title":"@pnp/sp/hubsites"},{"location":"v2/sp/hubsites/#ihubsites","text":"Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/hubsites\"; Preset: All import { sp, HubSites, IHubSites } from \"@pnp/sp/presets/all\";","title":"IHubSites"},{"location":"v2/sp/hubsites/#get-a-listing-of-all-hub-sites","text":"import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; // invoke the hub sites object const hubsites: IHubSiteInfo[] = await sp.hubSites(); // you can also use select to only return certain fields: const hubsites2: IHubSiteInfo[] = await sp.hubSites.select(\"ID\", \"Title\", \"RelatedHubSiteIds\")();","title":"Get a Listing of All Hub sites"},{"location":"v2/sp/hubsites/#get-hub-site-by-id","text":"Using the getById method on the hubsites module to get a hub site by site Id (guid). import { sp } from \"@pnp/sp\"; import { IHubSiteInfo } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/hubsites\"; const hubsite: IHubSiteInfo = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\")(); // log hub site title to console console.log(hubsite.Title);","title":"Get Hub site by Id"},{"location":"v2/sp/hubsites/#get-isite-instance","text":"We provide a helper method to load the ISite instance from the HubSite import { sp } from \"@pnp/sp\"; import { ISite } from \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites\"; const site: ISite = await sp.hubSites.getById(\"3504348e-b2be-49fb-a2a9-2d748db64beb\").getSite(); const siteData = await site(); console.log(siteData.Title);","title":"Get ISite instance"},{"location":"v2/sp/hubsites/#get-hub-site-data-for-a-web","text":"import { sp } from \"@pnp/sp\"; import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; const webData: Partial<IHubSiteWebData> = await sp.web.hubSiteData(); // you can also force a refresh of the hub site data const webData2: Partial<IHubSiteWebData> = await sp.web.hubSiteData(true);","title":"Get Hub site data for a web"},{"location":"v2/sp/hubsites/#synchubsitetheme","text":"Allows you to apply theme updates from the parent hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/hubsites/web\"; await sp.web.syncHubSiteTheme();","title":"syncHubSiteTheme"},{"location":"v2/sp/hubsites/#hub-site-site-methods","text":"You manage hub sites at the Site level.","title":"Hub site Site Methods"},{"location":"v2/sp/hubsites/#joinhubsite","text":"Id of the hub site collection you want to join. If you want to disassociate the site collection from hub site, then pass the siteId as 00000000-0000-0000-0000-000000000000 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // join a site to a hub site await sp.site.joinHubSite(\"{parent hub site id}\"); // remove a site from a hub site await sp.site.joinHubSite(\"00000000-0000-0000-0000-000000000000\");","title":"joinHubSite"},{"location":"v2/sp/hubsites/#registerhubsite","text":"Registers the current site collection as hub site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // register current site as a hub site await sp.site.registerHubSite();","title":"registerHubSite"},{"location":"v2/sp/hubsites/#unregisterhubsite","text":"Un-registers the current site collection as hub site collection. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import \"@pnp/sp/hubsites/site\"; // make a site no longer a hub await sp.site.unRegisterHubSite();","title":"unRegisterHubSite"},{"location":"v2/sp/items/","text":"@pnp/sp/items \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\"; GET \u00b6 Getting items from a list is one of the basic actions that most applications require. This is made easy through the library and the following examples demonstrate these actions. Basic Get \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // get all the items from a list const items: any[] = await sp.web.lists.getByTitle(\"My List\").items(); console.log(items); // get a specific item by id. const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); console.log(item); // use odata operators for more efficient queries const items2: any[] = await sp.web.lists.getByTitle(\"My List\").items.select(\"Title\", \"Description\").top(5).orderBy(\"Modified\", true)(); console.log(items2); Get Paged Items \u00b6 Working with paging can be a challenge as it is based on skip tokens and item ids, something that is hard to guess at runtime. To simplify things you can use the getPaged method on the Items class to assist. Note that there isn't a way to move backwards in the collection, this is by design. The pattern you should use to support backwards navigation in the results is to cache the results into a local array and use the standard array operators to get previous pages. Alternatively you can append the results to the UI, but this can have performance impact for large result sets. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic case to get paged items form a list let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged(); // you can also provide a type for the returned values instead of any let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged<{Title: string}[]>(); // the query also works with select to choose certain fields and top to set the page size let items = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\", \"Description\").top(50).getPaged<{Title: string}[]>(); // the results object will have two properties and one method: // the results property will be an array of the items returned if (items.results.length > 0) { console.log(\"We got results!\"); for (let i = 0; i < items.results.length; i++) { // type checking works here if we specify the return type console.log(items.results[i].Title); } } // the hasNext property is used with the getNext method to handle paging // hasNext will be true so long as there are additional results if (items.hasNext) { // this will carry over the type specified in the original query for the results array items = await items.getNext(); console.log(items.results.length); } getListItemChangesSinceToken \u00b6 The GetListItemChangesSinceToken method allows clients to track changes on a list. Changes, including deleted items, are returned along with a token that represents the moment in time when those changes were requested. By including this token when you call GetListItemChangesSinceToken, the server looks for only those changes that have occurred since the token was generated. Sending a GetListItemChangesSinceToken request without including a token returns the list schema, the full list contents and a token. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // Using RowLimit. Enables paging let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({RowLimit: '5'}); // Use QueryOptions to make a XML-style query. // Because it's XML we need to escape special characters // Instead of & we use &amp; in the query let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({QueryOptions: '<Paging ListItemCollectionPositionNext=\"Paged=TRUE&amp;p_ID=5\" />'}); // Get everything. Using null with ChangeToken gets everything let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({ChangeToken: null}); Get All Items \u00b6 Using the items collection's getAll method you can get all of the items in a list regardless of the size of the list. Sample usage is shown below. Only the odata operations top, select, and filter are supported. usingCaching and inBatch are ignored - you will need to handle caching the results on your own. This method will write a warning to the Logger and should not frequently be used. Instead the standard paging operations should be used. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic usage const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(); console.log(allItems.length); // set page size const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(4000); console.log(allItems.length); // use select and top. top will set page size and override the any value passed to getAll const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").top(4000).getAll(); console.log(allItems.length); // we can also use filter as a supported odata operation, but this will likely fail on large lists const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").filter(\"Title eq 'Test'\").getAll(); console.log(allItems.length); Retrieving Lookup Fields \u00b6 When working with lookup fields you need to use the expand operator along with select to get the related fields from the lookup column. This works for both the items collection and item instances. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const items = await sp.web.lists.getByTitle(\"LookupList\").items.select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(items); const item = await sp.web.lists.getByTitle(\"LookupList\").items.getById(1).select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(item); Filter using Metadata fields \u00b6 To filter on a metadata field you must use the getItemsByCAMLQuery method as $filter does not support these fields. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; const r = await sp.web.lists.getByTitle(\"TaxonomyList\").getItemsByCAMLQuery({ ViewXml: `<View><Query><Where><Eq><FieldRef Name=\"MetaData\"/><Value Type=\"TaxonomyFieldType\">Term 2</Value></Eq></Where></Query></View>`, }); Retrieving PublishingPageImage \u00b6 The PublishingPageImage and some other publishing-related fields aren't stored in normal fields, rather in the MetaInfo field. To get these values you need to use the technique shown below, and originally outlined in this thread . Note that a lot of information can be stored in this field so will pull back potentially a significant amount of data, so limit the rows as possible to aid performance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { Web } from \"@pnp/sp/webs\"; try { const w = Web(\"https://{publishing site url}\"); const r = await w.lists.getByTitle(\"Pages\").items .select(\"Title\", \"FileRef\", \"FieldValuesAsText/MetaInfo\") .expand(\"FieldValuesAsText\") (); // look through the returned items. for (var i = 0; i < r.length; i++) { // the title field value console.log(r[i].Title); // find the value in the MetaInfo string using regex const matches = /PublishingPageImage:SW\\|(.*?)\\r\\n/ig.exec(r[i].FieldValuesAsText.MetaInfo); if (matches !== null && matches.length > 1) { // this wil be the value of the PublishingPageImage field console.log(matches[1]); } } } catch (e) { console.error(e); } Add Items \u00b6 There are several ways to add items to a list. The simplest just uses the add method of the items collection passing in the properties as a plain object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { IItemAddResult } from \"@pnp/sp/items\"; // add an item to the list const iar: IItemAddResult = await sp.web.lists.getByTitle(\"My List\").items.add({ Title: \"Title\", Description: \"Description\" }); console.log(iar); Content Type \u00b6 You can also set the content type id when you create an item as shown in the example below. For more information on content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; await sp.web.lists.getById(\"4D5A36EA-6E84-4160-8458-65C436DB765C\").items.add({ Title: \"Test 1\", ContentTypeId: \"0x01030058FD86C279252341AB303852303E4DAF\" }); User Fields \u00b6 There are two types of user fields, those that allow a single value and those that allow multiple. For both types, you first need to determine the Id field name, which you can do by doing a GET REST request on an existing item. Typically the value will be the user field internal name with \"Id\" appended. So in our example, we have two fields User1 and User2 so the Id fields are User1Id and User2Id. Next, you need to remember there are two types of user fields, those that take a single value and those that allow multiple - these are updated in different ways. For single value user fields you supply just the user's id. For multiple value fields, you need to supply an object with a \"results\" property and an array. Examples for both are shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; const i = await sp.web.lists.getByTitle(\"PeopleFields\").items.add({ Title: getGUID(), User1Id: 9, // allows a single user User2Id: { results: [16, 45] // allows multiple users } }); console.log(i); If you want to update or add user field values when using validateUpdateListItem you need to use the form shown below. You can specify multiple values in the array. import { sp } from \"@pnp/sp\"; const result = await sp.web.lists.getByTitle(\"UserFieldList\").items.getById(1).validateUpdateListItem([{ FieldName: \"UserField\", FieldValue: JSON.stringify([{ \"Key\": \"i:0#.f|membership|person@tenant.com\" }]), }, { FieldName: \"Title\", FieldValue: \"Test - Updated\", }]); Lookup Fields \u00b6 What is said for User Fields is, in general, relevant to Lookup Fields: Lookup Field types: Single-valued lookup Multiple-valued lookup Id suffix should be appended to the end of lookups EntityPropertyName in payloads Numeric Ids for lookups' items should be passed as values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; await sp.web.lists.getByTitle(\"LookupFields\").items.add({ Title: getGUID(), LookupFieldId: 2, // allows a single lookup value MultiLookupFieldId: { results: [ 1, 56 ] // allows multiple lookup value } }); Add Multiple Items \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidadd\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: \"Batch 6\" }, entityTypeFullName).then(b => { console.log(b); }); list.items.inBatch(batch).add({ Title: \"Batch 7\" }, entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\"); Update \u00b6 The update method is very similar to the add method in that it takes a plain object representing the fields to update. The property names are the internal names of the fields. If you aren't sure you can always do a get request for an item in the list and see the field names that come back - you would use these same names to update the item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const i = await list.items.getById(1).update({ Title: \"My New Title\", Description: \"Here is a new description\" }); console.log(i); Getting and updating a collection using filter \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // you are getting back a collection here const items: any[] = await sp.web.lists.getByTitle(\"MyList\").items.top(1).filter(\"Title eq 'A Title'\")(); // see if we got something if (items.length > 0) { const updatedItem = await sp.web.lists.getByTitle(\"MyList\").items.getById(items[0].Id).update({ Title: \"Updated Title\", }); console.log(JSON.stringify(updatedItem)); } Update Multiple Items \u00b6 This approach avoids multiple calls for the same list's entity type name. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidupdate\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); // note requirement of \"*\" eTag param - or use a specific eTag value as needed list.items.getById(1).inBatch(batch).update({ Title: \"Batch 6\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); list.items.getById(2).inBatch(batch).update({ Title: \"Batch 7\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\") Recycle \u00b6 To send an item to the recycle bin use recycle. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const recycleBinIdentifier = await list.items.getById(1).recycle(); Delete \u00b6 Delete is as simple as calling the .delete method. It optionally takes an eTag if you need to manage concurrency. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).delete(); Delete With Params \u00b6 Added in 2.0.9 Deletes the item object with options. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).deleteWithParams({ BypassSharedLock: true, }); The deleteWithParams method can only be used by accounts where UserToken.IsSystemAccount is true Resolving field names \u00b6 It's a very common mistake trying wrong field names in the requests. Field's EntityPropertyName value should be used. The easiest way to get know EntityPropertyName is to use the following snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import \"@pnp/sp/fields\"; const response = await sp.web.lists .getByTitle('[Lists_Title]') .fields .select('Title, EntityPropertyName') .filter(`Hidden eq false and Title eq '[Field's_Display_Name]'`) (); console.log(response.map(field => { return { Title: field.Title, EntityPropertyName: field.EntityPropertyName }; })); Lookup fields' names should be ended with additional Id suffix. E.g. for Editor EntityPropertyName EditorId should be used. getParentInfos \u00b6 Added in 2.0.12 Gets information about an item, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); await item.getParentInfos();","title":"@pnp/sp/items"},{"location":"v2/sp/items/#pnpspitems","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\";","title":"@pnp/sp/items"},{"location":"v2/sp/items/#get","text":"Getting items from a list is one of the basic actions that most applications require. This is made easy through the library and the following examples demonstrate these actions.","title":"GET"},{"location":"v2/sp/items/#basic-get","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // get all the items from a list const items: any[] = await sp.web.lists.getByTitle(\"My List\").items(); console.log(items); // get a specific item by id. const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); console.log(item); // use odata operators for more efficient queries const items2: any[] = await sp.web.lists.getByTitle(\"My List\").items.select(\"Title\", \"Description\").top(5).orderBy(\"Modified\", true)(); console.log(items2);","title":"Basic Get"},{"location":"v2/sp/items/#get-paged-items","text":"Working with paging can be a challenge as it is based on skip tokens and item ids, something that is hard to guess at runtime. To simplify things you can use the getPaged method on the Items class to assist. Note that there isn't a way to move backwards in the collection, this is by design. The pattern you should use to support backwards navigation in the results is to cache the results into a local array and use the standard array operators to get previous pages. Alternatively you can append the results to the UI, but this can have performance impact for large result sets. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic case to get paged items form a list let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged(); // you can also provide a type for the returned values instead of any let items = await sp.web.lists.getByTitle(\"BigList\").items.getPaged<{Title: string}[]>(); // the query also works with select to choose certain fields and top to set the page size let items = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\", \"Description\").top(50).getPaged<{Title: string}[]>(); // the results object will have two properties and one method: // the results property will be an array of the items returned if (items.results.length > 0) { console.log(\"We got results!\"); for (let i = 0; i < items.results.length; i++) { // type checking works here if we specify the return type console.log(items.results[i].Title); } } // the hasNext property is used with the getNext method to handle paging // hasNext will be true so long as there are additional results if (items.hasNext) { // this will carry over the type specified in the original query for the results array items = await items.getNext(); console.log(items.results.length); }","title":"Get Paged Items"},{"location":"v2/sp/items/#getlistitemchangessincetoken","text":"The GetListItemChangesSinceToken method allows clients to track changes on a list. Changes, including deleted items, are returned along with a token that represents the moment in time when those changes were requested. By including this token when you call GetListItemChangesSinceToken, the server looks for only those changes that have occurred since the token was generated. Sending a GetListItemChangesSinceToken request without including a token returns the list schema, the full list contents and a token. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // Using RowLimit. Enables paging let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({RowLimit: '5'}); // Use QueryOptions to make a XML-style query. // Because it's XML we need to escape special characters // Instead of & we use &amp; in the query let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({QueryOptions: '<Paging ListItemCollectionPositionNext=\"Paged=TRUE&amp;p_ID=5\" />'}); // Get everything. Using null with ChangeToken gets everything let changes = await sp.web.lists.getByTitle(\"BigList\").getListItemChangesSinceToken({ChangeToken: null});","title":"getListItemChangesSinceToken"},{"location":"v2/sp/items/#get-all-items","text":"Using the items collection's getAll method you can get all of the items in a list regardless of the size of the list. Sample usage is shown below. Only the odata operations top, select, and filter are supported. usingCaching and inBatch are ignored - you will need to handle caching the results on your own. This method will write a warning to the Logger and should not frequently be used. Instead the standard paging operations should be used. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // basic usage const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(); console.log(allItems.length); // set page size const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.getAll(4000); console.log(allItems.length); // use select and top. top will set page size and override the any value passed to getAll const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").top(4000).getAll(); console.log(allItems.length); // we can also use filter as a supported odata operation, but this will likely fail on large lists const allItems: any[] = await sp.web.lists.getByTitle(\"BigList\").items.select(\"Title\").filter(\"Title eq 'Test'\").getAll(); console.log(allItems.length);","title":"Get All Items"},{"location":"v2/sp/items/#retrieving-lookup-fields","text":"When working with lookup fields you need to use the expand operator along with select to get the related fields from the lookup column. This works for both the items collection and item instances. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; const items = await sp.web.lists.getByTitle(\"LookupList\").items.select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(items); const item = await sp.web.lists.getByTitle(\"LookupList\").items.getById(1).select(\"Title\", \"Lookup/Title\", \"Lookup/ID\").expand(\"Lookup\")(); console.log(item);","title":"Retrieving Lookup Fields"},{"location":"v2/sp/items/#filter-using-metadata-fields","text":"To filter on a metadata field you must use the getItemsByCAMLQuery method as $filter does not support these fields. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; const r = await sp.web.lists.getByTitle(\"TaxonomyList\").getItemsByCAMLQuery({ ViewXml: `<View><Query><Where><Eq><FieldRef Name=\"MetaData\"/><Value Type=\"TaxonomyFieldType\">Term 2</Value></Eq></Where></Query></View>`, });","title":"Filter using Metadata fields"},{"location":"v2/sp/items/#retrieving-publishingpageimage","text":"The PublishingPageImage and some other publishing-related fields aren't stored in normal fields, rather in the MetaInfo field. To get these values you need to use the technique shown below, and originally outlined in this thread . Note that a lot of information can be stored in this field so will pull back potentially a significant amount of data, so limit the rows as possible to aid performance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { Web } from \"@pnp/sp/webs\"; try { const w = Web(\"https://{publishing site url}\"); const r = await w.lists.getByTitle(\"Pages\").items .select(\"Title\", \"FileRef\", \"FieldValuesAsText/MetaInfo\") .expand(\"FieldValuesAsText\") (); // look through the returned items. for (var i = 0; i < r.length; i++) { // the title field value console.log(r[i].Title); // find the value in the MetaInfo string using regex const matches = /PublishingPageImage:SW\\|(.*?)\\r\\n/ig.exec(r[i].FieldValuesAsText.MetaInfo); if (matches !== null && matches.length > 1) { // this wil be the value of the PublishingPageImage field console.log(matches[1]); } } } catch (e) { console.error(e); }","title":"Retrieving PublishingPageImage"},{"location":"v2/sp/items/#add-items","text":"There are several ways to add items to a list. The simplest just uses the add method of the items collection passing in the properties as a plain object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { IItemAddResult } from \"@pnp/sp/items\"; // add an item to the list const iar: IItemAddResult = await sp.web.lists.getByTitle(\"My List\").items.add({ Title: \"Title\", Description: \"Description\" }); console.log(iar);","title":"Add Items"},{"location":"v2/sp/items/#content-type","text":"You can also set the content type id when you create an item as shown in the example below. For more information on content type IDs reference the Microsoft Documentation . While this documentation references SharePoint 2010 the structure of the IDs has not changed. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; await sp.web.lists.getById(\"4D5A36EA-6E84-4160-8458-65C436DB765C\").items.add({ Title: \"Test 1\", ContentTypeId: \"0x01030058FD86C279252341AB303852303E4DAF\" });","title":"Content Type"},{"location":"v2/sp/items/#user-fields","text":"There are two types of user fields, those that allow a single value and those that allow multiple. For both types, you first need to determine the Id field name, which you can do by doing a GET REST request on an existing item. Typically the value will be the user field internal name with \"Id\" appended. So in our example, we have two fields User1 and User2 so the Id fields are User1Id and User2Id. Next, you need to remember there are two types of user fields, those that take a single value and those that allow multiple - these are updated in different ways. For single value user fields you supply just the user's id. For multiple value fields, you need to supply an object with a \"results\" property and an array. Examples for both are shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; const i = await sp.web.lists.getByTitle(\"PeopleFields\").items.add({ Title: getGUID(), User1Id: 9, // allows a single user User2Id: { results: [16, 45] // allows multiple users } }); console.log(i); If you want to update or add user field values when using validateUpdateListItem you need to use the form shown below. You can specify multiple values in the array. import { sp } from \"@pnp/sp\"; const result = await sp.web.lists.getByTitle(\"UserFieldList\").items.getById(1).validateUpdateListItem([{ FieldName: \"UserField\", FieldValue: JSON.stringify([{ \"Key\": \"i:0#.f|membership|person@tenant.com\" }]), }, { FieldName: \"Title\", FieldValue: \"Test - Updated\", }]);","title":"User Fields"},{"location":"v2/sp/items/#lookup-fields","text":"What is said for User Fields is, in general, relevant to Lookup Fields: Lookup Field types: Single-valued lookup Multiple-valued lookup Id suffix should be appended to the end of lookups EntityPropertyName in payloads Numeric Ids for lookups' items should be passed as values import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import { getGUID } from \"@pnp/core\"; await sp.web.lists.getByTitle(\"LookupFields\").items.add({ Title: getGUID(), LookupFieldId: 2, // allows a single lookup value MultiLookupFieldId: { results: [ 1, 56 ] // allows multiple lookup value } });","title":"Lookup Fields"},{"location":"v2/sp/items/#add-multiple-items","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidadd\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); list.items.inBatch(batch).add({ Title: \"Batch 6\" }, entityTypeFullName).then(b => { console.log(b); }); list.items.inBatch(batch).add({ Title: \"Batch 7\" }, entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\");","title":"Add Multiple Items"},{"location":"v2/sp/items/#update","text":"The update method is very similar to the add method in that it takes a plain object representing the fields to update. The property names are the internal names of the fields. If you aren't sure you can always do a get request for an item in the list and see the field names that come back - you would use these same names to update the item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const i = await list.items.getById(1).update({ Title: \"My New Title\", Description: \"Here is a new description\" }); console.log(i);","title":"Update"},{"location":"v2/sp/items/#getting-and-updating-a-collection-using-filter","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; // you are getting back a collection here const items: any[] = await sp.web.lists.getByTitle(\"MyList\").items.top(1).filter(\"Title eq 'A Title'\")(); // see if we got something if (items.length > 0) { const updatedItem = await sp.web.lists.getByTitle(\"MyList\").items.getById(items[0].Id).update({ Title: \"Updated Title\", }); console.log(JSON.stringify(updatedItem)); }","title":"Getting and updating a collection using filter"},{"location":"v2/sp/items/#update-multiple-items","text":"This approach avoids multiple calls for the same list's entity type name. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"rapidupdate\"); const entityTypeFullName = await list.getListItemEntityTypeFullName() let batch = sp.web.createBatch(); // note requirement of \"*\" eTag param - or use a specific eTag value as needed list.items.getById(1).inBatch(batch).update({ Title: \"Batch 6\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); list.items.getById(2).inBatch(batch).update({ Title: \"Batch 7\" }, \"*\", entityTypeFullName).then(b => { console.log(b); }); await batch.execute(); console.log(\"Done\")","title":"Update Multiple Items"},{"location":"v2/sp/items/#recycle","text":"To send an item to the recycle bin use recycle. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); const recycleBinIdentifier = await list.items.getById(1).recycle();","title":"Recycle"},{"location":"v2/sp/items/#delete","text":"Delete is as simple as calling the .delete method. It optionally takes an eTag if you need to manage concurrency. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).delete();","title":"Delete"},{"location":"v2/sp/items/#delete-with-params","text":"Added in 2.0.9 Deletes the item object with options. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; let list = sp.web.lists.getByTitle(\"MyList\"); await list.items.getById(1).deleteWithParams({ BypassSharedLock: true, }); The deleteWithParams method can only be used by accounts where UserToken.IsSystemAccount is true","title":"Delete With Params"},{"location":"v2/sp/items/#resolving-field-names","text":"It's a very common mistake trying wrong field names in the requests. Field's EntityPropertyName value should be used. The easiest way to get know EntityPropertyName is to use the following snippet: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/items\"; import \"@pnp/sp/fields\"; const response = await sp.web.lists .getByTitle('[Lists_Title]') .fields .select('Title, EntityPropertyName') .filter(`Hidden eq false and Title eq '[Field's_Display_Name]'`) (); console.log(response.map(field => { return { Title: field.Title, EntityPropertyName: field.EntityPropertyName }; })); Lookup fields' names should be ended with additional Id suffix. E.g. for Editor EntityPropertyName EditorId should be used.","title":"Resolving field names"},{"location":"v2/sp/items/#getparentinfos","text":"Added in 2.0.12 Gets information about an item, including details about the parent list, parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const item: any = await sp.web.lists.getByTitle(\"My List\").items.getById(1)(); await item.getParentInfos();","title":"getParentInfos"},{"location":"v2/sp/lists/","text":"@pnp/sp/lists \u00b6 Lists in SharePoint are collections of information built in a structural way using columns and rows. Columns for metadata, and rows representing each entry. Visually, it reminds us a lot of a database table or an Excel spreadsheet. ILists \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Lists, ILists } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; Preset: All import { sp, Lists, ILists } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Lists, ILists } from \"@pnp/sp/presets/core\"; Get List by Id \u00b6 Gets a list from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the list by Id const list = sp.web.lists.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // we can use this 'list' variable to execute more queries on the list: const r = await list.select(\"Title\")(); // show the response from the server console.log(r.Title); Get List by Title \u00b6 You can also get a list from the collection by title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the default document library 'Documents' const list = sp.web.lists.getByTitle(\"Documents\"); // we can use this 'list' variable to run more queries on the list: const r = await list.select(\"Id\")(); // log the list Id to console console.log(r.Id); Add List \u00b6 You can add a list to the web's list collection using the .add-method. To invoke this method in its most simple form, you can provide only a title as a parameter. This will result in a standard out of the box list with all default settings, and the title you provide. // create a new list, passing only the title const listAddResult = await sp.web.lists.add(\"My new list\"); // we can work with the list created using the IListAddResult.list property: const r = await listAddResult.list.select(\"Title\")(); // log newly created list title to console console.log(r.Title); }); You can also provide other (optional) parameters like description, template and enableContentTypes. If that is not enough for you, you can use the parameter named 'additionalSettings' which is just a TypedHash, meaning you can sent whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). You can find a listing of list template codes in the official docs. // this will create a list with template 101 (Document library), content types enabled and show it on the quick launch (using additionalSettings) const listAddResult = await sp.web.lists.add(\"My Doc Library\", \"This is a description of doc lib.\", 101, true, { OnQuickLaunch: true }); // get the Id of the newly added document library const r = await listAddResult.list.select(\"Id\")(); // log id to console console.log(r.Id); Ensure that a List exists (by title) \u00b6 Ensures that the specified list exists in the collection (note: this method not supported for batching). Just like with the add-method (see examples above) you can provide only the title, or any or all of the optional parameters desc, template, enableContentTypes and additionalSettings. // ensure that a list exists. If it doesn't it will be created with the provided title (the rest of the settings will be default): const listEnsureResult = await sp.web.lists.ensure(\"My List\"); // check if the list was created, or if it already existed: if (listEnsureResult.created) { console.log(\"My List was created!\"); } else { console.log(\"My List already existed!\"); } // work on the created/updated list const r = await listEnsureResult.list.select(\"Id\")(); // log the Id console.log(r.Id); If the list already exists, the other settings you provide will be used to update the existing list. // add a new list to the lists collection of the web sp.web.lists.add(\"My List 2\").then(async () => { // then call ensure on the created list with an updated description const listEnsureResult = await sp.web.lists.ensure(\"My List 2\", \"Updated description\"); // get the updated description const r = await listEnsureResult.list.select(\"Description\")(); // log the updated description console.log(r.Description); }); Ensure Site Assets Library exist \u00b6 Gets a list that is the default asset location for images or other files, which the users upload to their wiki pages. // get Site Assets library const siteAssetsList = await sp.web.lists.ensureSiteAssetsLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title); Ensure Site Pages Library exist \u00b6 Gets a list that is the default location for wiki pages. // get Site Pages library const siteAssetsList = await sp.web.lists.ensureSitePagesLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title); IList \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { List, IList } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists\"; Preset: All import { sp, List, IList } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, List, IList } from \"@pnp/sp/presets/core\"; Update a list \u00b6 Update an existing list with the provided properties. You can also provide an eTag value that will be used in the IF-Match header (default is \"*\") import { IListUpdateResult } from \"@pnp/sp/lists\"; // create a TypedHash object with the properties to update const updateProperties = { Description: \"This list title and description has been updated using PnPjs.\", Title: \"Updated title\", }; // update the list with the properties above list.update(updateProperties).then(async (l: IListUpdateResult) => { // get the updated title and description const r = await l.list.select(\"Title\", \"Description\")(); // log the updated properties to the console console.log(r.Title); console.log(r.Description); }); Get changes on a list \u00b6 From the change log, you can get a collection of changes that have occurred within the list based on the specified query. import { sp, IChangeQuery } from \"@pnp/sp\"; // build the changeQuery object, here we look att changes regarding Add, DeleteObject and Restore const changeQuery: IChangeQuery = { Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Rename: true, Restore: true, }; // get list changes const r = await list.getChanges(changeQuery); // log changes to console console.log(r); Get list items using a CAML Query \u00b6 You can get items from SharePoint using a CAML Query. import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml); // log resulting array to console console.log(r); If you need to get and expand a lookup field, there is a spread array parameter on the getItemsByCAMLQuery. This means that you can provide multiple properties to this method depending on how many lookup fields you are working with on your list. Below is a minimal example showing how to expand one field (RoleAssignment) import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /><FieldRef Name='RoleAssignments' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml, \"RoleAssignments\"); // log resulting item array to console console.log(r); Get list items changes using a Token \u00b6 import { IChangeLogItemQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const changeLogItemQuery: IChangeLogItemQuery = { Contains: `<Contains><FieldRef Name=\"Title\"/><Value Type=\"Text\">Item16</Value></Contains>`, QueryOptions: `<QueryOptions> <IncludeMandatoryColumns>FALSE</IncludeMandatoryColumns> <DateInUtc>False</DateInUtc> <IncludePermissions>TRUE</IncludePermissions> <IncludeAttachmentUrls>FALSE</IncludeAttachmentUrls> <Folder>My List</Folder></QueryOptions>`, }; // get list items const r = await list.getListItemChangesSinceToken(changeLogItemQuery); // log resulting XML to console console.log(r); Recycle a list \u00b6 Removes the list from the web's list collection and puts it in the recycle bin. await list.recycle(); Render list data \u00b6 import { IRenderListData } from \"@pnp/sp/lists\"; // render list data, top 5 items const r: IRenderListData = await list.renderListData(\"<View><RowLimit>5</RowLimit></View>\"); // log array of items in response console.log(r.Row); Render list data as stream \u00b6 import { IRenderListDataParameters } from \"@pnp/sp/lists\"; // setup parameters object const renderListDataParams: IRenderListDataParameters = { ViewXml: \"<View><RowLimit>5</RowLimit></View>\", }; // render list data as stream const r = await list.renderListDataAsStream(renderListDataParams); // log array of items in response console.log(r.Row); Reserve list item Id for idempotent list item creation \u00b6 const listItemId = await list.reserveListItemId(); // log id to console console.log(listItemId); Get list item entity type name \u00b6 const entityTypeFullName = await list.getListItemEntityTypeFullName(); // log entity type name console.log(entityTypeFullName); Add a list item using path (folder), validation and set field values \u00b6 const list = await sp.webs.lists.getByTitle(\"MyList\").select(\"Title\", \"ParentWebUrl\")(); const formValues: IListItemFormUpdateValue[] = [ { FieldName: \"Title\", FieldValue: title, }, ]; list.addValidateUpdateItemUsingPath(formValues,`${list.ParentWebUrl}/Lists/${list.Title}/MyFolder`) content-types imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; contentTypes \u00b6 Get all content types for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.contentTypes(); fields imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; fields \u00b6 Get all the fields for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.fields(); Add a field to the site, then add the site field to a list const fld = await sp.site.rootWeb.fields.addText(\"MyField\"); await sp.web.lists.getByTitle(\"MyList\").fields.createFieldAsXml(fld.data.SchemaXml); folders imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; folders \u00b6 Get the root folder of a list. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.rootFolder(); forms imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/forms\"; Selective 2 import \"@pnp/sp/forms/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; forms \u00b6 const r = await list.forms(); items imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/items\"; Selective 2 import \"@pnp/sp/items/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; items \u00b6 Get a collection of list items. const r = await list.items(); views imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/views\"; Selective 2 import \"@pnp/sp/views/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; views \u00b6 Get the default view of the list const list = sp.web.lists.getByTitle(\"Documents\"); const views = await list.views(); const defaultView = await list.defaultView(); Get a list view by Id const view = await list.getView(defaultView.Id).select(\"Title\")(); security imports \u00b6 To work with list security, you can import the list methods as follows: import \"@pnp/sp/security/list\"; For more information on how to call security methods for lists, please refer to the @pnp/sp/security documentation. subscriptions imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/subscriptions\"; Selective 2 import \"@pnp/sp/subscriptions/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; subscriptions \u00b6 Get all subscriptions on the list const list = sp.web.lists.getByTitle(\"Documents\"); const subscriptions = await list.subscriptions(); user-custom-actions imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; userCustomActions \u00b6 Get a collection of the list's user custom actions. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.userCustomActions(); getParentInfos \u00b6 Added in 2.0.12 Gets information about an list, including details about the parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const list = sp.web.lists.getByTitle(\"Documents\"); await list.getParentInfos();","title":"@pnp/sp/lists"},{"location":"v2/sp/lists/#pnpsplists","text":"Lists in SharePoint are collections of information built in a structural way using columns and rows. Columns for metadata, and rows representing each entry. Visually, it reminds us a lot of a database table or an Excel spreadsheet.","title":"@pnp/sp/lists"},{"location":"v2/sp/lists/#ilists","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; import { Lists, ILists } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; Preset: All import { sp, Lists, ILists } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Lists, ILists } from \"@pnp/sp/presets/core\";","title":"ILists"},{"location":"v2/sp/lists/#get-list-by-id","text":"Gets a list from the collection by id (guid). Note that the library will handle a guid formatted with curly braces (i.e. '{03b05ff4-d95d-45ed-841d-3855f77a2483}') as well as without curly braces (i.e. '03b05ff4-d95d-45ed-841d-3855f77a2483'). The Id parameter is also case insensitive. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the list by Id const list = sp.web.lists.getById(\"03b05ff4-d95d-45ed-841d-3855f77a2483\"); // we can use this 'list' variable to execute more queries on the list: const r = await list.select(\"Title\")(); // show the response from the server console.log(r.Title);","title":"Get List by Id"},{"location":"v2/sp/lists/#get-list-by-title","text":"You can also get a list from the collection by title. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; // get the default document library 'Documents' const list = sp.web.lists.getByTitle(\"Documents\"); // we can use this 'list' variable to run more queries on the list: const r = await list.select(\"Id\")(); // log the list Id to console console.log(r.Id);","title":"Get List by Title"},{"location":"v2/sp/lists/#add-list","text":"You can add a list to the web's list collection using the .add-method. To invoke this method in its most simple form, you can provide only a title as a parameter. This will result in a standard out of the box list with all default settings, and the title you provide. // create a new list, passing only the title const listAddResult = await sp.web.lists.add(\"My new list\"); // we can work with the list created using the IListAddResult.list property: const r = await listAddResult.list.select(\"Title\")(); // log newly created list title to console console.log(r.Title); }); You can also provide other (optional) parameters like description, template and enableContentTypes. If that is not enough for you, you can use the parameter named 'additionalSettings' which is just a TypedHash, meaning you can sent whatever properties you'd like in the body (provided that the property is supported by the SharePoint API). You can find a listing of list template codes in the official docs. // this will create a list with template 101 (Document library), content types enabled and show it on the quick launch (using additionalSettings) const listAddResult = await sp.web.lists.add(\"My Doc Library\", \"This is a description of doc lib.\", 101, true, { OnQuickLaunch: true }); // get the Id of the newly added document library const r = await listAddResult.list.select(\"Id\")(); // log id to console console.log(r.Id);","title":"Add List"},{"location":"v2/sp/lists/#ensure-that-a-list-exists-by-title","text":"Ensures that the specified list exists in the collection (note: this method not supported for batching). Just like with the add-method (see examples above) you can provide only the title, or any or all of the optional parameters desc, template, enableContentTypes and additionalSettings. // ensure that a list exists. If it doesn't it will be created with the provided title (the rest of the settings will be default): const listEnsureResult = await sp.web.lists.ensure(\"My List\"); // check if the list was created, or if it already existed: if (listEnsureResult.created) { console.log(\"My List was created!\"); } else { console.log(\"My List already existed!\"); } // work on the created/updated list const r = await listEnsureResult.list.select(\"Id\")(); // log the Id console.log(r.Id); If the list already exists, the other settings you provide will be used to update the existing list. // add a new list to the lists collection of the web sp.web.lists.add(\"My List 2\").then(async () => { // then call ensure on the created list with an updated description const listEnsureResult = await sp.web.lists.ensure(\"My List 2\", \"Updated description\"); // get the updated description const r = await listEnsureResult.list.select(\"Description\")(); // log the updated description console.log(r.Description); });","title":"Ensure that a List exists (by title)"},{"location":"v2/sp/lists/#ensure-site-assets-library-exist","text":"Gets a list that is the default asset location for images or other files, which the users upload to their wiki pages. // get Site Assets library const siteAssetsList = await sp.web.lists.ensureSiteAssetsLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title);","title":"Ensure Site Assets Library exist"},{"location":"v2/sp/lists/#ensure-site-pages-library-exist","text":"Gets a list that is the default location for wiki pages. // get Site Pages library const siteAssetsList = await sp.web.lists.ensureSitePagesLibrary(); // get the Title const r = await siteAssetsList.select(\"Title\")(); // log Title console.log(r.Title);","title":"Ensure Site Pages Library exist"},{"location":"v2/sp/lists/#ilist","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { List, IList } from \"@pnp/sp/lists\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/lists\"; Preset: All import { sp, List, IList } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, List, IList } from \"@pnp/sp/presets/core\";","title":"IList"},{"location":"v2/sp/lists/#update-a-list","text":"Update an existing list with the provided properties. You can also provide an eTag value that will be used in the IF-Match header (default is \"*\") import { IListUpdateResult } from \"@pnp/sp/lists\"; // create a TypedHash object with the properties to update const updateProperties = { Description: \"This list title and description has been updated using PnPjs.\", Title: \"Updated title\", }; // update the list with the properties above list.update(updateProperties).then(async (l: IListUpdateResult) => { // get the updated title and description const r = await l.list.select(\"Title\", \"Description\")(); // log the updated properties to the console console.log(r.Title); console.log(r.Description); });","title":"Update a list"},{"location":"v2/sp/lists/#get-changes-on-a-list","text":"From the change log, you can get a collection of changes that have occurred within the list based on the specified query. import { sp, IChangeQuery } from \"@pnp/sp\"; // build the changeQuery object, here we look att changes regarding Add, DeleteObject and Restore const changeQuery: IChangeQuery = { Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Rename: true, Restore: true, }; // get list changes const r = await list.getChanges(changeQuery); // log changes to console console.log(r);","title":"Get changes on a list"},{"location":"v2/sp/lists/#get-list-items-using-a-caml-query","text":"You can get items from SharePoint using a CAML Query. import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml); // log resulting array to console console.log(r); If you need to get and expand a lookup field, there is a spread array parameter on the getItemsByCAMLQuery. This means that you can provide multiple properties to this method depending on how many lookup fields you are working with on your list. Below is a minimal example showing how to expand one field (RoleAssignment) import { ICamlQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const caml: ICamlQuery = { ViewXml: \"<View><ViewFields><FieldRef Name='Title' /><FieldRef Name='RoleAssignments' /></ViewFields><RowLimit>5</RowLimit></View>\", }; // get list items const r = await list.getItemsByCAMLQuery(caml, \"RoleAssignments\"); // log resulting item array to console console.log(r);","title":"Get list items using a CAML Query"},{"location":"v2/sp/lists/#get-list-items-changes-using-a-token","text":"import { IChangeLogItemQuery } from \"@pnp/sp/lists\"; // build the caml query object (in this example, we include Title field and limit rows to 5) const changeLogItemQuery: IChangeLogItemQuery = { Contains: `<Contains><FieldRef Name=\"Title\"/><Value Type=\"Text\">Item16</Value></Contains>`, QueryOptions: `<QueryOptions> <IncludeMandatoryColumns>FALSE</IncludeMandatoryColumns> <DateInUtc>False</DateInUtc> <IncludePermissions>TRUE</IncludePermissions> <IncludeAttachmentUrls>FALSE</IncludeAttachmentUrls> <Folder>My List</Folder></QueryOptions>`, }; // get list items const r = await list.getListItemChangesSinceToken(changeLogItemQuery); // log resulting XML to console console.log(r);","title":"Get list items changes using a Token"},{"location":"v2/sp/lists/#recycle-a-list","text":"Removes the list from the web's list collection and puts it in the recycle bin. await list.recycle();","title":"Recycle a list"},{"location":"v2/sp/lists/#render-list-data","text":"import { IRenderListData } from \"@pnp/sp/lists\"; // render list data, top 5 items const r: IRenderListData = await list.renderListData(\"<View><RowLimit>5</RowLimit></View>\"); // log array of items in response console.log(r.Row);","title":"Render list data"},{"location":"v2/sp/lists/#render-list-data-as-stream","text":"import { IRenderListDataParameters } from \"@pnp/sp/lists\"; // setup parameters object const renderListDataParams: IRenderListDataParameters = { ViewXml: \"<View><RowLimit>5</RowLimit></View>\", }; // render list data as stream const r = await list.renderListDataAsStream(renderListDataParams); // log array of items in response console.log(r.Row);","title":"Render list data as stream"},{"location":"v2/sp/lists/#reserve-list-item-id-for-idempotent-list-item-creation","text":"const listItemId = await list.reserveListItemId(); // log id to console console.log(listItemId);","title":"Reserve list item Id for idempotent list item creation"},{"location":"v2/sp/lists/#get-list-item-entity-type-name","text":"const entityTypeFullName = await list.getListItemEntityTypeFullName(); // log entity type name console.log(entityTypeFullName);","title":"Get list item entity type name"},{"location":"v2/sp/lists/#add-a-list-item-using-path-folder-validation-and-set-field-values","text":"const list = await sp.webs.lists.getByTitle(\"MyList\").select(\"Title\", \"ParentWebUrl\")(); const formValues: IListItemFormUpdateValue[] = [ { FieldName: \"Title\", FieldValue: title, }, ]; list.addValidateUpdateItemUsingPath(formValues,`${list.ParentWebUrl}/Lists/${list.Title}/MyFolder`)","title":"Add a list item using path (folder), validation and set field values"},{"location":"v2/sp/lists/#content-types-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"content-types imports"},{"location":"v2/sp/lists/#contenttypes","text":"Get all content types for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.contentTypes();","title":"contentTypes"},{"location":"v2/sp/lists/#fields-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"fields imports"},{"location":"v2/sp/lists/#fields","text":"Get all the fields for a list const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.fields(); Add a field to the site, then add the site field to a list const fld = await sp.site.rootWeb.fields.addText(\"MyField\"); await sp.web.lists.getByTitle(\"MyList\").fields.createFieldAsXml(fld.data.SchemaXml);","title":"fields"},{"location":"v2/sp/lists/#folders-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"folders imports"},{"location":"v2/sp/lists/#folders","text":"Get the root folder of a list. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.rootFolder();","title":"folders"},{"location":"v2/sp/lists/#forms-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/forms\"; Selective 2 import \"@pnp/sp/forms/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"forms imports"},{"location":"v2/sp/lists/#forms","text":"const r = await list.forms();","title":"forms"},{"location":"v2/sp/lists/#items-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/items\"; Selective 2 import \"@pnp/sp/items/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"items imports"},{"location":"v2/sp/lists/#items","text":"Get a collection of list items. const r = await list.items();","title":"items"},{"location":"v2/sp/lists/#views-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/views\"; Selective 2 import \"@pnp/sp/views/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"views imports"},{"location":"v2/sp/lists/#views","text":"Get the default view of the list const list = sp.web.lists.getByTitle(\"Documents\"); const views = await list.views(); const defaultView = await list.defaultView(); Get a list view by Id const view = await list.getView(defaultView.Id).select(\"Title\")();","title":"views"},{"location":"v2/sp/lists/#security-imports","text":"To work with list security, you can import the list methods as follows: import \"@pnp/sp/security/list\"; For more information on how to call security methods for lists, please refer to the @pnp/sp/security documentation.","title":"security imports"},{"location":"v2/sp/lists/#subscriptions-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/subscriptions\"; Selective 2 import \"@pnp/sp/subscriptions/list\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"subscriptions imports"},{"location":"v2/sp/lists/#subscriptions","text":"Get all subscriptions on the list const list = sp.web.lists.getByTitle(\"Documents\"); const subscriptions = await list.subscriptions();","title":"subscriptions"},{"location":"v2/sp/lists/#user-custom-actions-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"user-custom-actions imports"},{"location":"v2/sp/lists/#usercustomactions","text":"Get a collection of the list's user custom actions. const list = sp.web.lists.getByTitle(\"Documents\"); const r = await list.userCustomActions();","title":"userCustomActions"},{"location":"v2/sp/lists/#getparentinfos","text":"Added in 2.0.12 Gets information about an list, including details about the parent list root folder, and parent web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/items\"; const list = sp.web.lists.getByTitle(\"Documents\"); await list.getParentInfos();","title":"getParentInfos"},{"location":"v2/sp/navigation/","text":"@pnp/sp - navigation \u00b6 Navigation Service \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; getMenuState \u00b6 The MenuState service operation returns a Menu-State (dump) of a SiteMapProvider on a site. It will return an exception if the SiteMapProvider cannot be found on the site, the SiteMapProvider does not implement the IEditableSiteMapProvider interface or the SiteMapNode key cannot be found within the provider hierarchy. The IEditableSiteMapProvider also supports Custom Properties which is an optional feature. What will be return in the custom properties is up to the IEditableSiteMapProvider implementation and can differ for for each SiteMapProvider implementation. The custom properties can be requested by providing a comma separated string of property names like: property1,property2,property3\\,containingcomma NOTE: the , separator can be escaped using the \\ as escape character as done in the example above. The string above would split like: property1 property2 property3,containingcomma import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; // Will return a menu state of the default SiteMapProvider 'SPSiteMapProvider' where the dump starts a the RootNode (within the site) with a depth of 10 levels. const state = await sp.navigation.getMenuState(); // Will return the menu state of the 'SPSiteMapProvider', starting with the node with the key '1002' with a depth of 5 const state2 = await sp.navigation.getMenuState(\"1002\", 5); // Will return the menu state of the 'CurrentNavSiteMapProviderNoEncode' from the root node of the provider with a depth of 5 const state3 = await sp.navigation.getMenuState(null, 5, \"CurrentNavSiteMapProviderNoEncode\"); getMenuNodeKey \u00b6 Tries to get a SiteMapNode.Key for a given URL within a site collection. If the SiteMapNode cannot be found an Exception is returned. The method is using SiteMapProvider.FindSiteMapNodeFromKey(string rawUrl) to lookup the SiteMapNode. Depending on the actual implementation of FindSiteMapNodeFromKey the matching can differ for different SiteMapProviders. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; const key = await sp.navigation.getMenuNodeKey(\"/sites/dev/Lists/SPPnPJSExampleList/AllItems.aspx\"); Web Navigation \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; The navigation object contains two properties \"quicklaunch\" and \"topnavigationbar\". Both have the same set of methods so our examples below show use of only quicklaunch but apply equally to topnavigationbar. Get navigation \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const top = await sp.web.navigation.topNavigationBar(); const quick = await sp.web.navigation.quicklaunch(); For the following examples we will refer to a variable named \"nav\" that is understood to be one of topNavigationBar or quicklaunch. getById \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node = await nav.getById(3)(); add \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const result = await nav.add(\"Node Title\", \"/sites/dev/pages/mypage.aspx\", true); const nodeDataRaw = result.data; // request the data from the created node const nodeData = result.node(); moveAfter \u00b6 Places a navigation node after another node in the tree import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)} (1)`, url, true); const node2result = await nav.add(`Testing - ${getRandomString(4)} (2)`, url, true); const node1 = await node1result.node(); const node2 = await node2result.node(); await nav.moveAfter(node1.Id, node2.Id); Delete \u00b6 Deletes a given node import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)}`, url, true); let nodes = await nav(); // check we added a node let index = nodes.findIndex(n => n.Id === node1result.data.Id) // index >= 0 // delete a node await nav.getById(node1result.data.Id).delete(); nodes = await nav(); index = nodes.findIndex(n => n.Id === node1result.data.Id) // index = -1 Update \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; await nav.getById(4).update({ Title: \"A new title\", }); Children \u00b6 The children property of a Navigation Node represents a collection with all the same properties and methods available on topNavigationBar or quicklaunch. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const childrenData = await nav.getById(1).children(); // add a child await nav.getById(1).children.add(\"Title\", \"Url\", true);","title":"@pnp/sp - navigation"},{"location":"v2/sp/navigation/#pnpsp-navigation","text":"","title":"@pnp/sp - navigation"},{"location":"v2/sp/navigation/#navigation-service","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\";","title":"Navigation Service"},{"location":"v2/sp/navigation/#getmenustate","text":"The MenuState service operation returns a Menu-State (dump) of a SiteMapProvider on a site. It will return an exception if the SiteMapProvider cannot be found on the site, the SiteMapProvider does not implement the IEditableSiteMapProvider interface or the SiteMapNode key cannot be found within the provider hierarchy. The IEditableSiteMapProvider also supports Custom Properties which is an optional feature. What will be return in the custom properties is up to the IEditableSiteMapProvider implementation and can differ for for each SiteMapProvider implementation. The custom properties can be requested by providing a comma separated string of property names like: property1,property2,property3\\,containingcomma NOTE: the , separator can be escaped using the \\ as escape character as done in the example above. The string above would split like: property1 property2 property3,containingcomma import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; // Will return a menu state of the default SiteMapProvider 'SPSiteMapProvider' where the dump starts a the RootNode (within the site) with a depth of 10 levels. const state = await sp.navigation.getMenuState(); // Will return the menu state of the 'SPSiteMapProvider', starting with the node with the key '1002' with a depth of 5 const state2 = await sp.navigation.getMenuState(\"1002\", 5); // Will return the menu state of the 'CurrentNavSiteMapProviderNoEncode' from the root node of the provider with a depth of 5 const state3 = await sp.navigation.getMenuState(null, 5, \"CurrentNavSiteMapProviderNoEncode\");","title":"getMenuState"},{"location":"v2/sp/navigation/#getmenunodekey","text":"Tries to get a SiteMapNode.Key for a given URL within a site collection. If the SiteMapNode cannot be found an Exception is returned. The method is using SiteMapProvider.FindSiteMapNodeFromKey(string rawUrl) to lookup the SiteMapNode. Depending on the actual implementation of FindSiteMapNodeFromKey the matching can differ for different SiteMapProviders. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/navigation\"; const key = await sp.navigation.getMenuNodeKey(\"/sites/dev/Lists/SPPnPJSExampleList/AllItems.aspx\");","title":"getMenuNodeKey"},{"location":"v2/sp/navigation/#web-navigation","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; The navigation object contains two properties \"quicklaunch\" and \"topnavigationbar\". Both have the same set of methods so our examples below show use of only quicklaunch but apply equally to topnavigationbar.","title":"Web Navigation"},{"location":"v2/sp/navigation/#get-navigation","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const top = await sp.web.navigation.topNavigationBar(); const quick = await sp.web.navigation.quicklaunch(); For the following examples we will refer to a variable named \"nav\" that is understood to be one of topNavigationBar or quicklaunch.","title":"Get navigation"},{"location":"v2/sp/navigation/#getbyid","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node = await nav.getById(3)();","title":"getById"},{"location":"v2/sp/navigation/#add","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const result = await nav.add(\"Node Title\", \"/sites/dev/pages/mypage.aspx\", true); const nodeDataRaw = result.data; // request the data from the created node const nodeData = result.node();","title":"add"},{"location":"v2/sp/navigation/#moveafter","text":"Places a navigation node after another node in the tree import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)} (1)`, url, true); const node2result = await nav.add(`Testing - ${getRandomString(4)} (2)`, url, true); const node1 = await node1result.node(); const node2 = await node2result.node(); await nav.moveAfter(node1.Id, node2.Id);","title":"moveAfter"},{"location":"v2/sp/navigation/#delete","text":"Deletes a given node import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const node1result = await nav.add(`Testing - ${getRandomString(4)}`, url, true); let nodes = await nav(); // check we added a node let index = nodes.findIndex(n => n.Id === node1result.data.Id) // index >= 0 // delete a node await nav.getById(node1result.data.Id).delete(); nodes = await nav(); index = nodes.findIndex(n => n.Id === node1result.data.Id) // index = -1","title":"Delete"},{"location":"v2/sp/navigation/#update","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; await nav.getById(4).update({ Title: \"A new title\", });","title":"Update"},{"location":"v2/sp/navigation/#children","text":"The children property of a Navigation Node represents a collection with all the same properties and methods available on topNavigationBar or quicklaunch. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/navigation\"; const childrenData = await nav.getById(1).children(); // add a child await nav.getById(1).children.add(\"Title\", \"Url\", true);","title":"Children"},{"location":"v2/sp/permissions/","text":"@pnp/sp - permissions \u00b6 A common task is to determine if a user or the current user has a certain permission level. It is a great idea to check before performing a task such as creating a list to ensure a user can without getting back an error. This allows you to provide a better experience to the user. Permissions in SharePoint are assigned to the set of securable objects which include Site, Web, List, and List Item. These are the four level to which unique permissions can be assigned. As such @pnp/sp provides a set of methods defined in the QueryableSecurable class to handle these permissions. These examples all use the Web to get the values, however the methods work identically on all securables. Get Role Assignments \u00b6 This gets a collection of all the role assignments on a given securable. The property returns a RoleAssignments collection which supports the OData collection operators. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const roles = await sp.web.roleAssignments(); Logger.writeJSON(roles); First Unique Ancestor Securable Object \u00b6 This method can be used to find the securable parent up the hierarchy that has unique permissions. If everything inherits permissions this will be the Site. If a sub web has unique permissions it will be the web, and so on. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const obj = await sp.web.firstUniqueAncestorSecurableObject(); Logger.writeJSON(obj); User Effective Permissions \u00b6 This method returns the BasePermissions for a given user or the current user. This value contains the High and Low values for a user on the securable you have queried. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const perms = await sp.web.getUserEffectivePermissions(\"i:0#.f|membership|user@site.com\"); Logger.writeJSON(perms); const perms2 = await sp.web.getCurrentUserEffectivePermissions(); Logger.writeJSON(perms2); User Has Permissions \u00b6 Because the High and Low values in the BasePermission don't obviously mean anything you can use these methods along with the PermissionKind enumeration to check actual rights on the securable. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.userHasPermissions(\"i:0#.f|membership|user@site.com\", PermissionKind.ApproveItems); console.log(perms); const perms2 = await sp.web.currentUserHasPermissions(PermissionKind.ApproveItems); console.log(perms2); Has Permissions \u00b6 If you need to check multiple permissions it can be more efficient to get the BasePermissions once and then use the hasPermissions method to check them as shown below. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.getCurrentUserEffectivePermissions(); if (sp.web.hasPermissions(perms, PermissionKind.AddListItems) && sp.web.hasPermissions(perms, PermissionKind.DeleteVersions)) { // ... }","title":"@pnp/sp - permissions"},{"location":"v2/sp/permissions/#pnpsp-permissions","text":"A common task is to determine if a user or the current user has a certain permission level. It is a great idea to check before performing a task such as creating a list to ensure a user can without getting back an error. This allows you to provide a better experience to the user. Permissions in SharePoint are assigned to the set of securable objects which include Site, Web, List, and List Item. These are the four level to which unique permissions can be assigned. As such @pnp/sp provides a set of methods defined in the QueryableSecurable class to handle these permissions. These examples all use the Web to get the values, however the methods work identically on all securables.","title":"@pnp/sp - permissions"},{"location":"v2/sp/permissions/#get-role-assignments","text":"This gets a collection of all the role assignments on a given securable. The property returns a RoleAssignments collection which supports the OData collection operators. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const roles = await sp.web.roleAssignments(); Logger.writeJSON(roles);","title":"Get Role Assignments"},{"location":"v2/sp/permissions/#first-unique-ancestor-securable-object","text":"This method can be used to find the securable parent up the hierarchy that has unique permissions. If everything inherits permissions this will be the Site. If a sub web has unique permissions it will be the web, and so on. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const obj = await sp.web.firstUniqueAncestorSecurableObject(); Logger.writeJSON(obj);","title":"First Unique Ancestor Securable Object"},{"location":"v2/sp/permissions/#user-effective-permissions","text":"This method returns the BasePermissions for a given user or the current user. This value contains the High and Low values for a user on the securable you have queried. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/security\"; import { Logger } from \"@pnp/logging\"; const perms = await sp.web.getUserEffectivePermissions(\"i:0#.f|membership|user@site.com\"); Logger.writeJSON(perms); const perms2 = await sp.web.getCurrentUserEffectivePermissions(); Logger.writeJSON(perms2);","title":"User Effective Permissions"},{"location":"v2/sp/permissions/#user-has-permissions","text":"Because the High and Low values in the BasePermission don't obviously mean anything you can use these methods along with the PermissionKind enumeration to check actual rights on the securable. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.userHasPermissions(\"i:0#.f|membership|user@site.com\", PermissionKind.ApproveItems); console.log(perms); const perms2 = await sp.web.currentUserHasPermissions(PermissionKind.ApproveItems); console.log(perms2);","title":"User Has Permissions"},{"location":"v2/sp/permissions/#has-permissions","text":"If you need to check multiple permissions it can be more efficient to get the BasePermissions once and then use the hasPermissions method to check them as shown below. import { sp } from \"@pnp/sp\"; import { PermissionKind } from \"@pnp/sp/security\"; const perms = await sp.web.getCurrentUserEffectivePermissions(); if (sp.web.hasPermissions(perms, PermissionKind.AddListItems) && sp.web.hasPermissions(perms, PermissionKind.DeleteVersions)) { // ... }","title":"Has Permissions"},{"location":"v2/sp/profiles/","text":"@pnp/sp/profiles \u00b6 The profile services allows you to work with the SharePoint User Profile Store. Profiles \u00b6 Profiles is accessed directly from the root sp object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/profiles\"; Get edit profile link for the current user \u00b6 editProfileLink(): Promise<string> const editProfileLink = await sp.profiles.editProfileLink(); console.log(\"My edit profile link =\" + editProfileLink); Is My People List Public \u00b6 Provides a boolean that indicates if the current users \"People I'm Following\" list is public or not isMyPeopleListPublic(): Promise<boolean> const isPublic = await sp.profiles.isMyPeopleListPublic(); console.log(\"Is my Following list Public =\" + isPubic); Find out if the current user is followed by another user \u00b6 Provides a boolean that indicates if the current users is followed by a specific user. amIFollowedBy(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const isFollowedBy = await sp.profiles.amIFollowedBy(loginName); console.log(\"Is \" + loginName + \" following me? \" + isFollowedBy); Find out if I am following a specific user \u00b6 Provides a boolean that indicates if the current users is followed by a specific user. amIFollowing(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const following = await sp.profiles.amIFollowing(loginName); console.log(\"Am I following \" + loginName + \"? \" + following); Get the tags I follow \u00b6 Gets the tags the current user is following. Accepts max count, default is 20. getFollowedTags(maxCount = 20): Promise<string[]> const tags = await sp.profiles.getFollowedTags(); console.log(tags); Get followers for a specific user \u00b6 Gets the people who are following the specified user. getFollowersFor(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); }); Get followers for the current \u00b6 Gets the people who are following the current user. myFollowers(): ISharePointQueryableCollection const folowers = await sp.profiles.myFollowers(); console.log(folowers); Get the properties for the current user \u00b6 Gets user properties for the current user. myProperties(): _SharePointQueryableInstance const profile = await sp.profiles.myProperties(); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName); Gets people specified user is following \u00b6 getPeopleFollowedBy(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const folowers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); }); Gets properties for a specified user \u00b6 getPropertiesFor(loginName: string): Promise<any> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const profile = await sp.profiles.getPropertiesFor(loginName); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in inconvenient Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName); Gets most popular tags \u00b6 Gets the 20 most popular hash tags over the past week, sorted so that the most popular tag appears first trendingTags(): Promise<IHashTagCollection> const tags = await sp.profiles.trendingTags(); tags.Items.forEach((tag) => { console.log(tag); }); Gets specified user profile property for the specified user \u00b6 getUserProfilePropertyFor(loginName: string, propertyName: string): Promise<string> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"AccountName\"; const property = await sp.profiles.getUserProfilePropertyFor(loginName, propertyName); console.log(property); Hide specific user from list of suggested people \u00b6 Removes the specified user from the user's list of suggested people to follow. hideSuggestion(loginName: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.hideSuggestion(loginName); Is one user following another \u00b6 Indicates whether the first user is following the second user. First parameter is the account name of the user who might be following the followee. Second parameter is the account name of the user who might be followed by the follower. isFollowing(follower: string, followee: string): Promise<boolean> const follower = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followee = \"i:0#.f|membership|testuser2@mytenant.onmicrosoft.com\"; const isFollowing = await sp.profiles.isFollowing(follower, followee); console.log(isFollowing); Set User Profile Picture \u00b6 Uploads and sets the user profile picture (Users can upload a picture to their own profile only). Not supported for batching. Accepts the profilePicSource Blob data representing the user's picture in BMP, JPEG, or PNG format of up to 4.76MB. setMyProfilePic(profilePicSource: Blob): Promise<void> import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/profiles\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files\"; // get the blob object through a request or from a file input const blob = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.getByName(\"profile.jpg\").getBlob(); await sp.profiles.setMyProfilePic(blob); Sets single value User Profile property \u00b6 accountName The account name of the user propertyName Property name propertyValue Property value setSingleValueProfileProperty(accountName: string, propertyName: string, propertyValue: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.setSingleValueProfileProperty(loginName, \"CellPhone\", \"(123) 555-1212\"); Sets a mult-value User Profile property \u00b6 accountName The account name of the user propertyName Property name propertyValues Property values setMultiValuedProfileProperty(accountName: string, propertyName: string, propertyValues: string[]): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"SPS-Skills\"; const propertyValues = [\"SharePoint\", \"Office 365\", \"Architecture\", \"Azure\"]; await sp.profiles.setMultiValuedProfileProperty(loginName, propertyName, propertyValues); const profile = await sp.profiles.getPropertiesFor(loginName); var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(profile.userProperties[propertyName]); Create Personal Site for specified users \u00b6 Provisions one or more users' personal sites. (My Site administrator on SharePoint Online only) Emails The email addresses of the users to provision sites for createPersonalSiteEnqueueBulk(...emails: string[]): Promise<void> let userEmails: string[] = [\"testuser1@mytenant.onmicrosoft.com\", \"testuser2@mytenant.onmicrosoft.com\"]; await sp.profiles.createPersonalSiteEnqueueBulk(userEmails); Get the user profile of the owner for the current site \u00b6 ownerUserProfile(): Promise<IUserProfile> const profile = await sp.profiles.ownerUserProfile(); console.log(profile); Get the user profile of the current user \u00b6 userProfile(): Promise<any> const profile = await sp.profiles.userProfile(); console.log(profile); Create personal site for current user \u00b6 createPersonalSite(interactiveRequest = false): Promise<void> await sp.profiles.createPersonalSite(); Make all profile data public or private \u00b6 Set the privacy settings for all social data. shareAllSocialData(share: boolean): Promise<void> await sp.profiles.shareAllSocialData(true); Resolve a user or group \u00b6 Resolves user or group using specified query parameters clientPeoplePickerResolveUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result); Search a user or group \u00b6 Searches for users or groups using specified query parameters clientPeoplePickerSearchUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity[]> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result);","title":"@pnp/sp/profiles"},{"location":"v2/sp/profiles/#pnpspprofiles","text":"The profile services allows you to work with the SharePoint User Profile Store.","title":"@pnp/sp/profiles"},{"location":"v2/sp/profiles/#profiles","text":"Profiles is accessed directly from the root sp object. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/profiles\";","title":"Profiles"},{"location":"v2/sp/profiles/#get-edit-profile-link-for-the-current-user","text":"editProfileLink(): Promise<string> const editProfileLink = await sp.profiles.editProfileLink(); console.log(\"My edit profile link =\" + editProfileLink);","title":"Get edit profile link for the current user"},{"location":"v2/sp/profiles/#is-my-people-list-public","text":"Provides a boolean that indicates if the current users \"People I'm Following\" list is public or not isMyPeopleListPublic(): Promise<boolean> const isPublic = await sp.profiles.isMyPeopleListPublic(); console.log(\"Is my Following list Public =\" + isPubic);","title":"Is My People List Public"},{"location":"v2/sp/profiles/#find-out-if-the-current-user-is-followed-by-another-user","text":"Provides a boolean that indicates if the current users is followed by a specific user. amIFollowedBy(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const isFollowedBy = await sp.profiles.amIFollowedBy(loginName); console.log(\"Is \" + loginName + \" following me? \" + isFollowedBy);","title":"Find out if the current user is followed by another user"},{"location":"v2/sp/profiles/#find-out-if-i-am-following-a-specific-user","text":"Provides a boolean that indicates if the current users is followed by a specific user. amIFollowing(loginName: string): Promise<boolean> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const following = await sp.profiles.amIFollowing(loginName); console.log(\"Am I following \" + loginName + \"? \" + following);","title":"Find out if I am following a specific user"},{"location":"v2/sp/profiles/#get-the-tags-i-follow","text":"Gets the tags the current user is following. Accepts max count, default is 20. getFollowedTags(maxCount = 20): Promise<string[]> const tags = await sp.profiles.getFollowedTags(); console.log(tags);","title":"Get the tags I follow"},{"location":"v2/sp/profiles/#get-followers-for-a-specific-user","text":"Gets the people who are following the specified user. getFollowersFor(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); });","title":"Get followers for a specific user"},{"location":"v2/sp/profiles/#get-followers-for-the-current","text":"Gets the people who are following the current user. myFollowers(): ISharePointQueryableCollection const folowers = await sp.profiles.myFollowers(); console.log(folowers);","title":"Get followers for the current"},{"location":"v2/sp/profiles/#get-the-properties-for-the-current-user","text":"Gets user properties for the current user. myProperties(): _SharePointQueryableInstance const profile = await sp.profiles.myProperties(); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName);","title":"Get the properties for the current user"},{"location":"v2/sp/profiles/#gets-people-specified-user-is-following","text":"getPeopleFollowedBy(loginName: string): Promise<any[]> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const folowers = await sp.profiles.getFollowersFor(loginName); followers.forEach((value) => { console.log(value); });","title":"Gets people specified user is following"},{"location":"v2/sp/profiles/#gets-properties-for-a-specified-user","text":"getPropertiesFor(loginName: string): Promise<any> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const profile = await sp.profiles.getPropertiesFor(loginName); console.log(profile.DisplayName); console.log(profile.Email); console.log(profile.Title); console.log(profile.UserProfileProperties.length); // Properties are stored in inconvenient Key/Value pairs, // so parse into an object called userProperties var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(\"Account Name: \" + profile.userProperties.AccountName);","title":"Gets properties for a specified user"},{"location":"v2/sp/profiles/#gets-most-popular-tags","text":"Gets the 20 most popular hash tags over the past week, sorted so that the most popular tag appears first trendingTags(): Promise<IHashTagCollection> const tags = await sp.profiles.trendingTags(); tags.Items.forEach((tag) => { console.log(tag); });","title":"Gets most popular tags"},{"location":"v2/sp/profiles/#gets-specified-user-profile-property-for-the-specified-user","text":"getUserProfilePropertyFor(loginName: string, propertyName: string): Promise<string> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"AccountName\"; const property = await sp.profiles.getUserProfilePropertyFor(loginName, propertyName); console.log(property);","title":"Gets specified user profile property for the specified user"},{"location":"v2/sp/profiles/#hide-specific-user-from-list-of-suggested-people","text":"Removes the specified user from the user's list of suggested people to follow. hideSuggestion(loginName: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.hideSuggestion(loginName);","title":"Hide specific user from list of suggested people"},{"location":"v2/sp/profiles/#is-one-user-following-another","text":"Indicates whether the first user is following the second user. First parameter is the account name of the user who might be following the followee. Second parameter is the account name of the user who might be followed by the follower. isFollowing(follower: string, followee: string): Promise<boolean> const follower = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const followee = \"i:0#.f|membership|testuser2@mytenant.onmicrosoft.com\"; const isFollowing = await sp.profiles.isFollowing(follower, followee); console.log(isFollowing);","title":"Is one user following another"},{"location":"v2/sp/profiles/#set-user-profile-picture","text":"Uploads and sets the user profile picture (Users can upload a picture to their own profile only). Not supported for batching. Accepts the profilePicSource Blob data representing the user's picture in BMP, JPEG, or PNG format of up to 4.76MB. setMyProfilePic(profilePicSource: Blob): Promise<void> import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/profiles\"; import \"@pnp/sp/folders\"; import \"@pnp/sp/files\"; // get the blob object through a request or from a file input const blob = await sp.web.lists.getByTitle(\"Documents\").rootFolder.files.getByName(\"profile.jpg\").getBlob(); await sp.profiles.setMyProfilePic(blob);","title":"Set User Profile Picture"},{"location":"v2/sp/profiles/#sets-single-value-user-profile-property","text":"accountName The account name of the user propertyName Property name propertyValue Property value setSingleValueProfileProperty(accountName: string, propertyName: string, propertyValue: string): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; await sp.profiles.setSingleValueProfileProperty(loginName, \"CellPhone\", \"(123) 555-1212\");","title":"Sets single value User Profile property"},{"location":"v2/sp/profiles/#sets-a-mult-value-user-profile-property","text":"accountName The account name of the user propertyName Property name propertyValues Property values setMultiValuedProfileProperty(accountName: string, propertyName: string, propertyValues: string[]): Promise<void> const loginName = \"i:0#.f|membership|testuser@mytenant.onmicrosoft.com\"; const propertyName = \"SPS-Skills\"; const propertyValues = [\"SharePoint\", \"Office 365\", \"Architecture\", \"Azure\"]; await sp.profiles.setMultiValuedProfileProperty(loginName, propertyName, propertyValues); const profile = await sp.profiles.getPropertiesFor(loginName); var props = {}; profile.UserProfileProperties.forEach((prop) => { props[prop.Key] = prop.Value; }); profile.userProperties = props; console.log(profile.userProperties[propertyName]);","title":"Sets a mult-value User Profile property"},{"location":"v2/sp/profiles/#create-personal-site-for-specified-users","text":"Provisions one or more users' personal sites. (My Site administrator on SharePoint Online only) Emails The email addresses of the users to provision sites for createPersonalSiteEnqueueBulk(...emails: string[]): Promise<void> let userEmails: string[] = [\"testuser1@mytenant.onmicrosoft.com\", \"testuser2@mytenant.onmicrosoft.com\"]; await sp.profiles.createPersonalSiteEnqueueBulk(userEmails);","title":"Create Personal Site for specified users"},{"location":"v2/sp/profiles/#get-the-user-profile-of-the-owner-for-the-current-site","text":"ownerUserProfile(): Promise<IUserProfile> const profile = await sp.profiles.ownerUserProfile(); console.log(profile);","title":"Get the user profile of the owner for the current site"},{"location":"v2/sp/profiles/#get-the-user-profile-of-the-current-user","text":"userProfile(): Promise<any> const profile = await sp.profiles.userProfile(); console.log(profile);","title":"Get the user profile of the current user"},{"location":"v2/sp/profiles/#create-personal-site-for-current-user","text":"createPersonalSite(interactiveRequest = false): Promise<void> await sp.profiles.createPersonalSite();","title":"Create personal site for current user"},{"location":"v2/sp/profiles/#make-all-profile-data-public-or-private","text":"Set the privacy settings for all social data. shareAllSocialData(share: boolean): Promise<void> await sp.profiles.shareAllSocialData(true);","title":"Make all profile data public or private"},{"location":"v2/sp/profiles/#resolve-a-user-or-group","text":"Resolves user or group using specified query parameters clientPeoplePickerResolveUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result);","title":"Resolve a user or group"},{"location":"v2/sp/profiles/#search-a-user-or-group","text":"Searches for users or groups using specified query parameters clientPeoplePickerSearchUser(queryParams: IClientPeoplePickerQueryParameters): Promise<IPeoplePickerEntity[]> const result = await sp.profiles.clientPeoplePickerSearchUser({ AllowEmailAddresses: true, AllowMultipleEntities: false, MaximumEntitySuggestions: 25, QueryString: 'John' }); console.log(result);","title":"Search a user or group"},{"location":"v2/sp/regional-settings/","text":"@pnp/sp/regional-settings \u00b6 The regional settings module helps with managing dates and times across various timezones. IRegionalSettings \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IRegionalSettings, ITimeZone, ITimeZones, RegionalSettings, TimeZone, TimeZones, } from \"@pnp/sp/regional-settings\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get all the web's regional settings const s = await sp.web.regionalSettings(); // select only some settings to return const s2 = await sp.web.regionalSettings.select(\"DecimalSeparator\", \"ListSeparator\", \"IsUIRightToLeft\")(); Installed Languages \u00b6 You can get a list of the installed languages in the web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; const s = await sp.web.regionalSettings.getInstalledLanguages(); The installedLanguages property accessor is deprecated after 2.0.4 in favor of getInstalledLanguages and will be removed in future versions. TimeZones \u00b6 You can also get information about the selected timezone in the web and all of the defined timezones. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get the web's configured timezone const s = await sp.web.regionalSettings.timeZone(); // select just the Description and Id const s2 = await sp.web.regionalSettings.timeZone.select(\"Description\", \"Id\")(); // get all the timezones const s3 = await sp.web.regionalSettings.timeZones(); // get a specific timezone by id // list of ids: https://msdn.microsoft.com/en-us/library/office/jj247008.aspx const s4 = await sp.web.regionalSettings.timeZones.getById(23); const s5 = await s.localTimeToUTC(new Date()); // convert a given date from web's local time to UTC time const s6 = await sp.web.regionalSettings.timeZone.localTimeToUTC(new Date()); // convert a given date from UTC time to web's local time const s6 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date()) const s7 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date(2019, 6, 10, 10, 0, 0, 0)) Title and Description Resources \u00b6 Added in 2.0.4 Some objects allow you to read language specific title information as shown in the following sample. This applies to Web, List, Field, Content Type, and User Custom Actions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; // // The below methods appears on // - Web // - List // - Field // - ContentType // - User Custom Action // // after you import @pnp/sp/regional-settings // // you can also import just parts of the regional settings: // import \"@pnp/sp/regional-settings/web\"; // import \"@pnp/sp/regional-settings/list\"; // import \"@pnp/sp/regional-settings/content-type\"; // import \"@pnp/sp/regional-settings/field\"; // import \"@pnp/sp/regional-settings/user-custom-actions\"; const title = await sp.web.titleResource(\"en-us\"); const title2 = await sp.web.titleResource(\"de-de\"); const description = await sp.web.descriptionResource(\"en-us\"); const description2 = await sp.web.descriptionResource(\"de-de\"); You can only read the values through the REST API, not set the value.","title":"@pnp/sp/regional-settings"},{"location":"v2/sp/regional-settings/#pnpspregional-settings","text":"The regional settings module helps with managing dates and times across various timezones.","title":"@pnp/sp/regional-settings"},{"location":"v2/sp/regional-settings/#iregionalsettings","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import { IRegionalSettings, ITimeZone, ITimeZones, RegionalSettings, TimeZone, TimeZones, } from \"@pnp/sp/regional-settings\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get all the web's regional settings const s = await sp.web.regionalSettings(); // select only some settings to return const s2 = await sp.web.regionalSettings.select(\"DecimalSeparator\", \"ListSeparator\", \"IsUIRightToLeft\")();","title":"IRegionalSettings"},{"location":"v2/sp/regional-settings/#installed-languages","text":"You can get a list of the installed languages in the web. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; const s = await sp.web.regionalSettings.getInstalledLanguages(); The installedLanguages property accessor is deprecated after 2.0.4 in favor of getInstalledLanguages and will be removed in future versions.","title":"Installed Languages"},{"location":"v2/sp/regional-settings/#timezones","text":"You can also get information about the selected timezone in the web and all of the defined timezones. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings/web\"; // get the web's configured timezone const s = await sp.web.regionalSettings.timeZone(); // select just the Description and Id const s2 = await sp.web.regionalSettings.timeZone.select(\"Description\", \"Id\")(); // get all the timezones const s3 = await sp.web.regionalSettings.timeZones(); // get a specific timezone by id // list of ids: https://msdn.microsoft.com/en-us/library/office/jj247008.aspx const s4 = await sp.web.regionalSettings.timeZones.getById(23); const s5 = await s.localTimeToUTC(new Date()); // convert a given date from web's local time to UTC time const s6 = await sp.web.regionalSettings.timeZone.localTimeToUTC(new Date()); // convert a given date from UTC time to web's local time const s6 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date()) const s7 = await sp.web.regionalSettings.timeZone.utcToLocalTime(new Date(2019, 6, 10, 10, 0, 0, 0))","title":"TimeZones"},{"location":"v2/sp/regional-settings/#title-and-description-resources","text":"Added in 2.0.4 Some objects allow you to read language specific title information as shown in the following sample. This applies to Web, List, Field, Content Type, and User Custom Actions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/regional-settings\"; // // The below methods appears on // - Web // - List // - Field // - ContentType // - User Custom Action // // after you import @pnp/sp/regional-settings // // you can also import just parts of the regional settings: // import \"@pnp/sp/regional-settings/web\"; // import \"@pnp/sp/regional-settings/list\"; // import \"@pnp/sp/regional-settings/content-type\"; // import \"@pnp/sp/regional-settings/field\"; // import \"@pnp/sp/regional-settings/user-custom-actions\"; const title = await sp.web.titleResource(\"en-us\"); const title2 = await sp.web.titleResource(\"de-de\"); const description = await sp.web.descriptionResource(\"en-us\"); const description2 = await sp.web.descriptionResource(\"de-de\"); You can only read the values through the REST API, not set the value.","title":"Title and Description Resources"},{"location":"v2/sp/related-items/","text":"@pnp/sp/related-items \u00b6 The related items API allows you to add related items to items within a task or workflow list. Related items need to be in the same site collection. Setup \u00b6 Instead of copying this block of code into each sample, understand that each sample is meant to run with this supporting code to work. import { sp, extractWebUrl } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/related-items/web\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import \"@pnp/sp/files/list\"; import { IList } from \"@pnp/sp/lists\"; import { getRandomString } from \"@pnp/core\"; // setup some lists (or just use existing ones this is just to show the complete process) // we need two lists to use for creating related items, they need to use template 107 (task list) const ler1 = await sp.web.lists.ensure(\"RelatedItemsSourceList\", \"\", 107); const ler2 = await sp.web.lists.ensure(\"RelatedItemsTargetList\", \"\", 107); const sourceList = ler1.list; const targetList = ler2.list; const sourceListName = await sourceList.select(\"Id\")().then(r => r.Id); const targetListName = await targetList.select(\"Id\")().then(r => r.Id); // or whatever you need to get the web url, both our example lists are in the same web. const webUrl = sp.web.toUrl(); // ...individual samples start here addSingleLink \u00b6 const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); addSingleLinkToUrl \u00b6 This method adds a link to task item based on a url. The list name and item id are to the task item, the url is to the related item/document. // get a file's server relative url in some manner, here we add one const file = await sp.web.defaultDocumentLibrary.rootFolder.files.add(`file_${getRandomString(4)}.txt`, \"Content\", true).then(r => r.data); // add an item or get an item from the task list const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLinkToUrl(targetListName, targetItem.Id, file.ServerRelativeUrl); addSingleLinkFromUrl \u00b6 This method adds a link to task item based on a url. The list name and item id are to related item, the url is to task item to which the related reference is being added. I haven't found a use case for this method. deleteSingleLink \u00b6 This method allows you to delete a link previously created. const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add the link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); // delete the link await sp.web.relatedItems.deleteSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); getRelatedItems \u00b6 Gets the related items for an item import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getRelatedItems(sourceListName, sourceItem.Id); // items.length === 2 Related items are defined by the IRelatedItem interface export interface IRelatedItem { ListId: string; ItemId: number; Url: string; Title: string; WebId: string; IconUrl: string; } getPageOneRelatedItems \u00b6 Gets an abbreviated set of related items import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getPageOneRelatedItems(sourceListName, sourceItem.Id); // items.length === 2","title":"@pnp/sp/related-items"},{"location":"v2/sp/related-items/#pnpsprelated-items","text":"The related items API allows you to add related items to items within a task or workflow list. Related items need to be in the same site collection.","title":"@pnp/sp/related-items"},{"location":"v2/sp/related-items/#setup","text":"Instead of copying this block of code into each sample, understand that each sample is meant to run with this supporting code to work. import { sp, extractWebUrl } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/related-items/web\"; import \"@pnp/sp/lists/web\"; import \"@pnp/sp/items/list\"; import \"@pnp/sp/files/list\"; import { IList } from \"@pnp/sp/lists\"; import { getRandomString } from \"@pnp/core\"; // setup some lists (or just use existing ones this is just to show the complete process) // we need two lists to use for creating related items, they need to use template 107 (task list) const ler1 = await sp.web.lists.ensure(\"RelatedItemsSourceList\", \"\", 107); const ler2 = await sp.web.lists.ensure(\"RelatedItemsTargetList\", \"\", 107); const sourceList = ler1.list; const targetList = ler2.list; const sourceListName = await sourceList.select(\"Id\")().then(r => r.Id); const targetListName = await targetList.select(\"Id\")().then(r => r.Id); // or whatever you need to get the web url, both our example lists are in the same web. const webUrl = sp.web.toUrl(); // ...individual samples start here","title":"Setup"},{"location":"v2/sp/related-items/#addsinglelink","text":"const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl);","title":"addSingleLink"},{"location":"v2/sp/related-items/#addsinglelinktourl","text":"This method adds a link to task item based on a url. The list name and item id are to the task item, the url is to the related item/document. // get a file's server relative url in some manner, here we add one const file = await sp.web.defaultDocumentLibrary.rootFolder.files.add(`file_${getRandomString(4)}.txt`, \"Content\", true).then(r => r.data); // add an item or get an item from the task list const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); await sp.web.relatedItems.addSingleLinkToUrl(targetListName, targetItem.Id, file.ServerRelativeUrl);","title":"addSingleLinkToUrl"},{"location":"v2/sp/related-items/#addsinglelinkfromurl","text":"This method adds a link to task item based on a url. The list name and item id are to related item, the url is to task item to which the related reference is being added. I haven't found a use case for this method.","title":"addSingleLinkFromUrl"},{"location":"v2/sp/related-items/#deletesinglelink","text":"This method allows you to delete a link previously created. const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add the link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); // delete the link await sp.web.relatedItems.deleteSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl);","title":"deleteSingleLink"},{"location":"v2/sp/related-items/#getrelateditems","text":"Gets the related items for an item import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getRelatedItems(sourceListName, sourceItem.Id); // items.length === 2 Related items are defined by the IRelatedItem interface export interface IRelatedItem { ListId: string; ItemId: number; Url: string; Title: string; WebId: string; IconUrl: string; }","title":"getRelatedItems"},{"location":"v2/sp/related-items/#getpageonerelateditems","text":"Gets an abbreviated set of related items import { IRelatedItem } from \"@pnp/sp/related-items\"; const sourceItem = await sourceList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); const targetItem = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem.Id, webUrl); const targetItem2 = await targetList.items.add({ Title: `Item ${getRandomString(4)}` }).then(r => r.data); // add a link await sp.web.relatedItems.addSingleLink(sourceListName, sourceItem.Id, webUrl, targetListName, targetItem2.Id, webUrl); const items: IRelatedItem[] = await sp.web.relatedItems.getPageOneRelatedItems(sourceListName, sourceItem.Id); // items.length === 2","title":"getPageOneRelatedItems"},{"location":"v2/sp/search/","text":"@pnp/sp/search \u00b6 Using search you can access content throughout your organization in a secure and consistent manner. The library provides support for searching and suggest - as well as some interfaces and helper classes to make building your queries and processing responses easier. Search \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults } from \"@pnp/sp/search\"; Preset: All import { sp, ISearchQuery, SearchResults } from \"@pnp/sp/presets/all\"; Search is accessed directly from the root sp object and can take either a string representing the query text, a plain object matching the ISearchQuery interface, or a SearchQueryBuilder instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // text search using SharePoint default values for other parameters const results: SearchResults = await sp.search(\"test\"); console.log(results.ElapsedTime); console.log(results.RowCount); console.log(results.PrimarySearchResults); // define a search query object matching the ISearchQuery interface const results2: SearchResults = await sp.search(<ISearchQuery>{ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, }); console.log(results2.ElapsedTime); console.log(results2.RowCount); console.log(results2.PrimarySearchResults); // define a query using a builder const builder = SearchQueryBuilder(\"test\").rowLimit(10).enableInterleaving.enableQueryRules.processPersonalFavorites; const results3 = await sp.search(builder); console.log(results3.ElapsedTime); console.log(results3.RowCount); console.log(results3.PrimarySearchResults); Search Result Caching \u00b6 You can use the searchWithCaching method to enable cache support for your search results this option works with any of the options for providing a query, just replace \"search\" with \"searchWithCaching\" in your method chain and gain all the benefits of caching. The second parameter is optional and allows you to specify the cache options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; sp.searchWithCaching({ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, } as ISearchQuery).then((r: SearchResults) => { console.log(r.ElapsedTime); console.log(r.RowCount); console.log(r.PrimarySearchResults); }); // use a query builder const builder = SearchQueryBuilder(\"test\").rowLimit(3); // supply a search query builder and caching options const results2 = await sp.searchWithCaching(builder, { key: \"mykey\", expiration: dateAdd(new Date(), \"month\", 1) }); console.log(results2.TotalRows); Paging with SearchResults.getPage \u00b6 Paging is controlled by a start row and page size parameter. You can specify both arguments in your initial query however you can use the getPage method to jump to any page. The second parameter page size is optional and will use the previous RowLimit or default to 10. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // this will hold our current results let currentResults: SearchResults = null; let page = 1; // triggered on page load or through some other means function onStart() { // construct our query that will be used throughout the paging process, likely from user input const q = SearchQueryBuilder(\"test\").rowLimit(5); const results = await sp.search(q); currentResults = results; // set the current results page = 1; // reset page counter // update UI... } // triggered by an event async function next() { currentResults = await currentResults.getPage(++page); // update UI... } // triggered by an event async function prev() { currentResults = await currentResults.getPage(--page); // update UI... } SearchQueryBuilder \u00b6 The SearchQueryBuilder allows you to build your queries in a fluent manner. It also accepts constructor arguments for query text and a base query plain object, should you have a shared configuration for queries in an application you can define them once. The methods and properties match those on the SearchQuery interface. Boolean properties add the flag to the query while methods require that you supply one or more arguments. Also arguments supplied later in the chain will overwrite previous values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchQueryBuilder, SearchResults, ISearchQuery } from \"@pnp/sp/search\"; // basic usage let q = SearchQueryBuilder().text(\"test\").rowLimit(4).enablePhonetic; sp.search(q).then(h => { /* ... */ }); // provide a default query text at creation let q2 = SearchQueryBuilder(\"text\").rowLimit(4).enablePhonetic; const results: SearchResults = await sp.search(q2); // provide query text and a template for // shared settings across queries that can // be overwritten by individual builders const appSearchSettings: ISearchQuery = { EnablePhonetic: true, HiddenConstraints: \"reports\" }; let q3 = SearchQueryBuilder(\"test\", appSearchSettings).enableQueryRules; let q4 = SearchQueryBuilder(\"financial data\", appSearchSettings).enableSorting.enableStemming; const results2 = await sp.search(q3); const results3 = sp.search(q4); Search Suggest \u00b6 Search suggest works in much the same way as search, except against the suggest end point. It takes a string or a plain object that matches ISuggestQuery. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISuggestQuery, ISuggestResult } from \"@pnp/sp/search\"; const results = await sp.searchSuggest(\"test\"); const results2 = await sp.searchSuggest({ querytext: \"test\", count: 5, } as ISuggestQuery); Search Factory \u00b6 You can also configure a search or suggest query against any valid SP url using the factory methods. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { Search, Suggest } from \"@pnp/sp/search\"; // set the url for search const searcher = Search(\"https://mytenant.sharepoint.com/sites/dev\"); // this can accept any of the query types (text, ISearchQuery, or SearchQueryBuilder) const results = await searcher(\"test\"); // you can reuse the ISearch instance const results2 = await searcher(\"another query\"); // same process works for Suggest const suggester = Suggest(\"https://mytenant.sharepoint.com/sites/dev\"); const suggestions = await suggester({ querytext: \"test\" });","title":"@pnp/sp/search"},{"location":"v2/sp/search/#pnpspsearch","text":"Using search you can access content throughout your organization in a secure and consistent manner. The library provides support for searching and suggest - as well as some interfaces and helper classes to make building your queries and processing responses easier.","title":"@pnp/sp/search"},{"location":"v2/sp/search/#search","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults } from \"@pnp/sp/search\"; Preset: All import { sp, ISearchQuery, SearchResults } from \"@pnp/sp/presets/all\"; Search is accessed directly from the root sp object and can take either a string representing the query text, a plain object matching the ISearchQuery interface, or a SearchQueryBuilder instance. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // text search using SharePoint default values for other parameters const results: SearchResults = await sp.search(\"test\"); console.log(results.ElapsedTime); console.log(results.RowCount); console.log(results.PrimarySearchResults); // define a search query object matching the ISearchQuery interface const results2: SearchResults = await sp.search(<ISearchQuery>{ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, }); console.log(results2.ElapsedTime); console.log(results2.RowCount); console.log(results2.PrimarySearchResults); // define a query using a builder const builder = SearchQueryBuilder(\"test\").rowLimit(10).enableInterleaving.enableQueryRules.processPersonalFavorites; const results3 = await sp.search(builder); console.log(results3.ElapsedTime); console.log(results3.RowCount); console.log(results3.PrimarySearchResults);","title":"Search"},{"location":"v2/sp/search/#search-result-caching","text":"You can use the searchWithCaching method to enable cache support for your search results this option works with any of the options for providing a query, just replace \"search\" with \"searchWithCaching\" in your method chain and gain all the benefits of caching. The second parameter is optional and allows you to specify the cache options import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISearchQuery, SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; sp.searchWithCaching({ Querytext: \"test\", RowLimit: 10, EnableInterleaving: true, } as ISearchQuery).then((r: SearchResults) => { console.log(r.ElapsedTime); console.log(r.RowCount); console.log(r.PrimarySearchResults); }); // use a query builder const builder = SearchQueryBuilder(\"test\").rowLimit(3); // supply a search query builder and caching options const results2 = await sp.searchWithCaching(builder, { key: \"mykey\", expiration: dateAdd(new Date(), \"month\", 1) }); console.log(results2.TotalRows);","title":"Search Result Caching"},{"location":"v2/sp/search/#paging-with-searchresultsgetpage","text":"Paging is controlled by a start row and page size parameter. You can specify both arguments in your initial query however you can use the getPage method to jump to any page. The second parameter page size is optional and will use the previous RowLimit or default to 10. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchResults, SearchQueryBuilder } from \"@pnp/sp/search\"; // this will hold our current results let currentResults: SearchResults = null; let page = 1; // triggered on page load or through some other means function onStart() { // construct our query that will be used throughout the paging process, likely from user input const q = SearchQueryBuilder(\"test\").rowLimit(5); const results = await sp.search(q); currentResults = results; // set the current results page = 1; // reset page counter // update UI... } // triggered by an event async function next() { currentResults = await currentResults.getPage(++page); // update UI... } // triggered by an event async function prev() { currentResults = await currentResults.getPage(--page); // update UI... }","title":"Paging with SearchResults.getPage"},{"location":"v2/sp/search/#searchquerybuilder","text":"The SearchQueryBuilder allows you to build your queries in a fluent manner. It also accepts constructor arguments for query text and a base query plain object, should you have a shared configuration for queries in an application you can define them once. The methods and properties match those on the SearchQuery interface. Boolean properties add the flag to the query while methods require that you supply one or more arguments. Also arguments supplied later in the chain will overwrite previous values. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { SearchQueryBuilder, SearchResults, ISearchQuery } from \"@pnp/sp/search\"; // basic usage let q = SearchQueryBuilder().text(\"test\").rowLimit(4).enablePhonetic; sp.search(q).then(h => { /* ... */ }); // provide a default query text at creation let q2 = SearchQueryBuilder(\"text\").rowLimit(4).enablePhonetic; const results: SearchResults = await sp.search(q2); // provide query text and a template for // shared settings across queries that can // be overwritten by individual builders const appSearchSettings: ISearchQuery = { EnablePhonetic: true, HiddenConstraints: \"reports\" }; let q3 = SearchQueryBuilder(\"test\", appSearchSettings).enableQueryRules; let q4 = SearchQueryBuilder(\"financial data\", appSearchSettings).enableSorting.enableStemming; const results2 = await sp.search(q3); const results3 = sp.search(q4);","title":"SearchQueryBuilder"},{"location":"v2/sp/search/#search-suggest","text":"Search suggest works in much the same way as search, except against the suggest end point. It takes a string or a plain object that matches ISuggestQuery. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { ISuggestQuery, ISuggestResult } from \"@pnp/sp/search\"; const results = await sp.searchSuggest(\"test\"); const results2 = await sp.searchSuggest({ querytext: \"test\", count: 5, } as ISuggestQuery);","title":"Search Suggest"},{"location":"v2/sp/search/#search-factory","text":"You can also configure a search or suggest query against any valid SP url using the factory methods. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/search\"; import { Search, Suggest } from \"@pnp/sp/search\"; // set the url for search const searcher = Search(\"https://mytenant.sharepoint.com/sites/dev\"); // this can accept any of the query types (text, ISearchQuery, or SearchQueryBuilder) const results = await searcher(\"test\"); // you can reuse the ISearch instance const results2 = await searcher(\"another query\"); // same process works for Suggest const suggester = Suggest(\"https://mytenant.sharepoint.com/sites/dev\"); const suggestions = await suggester({ querytext: \"test\" });","title":"Search Factory"},{"location":"v2/sp/security/","text":"@pnp/sp/security \u00b6 There are four levels where you can break inheritance and assign security: Site, Web, List, Item. All four of these objects share a common set of methods. Because of this we are showing in the examples below usage of these methods for an IList instance, but they apply across all four securable objects. In addition to the shared methods, some types have unique methods which are listed below. Site permissions are managed on the root web of the site collection. A Note on Selective Imports for Security \u00b6 Because the method are shared you can opt to import only the methods for one of the instances. import \"@pnp/sp/security/web\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/security/item\"; Possibly useful if you are trying to hyper-optimize for bundle size but it is just as easy to import the whole module: import \"@pnp/sp/security\"; Securable Methods \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // role assignments (see section below) await list.roleAssignments(); // data will represent one of the possible parents Site, Web, or List const data = await list.firstUniqueAncestorSecurableObject(); // getUserEffectivePermissions const users = await sp.web.siteUsers.top(1).select(\"LoginName\")(); const perms = await list.getUserEffectivePermissions(users[0].LoginName); // getCurrentUserEffectivePermissions const perms2 = list.getCurrentUserEffectivePermissions(); // userHasPermissions const v: boolean = list.userHasPermissions(users[0].LoginName, PermissionKind.AddListItems) // currentUserHasPermissions const v2: boolean = list.currentUserHasPermissions(PermissionKind.AddListItems) // breakRoleInheritance await list.breakRoleInheritance(); // copy existing permissions await list.breakRoleInheritance(true); // copy existing permissions and reset all child securables to the new permissions await list.breakRoleInheritance(true, true); // resetRoleInheritance await list.resetRoleInheritance(); Web Specific methods \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // role definitions (see section below) const defs = await sp.web.roleDefinitions(); Role Assignments \u00b6 Allows you to list and manipulate the set of role assignments for the given securable. Again we show usage using list, but the examples apply to web and item as well. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/web\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // list role assignments const assignments = await list.roleAssignments(); // add a role assignment const defs = await sp.web.roleDefinitions(); const user = await sp.web.currentUser(); const r = await list.roleAssignments.add(user.Id, defs[0].Id); // remove a role assignment const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); const r = await list.roleAssignments.remove(ra.Id); // read role assignment info const info = await list.roleAssignments.getById(ra.Id)(); // get the groups const info2 = await list.roleAssignments.getById(ra.Id).groups(); // get the bindings const info3 = await list.roleAssignments.getById(ra.Id).bindings(); // delete a role assignment (same as remove) const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); // delete it await list.roleAssignments.getById(ra.Id).delete(); Role Definitions \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // read role definitions const defs = await sp.web.roleDefinitions(); // get by id const def = await sp.web.roleDefinitions.getById(5)(); const def = await sp.web.roleDefinitions.getById(5).select(\"Name\", \"Order\")(); // get by name const def = await sp.web.roleDefinitions.getByName(\"Full Control\")(); const def = await sp.web.roleDefinitions.getByName(\"Full Control\").select(\"Name\", \"Order\")(); // get by type const def = await sp.web.roleDefinitions.getByName(5)(); const def = await sp.web.roleDefinitions.getByName(5).select(\"Name\", \"Order\")(); // add // name The new role definition's name // description The new role definition's description // order The order in which the role definition appears // basePermissions The permissions mask for this role definition const rdar = await sp.web.roleDefinitions.add(\"title\", \"description\", 99, { High: 1, Low: 2 }); // the following methods work on a single role def, you can use any of the three getBy methods, here we use getById as an example // delete await sp.web.roleDefinitions.getById(5).delete(); // update const res = sp.web.roleDefinitions.getById(5).update({ Name: \"New Name\" });","title":"@pnp/sp/security"},{"location":"v2/sp/security/#pnpspsecurity","text":"There are four levels where you can break inheritance and assign security: Site, Web, List, Item. All four of these objects share a common set of methods. Because of this we are showing in the examples below usage of these methods for an IList instance, but they apply across all four securable objects. In addition to the shared methods, some types have unique methods which are listed below. Site permissions are managed on the root web of the site collection.","title":"@pnp/sp/security"},{"location":"v2/sp/security/#a-note-on-selective-imports-for-security","text":"Because the method are shared you can opt to import only the methods for one of the instances. import \"@pnp/sp/security/web\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/security/item\"; Possibly useful if you are trying to hyper-optimize for bundle size but it is just as easy to import the whole module: import \"@pnp/sp/security\";","title":"A Note on Selective Imports for Security"},{"location":"v2/sp/security/#securable-methods","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/list\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // role assignments (see section below) await list.roleAssignments(); // data will represent one of the possible parents Site, Web, or List const data = await list.firstUniqueAncestorSecurableObject(); // getUserEffectivePermissions const users = await sp.web.siteUsers.top(1).select(\"LoginName\")(); const perms = await list.getUserEffectivePermissions(users[0].LoginName); // getCurrentUserEffectivePermissions const perms2 = list.getCurrentUserEffectivePermissions(); // userHasPermissions const v: boolean = list.userHasPermissions(users[0].LoginName, PermissionKind.AddListItems) // currentUserHasPermissions const v2: boolean = list.currentUserHasPermissions(PermissionKind.AddListItems) // breakRoleInheritance await list.breakRoleInheritance(); // copy existing permissions await list.breakRoleInheritance(true); // copy existing permissions and reset all child securables to the new permissions await list.breakRoleInheritance(true, true); // resetRoleInheritance await list.resetRoleInheritance();","title":"Securable Methods"},{"location":"v2/sp/security/#web-specific-methods","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // role definitions (see section below) const defs = await sp.web.roleDefinitions();","title":"Web Specific methods"},{"location":"v2/sp/security/#role-assignments","text":"Allows you to list and manipulate the set of role assignments for the given securable. Again we show usage using list, but the examples apply to web and item as well. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/security/web\"; import \"@pnp/sp/site-users/web\"; import { IList } from \"@pnp/sp/lists\"; import { PermissionKind } from \"@pnp/sp/security\"; // ensure we have a list const ler = await sp.web.lists.ensure(\"SecurityTestingList\"); const list: IList = ler.list; // list role assignments const assignments = await list.roleAssignments(); // add a role assignment const defs = await sp.web.roleDefinitions(); const user = await sp.web.currentUser(); const r = await list.roleAssignments.add(user.Id, defs[0].Id); // remove a role assignment const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); const r = await list.roleAssignments.remove(ra.Id); // read role assignment info const info = await list.roleAssignments.getById(ra.Id)(); // get the groups const info2 = await list.roleAssignments.getById(ra.Id).groups(); // get the bindings const info3 = await list.roleAssignments.getById(ra.Id).bindings(); // delete a role assignment (same as remove) const ras = await list.roleAssignments(); // filter/find the role assignment you want to remove // here we just grab the first const ra = ras.find(v => true); // delete it await list.roleAssignments.getById(ra.Id).delete();","title":"Role Assignments"},{"location":"v2/sp/security/#role-definitions","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/security/web\"; // read role definitions const defs = await sp.web.roleDefinitions(); // get by id const def = await sp.web.roleDefinitions.getById(5)(); const def = await sp.web.roleDefinitions.getById(5).select(\"Name\", \"Order\")(); // get by name const def = await sp.web.roleDefinitions.getByName(\"Full Control\")(); const def = await sp.web.roleDefinitions.getByName(\"Full Control\").select(\"Name\", \"Order\")(); // get by type const def = await sp.web.roleDefinitions.getByName(5)(); const def = await sp.web.roleDefinitions.getByName(5).select(\"Name\", \"Order\")(); // add // name The new role definition's name // description The new role definition's description // order The order in which the role definition appears // basePermissions The permissions mask for this role definition const rdar = await sp.web.roleDefinitions.add(\"title\", \"description\", 99, { High: 1, Low: 2 }); // the following methods work on a single role def, you can use any of the three getBy methods, here we use getById as an example // delete await sp.web.roleDefinitions.getById(5).delete(); // update const res = sp.web.roleDefinitions.getById(5).update({ Name: \"New Name\" });","title":"Role Definitions"},{"location":"v2/sp/sharing/","text":"@pnp/sp/sharing \u00b6 Note: This API is still considered \"beta\" meaning it may change and some behaviors may differ across tenants by version. It is also supported only in SharePoint Online. One of the newer abilities in SharePoint is the ability to share webs, files, or folders with both internal and external folks. It is important to remember that these settings are managed at the tenant level and ? override anything you may supply as an argument to these methods. If you receive an InvalidOperationException when using these methods please check your tenant sharing settings to ensure sharing is not blocked before ?submitting an issue. Imports \u00b6 In previous versions of this library the sharing methods were part of the inheritance stack for SharePointQueryable objects. Starting with v2 this is no longer the case and they are now selectively importable. There are four objects within the SharePoint hierarchy that support sharing: Item, File, Folder, and Web. You can import the sharing methods for all of them, or for individual objects. Import All \u00b6 To import and attach the sharing methods to all four of the sharable types include all of the sharing sub module: import \"@pnp/sp/sharing\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName); Selective Import \u00b6 Import only the web's sharing methods into the library import \"@pnp/sp/sharing/web\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName); getShareLink \u00b6 Applies to: Item, Folder, File Creates a sharing link for the given resource with an optional expiration. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { SharingLinkKind, IShareLinkResponse } from \"@pnp/sp/sharing\"; import { dateAdd } from \"@pnp/core\"; const result = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView); console.log(JSON.stringify(result, null, 2)); const result2 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView, dateAdd(new Date(), \"day\", 5)); console.log(JSON.stringify(result2, null, 2)); shareWith \u00b6 Applies to: Item, Folder, File, Web Shares the given resource with the specified permissions (View or Edit) and optionally sends an email to the users. You can supply a single string for the loginnames parameter or an array of loginnames . The folder method takes an optional parameter \"shareEverything\" which determines if the shared permissions are pushed down to all items in the folder, even those with unique permissions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/files/web\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; const result = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\"); console.log(JSON.stringify(result, null, 2)); // Share and allow editing const result2 = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit); console.log(JSON.stringify(result2, null, 2)); // share folder const result3 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share folder with edit permissions, and provide params for requireSignin and propagateAcl (apply to all children) await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit, true, true); // Share a file await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share a file with edit permissions await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit); shareObject & shareObjectRaw \u00b6 Applies to: Web Allows you to share any shareable object in a web by providing the appropriate parameters. These two methods differ in that shareObject will try and fix up your query based on the supplied parameters where shareObjectRaw will send your supplied json object directly to the server. The later method is provided for the greatest amount of flexibility. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; // Share an object in this web const result = await sp.web.shareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", \"i:0#.f|membership|user@site.com\", SharingRole.View); // Share an object with all settings available await sp.web.shareObjectRaw({ url: \"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", peoplePickerInput: [{ Key: \"i:0#.f|membership|user@site.com\" }], roleValue: \"role: 1973741327\", groupId: 0, propagateAcl: false, sendEmail: true, includeAnonymousLinkInEmail: false, emailSubject: \"subject\", emailBody: \"body\", useSimplifiedRoles: true, }); unshareObject \u00b6 Applies to: Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result = await sp.web.unshareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\"); checkSharingPermissions \u00b6 Applies to: Item, Folder, File Checks Permissions on the list of Users and returns back role the users have on the Item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing/folders\"; import \"@pnp/sp/folders/web\"; import { SharingEntityPermission } from \"@pnp/sp/sharing\"; // check the sharing permissions for a folder const perms = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").checkSharingPermissions([{ alias: \"i:0#.f|membership|user@site.com\" }]); getSharingInformation \u00b6 Applies to: Item, Folder, File Get Sharing Information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingInformation } from \"@pnp/sp/sharing\"; // Get the sharing information for a folder const info = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getSharingInformation(); getObjectSharingSettings \u00b6 Applies to: Item, Folder, File Gets the sharing settings import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { IObjectSharingSettings } from \"@pnp/sp/sharing\"; // Gets the sharing object settings const settings: IObjectSharingSettings = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getObjectSharingSettings(); unshare \u00b6 Applies to: Item, Folder, File Unshares a given resource import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshare(); deleteSharingLinkByKind \u00b6 Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult, SharingLinkKind } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").deleteSharingLinkByKind(SharingLinkKind.AnonymousEdit); unshareLink \u00b6 Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { SharingLinkKind } from \"@pnp/sp/sharing\"; await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit); // specify the sharing link id if available await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit, \"12345\");","title":"@pnp/sp/sharing"},{"location":"v2/sp/sharing/#pnpspsharing","text":"Note: This API is still considered \"beta\" meaning it may change and some behaviors may differ across tenants by version. It is also supported only in SharePoint Online. One of the newer abilities in SharePoint is the ability to share webs, files, or folders with both internal and external folks. It is important to remember that these settings are managed at the tenant level and ? override anything you may supply as an argument to these methods. If you receive an InvalidOperationException when using these methods please check your tenant sharing settings to ensure sharing is not blocked before ?submitting an issue.","title":"@pnp/sp/sharing"},{"location":"v2/sp/sharing/#imports","text":"In previous versions of this library the sharing methods were part of the inheritance stack for SharePointQueryable objects. Starting with v2 this is no longer the case and they are now selectively importable. There are four objects within the SharePoint hierarchy that support sharing: Item, File, Folder, and Web. You can import the sharing methods for all of them, or for individual objects.","title":"Imports"},{"location":"v2/sp/sharing/#import-all","text":"To import and attach the sharing methods to all four of the sharable types include all of the sharing sub module: import \"@pnp/sp/sharing\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName);","title":"Import All"},{"location":"v2/sp/sharing/#selective-import","text":"Import only the web's sharing methods into the library import \"@pnp/sp/sharing/web\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; import { sp } from \"@pnp/sp\"; const user = await sp.web.siteUsers.getByEmail(\"user@site.com\")(); const r = await sp.web.shareWith(user.LoginName);","title":"Selective Import"},{"location":"v2/sp/sharing/#getsharelink","text":"Applies to: Item, Folder, File Creates a sharing link for the given resource with an optional expiration. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { SharingLinkKind, IShareLinkResponse } from \"@pnp/sp/sharing\"; import { dateAdd } from \"@pnp/core\"; const result = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView); console.log(JSON.stringify(result, null, 2)); const result2 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").getShareLink(SharingLinkKind.AnonymousView, dateAdd(new Date(), \"day\", 5)); console.log(JSON.stringify(result2, null, 2));","title":"getShareLink"},{"location":"v2/sp/sharing/#sharewith","text":"Applies to: Item, Folder, File, Web Shares the given resource with the specified permissions (View or Edit) and optionally sends an email to the users. You can supply a single string for the loginnames parameter or an array of loginnames . The folder method takes an optional parameter \"shareEverything\" which determines if the shared permissions are pushed down to all items in the folder, even those with unique permissions. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders/web\"; import \"@pnp/sp/files/web\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; const result = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\"); console.log(JSON.stringify(result, null, 2)); // Share and allow editing const result2 = await sp.web.shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit); console.log(JSON.stringify(result2, null, 2)); // share folder const result3 = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/folder1\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share folder with edit permissions, and provide params for requireSignin and propagateAcl (apply to all children) await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit, true, true); // Share a file await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\"); // Share a file with edit permissions await sp.web.getFileByServerRelativeUrl(\"/sites/dev/Shared Documents/test.txt\").shareWith(\"i:0#.f|membership|user@site.com\", SharingRole.Edit);","title":"shareWith"},{"location":"v2/sp/sharing/#shareobject-shareobjectraw","text":"Applies to: Web Allows you to share any shareable object in a web by providing the appropriate parameters. These two methods differ in that shareObject will try and fix up your query based on the supplied parameters where shareObjectRaw will send your supplied json object directly to the server. The later method is provided for the greatest amount of flexibility. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult, SharingRole } from \"@pnp/sp/sharing\"; // Share an object in this web const result = await sp.web.shareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", \"i:0#.f|membership|user@site.com\", SharingRole.View); // Share an object with all settings available await sp.web.shareObjectRaw({ url: \"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\", peoplePickerInput: [{ Key: \"i:0#.f|membership|user@site.com\" }], roleValue: \"role: 1973741327\", groupId: 0, propagateAcl: false, sendEmail: true, includeAnonymousLinkInEmail: false, emailSubject: \"subject\", emailBody: \"body\", useSimplifiedRoles: true, });","title":"shareObject &amp; shareObjectRaw"},{"location":"v2/sp/sharing/#unshareobject","text":"Applies to: Web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result = await sp.web.unshareObject(\"https://mysite.sharepoint.com/sites/dev/Docs/test.txt\");","title":"unshareObject"},{"location":"v2/sp/sharing/#checksharingpermissions","text":"Applies to: Item, Folder, File Checks Permissions on the list of Users and returns back role the users have on the Item. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing/folders\"; import \"@pnp/sp/folders/web\"; import { SharingEntityPermission } from \"@pnp/sp/sharing\"; // check the sharing permissions for a folder const perms = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").checkSharingPermissions([{ alias: \"i:0#.f|membership|user@site.com\" }]);","title":"checkSharingPermissions"},{"location":"v2/sp/sharing/#getsharinginformation","text":"Applies to: Item, Folder, File Get Sharing Information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingInformation } from \"@pnp/sp/sharing\"; // Get the sharing information for a folder const info = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getSharingInformation();","title":"getSharingInformation"},{"location":"v2/sp/sharing/#getobjectsharingsettings","text":"Applies to: Item, Folder, File Gets the sharing settings import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { IObjectSharingSettings } from \"@pnp/sp/sharing\"; // Gets the sharing object settings const settings: IObjectSharingSettings = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").getObjectSharingSettings();","title":"getObjectSharingSettings"},{"location":"v2/sp/sharing/#unshare","text":"Applies to: Item, Folder, File Unshares a given resource import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshare();","title":"unshare"},{"location":"v2/sp/sharing/#deletesharinglinkbykind","text":"Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { ISharingResult, SharingLinkKind } from \"@pnp/sp/sharing\"; const result: ISharingResult = await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").deleteSharingLinkByKind(SharingLinkKind.AnonymousEdit);","title":"deleteSharingLinkByKind"},{"location":"v2/sp/sharing/#unsharelink","text":"Applies to: Item, Folder, File import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sharing\"; import \"@pnp/sp/folders\"; import { SharingLinkKind } from \"@pnp/sp/sharing\"; await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit); // specify the sharing link id if available await sp.web.getFolderByServerRelativeUrl(\"/sites/dev/Shared Documents/test\").unshareLink(SharingLinkKind.AnonymousEdit, \"12345\");","title":"unshareLink"},{"location":"v2/sp/site-designs/","text":"@pnp/sp/site-designs \u00b6 You can create site designs to provide reusable lists, themes, layouts, pages, or custom actions so that your users can quickly build new SharePoint sites with the features they need. Check out SharePoint site design and site script overview for more information. Site Designs \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Create a new site design \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // WebTemplate: 64 Team site template, 68 Communication site template const siteDesign = await sp.siteDesigns.createSiteDesign({ SiteScriptIds: [\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"], Title: \"SiteDesign001\", WebTemplate: \"64\", }); console.log(siteDesign.Title); Applying a site design to a site \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Limited to 30 actions in a site script, but runs synchronously await sp.siteDesigns.applySiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\",\"https://contoso.sharepoint.com/sites/teamsite-pnpjs001\"); // Better use the following method for 300 actions in a site script const task = await sp.web.addSiteDesignTask(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); Retrieval \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Retrieving all site designs const allSiteDesigns = await sp.siteDesigns.getSiteDesigns(); console.log(`Total site designs: ${allSiteDesigns.length}`); // Retrieving a single site design by Id const siteDesign = await sp.siteDesigns.getSiteDesignMetadata(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(siteDesign.Title); Update and delete \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Update const updatedSiteDesign = await sp.siteDesigns.updateSiteDesign({ Id: \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", Title: \"SiteDesignUpdatedTitle001\" }); // Delete await sp.siteDesigns.deleteSiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); Setting Rights/Permissions \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Get const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(rights.length > 0 ? rights[0].PrincipalName : \"\"); // Grant await sp.siteDesigns.grantSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Revoke await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Reset all view rights const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", rights.map(u => u.PrincipalName)); Get a history of site designs that have run on a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; const runs = await sp.web.getSiteDesignRuns(); const runs2 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\"); // Get runs specific to a site design const runs3 = await sp.web.getSiteDesignRuns(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); const runs4 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\", \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); // For more information about the site script actions const runStatus = await sp.web.getSiteDesignRunStatus(runs[0].ID); const runStatus2 = await sp.siteDesigns.getSiteDesignRunStatus(\"https://TENANT.sharepoint.com/sites/mysite\", runs[0].ID);","title":"@pnp/sp/site-designs"},{"location":"v2/sp/site-designs/#pnpspsite-designs","text":"You can create site designs to provide reusable lists, themes, layouts, pages, or custom actions so that your users can quickly build new SharePoint sites with the features they need. Check out SharePoint site design and site script overview for more information.","title":"@pnp/sp/site-designs"},{"location":"v2/sp/site-designs/#site-designs","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"Site Designs"},{"location":"v2/sp/site-designs/#create-a-new-site-design","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // WebTemplate: 64 Team site template, 68 Communication site template const siteDesign = await sp.siteDesigns.createSiteDesign({ SiteScriptIds: [\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"], Title: \"SiteDesign001\", WebTemplate: \"64\", }); console.log(siteDesign.Title);","title":"Create a new site design"},{"location":"v2/sp/site-designs/#applying-a-site-design-to-a-site","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Limited to 30 actions in a site script, but runs synchronously await sp.siteDesigns.applySiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\",\"https://contoso.sharepoint.com/sites/teamsite-pnpjs001\"); // Better use the following method for 300 actions in a site script const task = await sp.web.addSiteDesignTask(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\");","title":"Applying a site design to a site"},{"location":"v2/sp/site-designs/#retrieval","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Retrieving all site designs const allSiteDesigns = await sp.siteDesigns.getSiteDesigns(); console.log(`Total site designs: ${allSiteDesigns.length}`); // Retrieving a single site design by Id const siteDesign = await sp.siteDesigns.getSiteDesignMetadata(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(siteDesign.Title);","title":"Retrieval"},{"location":"v2/sp/site-designs/#update-and-delete","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Update const updatedSiteDesign = await sp.siteDesigns.updateSiteDesign({ Id: \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", Title: \"SiteDesignUpdatedTitle001\" }); // Delete await sp.siteDesigns.deleteSiteDesign(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\");","title":"Update and delete"},{"location":"v2/sp/site-designs/#setting-rightspermissions","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; // Get const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); console.log(rights.length > 0 ? rights[0].PrincipalName : \"\"); // Grant await sp.siteDesigns.grantSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Revoke await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", [\"user@contoso.onmicrosoft.com\"]); // Reset all view rights const rights = await sp.siteDesigns.getSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); await sp.siteDesigns.revokeSiteDesignRights(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\", rights.map(u => u.PrincipalName));","title":"Setting Rights/Permissions"},{"location":"v2/sp/site-designs/#get-a-history-of-site-designs-that-have-run-on-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-designs\"; const runs = await sp.web.getSiteDesignRuns(); const runs2 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\"); // Get runs specific to a site design const runs3 = await sp.web.getSiteDesignRuns(\"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); const runs4 = await sp.siteDesigns.getSiteDesignRun(\"https://TENANT.sharepoint.com/sites/mysite\", \"75b9d8fe-4381-45d9-88c6-b03f483ae6a8\"); // For more information about the site script actions const runStatus = await sp.web.getSiteDesignRunStatus(runs[0].ID); const runStatus2 = await sp.siteDesigns.getSiteDesignRunStatus(\"https://TENANT.sharepoint.com/sites/mysite\", runs[0].ID);","title":"Get a history of site designs that have run on a web"},{"location":"v2/sp/site-groups/","text":"@pnp/sp/site-groups \u00b6 The site groups module provides methods to manage groups for a sharepoint site. ISiteGroups \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups } from \"@pnp/sp/presets/all\"; Get all site groups \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // gets all site groups of the web const groups = await sp.web.siteGroups(); Get the associated groups of a web \u00b6 You can get the associated Owner, Member and Visitor groups of a web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Gets the associated visitors group of a web const visitorGroup = await sp.web.associatedVisitorGroup(); // Gets the associated members group of a web const memberGroup = await sp.web.associatedMemberGroup(); // Gets the associated owners group of a web const ownerGroup = await sp.web.associatedOwnerGroup(); Create the default associated groups for a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Breaks permission inheritance and creates the default associated groups for the web // Login name of the owner const owner1 = \"owner@example.onmicrosoft.com\"; // Specify true, the permissions should be copied from the current parent scope, else false const copyRoleAssignments = false; // Specify true to make all child securable objects inherit role assignments from the current object const clearSubScopes = true; await sp.web.createDefaultAssociatedGroups(\"PnP Site\", owner1, copyRoleAssignments, clearSubScopes); Create a new site group \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Creates a new site group with the specified title await sp.web.siteGroups.add({\"Title\":\"new group name\"}); ISiteGroup \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups, SiteGroup } from \"@pnp/sp/presets/all\"; Getting and updating the groups of a sharepoint web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get the group using a group id const groupID = 33; let grp = await sp.web.siteGroups.getById(groupID)(); // get the group using the group's name const groupName = \"ClassicTeam Visitors\"; grp = await sp.web.siteGroups.getByName(groupName)(); // update a group await sp.web.siteGroups.getById(groupID).update({\"Title\": \"New Group Title\"}); // delete a group from the site using group id await sp.web.siteGroups.removeById(groupID); // delete a group from the site using group name await sp.web.siteGroups.removeByLoginName(groupName); Getting all users of a group \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get all users of group const groupID = 7; const users = await sp.web.siteGroups.getById(groupID).users(); Updating the owner of a site group \u00b6 Unfortunately for now setting the owner of a group as another or same SharePoint group is currently unsupported in REST. Setting the owner as a user is supported. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // Update the owner with a user id await sp.web.siteGroups.getById(7).setUserAsOwner(4);","title":"@pnp/sp/site-groups"},{"location":"v2/sp/site-groups/#pnpspsite-groups","text":"The site groups module provides methods to manage groups for a sharepoint site.","title":"@pnp/sp/site-groups"},{"location":"v2/sp/site-groups/#isitegroups","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups } from \"@pnp/sp/presets/all\";","title":"ISiteGroups"},{"location":"v2/sp/site-groups/#get-all-site-groups","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // gets all site groups of the web const groups = await sp.web.siteGroups();","title":"Get all site groups"},{"location":"v2/sp/site-groups/#get-the-associated-groups-of-a-web","text":"You can get the associated Owner, Member and Visitor groups of a web import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Gets the associated visitors group of a web const visitorGroup = await sp.web.associatedVisitorGroup(); // Gets the associated members group of a web const memberGroup = await sp.web.associatedMemberGroup(); // Gets the associated owners group of a web const ownerGroup = await sp.web.associatedOwnerGroup();","title":"Get the associated groups of a web"},{"location":"v2/sp/site-groups/#create-the-default-associated-groups-for-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Breaks permission inheritance and creates the default associated groups for the web // Login name of the owner const owner1 = \"owner@example.onmicrosoft.com\"; // Specify true, the permissions should be copied from the current parent scope, else false const copyRoleAssignments = false; // Specify true to make all child securable objects inherit role assignments from the current object const clearSubScopes = true; await sp.web.createDefaultAssociatedGroups(\"PnP Site\", owner1, copyRoleAssignments, clearSubScopes);","title":"Create the default associated groups for a web"},{"location":"v2/sp/site-groups/#create-a-new-site-group","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; // Creates a new site group with the specified title await sp.web.siteGroups.add({\"Title\":\"new group name\"});","title":"Create a new site group"},{"location":"v2/sp/site-groups/#isitegroup","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups/web\"; Preset: All import {sp, SiteGroups, SiteGroup } from \"@pnp/sp/presets/all\";","title":"ISiteGroup"},{"location":"v2/sp/site-groups/#getting-and-updating-the-groups-of-a-sharepoint-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get the group using a group id const groupID = 33; let grp = await sp.web.siteGroups.getById(groupID)(); // get the group using the group's name const groupName = \"ClassicTeam Visitors\"; grp = await sp.web.siteGroups.getByName(groupName)(); // update a group await sp.web.siteGroups.getById(groupID).update({\"Title\": \"New Group Title\"}); // delete a group from the site using group id await sp.web.siteGroups.removeById(groupID); // delete a group from the site using group name await sp.web.siteGroups.removeByLoginName(groupName);","title":"Getting and updating the groups of a sharepoint web"},{"location":"v2/sp/site-groups/#getting-all-users-of-a-group","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // get all users of group const groupID = 7; const users = await sp.web.siteGroups.getById(groupID).users();","title":"Getting all users of a group"},{"location":"v2/sp/site-groups/#updating-the-owner-of-a-site-group","text":"Unfortunately for now setting the owner of a group as another or same SharePoint group is currently unsupported in REST. Setting the owner as a user is supported. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-groups\"; // Update the owner with a user id await sp.web.siteGroups.getById(7).setUserAsOwner(4);","title":"Updating the owner of a site group"},{"location":"v2/sp/site-scripts/","text":"@pnp/sp/site-scripts \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Create a new site script \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const sitescriptContent = { \"$schema\": \"schema.json\", \"actions\": [ { \"themeName\": \"Theme Name 123\", \"verb\": \"applyTheme\", }, ], \"bindata\": {}, \"version\": 1, }; const siteScript = await sp.siteScripts.createSiteScript(\"Title\", \"description\", sitescriptContent); console.log(siteScript.Title); Retrieval \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Retrieving all site scripts const allSiteScripts = await sp.siteScripts.getSiteScripts(); console.log(allSiteScripts.length > 0 ? allSiteScripts[0].Title : \"\"); // Retrieving a single site script by Id const siteScript = await sp.siteScripts.getSiteScriptMetadata(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"); console.log(siteScript.Title); Update and delete \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Update const updatedSiteScript = await sp.siteScripts.updateSiteScript({ Id: \"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\", Title: \"New Title\" }); console.log(updatedSiteScript.Title); // Delete await sp.siteScripts.deleteSiteScript(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"); Get site script from a list \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Using the absolute URL of the list const ss = await sp.siteScripts.getSiteScriptFromList(\"https://TENANT.sharepoint.com/Lists/mylist\"); // Using the PnPjs web object to fetch the site script from a specific list const ss2 = await sp.web.lists.getByTitle(\"mylist\").getSiteScript(); Get site script from a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const extractInfo = { IncludeBranding: true, IncludeLinksToExportedItems: true, IncludeRegionalSettings: true, IncludeSiteExternalSharingCapability: true, IncludeTheme: true, IncludedLists: [\"Lists/MyList\"] }; const ss = await sp.siteScripts.getSiteScriptFromWeb(\"https://TENANT.sharepoint.com/sites/mysite\", extractInfo); // Using the PnPjs web object to fetch the site script from a specific web const ss2 = await sp.web.getSiteScript(extractInfo); Execute Site Script Action \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const ss = await sp.siteScripts.executeSiteScriptAction(siteScript); Execute site script for a specific web \u00b6 import { sp } from \"@pnp/sp\"; import { SiteScripts } \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const scriptService = SiteScripts(\"https://absolute/url/to/web\"); const ss = await scriptService.executeSiteScriptAction(siteScript);","title":"@pnp/sp/site-scripts"},{"location":"v2/sp/site-scripts/#pnpspsite-scripts","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"@pnp/sp/site-scripts"},{"location":"v2/sp/site-scripts/#create-a-new-site-script","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const sitescriptContent = { \"$schema\": \"schema.json\", \"actions\": [ { \"themeName\": \"Theme Name 123\", \"verb\": \"applyTheme\", }, ], \"bindata\": {}, \"version\": 1, }; const siteScript = await sp.siteScripts.createSiteScript(\"Title\", \"description\", sitescriptContent); console.log(siteScript.Title);","title":"Create a new site script"},{"location":"v2/sp/site-scripts/#retrieval","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Retrieving all site scripts const allSiteScripts = await sp.siteScripts.getSiteScripts(); console.log(allSiteScripts.length > 0 ? allSiteScripts[0].Title : \"\"); // Retrieving a single site script by Id const siteScript = await sp.siteScripts.getSiteScriptMetadata(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\"); console.log(siteScript.Title);","title":"Retrieval"},{"location":"v2/sp/site-scripts/#update-and-delete","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Update const updatedSiteScript = await sp.siteScripts.updateSiteScript({ Id: \"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\", Title: \"New Title\" }); console.log(updatedSiteScript.Title); // Delete await sp.siteScripts.deleteSiteScript(\"884ed56b-1aab-4653-95cf-4be0bfa5ef0a\");","title":"Update and delete"},{"location":"v2/sp/site-scripts/#get-site-script-from-a-list","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; // Using the absolute URL of the list const ss = await sp.siteScripts.getSiteScriptFromList(\"https://TENANT.sharepoint.com/Lists/mylist\"); // Using the PnPjs web object to fetch the site script from a specific list const ss2 = await sp.web.lists.getByTitle(\"mylist\").getSiteScript();","title":"Get site script from a list"},{"location":"v2/sp/site-scripts/#get-site-script-from-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const extractInfo = { IncludeBranding: true, IncludeLinksToExportedItems: true, IncludeRegionalSettings: true, IncludeSiteExternalSharingCapability: true, IncludeTheme: true, IncludedLists: [\"Lists/MyList\"] }; const ss = await sp.siteScripts.getSiteScriptFromWeb(\"https://TENANT.sharepoint.com/sites/mysite\", extractInfo); // Using the PnPjs web object to fetch the site script from a specific web const ss2 = await sp.web.getSiteScript(extractInfo);","title":"Get site script from a web"},{"location":"v2/sp/site-scripts/#execute-site-script-action","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const ss = await sp.siteScripts.executeSiteScriptAction(siteScript);","title":"Execute Site Script Action"},{"location":"v2/sp/site-scripts/#execute-site-script-for-a-specific-web","text":"import { sp } from \"@pnp/sp\"; import { SiteScripts } \"@pnp/sp/site-scripts\"; const siteScript = \"your site script action...\"; const scriptService = SiteScripts(\"https://absolute/url/to/web\"); const ss = await scriptService.executeSiteScriptAction(siteScript);","title":"Execute site script for a specific web"},{"location":"v2/sp/site-users/","text":"@pnp/sp/site-users \u00b6 The site users module provides methods to manage users for a sharepoint site. ISiteUsers \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers } from \"@pnp/sp/presets/all\"; Get all site user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const users = await sp.web.siteUsers(); Get Current user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let user = await sp.web.currentUser(); Get user by id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const id = 6; user = await sp.web.getUserById(id); Ensure user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const username = \"usernames@microsoft.com\"; result = await sp.web.ensureUser(username); ISiteUser \u00b6 Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers, SiteUser } from \"@pnp/sp/presets/all\"; Get user Groups \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let groups = await sp.web.currentUser.groups(); Add user to Site collection \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const user = await sp.web.ensureUser(\"userLoginname\") const users = await sp.web.siteUsers; await users.add(user.data.LoginName); Get user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // get user object by id const user = await sp.web.siteUsers.getById(6); //get user object by Email const user = await sp.web.siteUsers.getByEmail(\"user@mail.com\"); //get user object by LoginName const user = await sp.web.siteUsers.getByLoginName(\"userLoginName\"); Update user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let userProps = await sp.web.currentUser(); userProps.Title = \"New title\"; await sp.web.currentUser.update(userProps); Remove user \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // remove user by id await sp.web.siteUsers.removeById(6); // remove user by LoginName await sp.web.siteUsers.removeByLoginName(6); ISiteUserProps \u00b6 User properties: Property Name Type Description Email string Contains Site user email Id Number Contains Site user Id IsHiddenInUI Boolean Site user IsHiddenInUI IsShareByEmailGuestUser boolean Site user is external user IsSiteAdmin Boolean Describes if Site user Is Site Admin LoginName string Site user LoginName PrincipalType number Site user Principal type Title string Site user Title interface ISiteUserProps { /** * Contains Site user email * */ Email: string; /** * Contains Site user Id * */ Id: number; /** * Site user IsHiddenInUI * */ IsHiddenInUI: boolean; /** * Site user IsShareByEmailGuestUser * */ IsShareByEmailGuestUser: boolean; /** * Describes if Site user Is Site Admin * */ IsSiteAdmin: boolean; /** * Site user LoginName * */ LoginName: string; /** * Site user Principal type * */ PrincipalType: number | PrincipalType; /** * Site user Title * */ Title: string; }","title":"@pnp/sp/site-users"},{"location":"v2/sp/site-users/#pnpspsite-users","text":"The site users module provides methods to manage users for a sharepoint site.","title":"@pnp/sp/site-users"},{"location":"v2/sp/site-users/#isiteusers","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers } from \"@pnp/sp/presets/all\";","title":"ISiteUsers"},{"location":"v2/sp/site-users/#get-all-site-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const users = await sp.web.siteUsers();","title":"Get all site user"},{"location":"v2/sp/site-users/#get-current-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let user = await sp.web.currentUser();","title":"Get Current user"},{"location":"v2/sp/site-users/#get-user-by-id","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const id = 6; user = await sp.web.getUserById(id);","title":"Get user by id"},{"location":"v2/sp/site-users/#ensure-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const username = \"usernames@microsoft.com\"; result = await sp.web.ensureUser(username);","title":"Ensure user"},{"location":"v2/sp/site-users/#isiteuser","text":"Scenario Import Statement Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users\"; Selective 3 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; Preset: All import {sp, SiteUsers, SiteUser } from \"@pnp/sp/presets/all\";","title":"ISiteUser"},{"location":"v2/sp/site-users/#get-user-groups","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let groups = await sp.web.currentUser.groups();","title":"Get user Groups"},{"location":"v2/sp/site-users/#add-user-to-site-collection","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; const user = await sp.web.ensureUser(\"userLoginname\") const users = await sp.web.siteUsers; await users.add(user.data.LoginName);","title":"Add user to Site collection"},{"location":"v2/sp/site-users/#get-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // get user object by id const user = await sp.web.siteUsers.getById(6); //get user object by Email const user = await sp.web.siteUsers.getByEmail(\"user@mail.com\"); //get user object by LoginName const user = await sp.web.siteUsers.getByLoginName(\"userLoginName\");","title":"Get user"},{"location":"v2/sp/site-users/#update-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; let userProps = await sp.web.currentUser(); userProps.Title = \"New title\"; await sp.web.currentUser.update(userProps);","title":"Update user"},{"location":"v2/sp/site-users/#remove-user","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/site-users/web\"; // remove user by id await sp.web.siteUsers.removeById(6); // remove user by LoginName await sp.web.siteUsers.removeByLoginName(6);","title":"Remove user"},{"location":"v2/sp/site-users/#isiteuserprops","text":"User properties: Property Name Type Description Email string Contains Site user email Id Number Contains Site user Id IsHiddenInUI Boolean Site user IsHiddenInUI IsShareByEmailGuestUser boolean Site user is external user IsSiteAdmin Boolean Describes if Site user Is Site Admin LoginName string Site user LoginName PrincipalType number Site user Principal type Title string Site user Title interface ISiteUserProps { /** * Contains Site user email * */ Email: string; /** * Contains Site user Id * */ Id: number; /** * Site user IsHiddenInUI * */ IsHiddenInUI: boolean; /** * Site user IsShareByEmailGuestUser * */ IsShareByEmailGuestUser: boolean; /** * Describes if Site user Is Site Admin * */ IsSiteAdmin: boolean; /** * Site user LoginName * */ LoginName: string; /** * Site user Principal type * */ PrincipalType: number | PrincipalType; /** * Site user Title * */ Title: string; }","title":"ISiteUserProps"},{"location":"v2/sp/sites/","text":"@pnp/sp/site - Site properties \u00b6 Site collection are one of the fundamental entry points while working with SharePoint. Sites serve as container for webs, lists, features and other entity types. Get context information for the current site collection \u00b6 Using the library, you can get the context information of the current site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IContextInfo } from \"@pnp/sp/sites\"; const oContext: IContextInfo = await sp.site.getContextInfo(); console.log(oContext.FormDigestValue); Get document libraries of a web \u00b6 Using the library, you can get a list of the document libraries present in the a given web. Note: Works only in SharePoint online import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IDocumentLibraryInformation } from \"@pnp/sp/sites\"; const docLibs: IDocumentLibraryInformation[] = await sp.site.getDocumentLibraries(\"https://tenant.sharepoint.com/sites/test/subsite\"); //we got the array of document library information docLibs.forEach((docLib: IDocumentLibraryInformation) => { // do something with each library }); Open Web By Id \u00b6 Because this method is a POST request you can chain off it directly. You will get back the full web properties in the data property of the return object. You can also chain directly off the returned Web instance on the web property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const w = await sp.site.openWebById(\"111ca453-90f5-482e-a381-cee1ff383c9e\"); //we got all the data from the web as well console.log(w.data); // we can chain const w2 = await w.web.select(\"Title\")(); Get site collection url from page \u00b6 Using the library, you can get the site collection url by providing a page url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const d: string = await sp.site.getWebUrlFromPageUrl(\"https://tenant.sharepoint.com/sites/test/Pages/test.aspx\"); console.log(d); //https://tenant.sharepoint.com/sites/test Access the root web \u00b6 There are two methods to access the root web. The first, using the rootWeb property, is best for directly accessing information about that web. If you want to chain multiple operations off of the web, better to use the getRootWeb method that will ensure the web instance is created using its own Url vs. \"_api/sites/rootweb\" which does not work for all operations. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; // use for rootweb information access const rootwebData = await sp.site.rootWeb(); // use for chaining const rootweb = await sp.site.getRootWeb(); const listData = await rootWeb.lists.getByTitle(\"MyList\")(); Create a modern communication site \u00b6 Note: Works only in SharePoint online Creates a modern communication site. Property Type Required Description Title string yes The title of the site to create. lcid number yes The default language to use for the site. shareByEmailEnabled boolean yes If set to true, it will enable sharing files via Email. By default it is set to false url string yes The fully qualified URL (e.g. https://yourtenant.sharepoint.com/sites/mysitecollection ) of the site. description string no The description of the communication site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc hubSiteId string no The Guid of the already existing Hub site Owner string no Required when using app-only context. Owner principal name e.g. user@tenant.onmicrosoft.com import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createCommunicationSite( \"Title\", 1033, true, \"https://tenant.sharepoint.com/sites/commSite\", \"Description\", \"HBI\", \"f6cc5403-0d63-442e-96c0-285923709ffc\", \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"user@TENANT.onmicrosoft.com\"); Create from Props \u00b6 You may need to supply additional parameters such as WebTemplate, to do so please use the createCommunicationSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createCommunicationSiteFromProps({ Owner: \"patrick@three18studios.com\", Title: \"A Test Site\", Url: \"https://{tenant}.sharepoint.com/sites/commsite2\", WebTemplate: \"STS#3\", }); Create a modern team site \u00b6 Note: Works only in SharePoint online. It wont work with App only tokens Creates a modern team site backed by O365 group. Property Type Required Description displayName string yes The title/displayName of the site to be created. alias string yes Alias of the underlying Office 365 Group. isPublic boolean yes Defines whether the Office 365 Group will be public (default), or private. lcid number yes The language to use for the site. If not specified will default to English (1033). description string no The description of the modern team site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information owners string array (string[]) no The Owners of the site to be created hubSiteId string no The Guid of the already existing Hub site siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createModernTeamSite( \"displayName\", \"alias\", true, 1033, \"description\", \"HBI\", [\"user1@tenant.onmicrosoft.com\",\"user2@tenant.onmicrosoft.com\",\"user3@tenant.onmicrosoft.com\"], \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"f6cc5403-0d63-442e-96c0-285923709ffc\" ); console.log(d); Create from Props \u00b6 You may need to supply additional parameters, to do so please use the createModernTeamSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createModernTeamSiteFromProps({ alias: \"JenniferGarner\", displayName: \"A Test Site\", owners: [\"patrick@three18studios.com\"], }); Delete a site collection \u00b6 Using the library, you can delete a specific site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { Site } from \"@pnp/sp/sites\"; // Delete the current site await sp.site.delete(); // Specify which site to delete const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const site2 = Site(siteUrl); await site2.delete(); Check if a Site Collection Exists \u00b6 Using the library, you can check if a specific site collection exist or not on your tenant import { sp } from \"@pnp/sp\"; // Specify which site to verify const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const exists = sp.site.exists(siteUrl); console.log(exists);","title":"@pnp/sp/site - Site properties"},{"location":"v2/sp/sites/#pnpspsite-site-properties","text":"Site collection are one of the fundamental entry points while working with SharePoint. Sites serve as container for webs, lists, features and other entity types.","title":"@pnp/sp/site - Site properties"},{"location":"v2/sp/sites/#get-context-information-for-the-current-site-collection","text":"Using the library, you can get the context information of the current site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IContextInfo } from \"@pnp/sp/sites\"; const oContext: IContextInfo = await sp.site.getContextInfo(); console.log(oContext.FormDigestValue);","title":"Get context information for the current site collection"},{"location":"v2/sp/sites/#get-document-libraries-of-a-web","text":"Using the library, you can get a list of the document libraries present in the a given web. Note: Works only in SharePoint online import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { IDocumentLibraryInformation } from \"@pnp/sp/sites\"; const docLibs: IDocumentLibraryInformation[] = await sp.site.getDocumentLibraries(\"https://tenant.sharepoint.com/sites/test/subsite\"); //we got the array of document library information docLibs.forEach((docLib: IDocumentLibraryInformation) => { // do something with each library });","title":"Get document libraries of a web"},{"location":"v2/sp/sites/#open-web-by-id","text":"Because this method is a POST request you can chain off it directly. You will get back the full web properties in the data property of the return object. You can also chain directly off the returned Web instance on the web property. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const w = await sp.site.openWebById(\"111ca453-90f5-482e-a381-cee1ff383c9e\"); //we got all the data from the web as well console.log(w.data); // we can chain const w2 = await w.web.select(\"Title\")();","title":"Open Web By Id"},{"location":"v2/sp/sites/#get-site-collection-url-from-page","text":"Using the library, you can get the site collection url by providing a page url import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const d: string = await sp.site.getWebUrlFromPageUrl(\"https://tenant.sharepoint.com/sites/test/Pages/test.aspx\"); console.log(d); //https://tenant.sharepoint.com/sites/test","title":"Get site collection url from page"},{"location":"v2/sp/sites/#access-the-root-web","text":"There are two methods to access the root web. The first, using the rootWeb property, is best for directly accessing information about that web. If you want to chain multiple operations off of the web, better to use the getRootWeb method that will ensure the web instance is created using its own Url vs. \"_api/sites/rootweb\" which does not work for all operations. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; // use for rootweb information access const rootwebData = await sp.site.rootWeb(); // use for chaining const rootweb = await sp.site.getRootWeb(); const listData = await rootWeb.lists.getByTitle(\"MyList\")();","title":"Access the root web"},{"location":"v2/sp/sites/#create-a-modern-communication-site","text":"Note: Works only in SharePoint online Creates a modern communication site. Property Type Required Description Title string yes The title of the site to create. lcid number yes The default language to use for the site. shareByEmailEnabled boolean yes If set to true, it will enable sharing files via Email. By default it is set to false url string yes The fully qualified URL (e.g. https://yourtenant.sharepoint.com/sites/mysitecollection ) of the site. description string no The description of the communication site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc hubSiteId string no The Guid of the already existing Hub site Owner string no Required when using app-only context. Owner principal name e.g. user@tenant.onmicrosoft.com import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createCommunicationSite( \"Title\", 1033, true, \"https://tenant.sharepoint.com/sites/commSite\", \"Description\", \"HBI\", \"f6cc5403-0d63-442e-96c0-285923709ffc\", \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"user@TENANT.onmicrosoft.com\");","title":"Create a modern communication site"},{"location":"v2/sp/sites/#create-from-props","text":"You may need to supply additional parameters such as WebTemplate, to do so please use the createCommunicationSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createCommunicationSiteFromProps({ Owner: \"patrick@three18studios.com\", Title: \"A Test Site\", Url: \"https://{tenant}.sharepoint.com/sites/commsite2\", WebTemplate: \"STS#3\", });","title":"Create from Props"},{"location":"v2/sp/sites/#create-a-modern-team-site","text":"Note: Works only in SharePoint online. It wont work with App only tokens Creates a modern team site backed by O365 group. Property Type Required Description displayName string yes The title/displayName of the site to be created. alias string yes Alias of the underlying Office 365 Group. isPublic boolean yes Defines whether the Office 365 Group will be public (default), or private. lcid number yes The language to use for the site. If not specified will default to English (1033). description string no The description of the modern team site. classification string no The Site classification to use. For instance \"Contoso Classified\". See https://www.youtube.com/watch?v=E-8Z2ggHcS0 for more information owners string array (string[]) no The Owners of the site to be created hubSiteId string no The Guid of the already existing Hub site siteDesignId string no The Guid of the site design to be used. You can use the below default OOTB GUIDs: Topic: null Showcase: 6142d2a0-63a5-4ba0-aede-d9fefca2c767 Blank: f6cc5403-0d63-442e-96c0-285923709ffc import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; const result = await sp.site.createModernTeamSite( \"displayName\", \"alias\", true, 1033, \"description\", \"HBI\", [\"user1@tenant.onmicrosoft.com\",\"user2@tenant.onmicrosoft.com\",\"user3@tenant.onmicrosoft.com\"], \"a00ec589-ea9f-4dba-a34e-67e78d41e509\", \"f6cc5403-0d63-442e-96c0-285923709ffc\" ); console.log(d);","title":"Create a modern team site"},{"location":"v2/sp/sites/#create-from-props_1","text":"You may need to supply additional parameters, to do so please use the createModernTeamSiteFromProps method. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/sites\"; // in this case you supply a single struct deinfing the creation props const result = await sp.site.createModernTeamSiteFromProps({ alias: \"JenniferGarner\", displayName: \"A Test Site\", owners: [\"patrick@three18studios.com\"], });","title":"Create from Props"},{"location":"v2/sp/sites/#delete-a-site-collection","text":"Using the library, you can delete a specific site collection import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sites\"; import { Site } from \"@pnp/sp/sites\"; // Delete the current site await sp.site.delete(); // Specify which site to delete const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const site2 = Site(siteUrl); await site2.delete();","title":"Delete a site collection"},{"location":"v2/sp/sites/#check-if-a-site-collection-exists","text":"Using the library, you can check if a specific site collection exist or not on your tenant import { sp } from \"@pnp/sp\"; // Specify which site to verify const siteUrl = \"https://tenant.sharepoint.com/sites/subsite\"; const exists = sp.site.exists(siteUrl); console.log(exists);","title":"Check if a Site Collection Exists"},{"location":"v2/sp/social/","text":"@pnp/sp/ - social \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; The social API allows you to track followed sites, people, and docs. Note, many of these methods only work with the context of a logged in user, and not with app-only permissions. getFollowedSitesUri \u00b6 Gets a URI to a site that lists the current user's followed sites. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedSitesUri(); getFollowedDocumentsUri \u00b6 Gets a URI to a site that lists the current user's followed documents. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedDocumentsUri(); follow \u00b6 Makes the current user start following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // follow a site const r1 = await sp.social.follow({ ActorType: SocialActorType.Site, ContentUri: \"htts://tenant.sharepoint.com/sites/site\", }); // follow a person const r2 = await sp.social.follow({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); // follow a doc const r3 = await sp.social.follow({ ActorType: SocialActorType.Document, ContentUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/Test.aspx\", }); // follow a tag // You need the tag GUID to start following a tag. // You can't get the GUID by using the REST service, but you can use the .NET client object model or the JavaScript object model. // See How to get a tag's GUID based on the tag's name by using the JavaScript object model. // https://docs.microsoft.com/en-us/sharepoint/dev/general-development/follow-content-in-sharepoint#bk_getTagGuid const r4 = await sp.social.follow({ ActorType: SocialActorType.Tag, TagGuid: \"19a4a484-c1dc-4bc5-8c93-bb96245ce928\", }); isFollowed \u00b6 Indicates whether the current user is following a specified user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.isFollowed({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); stopFollowing \u00b6 Makes the current user stop following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.stopFollowing({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); my \u00b6 get \u00b6 Gets this user's social information import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const r = await sp.social.my(); followed \u00b6 Gets users, documents, sites, and tags that the current user is following based on the supplied flags. import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get all the followed documents const r1 = await sp.social.my.followed(SocialActorTypes.Document); // get all the followed documents and sites const r2 = await sp.social.my.followed(SocialActorTypes.Document | SocialActorTypes.Site); // get all the followed sites updated in the last 24 hours const r3 = await sp.social.my.followed(SocialActorTypes.Site | SocialActorTypes.WithinLast24Hours); followedCount \u00b6 Works as followed but returns on the count of actors specified by the query import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followedCount(SocialActorTypes.Document); followers \u00b6 Gets the users who are following the current user. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followers(); suggestions \u00b6 Gets users who the current user might want to follow. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.suggestions();","title":"@pnp/sp/ - social"},{"location":"v2/sp/social/#pnpsp-social","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; The social API allows you to track followed sites, people, and docs. Note, many of these methods only work with the context of a logged in user, and not with app-only permissions.","title":"@pnp/sp/ - social"},{"location":"v2/sp/social/#getfollowedsitesuri","text":"Gets a URI to a site that lists the current user's followed sites. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedSitesUri();","title":"getFollowedSitesUri"},{"location":"v2/sp/social/#getfolloweddocumentsuri","text":"Gets a URI to a site that lists the current user's followed documents. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const uri = await sp.social.getFollowedDocumentsUri();","title":"getFollowedDocumentsUri"},{"location":"v2/sp/social/#follow","text":"Makes the current user start following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // follow a site const r1 = await sp.social.follow({ ActorType: SocialActorType.Site, ContentUri: \"htts://tenant.sharepoint.com/sites/site\", }); // follow a person const r2 = await sp.social.follow({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, }); // follow a doc const r3 = await sp.social.follow({ ActorType: SocialActorType.Document, ContentUri: \"https://tenant.sharepoint.com/sites/dev/SitePages/Test.aspx\", }); // follow a tag // You need the tag GUID to start following a tag. // You can't get the GUID by using the REST service, but you can use the .NET client object model or the JavaScript object model. // See How to get a tag's GUID based on the tag's name by using the JavaScript object model. // https://docs.microsoft.com/en-us/sharepoint/dev/general-development/follow-content-in-sharepoint#bk_getTagGuid const r4 = await sp.social.follow({ ActorType: SocialActorType.Tag, TagGuid: \"19a4a484-c1dc-4bc5-8c93-bb96245ce928\", });","title":"follow"},{"location":"v2/sp/social/#isfollowed","text":"Indicates whether the current user is following a specified user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.isFollowed({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, });","title":"isFollowed"},{"location":"v2/sp/social/#stopfollowing","text":"Makes the current user stop following a user, document, site, or tag import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // pass the same social actor struct as shown in follow example for each type const r = await sp.social.stopFollowing({ AccountName: \"i:0#.f|membership|person@tenant.com\", ActorType: SocialActorType.User, });","title":"stopFollowing"},{"location":"v2/sp/social/#my","text":"","title":"my"},{"location":"v2/sp/social/#get","text":"Gets this user's social information import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; const r = await sp.social.my();","title":"get"},{"location":"v2/sp/social/#followed","text":"Gets users, documents, sites, and tags that the current user is following based on the supplied flags. import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get all the followed documents const r1 = await sp.social.my.followed(SocialActorTypes.Document); // get all the followed documents and sites const r2 = await sp.social.my.followed(SocialActorTypes.Document | SocialActorTypes.Site); // get all the followed sites updated in the last 24 hours const r3 = await sp.social.my.followed(SocialActorTypes.Site | SocialActorTypes.WithinLast24Hours);","title":"followed"},{"location":"v2/sp/social/#followedcount","text":"Works as followed but returns on the count of actors specified by the query import { sp } from \"@pnp/sp\"; import { SocialActorType } from \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followedCount(SocialActorTypes.Document);","title":"followedCount"},{"location":"v2/sp/social/#followers","text":"Gets the users who are following the current user. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.followers();","title":"followers"},{"location":"v2/sp/social/#suggestions","text":"Gets users who the current user might want to follow. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/social\"; // get the followed documents count const r = await sp.social.my.suggestions();","title":"suggestions"},{"location":"v2/sp/sp-utilities-utility/","text":"@pnp/sp/utilities \u00b6 Through the REST api you are able to call a subset of the SP.Utilities.Utility methods. We have explicitly defined some of these methods and provided a method to call any others in a generic manner. These methods are exposed on pnp.sp.utility and support batching and caching. sendEmail \u00b6 This methods allows you to send an email based on the supplied arguments. The method takes a single argument, a plain object defined by the EmailProperties interface (shown below). EmailProperties \u00b6 export interface EmailProperties { To: string[]; CC?: string[]; BCC?: string[]; Subject: string; Body: string; AdditionalHeaders?: TypedHash<string>; From?: string; } Usage \u00b6 You must define the To, Subject, and Body values - the remaining are optional. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { IEmailProperties } from \"@pnp/sp/sputilities\"; const emailProps: IEmailProperties = { To: [\"user@site.com\"], CC: [\"user2@site.com\", \"user3@site.com\"], BCC: [\"user4@site.com\", \"user5@site.com\"], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" } }; await sp.utility.sendEmail(emailProps); console.log(\"Email Sent!\"); getCurrentUserEmailAddresses \u00b6 This method returns the current user's email addresses known to SharePoint. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let addressString: string = await sp.utility.getCurrentUserEmailAddresses(); // and use it with sendEmail await sp.utility.sendEmail({ To: [addressString], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" }, }); resolvePrincipal \u00b6 Gets information about a principal that matches the specified Search criteria import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principal : IPrincipalInfo = await sp.utility.resolvePrincipal(\"user@site.com\", PrincipalType.User, PrincipalSource.All, true, false, true); console.log(principal); searchPrincipals \u00b6 Gets information about the principals that match the specified Search criteria. import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.searchPrincipals(\"john\", PrincipalType.User, PrincipalSource.All,\"\", 10); console.log(principals); createEmailBodyForInvitation \u00b6 Gets the external (outside the firewall) URL to a document or resource in a site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let url : string = await sp.utility.createEmailBodyForInvitation(\"https://contoso.sharepoint.com/sites/dev/SitePages/DevHome.aspx\"); console.log(url); expandGroupsToPrincipals \u00b6 Resolves the principals contained within the supplied groups import { sp, IPrincipalInfo } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"]); console.log(principals); // optionally supply a max results count. Default is 30. let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"], 10); console.log(principals); createWikiPage \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { ICreateWikiPageResult } from \"@pnp/sp/sputilities\"; let newPage : ICreateWikiPageResult = await sp.utility.createWikiPage({ ServerRelativeUrl: \"/sites/dev/SitePages/mynewpage.aspx\", WikiHtmlContent: \"This is my <b>page</b> content. It supports rich html.\", }); // newPage contains the raw data returned by the service console.log(newPage.data); // newPage contains a File instance you can use to further update the new page let file = await newPage.file(); console.log(file);","title":"@pnp/sp/utilities"},{"location":"v2/sp/sp-utilities-utility/#pnpsputilities","text":"Through the REST api you are able to call a subset of the SP.Utilities.Utility methods. We have explicitly defined some of these methods and provided a method to call any others in a generic manner. These methods are exposed on pnp.sp.utility and support batching and caching.","title":"@pnp/sp/utilities"},{"location":"v2/sp/sp-utilities-utility/#sendemail","text":"This methods allows you to send an email based on the supplied arguments. The method takes a single argument, a plain object defined by the EmailProperties interface (shown below).","title":"sendEmail"},{"location":"v2/sp/sp-utilities-utility/#emailproperties","text":"export interface EmailProperties { To: string[]; CC?: string[]; BCC?: string[]; Subject: string; Body: string; AdditionalHeaders?: TypedHash<string>; From?: string; }","title":"EmailProperties"},{"location":"v2/sp/sp-utilities-utility/#usage","text":"You must define the To, Subject, and Body values - the remaining are optional. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { IEmailProperties } from \"@pnp/sp/sputilities\"; const emailProps: IEmailProperties = { To: [\"user@site.com\"], CC: [\"user2@site.com\", \"user3@site.com\"], BCC: [\"user4@site.com\", \"user5@site.com\"], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" } }; await sp.utility.sendEmail(emailProps); console.log(\"Email Sent!\");","title":"Usage"},{"location":"v2/sp/sp-utilities-utility/#getcurrentuseremailaddresses","text":"This method returns the current user's email addresses known to SharePoint. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let addressString: string = await sp.utility.getCurrentUserEmailAddresses(); // and use it with sendEmail await sp.utility.sendEmail({ To: [addressString], Subject: \"This email is about...\", Body: \"Here is the body. <b>It supports html</b>\", AdditionalHeaders: { \"content-type\": \"text/html\" }, });","title":"getCurrentUserEmailAddresses"},{"location":"v2/sp/sp-utilities-utility/#resolveprincipal","text":"Gets information about a principal that matches the specified Search criteria import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principal : IPrincipalInfo = await sp.utility.resolvePrincipal(\"user@site.com\", PrincipalType.User, PrincipalSource.All, true, false, true); console.log(principal);","title":"resolvePrincipal"},{"location":"v2/sp/sp-utilities-utility/#searchprincipals","text":"Gets information about the principals that match the specified Search criteria. import { sp, IPrincipalInfo, PrincipalType, PrincipalSource } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.searchPrincipals(\"john\", PrincipalType.User, PrincipalSource.All,\"\", 10); console.log(principals);","title":"searchPrincipals"},{"location":"v2/sp/sp-utilities-utility/#createemailbodyforinvitation","text":"Gets the external (outside the firewall) URL to a document or resource in a site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let url : string = await sp.utility.createEmailBodyForInvitation(\"https://contoso.sharepoint.com/sites/dev/SitePages/DevHome.aspx\"); console.log(url);","title":"createEmailBodyForInvitation"},{"location":"v2/sp/sp-utilities-utility/#expandgroupstoprincipals","text":"Resolves the principals contained within the supplied groups import { sp, IPrincipalInfo } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"]); console.log(principals); // optionally supply a max results count. Default is 30. let principals : IPrincipalInfo[] = await sp.utility.expandGroupsToPrincipals([\"Dev Owners\", \"Dev Members\"], 10); console.log(principals);","title":"expandGroupsToPrincipals"},{"location":"v2/sp/sp-utilities-utility/#createwikipage","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/sputilities\"; import { ICreateWikiPageResult } from \"@pnp/sp/sputilities\"; let newPage : ICreateWikiPageResult = await sp.utility.createWikiPage({ ServerRelativeUrl: \"/sites/dev/SitePages/mynewpage.aspx\", WikiHtmlContent: \"This is my <b>page</b> content. It supports rich html.\", }); // newPage contains the raw data returned by the service console.log(newPage.data); // newPage contains a File instance you can use to further update the new page let file = await newPage.file(); console.log(file);","title":"createWikiPage"},{"location":"v2/sp/subscriptions/","text":"@pnp/sp/subscriptions \u00b6 Webhooks on a SharePoint list are used to notify any change in the list, to other applications using a push model. This module provides methods to add, update or delete webhooks on a particular SharePoint list or library. ISubscriptions \u00b6 Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import {sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/presets/all\"; Add a webhook \u00b6 Using this library, you can add a webhook to a specified list within the SharePoint site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\"; // This is the URL which will be called by SharePoint when there is a change in the list const notificationUrl = \"<notification-url>\"; // Set the expiry date to 180 days from now, which is the maximum allowed for the webhook expiry date. const expiryDate = dateAdd(new Date(), \"day\" , 180).toISOString(); // Adds a webhook to the Documents library var res = await sp.web.lists.getByTitle(\"Documents\").subscriptions.add(notificationUrl,expiryDate); Get all webhooks added to a list \u00b6 Read all the webhooks' details which are associated to the list import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; const res = await sp.web.lists.getByTitle(\"Documents\").subscriptions(); ISubscription \u00b6 This interface provides the methods for managing a particular webhook. Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import { sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription } from \"@pnp/sp/presets/all\"; Managing a webhook \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; // Get details of a webhook based on its ID const webhookId = \"1f029e5c-16e4-4941-b46f-67895118763f\"; const webhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId)(); // Update a webhook const newDate = dateAdd(new Date(), \"day\" , 150).toISOString(); const updatedWebhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).update(newDate); // Delete a webhook await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).delete();","title":"@pnp/sp/subscriptions"},{"location":"v2/sp/subscriptions/#pnpspsubscriptions","text":"Webhooks on a SharePoint list are used to notify any change in the list, to other applications using a push model. This module provides methods to add, update or delete webhooks on a particular SharePoint list or library.","title":"@pnp/sp/subscriptions"},{"location":"v2/sp/subscriptions/#isubscriptions","text":"Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import {sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/presets/all\";","title":"ISubscriptions"},{"location":"v2/sp/subscriptions/#add-a-webhook","text":"Using this library, you can add a webhook to a specified list within the SharePoint site. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\"; // This is the URL which will be called by SharePoint when there is a change in the list const notificationUrl = \"<notification-url>\"; // Set the expiry date to 180 days from now, which is the maximum allowed for the webhook expiry date. const expiryDate = dateAdd(new Date(), \"day\" , 180).toISOString(); // Adds a webhook to the Documents library var res = await sp.web.lists.getByTitle(\"Documents\").subscriptions.add(notificationUrl,expiryDate);","title":"Add a webhook"},{"location":"v2/sp/subscriptions/#get-all-webhooks-added-to-a-list","text":"Read all the webhooks' details which are associated to the list import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; const res = await sp.web.lists.getByTitle(\"Documents\").subscriptions();","title":"Get all webhooks added to a list"},{"location":"v2/sp/subscriptions/#isubscription","text":"This interface provides the methods for managing a particular webhook. Scenario Import Statement Selective import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import { Subscriptions, ISubscriptions, Subscription, ISubscription} from \"@pnp/sp/subscriptions\"; import \"@pnp/sp/subscriptions/list\" Preset: All import { sp, Webs, IWebs, Lists, ILists, Subscriptions, ISubscriptions, Subscription, ISubscription } from \"@pnp/sp/presets/all\";","title":"ISubscription"},{"location":"v2/sp/subscriptions/#managing-a-webhook","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/subscriptions\"; // Get details of a webhook based on its ID const webhookId = \"1f029e5c-16e4-4941-b46f-67895118763f\"; const webhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId)(); // Update a webhook const newDate = dateAdd(new Date(), \"day\" , 150).toISOString(); const updatedWebhook = await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).update(newDate); // Delete a webhook await sp.web.lists.getByTitle(\"Documents\").subscriptions.getById(webhookId).delete();","title":"Managing a webhook"},{"location":"v2/sp/taxonomy/","text":"@pnp/sp/taxonomy \u00b6 Provides access to the v2.1 api term store Docs updated with v2.0.9 release as the underlying API changed. \u00b6 NOTE: This API may change so please be aware updates to the taxonomy module will not trigger a major version bump in PnPjs even if they are breaking. Once things stabalize this note will be removed. Term Store \u00b6 Access term store data from the root sp object as shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermStoreInfo } from \"@pnp/sp/taxonomy\"; // get term store data const info: ITermStoreInfo = await sp.termStore(); Term Groups \u00b6 Access term group information List \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups const info: ITermGroupInfo[] = await sp.termStore.groups(); Get By Id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups data const info: ITermGroupInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\")(); Term Sets \u00b6 Access term set information List \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get get set info const info: ITermSetInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets(); Get By Id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermSetInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\")(); getAllChildrenAsOrderedTree \u00b6 Added in 2.0.13 This method will get all of a set's child terms in an ordered array. It is a costly method in terms of requests so we suggest you cache the results as taxonomy trees seldom change. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; import { dateAdd, PnPClientStorage } from \"@pnp/core\"; // here we get all the children of a given set const childTree = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); // here we show caching the results using the PnPClientStorage class, there are many caching libraries and options available const store = new PnPClientStorage(); // our tree likely doesn't change much in 30 minutes for most applications // adjust to be longer or shorter as needed const cachedTree = await store.local.getOrPut(\"myKey\", () => { return sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); }, dateAdd(new Date(), \"minute\", 30)); Terms \u00b6 Access term set information List \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").children(); List (terms) \u00b6 Added in 2.0.13 You can use the terms property to get a flat list of all terms in the set. These terms do not contain parent/child relationship information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").terms(); Get By Id \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getTermById(\"338666a8-1111-2222-3333-f72471314e72\")(); Get Term Parent \u00b6 Behavior Change in 2.1.0 The server API changed again, resulting in the removal of the \"parent\" property from ITerm as it is not longer supported as a path property. You now must use \"expand\" to load a term's parent information. The side affect of this is that the parent is no longer chainable, meaning you need to load a new term instance to work with the parent term. An approach for this is shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; // get a ref to the set const set = sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\"); // get a term's information and expand parent to get the parent info as well const w = await set.getTermById(\"338666a8-1111-2222-3333-f72471314e72\").expand(\"parent\")(); // get a ref to the parent term const parent = set.getTermById(w.parent.id); // make a request for the parent term's info - this data currently match the results in the expand call above, but this // is to demonstrate how to gain a ref to the parent and select its data const parentInfo = await parent.select(\"Id\", \"Descriptions\")();","title":"@pnp/sp/taxonomy"},{"location":"v2/sp/taxonomy/#pnpsptaxonomy","text":"Provides access to the v2.1 api term store","title":"@pnp/sp/taxonomy"},{"location":"v2/sp/taxonomy/#docs-updated-with-v209-release-as-the-underlying-api-changed","text":"NOTE: This API may change so please be aware updates to the taxonomy module will not trigger a major version bump in PnPjs even if they are breaking. Once things stabalize this note will be removed.","title":"Docs updated with v2.0.9 release as the underlying API changed."},{"location":"v2/sp/taxonomy/#term-store","text":"Access term store data from the root sp object as shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermStoreInfo } from \"@pnp/sp/taxonomy\"; // get term store data const info: ITermStoreInfo = await sp.termStore();","title":"Term Store"},{"location":"v2/sp/taxonomy/#term-groups","text":"Access term group information","title":"Term Groups"},{"location":"v2/sp/taxonomy/#list","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups const info: ITermGroupInfo[] = await sp.termStore.groups();","title":"List"},{"location":"v2/sp/taxonomy/#get-by-id","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermGroupInfo } from \"@pnp/sp/taxonomy\"; // get term groups data const info: ITermGroupInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\")();","title":"Get By Id"},{"location":"v2/sp/taxonomy/#term-sets","text":"Access term set information","title":"Term Sets"},{"location":"v2/sp/taxonomy/#list_1","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get get set info const info: ITermSetInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets();","title":"List"},{"location":"v2/sp/taxonomy/#get-by-id_1","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermSetInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermSetInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\")();","title":"Get By Id"},{"location":"v2/sp/taxonomy/#getallchildrenasorderedtree","text":"Added in 2.0.13 This method will get all of a set's child terms in an ordered array. It is a costly method in terms of requests so we suggest you cache the results as taxonomy trees seldom change. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; import { dateAdd, PnPClientStorage } from \"@pnp/core\"; // here we get all the children of a given set const childTree = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); // here we show caching the results using the PnPClientStorage class, there are many caching libraries and options available const store = new PnPClientStorage(); // our tree likely doesn't change much in 30 minutes for most applications // adjust to be longer or shorter as needed const cachedTree = await store.local.getOrPut(\"myKey\", () => { return sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getAllChildrenAsOrderedTree(); }, dateAdd(new Date(), \"minute\", 30));","title":"getAllChildrenAsOrderedTree"},{"location":"v2/sp/taxonomy/#terms","text":"Access term set information","title":"Terms"},{"location":"v2/sp/taxonomy/#list_2","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").children();","title":"List"},{"location":"v2/sp/taxonomy/#list-terms","text":"Added in 2.0.13 You can use the terms property to get a flat list of all terms in the set. These terms do not contain parent/child relationship information. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // list all the terms that are direct children of this set const infos: ITermInfo[] = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").terms();","title":"List (terms)"},{"location":"v2/sp/taxonomy/#get-by-id_2","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; import { ITermInfo } from \"@pnp/sp/taxonomy\"; // get term set data const info: ITermInfo = await sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\").getTermById(\"338666a8-1111-2222-3333-f72471314e72\")();","title":"Get By Id"},{"location":"v2/sp/taxonomy/#get-term-parent","text":"Behavior Change in 2.1.0 The server API changed again, resulting in the removal of the \"parent\" property from ITerm as it is not longer supported as a path property. You now must use \"expand\" to load a term's parent information. The side affect of this is that the parent is no longer chainable, meaning you need to load a new term instance to work with the parent term. An approach for this is shown below. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/taxonomy\"; // get a ref to the set const set = sp.termStore.groups.getById(\"338666a8-1111-2222-3333-f72471314e72\").sets.getById(\"338666a8-1111-2222-3333-f72471314e72\"); // get a term's information and expand parent to get the parent info as well const w = await set.getTermById(\"338666a8-1111-2222-3333-f72471314e72\").expand(\"parent\")(); // get a ref to the parent term const parent = set.getTermById(w.parent.id); // make a request for the parent term's info - this data currently match the results in the expand call above, but this // is to demonstrate how to gain a ref to the parent and select its data const parentInfo = await parent.select(\"Id\", \"Descriptions\")();","title":"Get Term Parent"},{"location":"v2/sp/tenant-properties/","text":"@pnp/sp/web - tenant properties \u00b6 You can set, read, and remove tenant properties using the methods shown below: setStorageEntity \u00b6 This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); // specify required key and value await w.setStorageEntity(\"Test1\", \"Value 1\"); // specify optional description and comments await w.setStorageEntity(\"Test2\", \"Value 2\", \"description\", \"comments\"); getStorageEntity \u00b6 This method can be used from any web to retrieve values previously set. import { sp, IStorageEntity } from \"@pnp/sp/presets/all\"; const prop: IStorageEntity = await sp.web.getStorageEntity(\"Test1\"); console.log(prop.Value); removeStorageEntity \u00b6 This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); await w.removeStorageEntity(\"Test1\");","title":"@pnp/sp/web - tenant properties"},{"location":"v2/sp/tenant-properties/#pnpspweb-tenant-properties","text":"You can set, read, and remove tenant properties using the methods shown below:","title":"@pnp/sp/web - tenant properties"},{"location":"v2/sp/tenant-properties/#setstorageentity","text":"This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); // specify required key and value await w.setStorageEntity(\"Test1\", \"Value 1\"); // specify optional description and comments await w.setStorageEntity(\"Test2\", \"Value 2\", \"description\", \"comments\");","title":"setStorageEntity"},{"location":"v2/sp/tenant-properties/#getstorageentity","text":"This method can be used from any web to retrieve values previously set. import { sp, IStorageEntity } from \"@pnp/sp/presets/all\"; const prop: IStorageEntity = await sp.web.getStorageEntity(\"Test1\"); console.log(prop.Value);","title":"getStorageEntity"},{"location":"v2/sp/tenant-properties/#removestorageentity","text":"This method MUST be called in the context of the app catalog web or you will get an access denied message. import { Web } from \"@pnp/sp/webs\"; const w = Web(\"https://tenant.sharepoint.com/sites/appcatalog/\"); await w.removeStorageEntity(\"Test1\");","title":"removeStorageEntity"},{"location":"v2/sp/user-custom-actions/","text":"@pnp/sp/user-custom-actions \u00b6 Represents a custom action associated with a SharePoint list, web or site collection. IUserCustomActions \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IUserCustomActions, IUserCustomAction } from \"@pnp/sp/user-custom-actions\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/user-custom-actions\"; Preset: All import { sp, IUserCustomActions, IUserCustomAction } from \"@pnp/sp/presents/all\"; Get a collection of User Custom Actions from a web \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const userCustomActions = sp.web.userCustomActions(); Add a new User Custom Action \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionAddResult } from '@pnp/sp/user-custom-actions'; const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"Location\": \"ScriptLink\", \"ScriptSrc\": \"https://...\" }; const response : IUserCustomActionAddResult = await sp.web.userCustomActions.add(newValues); Get a User Custom Action by ID \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const uca: IUserCustomAction = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const ucaData = await uca(); Clear the User Custom Action collection \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; // Site collection level await sp.site.userCustomActions.clear(); // Site (web) level await sp.web.userCustomActions.clear(); // List level await sp.web.lists.getByTitle(\"Documents\").userCustomActions.clear(); IUserCustomAction \u00b6 Update an existing User Custom Action \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionUpdateResult } from '@pnp/sp/user-custom-actions'; const uca = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"ScriptSrc\": \"https://...\" }; const response: IUserCustomActionUpdateResult = uca.update(newValues);","title":"@pnp/sp/user-custom-actions"},{"location":"v2/sp/user-custom-actions/#pnpspuser-custom-actions","text":"Represents a custom action associated with a SharePoint list, web or site collection.","title":"@pnp/sp/user-custom-actions"},{"location":"v2/sp/user-custom-actions/#iusercustomactions","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { IUserCustomActions, IUserCustomAction } from \"@pnp/sp/user-custom-actions\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/user-custom-actions\"; Preset: All import { sp, IUserCustomActions, IUserCustomAction } from \"@pnp/sp/presents/all\";","title":"IUserCustomActions"},{"location":"v2/sp/user-custom-actions/#get-a-collection-of-user-custom-actions-from-a-web","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const userCustomActions = sp.web.userCustomActions();","title":"Get a collection of User Custom Actions from a web"},{"location":"v2/sp/user-custom-actions/#add-a-new-user-custom-action","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionAddResult } from '@pnp/sp/user-custom-actions'; const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"Location\": \"ScriptLink\", \"ScriptSrc\": \"https://...\" }; const response : IUserCustomActionAddResult = await sp.web.userCustomActions.add(newValues);","title":"Add a new User Custom Action"},{"location":"v2/sp/user-custom-actions/#get-a-user-custom-action-by-id","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; const uca: IUserCustomAction = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const ucaData = await uca();","title":"Get a User Custom Action by ID"},{"location":"v2/sp/user-custom-actions/#clear-the-user-custom-action-collection","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; // Site collection level await sp.site.userCustomActions.clear(); // Site (web) level await sp.web.userCustomActions.clear(); // List level await sp.web.lists.getByTitle(\"Documents\").userCustomActions.clear();","title":"Clear the User Custom Action collection"},{"location":"v2/sp/user-custom-actions/#iusercustomaction","text":"","title":"IUserCustomAction"},{"location":"v2/sp/user-custom-actions/#update-an-existing-user-custom-action","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/user-custom-actions\"; import { IUserCustomActionUpdateResult } from '@pnp/sp/user-custom-actions'; const uca = sp.web.userCustomActions.getById(\"00000000-0000-0000-0000-000000000000\"); const newValues: TypedHash<string> = { \"Title\": \"New Title\", \"Description\": \"New Description\", \"ScriptSrc\": \"https://...\" }; const response: IUserCustomActionUpdateResult = uca.update(newValues);","title":"Update an existing User Custom Action"},{"location":"v2/sp/views/","text":"@pnp/sp/views \u00b6 Views define the columns, ordering, and other details we see when we look at a list. You can have multiple views for a list, including private views - and one default view. IViews \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Views, IViews } from \"@pnp/sp/views\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/views\"; Preset: All import { sp, Views, IViews } from \"@pnp/sp/presets/all\"; Get views in a list \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // get all the views and their properties const views1 = await list.views(); // you can use odata select operations to get just a set a fields const views2 = await list.views.select(\"Id\", \"Title\")(); // get the top three views const views3 = await list.views.top(3)(); Add a View \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // create a new view with default fields and properties const result = await list.views.add(\"My New View\"); // create a new view with specific properties const result2 = await list.views.add(\"My New View 2\", false, { RowLimit: 10, ViewQuery: \"<OrderBy><FieldRef Name='Modified' Ascending='False' /></OrderBy>\", }); // manipulate the view's fields await result2.view.fields.removeAll(); await Promise.all([ result2.view.fields.add(\"Title\"), result2.view.fields.add(\"Modified\"), ]); IView \u00b6 Get a View's Information \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\")(); const result2 = await list.views.getByTitle(\"My View\")(); const result3 = await list.views.getByTitle(\"My View\").select(\"Id\", \"Title\")(); const result4 = await list.defaultView(); const result5 = await list.getView(\"{GUID view id}\")(); fields \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").fields(); update \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").update({ RowLimit: 20, }); renderAsHtml \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const result = await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").renderAsHtml(); setViewXml \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").setViewXml(viewXml); delete \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").delete(); ViewFields \u00b6 getSchemaXml \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const xml = await sp.web.lists.getByTitle(\"My List\").defaultView.fields.getSchemaXml(); add \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.add(\"Created\"); move \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.move(\"Created\", 0); remove \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.remove(\"Created\"); removeAll \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.removeAll();","title":"@pnp/sp/views"},{"location":"v2/sp/views/#pnpspviews","text":"Views define the columns, ordering, and other details we see when we look at a list. You can have multiple views for a list, including private views - and one default view.","title":"@pnp/sp/views"},{"location":"v2/sp/views/#iviews","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Views, IViews } from \"@pnp/sp/views\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/views\"; Preset: All import { sp, Views, IViews } from \"@pnp/sp/presets/all\";","title":"IViews"},{"location":"v2/sp/views/#get-views-in-a-list","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // get all the views and their properties const views1 = await list.views(); // you can use odata select operations to get just a set a fields const views2 = await list.views.select(\"Id\", \"Title\")(); // get the top three views const views3 = await list.views.top(3)();","title":"Get views in a list"},{"location":"v2/sp/views/#add-a-view","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); // create a new view with default fields and properties const result = await list.views.add(\"My New View\"); // create a new view with specific properties const result2 = await list.views.add(\"My New View 2\", false, { RowLimit: 10, ViewQuery: \"<OrderBy><FieldRef Name='Modified' Ascending='False' /></OrderBy>\", }); // manipulate the view's fields await result2.view.fields.removeAll(); await Promise.all([ result2.view.fields.add(\"Title\"), result2.view.fields.add(\"Modified\"), ]);","title":"Add a View"},{"location":"v2/sp/views/#iview","text":"","title":"IView"},{"location":"v2/sp/views/#get-a-views-information","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\")(); const result2 = await list.views.getByTitle(\"My View\")(); const result3 = await list.views.getByTitle(\"My View\").select(\"Id\", \"Title\")(); const result4 = await list.defaultView(); const result5 = await list.getView(\"{GUID view id}\")();","title":"Get a View's Information"},{"location":"v2/sp/views/#fields","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").fields();","title":"fields"},{"location":"v2/sp/views/#update","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const list = sp.web.lists.getByTitle(\"My List\"); const result = await list.views.getById(\"{GUID view id}\").update({ RowLimit: 20, });","title":"update"},{"location":"v2/sp/views/#renderashtml","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const result = await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").renderAsHtml();","title":"renderAsHtml"},{"location":"v2/sp/views/#setviewxml","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").setViewXml(viewXml);","title":"setViewXml"},{"location":"v2/sp/views/#delete","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const viewXml = \"...\"; await sp.web.lists.getByTitle(\"My List\").views.getById(\"{GUID view id}\").delete();","title":"delete"},{"location":"v2/sp/views/#viewfields","text":"","title":"ViewFields"},{"location":"v2/sp/views/#getschemaxml","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; const xml = await sp.web.lists.getByTitle(\"My List\").defaultView.fields.getSchemaXml();","title":"getSchemaXml"},{"location":"v2/sp/views/#add","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.add(\"Created\");","title":"add"},{"location":"v2/sp/views/#move","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.move(\"Created\", 0);","title":"move"},{"location":"v2/sp/views/#remove","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.remove(\"Created\");","title":"remove"},{"location":"v2/sp/views/#removeall","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/lists\"; import \"@pnp/sp/views\"; await sp.web.lists.getByTitle(\"My List\").defaultView.fields.removeAll();","title":"removeAll"},{"location":"v2/sp/webs/","text":"@pnp/sp/webs \u00b6 Webs are one of the fundamental entry points when working with SharePoint. Webs serve as a container for lists, features, sub-webs, and all of the entity types. IWebs \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Webs, IWebs } from \"@pnp/sp/presets/core\"; Add Web \u00b6 Using the library you can add a web to another web's collection of subwebs. The simplest usage requires only a title and url. This will result in a team site with all of the default settings. You can also provide other settings such as description, template, language, and inherit permissions. import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; const result = await sp.web.webs.add(\"title\", \"subweb1\"); // show the response from the server when adding the web console.log(result.data); // we can immediately operate on the new web result.web.select(\"Title\")().then((w: IWebAddResult) => { // show our title console.log(w.Title); }); import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; // create a German language wiki site with title, url, description, which does not inherit permissions sp.web.webs.add(\"wiki\", \"subweb2\", \"a wiki web\", \"WIKI#0\", 1031, false).then((w: IWebAddResult) => { // ... }); IWeb \u00b6 Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Web, IWeb } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Web, IWeb } from \"@pnp/sp/presets/core\"; Access a Web \u00b6 There are several ways to access a web instance, each of these methods is equivalent in that you will have an IWeb instance to work with. All of the examples below use a variable named \"web\" which represents an IWeb instance - regardless of how it was initially accessed. Access the web from the imported \"sp\" object using selective import: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'all' preset import { sp } from \"@pnp/sp/presets/all\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'core' preset import { sp } from \"@pnp/sp/presets/core\"; const r = await sp.web(); Create a web instance using the factory function import { Web } from \"@pnp/sp/webs\"; const web = Web(\"https://something.sharepoint.com/sites/dev\"); const r = await web(); webs \u00b6 Access the child webs collection of this web const webs = web.webs(); Get A Web's properties \u00b6 // basic get of the webs properties const props = await web(); // use odata operators to get specific fields const props2 = await web.select(\"Title\")(); // type the result to match what you are requesting const props3 = await web.select(\"Title\")<{ Title: string }>(); getParentWeb \u00b6 Get the data and IWeb instance for the parent web for the given web instance import { IOpenWebByIdResult } from \"@pnp/sp/sites\"; const web: IOpenWebByIdResult = web.getParentWeb(); getSubwebsFilteredForCurrentUser \u00b6 Returns a collection of objects that contain metadata about subsites of the current site in which the current user is a member. const subWebs = await web.getSubwebsFilteredForCurrentUser()(); // apply odata operations to the collection const subWebs2 = await sp.web.getSubwebsFilteredForCurrentUser().select(\"Title\", \"Language\").orderBy(\"Created\", true)(); Note: getSubwebsFilteredForCurrentUser returns IWebInfosData which is a subset of all the available fields on IWebInfo. allProperties \u00b6 Allows access to the web's all properties collection. This is readonly in REST. const props = await web.allProperties(); // select certain props const props2 = await web.allProperties.select(\"prop1\", \"prop2\")(); webinfos \u00b6 Gets a collection of WebInfos for this web's subwebs const infos = await web.webinfos(); // or select certain fields const infos2 = await web.webinfos.select(\"Title\", \"Description\")(); // or filter const infos3 = await web.webinfos.filter(\"Title eq 'MyWebTitle'\")(); // or both const infos4 = await web.webinfos.select(\"Title\", \"Description\").filter(\"Title eq 'MyWebTitle'\")(); // get the top 4 ordered by Title const infos5 = await web.webinfos.top(4).orderBy(\"Title\")(); Note: webinfos returns IWebInfosData which is a subset of all the available fields on IWebInfo. update \u00b6 Updates this web instance with the supplied properties // update the web's title and description const result = await web.update({ Title: \"New Title\", Description: \"My new description\", }); // a project implementation could wrap the update to provide type information for your expected fields: import { IWebUpdateResult } from \"@pnp/sp/webs\"; interface IWebUpdateProps { Title: string; Description: string; } function updateWeb(props: IWebUpdateProps): Promise<IWebUpdateResult> { web.update(props); } Delete a Web \u00b6 await web.delete(); applyTheme \u00b6 Applies the theme specified by the contents of each of the files specified in the arguments to the site import { combine } from \"@pnp/core\"; // we are going to apply the theme to this sub web as an example const web = Web(\"https://{tenant}.sharepoint.com/sites/dev/subweb\"); // the urls to the color and font need to both be from the catalog at the root // these urls can be constants or calculated from existing urls const colorUrl = combine(\"/\", \"sites/dev\", \"_catalogs/theme/15/palette011.spcolor\"); // this gives us the same result const fontUrl = \"/sites/dev/_catalogs/theme/15/fontscheme007.spfont\"; // apply the font and color, no background image, and don't share this theme await web.applyTheme(colorUrl, fontUrl, \"\", false); applyWebTemplate & availableWebTemplates \u00b6 Applies the specified site definition or site template to the Web site that has no template applied to it. This is seldom used outside provisioning scenarios. const templates = (await web.availableWebTemplates().select(\"Name\")<{ Name: string }[]>()).filter(t => /ENTERWIKI#0/i.test(t.Name)); // apply the wiki template const template = templates.length > 0 ? templates[0].Name : \"STS#0\"; await web.applyWebTemplate(template); getChanges \u00b6 Returns the collection of changes from the change log that have occurred within the web, based on the specified query. // get the web changes including add, update, and delete const changes = await web.getChanges({ Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Update: true, Web: true, }); mapToIcon \u00b6 Returns the name of the image file for the icon that is used to represent the specified file import { combine } from \"@pnp/core\"; const iconFileName = await web.mapToIcon(\"test.docx\"); // iconPath === \"icdocx.png\" // which you can need to map to a real url const iconFullPath = `https://{tenant}.sharepoint.com/sites/dev/_layouts/images/${iconFileName}`; // OR dynamically const webData = await sp.web.select(\"Url\")(); const iconFullPath2 = combine(webData.Url, \"_layouts\", \"images\", iconFileName); // OR within SPFx using the context const iconFullPath3 = combine(this.context.pageContext.web.absoluteUrl, \"_layouts\", \"images\", iconFileName); // You can also set size // 16x16 pixels = 0, 32x32 pixels = 1 const icon32FileName = await web.mapToIcon(\"test.docx\", 1); storage entities \u00b6 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import { IStorageEntity } from \"@pnp/sp/webs\"; // needs to be unique, GUIDs are great const key = \"my-storage-key\"; // read an existing entity const entity: IStorageEntity = await web.getStorageEntity(key); // setStorageEntity and removeStorageEntity must be called in the context of the tenant app catalog site // you can get the tenant app catalog using the getTenantAppCatalogWeb const tenantAppCatalogWeb = await sp.getTenantAppCatalogWeb(); tenantAppCatalogWeb.setStorageEntity(key, \"new value\"); // set other properties tenantAppCatalogWeb.setStorageEntity(key, \"another value\", \"description\", \"comments\"); const entity2: IStorageEntity = await web.getStorageEntity(key); /* entity2 === { Value: \"another value\", Comment: \"comments\"; Description: \"description\", }; */ // you can also remove a storage entity await tenantAppCatalogWeb.removeStorageEntity(key); appcatalog imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/appcatalog\"; Selective 2 import \"@pnp/sp/appcatalog/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; getAppCatalog \u00b6 Returns this web as an IAppCatalog instance or creates a new IAppCatalog instance from the provided url. import { IApp } from \"@pnp/sp/appcatalog\"; const appWeb = web.getAppCatalog(); // appWeb url === web url const app: IApp = appWeb.getAppById(\"{your app id}\"); const appWeb2 = web.getAppCatalog(\"https://tenant.sharepoing.com/sites/someappcatalog\"); // appWeb2 url === \"https://tenant.sharepoing.com/sites/someappcatalog\" client-side-pages imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/client-side-pages\"; Selective 2 import \"@pnp/sp/client-side-pages/web\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; You can create and load clientside page instances directly from a web. More details on working with clientside pages are available in the dedicated article. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // simplest add a page example const page = await sp.web.addClientsidePage(\"mypage1\"); // simplest load a page example const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\"); content-type imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; contentTypes \u00b6 Allows access to the collection of content types in this web. const cts = await web.contentTypes(); // you can also select fields and use other odata operators const cts2 = await web.contentTypes.select(\"Name\")(); features imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/features\"; Selective 2 import \"@pnp/sp/features/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; features \u00b6 Allows access to the collection of content types in this web. const features = await web.features(); fields imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; fields \u00b6 Allows access to the collection of fields in this web. const fields = await web.fields(); files imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/files\"; Selective 2 import \"@pnp/sp/files/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; getFileByServerRelativeUrl \u00b6 Gets a file by server relative url import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativeUrl(\"/sites/dev/library/myfile.docx\"); getFileByServerRelativePath \u00b6 Gets a file by server relative url if your file name contains # and % characters import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativePath(\"/sites/dev/library/my # file%.docx\"); folders imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; folders \u00b6 Gets the collection of folders in this web const folders = await web.folders(); // you can also filter and select as with any collection const folders2 = await web.folders.select(\"ServerRelativeUrl\", \"TimeLastModified\").filter(\"ItemCount gt 0\")(); // or get the most recently modified folder const folders2 = await web.folders.orderBy(\"TimeLastModified\").top(1)(); rootFolder \u00b6 Gets the root folder of the web const folder = await web.rootFolder(); getFolderByServerRelativeUrl \u00b6 Gets a folder by server relative url import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativeUrl(\"/sites/dev/library\"); getFolderByServerRelativePath \u00b6 Gets a folder by server relative url if your folder name contains # and % characters import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativePath(\"/sites/dev/library/my # folder%/\"); hubsites imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/hubsites\"; Selective 2 import \"@pnp/sp/hubsites/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; hubSiteData \u00b6 Gets hub site data for the current web import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; // get the data and force a refresh const data: IHubSiteWebData = await web.hubSiteData(true); syncHubSiteTheme \u00b6 Applies theme updates from the parent hub site collection await web.syncHubSiteTheme(); lists imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/lists\"; Selective 2 import \"@pnp/sp/lists/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\"; lists \u00b6 Gets the collection of all lists that are contained in the Web site import { ILists } from \"@pnp/sp/lists\"; const lists: ILists = web.lists; // you can always order the lists and select properties const data = await lists.select(\"Title\").orderBy(\"Title\")(); // and use other odata operators as well const data2 = await web.lists.top(3).orderBy(\"LastItemModifiedDate\")(); siteUserInfoList \u00b6 Gets the UserInfo list of the site collection that contains the Web site import { IList } from \"@pnp/sp/lists\"; const list: IList = web.siteUserInfoList; const data = await list(); // or chain off that list to get additional details const items = await list.items.top(2)(); defaultDocumentLibrary \u00b6 Get a reference the default documents library of a web import { IList } from \"@pnp/sp/lists\"; const list: IList = web.defaultDocumentLibrary; customListTemplates \u00b6 Gets the collection of all list definitions and list templates that are available import { IList } from \"@pnp/sp/lists\"; const templates = await web.customListTemplates(); // odata operators chain off the collection as expected const templates2 = await web.customListTemplates.select(\"Title\")(); getList \u00b6 Gets a list by server relative url (list's root folder) import { IList } from \"@pnp/sp/lists\"; const list: IList = web.getList(\"/sites/dev/lists/test\"); const listData = list(); getCatalog \u00b6 Returns the list gallery on the site Name Value WebTemplateCatalog 111 WebPartCatalog 113 ListTemplateCatalog 114 MasterPageCatalog 116 SolutionCatalog 121 ThemeCatalog 123 DesignCatalog 124 AppDataCatalog 125 import { IList } from \"@pnp/sp/lists\"; const templateCatalog: IList = await web.getCatalog(111); const themeCatalog: IList = await web.getCatalog(123); navigation imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/navigation\"; Selective 2 import \"@pnp/sp/navigation/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; navigation \u00b6 Gets a navigation object that represents navigation on the Web site, including the Quick Launch area and the top navigation bar import { INavigation } from \"@pnp/sp/navigation\"; const nav: INavigation = web.navigation; const navData = await nav(); regional-settings imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/regional-settings\"; Selective 2 import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRegionalSettings } from \"@pnp/sp/navigation\"; const settings: IRegionalSettings = web.regionalSettings; const settingsData = await settings(); related-items imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/related-items\"; Selective 2 import \"@pnp/sp/related-items/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRelatedItemManager, IRelatedItem } from \"@pnp/sp/related-items\"; const manager: IRelatedItemManager = web.relatedItems; const data: IRelatedItem[] = await manager.getRelatedItems(\"{list name}\", 4); security imports \u00b6 Please see information around the available security methods in the security article . sharing imports \u00b6 Please see information around the available sharing methods in the sharing article . site-groups imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/site-groups\"; Selective 2 import \"@pnp/sp/site-groups/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; siteGroups \u00b6 The site groups const groups = await web.siteGroups(); const groups2 = await web.siteGroups.top(2)(); associatedOwnerGroup \u00b6 The web's owner group const group = await web.associatedOwnerGroup(); const users = await web.associatedOwnerGroup.users(); associatedMemberGroup \u00b6 The web's member group const group = await web.associatedMemberGroup(); const users = await web.associatedMemberGroup.users(); associatedVisitorGroup \u00b6 The web's visitor group const group = await web.associatedVisitorGroup(); const users = await web.associatedVisitorGroup.users(); createDefaultAssociatedGroups \u00b6 Creates the default associated groups (Members, Owners, Visitors) and gives them the default permissions on the site. The target site must have unique permissions and no associated members / owners / visitors groups await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\"); // copy the role assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", true); // don't clear sub assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, false); // specify secondary owner, don't copy permissions, clear sub scopes await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, true, \"{second owner login}\"); site-users imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/site-users\"; Selective 2 import \"@pnp/sp/site-users/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; siteUsers \u00b6 The site users const users = await web.siteUsers(); const users2 = await web.siteUsers.top(5)(); const users3 = await web.siteUsers.filter(`startswith(LoginName, '${encodeURIComponent(\"i:0#.f|m\")}')`)(); currentUser \u00b6 Information on the current user const user = await web.currentUser(); // check the login name of the current user const user2 = await web.currentUser.select(\"LoginName\")(); ensureUser \u00b6 Checks whether the specified login name belongs to a valid user in the web. If the user doesn't exist, adds the user to the web import { IWebEnsureUserResult } from \"@pnp/sp/site-users/\"; const result: IWebEnsureUserResult = await web.ensureUser(\"i:0#.f|membership|user@domain.onmicrosoft.com\"); getUserById \u00b6 Returns the user corresponding to the specified member identifier for the current web import { ISiteUser } from \"@pnp/sp/site-users/\"; const user: ISiteUser = web.getUserById(23); const userData = await user(); const userData2 = await user.select(\"LoginName\")(); user-custom-actions imports \u00b6 Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; userCustomActions \u00b6 Gets a newly refreshed collection of the SPWeb's SPUserCustomActionCollection import { IUserCustomActions } from \"@pnp/sp/user-custom-actions\"; const actions: IUserCustomActions = web.userCustomActions; const actionsData = await actions(); IWebInfosData \u00b6 Some web operations return a subset of web information defined by the IWebInfosData interface, shown below. In those cases only these fields are available for select, orderby, and other odata operations. interface IWebInfosData { Configuration: number; Created: string; Description: string; Id: string; Language: number; LastItemModifiedDate: string; LastItemUserModifiedDate: string; ServerRelativeUrl: string; Title: string; WebTemplate: string; WebTemplateId: number; }","title":"@pnp/sp/webs"},{"location":"v2/sp/webs/#pnpspwebs","text":"Webs are one of the fundamental entry points when working with SharePoint. Webs serve as a container for lists, features, sub-webs, and all of the entity types.","title":"@pnp/sp/webs"},{"location":"v2/sp/webs/#iwebs","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Webs, IWebs } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Webs, IWebs } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Webs, IWebs } from \"@pnp/sp/presets/core\";","title":"IWebs"},{"location":"v2/sp/webs/#add-web","text":"Using the library you can add a web to another web's collection of subwebs. The simplest usage requires only a title and url. This will result in a team site with all of the default settings. You can also provide other settings such as description, template, language, and inherit permissions. import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; const result = await sp.web.webs.add(\"title\", \"subweb1\"); // show the response from the server when adding the web console.log(result.data); // we can immediately operate on the new web result.web.select(\"Title\")().then((w: IWebAddResult) => { // show our title console.log(w.Title); }); import { sp } from \"@pnp/sp\"; import { IWebAddResult } from \"@pnp/sp/webs\"; // create a German language wiki site with title, url, description, which does not inherit permissions sp.web.webs.add(\"wiki\", \"subweb2\", \"a wiki web\", \"WIKI#0\", 1031, false).then((w: IWebAddResult) => { // ... });","title":"Add Web"},{"location":"v2/sp/webs/#iweb","text":"Scenario Import Statement Selective 1 import { sp } from \"@pnp/sp\"; import { Web, IWeb } from \"@pnp/sp/webs\"; Selective 2 import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; Preset: Core import { sp, Web, IWeb } from \"@pnp/sp/presets/core\";","title":"IWeb"},{"location":"v2/sp/webs/#access-a-web","text":"There are several ways to access a web instance, each of these methods is equivalent in that you will have an IWeb instance to work with. All of the examples below use a variable named \"web\" which represents an IWeb instance - regardless of how it was initially accessed. Access the web from the imported \"sp\" object using selective import: import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'all' preset import { sp } from \"@pnp/sp/presets/all\"; const r = await sp.web(); Access the web from the imported \"sp\" using the 'core' preset import { sp } from \"@pnp/sp/presets/core\"; const r = await sp.web(); Create a web instance using the factory function import { Web } from \"@pnp/sp/webs\"; const web = Web(\"https://something.sharepoint.com/sites/dev\"); const r = await web();","title":"Access a Web"},{"location":"v2/sp/webs/#webs","text":"Access the child webs collection of this web const webs = web.webs();","title":"webs"},{"location":"v2/sp/webs/#get-a-webs-properties","text":"// basic get of the webs properties const props = await web(); // use odata operators to get specific fields const props2 = await web.select(\"Title\")(); // type the result to match what you are requesting const props3 = await web.select(\"Title\")<{ Title: string }>();","title":"Get A Web's properties"},{"location":"v2/sp/webs/#getparentweb","text":"Get the data and IWeb instance for the parent web for the given web instance import { IOpenWebByIdResult } from \"@pnp/sp/sites\"; const web: IOpenWebByIdResult = web.getParentWeb();","title":"getParentWeb"},{"location":"v2/sp/webs/#getsubwebsfilteredforcurrentuser","text":"Returns a collection of objects that contain metadata about subsites of the current site in which the current user is a member. const subWebs = await web.getSubwebsFilteredForCurrentUser()(); // apply odata operations to the collection const subWebs2 = await sp.web.getSubwebsFilteredForCurrentUser().select(\"Title\", \"Language\").orderBy(\"Created\", true)(); Note: getSubwebsFilteredForCurrentUser returns IWebInfosData which is a subset of all the available fields on IWebInfo.","title":"getSubwebsFilteredForCurrentUser"},{"location":"v2/sp/webs/#allproperties","text":"Allows access to the web's all properties collection. This is readonly in REST. const props = await web.allProperties(); // select certain props const props2 = await web.allProperties.select(\"prop1\", \"prop2\")();","title":"allProperties"},{"location":"v2/sp/webs/#webinfos","text":"Gets a collection of WebInfos for this web's subwebs const infos = await web.webinfos(); // or select certain fields const infos2 = await web.webinfos.select(\"Title\", \"Description\")(); // or filter const infos3 = await web.webinfos.filter(\"Title eq 'MyWebTitle'\")(); // or both const infos4 = await web.webinfos.select(\"Title\", \"Description\").filter(\"Title eq 'MyWebTitle'\")(); // get the top 4 ordered by Title const infos5 = await web.webinfos.top(4).orderBy(\"Title\")(); Note: webinfos returns IWebInfosData which is a subset of all the available fields on IWebInfo.","title":"webinfos"},{"location":"v2/sp/webs/#update","text":"Updates this web instance with the supplied properties // update the web's title and description const result = await web.update({ Title: \"New Title\", Description: \"My new description\", }); // a project implementation could wrap the update to provide type information for your expected fields: import { IWebUpdateResult } from \"@pnp/sp/webs\"; interface IWebUpdateProps { Title: string; Description: string; } function updateWeb(props: IWebUpdateProps): Promise<IWebUpdateResult> { web.update(props); }","title":"update"},{"location":"v2/sp/webs/#delete-a-web","text":"await web.delete();","title":"Delete a Web"},{"location":"v2/sp/webs/#applytheme","text":"Applies the theme specified by the contents of each of the files specified in the arguments to the site import { combine } from \"@pnp/core\"; // we are going to apply the theme to this sub web as an example const web = Web(\"https://{tenant}.sharepoint.com/sites/dev/subweb\"); // the urls to the color and font need to both be from the catalog at the root // these urls can be constants or calculated from existing urls const colorUrl = combine(\"/\", \"sites/dev\", \"_catalogs/theme/15/palette011.spcolor\"); // this gives us the same result const fontUrl = \"/sites/dev/_catalogs/theme/15/fontscheme007.spfont\"; // apply the font and color, no background image, and don't share this theme await web.applyTheme(colorUrl, fontUrl, \"\", false);","title":"applyTheme"},{"location":"v2/sp/webs/#applywebtemplate-availablewebtemplates","text":"Applies the specified site definition or site template to the Web site that has no template applied to it. This is seldom used outside provisioning scenarios. const templates = (await web.availableWebTemplates().select(\"Name\")<{ Name: string }[]>()).filter(t => /ENTERWIKI#0/i.test(t.Name)); // apply the wiki template const template = templates.length > 0 ? templates[0].Name : \"STS#0\"; await web.applyWebTemplate(template);","title":"applyWebTemplate &amp; availableWebTemplates"},{"location":"v2/sp/webs/#getchanges","text":"Returns the collection of changes from the change log that have occurred within the web, based on the specified query. // get the web changes including add, update, and delete const changes = await web.getChanges({ Add: true, ChangeTokenEnd: null, ChangeTokenStart: null, DeleteObject: true, Update: true, Web: true, });","title":"getChanges"},{"location":"v2/sp/webs/#maptoicon","text":"Returns the name of the image file for the icon that is used to represent the specified file import { combine } from \"@pnp/core\"; const iconFileName = await web.mapToIcon(\"test.docx\"); // iconPath === \"icdocx.png\" // which you can need to map to a real url const iconFullPath = `https://{tenant}.sharepoint.com/sites/dev/_layouts/images/${iconFileName}`; // OR dynamically const webData = await sp.web.select(\"Url\")(); const iconFullPath2 = combine(webData.Url, \"_layouts\", \"images\", iconFileName); // OR within SPFx using the context const iconFullPath3 = combine(this.context.pageContext.web.absoluteUrl, \"_layouts\", \"images\", iconFileName); // You can also set size // 16x16 pixels = 0, 32x32 pixels = 1 const icon32FileName = await web.mapToIcon(\"test.docx\", 1);","title":"mapToIcon"},{"location":"v2/sp/webs/#storage-entities","text":"import { sp } from \"@pnp/sp\"; import \"@pnp/sp/appcatalog\"; import { IStorageEntity } from \"@pnp/sp/webs\"; // needs to be unique, GUIDs are great const key = \"my-storage-key\"; // read an existing entity const entity: IStorageEntity = await web.getStorageEntity(key); // setStorageEntity and removeStorageEntity must be called in the context of the tenant app catalog site // you can get the tenant app catalog using the getTenantAppCatalogWeb const tenantAppCatalogWeb = await sp.getTenantAppCatalogWeb(); tenantAppCatalogWeb.setStorageEntity(key, \"new value\"); // set other properties tenantAppCatalogWeb.setStorageEntity(key, \"another value\", \"description\", \"comments\"); const entity2: IStorageEntity = await web.getStorageEntity(key); /* entity2 === { Value: \"another value\", Comment: \"comments\"; Description: \"description\", }; */ // you can also remove a storage entity await tenantAppCatalogWeb.removeStorageEntity(key);","title":"storage entities"},{"location":"v2/sp/webs/#appcatalog-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/appcatalog\"; Selective 2 import \"@pnp/sp/appcatalog/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"appcatalog imports"},{"location":"v2/sp/webs/#getappcatalog","text":"Returns this web as an IAppCatalog instance or creates a new IAppCatalog instance from the provided url. import { IApp } from \"@pnp/sp/appcatalog\"; const appWeb = web.getAppCatalog(); // appWeb url === web url const app: IApp = appWeb.getAppById(\"{your app id}\"); const appWeb2 = web.getAppCatalog(\"https://tenant.sharepoing.com/sites/someappcatalog\"); // appWeb2 url === \"https://tenant.sharepoing.com/sites/someappcatalog\"","title":"getAppCatalog"},{"location":"v2/sp/webs/#client-side-pages-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/client-side-pages\"; Selective 2 import \"@pnp/sp/client-side-pages/web\"; Preset: All import { sp, Web, IWeb } from \"@pnp/sp/presets/all\"; You can create and load clientside page instances directly from a web. More details on working with clientside pages are available in the dedicated article. import { sp } from \"@pnp/sp\"; import \"@pnp/sp/webs\"; import \"@pnp/sp/clientside-pages/web\"; // simplest add a page example const page = await sp.web.addClientsidePage(\"mypage1\"); // simplest load a page example const page = await sp.web.loadClientsidePage(\"/sites/dev/sitepages/mypage3.aspx\");","title":"client-side-pages imports"},{"location":"v2/sp/webs/#content-type-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/content-types\"; Selective 2 import \"@pnp/sp/content-types/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"content-type imports"},{"location":"v2/sp/webs/#contenttypes","text":"Allows access to the collection of content types in this web. const cts = await web.contentTypes(); // you can also select fields and use other odata operators const cts2 = await web.contentTypes.select(\"Name\")();","title":"contentTypes"},{"location":"v2/sp/webs/#features-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/features\"; Selective 2 import \"@pnp/sp/features/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"features imports"},{"location":"v2/sp/webs/#features","text":"Allows access to the collection of content types in this web. const features = await web.features();","title":"features"},{"location":"v2/sp/webs/#fields-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/fields\"; Selective 2 import \"@pnp/sp/fields/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"fields imports"},{"location":"v2/sp/webs/#fields","text":"Allows access to the collection of fields in this web. const fields = await web.fields();","title":"fields"},{"location":"v2/sp/webs/#files-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/files\"; Selective 2 import \"@pnp/sp/files/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"files imports"},{"location":"v2/sp/webs/#getfilebyserverrelativeurl","text":"Gets a file by server relative url import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativeUrl(\"/sites/dev/library/myfile.docx\");","title":"getFileByServerRelativeUrl"},{"location":"v2/sp/webs/#getfilebyserverrelativepath","text":"Gets a file by server relative url if your file name contains # and % characters import { IFile } from \"@pnp/sp/files\"; const file: IFile = web.getFileByServerRelativePath(\"/sites/dev/library/my # file%.docx\");","title":"getFileByServerRelativePath"},{"location":"v2/sp/webs/#folders-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/folders\"; Selective 2 import \"@pnp/sp/folders/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"folders imports"},{"location":"v2/sp/webs/#folders","text":"Gets the collection of folders in this web const folders = await web.folders(); // you can also filter and select as with any collection const folders2 = await web.folders.select(\"ServerRelativeUrl\", \"TimeLastModified\").filter(\"ItemCount gt 0\")(); // or get the most recently modified folder const folders2 = await web.folders.orderBy(\"TimeLastModified\").top(1)();","title":"folders"},{"location":"v2/sp/webs/#rootfolder","text":"Gets the root folder of the web const folder = await web.rootFolder();","title":"rootFolder"},{"location":"v2/sp/webs/#getfolderbyserverrelativeurl","text":"Gets a folder by server relative url import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativeUrl(\"/sites/dev/library\");","title":"getFolderByServerRelativeUrl"},{"location":"v2/sp/webs/#getfolderbyserverrelativepath","text":"Gets a folder by server relative url if your folder name contains # and % characters import { IFolder } from \"@pnp/sp/folders\"; const folder: IFolder = web.getFolderByServerRelativePath(\"/sites/dev/library/my # folder%/\");","title":"getFolderByServerRelativePath"},{"location":"v2/sp/webs/#hubsites-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/hubsites\"; Selective 2 import \"@pnp/sp/hubsites/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"hubsites imports"},{"location":"v2/sp/webs/#hubsitedata","text":"Gets hub site data for the current web import { IHubSiteWebData } from \"@pnp/sp/hubsites\"; // get the data and force a refresh const data: IHubSiteWebData = await web.hubSiteData(true);","title":"hubSiteData"},{"location":"v2/sp/webs/#synchubsitetheme","text":"Applies theme updates from the parent hub site collection await web.syncHubSiteTheme();","title":"syncHubSiteTheme"},{"location":"v2/sp/webs/#lists-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/lists\"; Selective 2 import \"@pnp/sp/lists/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; Preset: Core import { sp } from \"@pnp/sp/presets/core\";","title":"lists imports"},{"location":"v2/sp/webs/#lists","text":"Gets the collection of all lists that are contained in the Web site import { ILists } from \"@pnp/sp/lists\"; const lists: ILists = web.lists; // you can always order the lists and select properties const data = await lists.select(\"Title\").orderBy(\"Title\")(); // and use other odata operators as well const data2 = await web.lists.top(3).orderBy(\"LastItemModifiedDate\")();","title":"lists"},{"location":"v2/sp/webs/#siteuserinfolist","text":"Gets the UserInfo list of the site collection that contains the Web site import { IList } from \"@pnp/sp/lists\"; const list: IList = web.siteUserInfoList; const data = await list(); // or chain off that list to get additional details const items = await list.items.top(2)();","title":"siteUserInfoList"},{"location":"v2/sp/webs/#defaultdocumentlibrary","text":"Get a reference the default documents library of a web import { IList } from \"@pnp/sp/lists\"; const list: IList = web.defaultDocumentLibrary;","title":"defaultDocumentLibrary"},{"location":"v2/sp/webs/#customlisttemplates","text":"Gets the collection of all list definitions and list templates that are available import { IList } from \"@pnp/sp/lists\"; const templates = await web.customListTemplates(); // odata operators chain off the collection as expected const templates2 = await web.customListTemplates.select(\"Title\")();","title":"customListTemplates"},{"location":"v2/sp/webs/#getlist","text":"Gets a list by server relative url (list's root folder) import { IList } from \"@pnp/sp/lists\"; const list: IList = web.getList(\"/sites/dev/lists/test\"); const listData = list();","title":"getList"},{"location":"v2/sp/webs/#getcatalog","text":"Returns the list gallery on the site Name Value WebTemplateCatalog 111 WebPartCatalog 113 ListTemplateCatalog 114 MasterPageCatalog 116 SolutionCatalog 121 ThemeCatalog 123 DesignCatalog 124 AppDataCatalog 125 import { IList } from \"@pnp/sp/lists\"; const templateCatalog: IList = await web.getCatalog(111); const themeCatalog: IList = await web.getCatalog(123);","title":"getCatalog"},{"location":"v2/sp/webs/#navigation-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/navigation\"; Selective 2 import \"@pnp/sp/navigation/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"navigation imports"},{"location":"v2/sp/webs/#navigation","text":"Gets a navigation object that represents navigation on the Web site, including the Quick Launch area and the top navigation bar import { INavigation } from \"@pnp/sp/navigation\"; const nav: INavigation = web.navigation; const navData = await nav();","title":"navigation"},{"location":"v2/sp/webs/#regional-settings-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/regional-settings\"; Selective 2 import \"@pnp/sp/regional-settings/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRegionalSettings } from \"@pnp/sp/navigation\"; const settings: IRegionalSettings = web.regionalSettings; const settingsData = await settings();","title":"regional-settings imports"},{"location":"v2/sp/webs/#related-items-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/related-items\"; Selective 2 import \"@pnp/sp/related-items/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\"; import { IRelatedItemManager, IRelatedItem } from \"@pnp/sp/related-items\"; const manager: IRelatedItemManager = web.relatedItems; const data: IRelatedItem[] = await manager.getRelatedItems(\"{list name}\", 4);","title":"related-items imports"},{"location":"v2/sp/webs/#security-imports","text":"Please see information around the available security methods in the security article .","title":"security imports"},{"location":"v2/sp/webs/#sharing-imports","text":"Please see information around the available sharing methods in the sharing article .","title":"sharing imports"},{"location":"v2/sp/webs/#site-groups-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/site-groups\"; Selective 2 import \"@pnp/sp/site-groups/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"site-groups imports"},{"location":"v2/sp/webs/#sitegroups","text":"The site groups const groups = await web.siteGroups(); const groups2 = await web.siteGroups.top(2)();","title":"siteGroups"},{"location":"v2/sp/webs/#associatedownergroup","text":"The web's owner group const group = await web.associatedOwnerGroup(); const users = await web.associatedOwnerGroup.users();","title":"associatedOwnerGroup"},{"location":"v2/sp/webs/#associatedmembergroup","text":"The web's member group const group = await web.associatedMemberGroup(); const users = await web.associatedMemberGroup.users();","title":"associatedMemberGroup"},{"location":"v2/sp/webs/#associatedvisitorgroup","text":"The web's visitor group const group = await web.associatedVisitorGroup(); const users = await web.associatedVisitorGroup.users();","title":"associatedVisitorGroup"},{"location":"v2/sp/webs/#createdefaultassociatedgroups","text":"Creates the default associated groups (Members, Owners, Visitors) and gives them the default permissions on the site. The target site must have unique permissions and no associated members / owners / visitors groups await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\"); // copy the role assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", true); // don't clear sub assignments await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, false); // specify secondary owner, don't copy permissions, clear sub scopes await web.createDefaultAssociatedGroups(\"Contoso\", \"{first owner login}\", false, true, \"{second owner login}\");","title":"createDefaultAssociatedGroups"},{"location":"v2/sp/webs/#site-users-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/site-users\"; Selective 2 import \"@pnp/sp/site-users/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"site-users imports"},{"location":"v2/sp/webs/#siteusers","text":"The site users const users = await web.siteUsers(); const users2 = await web.siteUsers.top(5)(); const users3 = await web.siteUsers.filter(`startswith(LoginName, '${encodeURIComponent(\"i:0#.f|m\")}')`)();","title":"siteUsers"},{"location":"v2/sp/webs/#currentuser","text":"Information on the current user const user = await web.currentUser(); // check the login name of the current user const user2 = await web.currentUser.select(\"LoginName\")();","title":"currentUser"},{"location":"v2/sp/webs/#ensureuser","text":"Checks whether the specified login name belongs to a valid user in the web. If the user doesn't exist, adds the user to the web import { IWebEnsureUserResult } from \"@pnp/sp/site-users/\"; const result: IWebEnsureUserResult = await web.ensureUser(\"i:0#.f|membership|user@domain.onmicrosoft.com\");","title":"ensureUser"},{"location":"v2/sp/webs/#getuserbyid","text":"Returns the user corresponding to the specified member identifier for the current web import { ISiteUser } from \"@pnp/sp/site-users/\"; const user: ISiteUser = web.getUserById(23); const userData = await user(); const userData2 = await user.select(\"LoginName\")();","title":"getUserById"},{"location":"v2/sp/webs/#user-custom-actions-imports","text":"Scenario Import Statement Selective 1 import \"@pnp/sp/user-custom-actions\"; Selective 2 import \"@pnp/sp/user-custom-actions/web\"; Preset: All import { sp } from \"@pnp/sp/presets/all\";","title":"user-custom-actions imports"},{"location":"v2/sp/webs/#usercustomactions","text":"Gets a newly refreshed collection of the SPWeb's SPUserCustomActionCollection import { IUserCustomActions } from \"@pnp/sp/user-custom-actions\"; const actions: IUserCustomActions = web.userCustomActions; const actionsData = await actions();","title":"userCustomActions"},{"location":"v2/sp/webs/#iwebinfosdata","text":"Some web operations return a subset of web information defined by the IWebInfosData interface, shown below. In those cases only these fields are available for select, orderby, and other odata operations. interface IWebInfosData { Configuration: number; Created: string; Description: string; Id: string; Language: number; LastItemModifiedDate: string; LastItemUserModifiedDate: string; ServerRelativeUrl: string; Title: string; WebTemplate: string; WebTemplateId: number; }","title":"IWebInfosData"},{"location":"v2/sp-addinhelpers/","text":"@pnp/sp-addinhelpers \u00b6 This module contains classes to allow use of the libraries within a SharePoint add-in. Getting Started \u00b6 Install the library and all dependencies, npm install @pnp/sp @pnp/sp-addinhelpers --save Now you can make requests to the host web from your add-in using the crossDomainWeb method. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4)); Library Topics \u00b6 SPRequestExecutorClient SPRestAddIn","title":"@pnp/sp-addinhelpers"},{"location":"v2/sp-addinhelpers/#pnpsp-addinhelpers","text":"This module contains classes to allow use of the libraries within a SharePoint add-in.","title":"@pnp/sp-addinhelpers"},{"location":"v2/sp-addinhelpers/#getting-started","text":"Install the library and all dependencies, npm install @pnp/sp @pnp/sp-addinhelpers --save Now you can make requests to the host web from your add-in using the crossDomainWeb method. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4));","title":"Getting Started"},{"location":"v2/sp-addinhelpers/#library-topics","text":"SPRequestExecutorClient SPRestAddIn","title":"Library Topics"},{"location":"v2/sp-addinhelpers/sp-request-executor-client/","text":"@pnp/sp-addinhelpers/sprequestexecutorclient \u00b6 The SPRequestExecutorClient is an implementation of the HttpClientImpl interface that facilitates requests to SharePoint from an add-in. It relies on the SharePoint SP product libraries being present to allow use of the SP.RequestExecutor to make the request. Setup \u00b6 To use the client you need to set it using the fetch client factory using the setup method as shown below. This is only required when working within a SharePoint add-in web. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor sp.crossDomainWeb(addInWenUrl, hostWebUrl)().then(w => { console.log(JSON.stringify(w, null, 4)); });","title":"@pnp/sp-addinhelpers/sprequestexecutorclient"},{"location":"v2/sp-addinhelpers/sp-request-executor-client/#pnpsp-addinhelperssprequestexecutorclient","text":"The SPRequestExecutorClient is an implementation of the HttpClientImpl interface that facilitates requests to SharePoint from an add-in. It relies on the SharePoint SP product libraries being present to allow use of the SP.RequestExecutor to make the request.","title":"@pnp/sp-addinhelpers/sprequestexecutorclient"},{"location":"v2/sp-addinhelpers/sp-request-executor-client/#setup","text":"To use the client you need to set it using the fetch client factory using the setup method as shown below. This is only required when working within a SharePoint add-in web. // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor sp.crossDomainWeb(addInWenUrl, hostWebUrl)().then(w => { console.log(JSON.stringify(w, null, 4)); });","title":"Setup"},{"location":"v2/sp-addinhelpers/sp-rest-addin/","text":"@pnp/sp-addinhelpers/sprestaddin \u00b6 This class extends the sp export from @pnp/sp and adds in the methods required to make cross domain calls // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4));","title":"@pnp/sp-addinhelpers/sprestaddin"},{"location":"v2/sp-addinhelpers/sp-rest-addin/#pnpsp-addinhelperssprestaddin","text":"This class extends the sp export from @pnp/sp and adds in the methods required to make cross domain calls // note we are getting the sp variable from this library, it extends the sp export from @pnp/sp to add the required helper methods import { sp, SPRequestExecutorClient } from \"@pnp/sp-addinhelpers\"; // this only needs to be done once within your application sp.setup({ sp: { fetchClientFactory: () => { return new SPRequestExecutorClient(); } } }); // now we need to use the crossDomainWeb method to make our requests to the host web const addInWenUrl = \"{The add-in web url, likely from the query string}\"; const hostWebUrl = \"{The host web url, likely from the query string}\"; // make requests into the host web via the SP.RequestExecutor const w = await sp.crossDomainWeb(addInWenUrl, hostWebUrl)(); console.log(JSON.stringify(w, null, 4));","title":"@pnp/sp-addinhelpers/sprestaddin"}]}